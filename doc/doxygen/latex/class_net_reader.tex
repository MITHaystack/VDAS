\hypertarget{class_net_reader}{
\section{NetReader Class Reference}
\label{class_net_reader}\index{NetReader@{NetReader}}
}


{\ttfamily \#include $<$net\_\-reader.h$>$}

Inheritance diagram for NetReader:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_net_reader}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_net_reader_adadbce06c16a6350aba08f468a7b0d83}{NetReader} (const int id, const std::string interface, const int snaplen, const int payload\_\-length, const int buffer\_\-size, const bool promiscuous, \hyperlink{class_file_writer}{FileWriter} $\ast$const fw, \hyperlink{class_stats_writer}{StatsWriter} $\ast$const sw, const double command\_\-interval)
\item 
\hypertarget{class_net_reader_a87d8aa64164c1f55ad34dc3c1b362559}{
virtual \hyperlink{class_net_reader_a87d8aa64164c1f55ad34dc3c1b362559}{$\sim$NetReader} ()}
\label{class_net_reader_a87d8aa64164c1f55ad34dc3c1b362559}

\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
\hypertarget{class_net_reader_aa3d94d0ddcddacb2985046934fa1006e}{
virtual void \hyperlink{class_net_reader_aa3d94d0ddcddacb2985046934fa1006e}{start} ()}
\label{class_net_reader_aa3d94d0ddcddacb2985046934fa1006e}

\begin{DoxyCompactList}\small\item\em Start the main processing loop \hyperlink{class_net_reader_af770f94a75655fc02489c9cb1f778181}{run()} in its own thread of execution. \end{DoxyCompactList}\item 
\hypertarget{class_net_reader_a4eb2447a323f7068b3838418bf746854}{
virtual void \hyperlink{class_net_reader_a4eb2447a323f7068b3838418bf746854}{join} ()}
\label{class_net_reader_a4eb2447a323f7068b3838418bf746854}

\begin{DoxyCompactList}\small\item\em Wait for the main processing loop/thread to exit. \end{DoxyCompactList}\item 
virtual void \hyperlink{class_net_reader_a8ba627314d064cb636f192974e4daed6}{cmd\_\-stop} ()
\item 
virtual void \hyperlink{class_net_reader_a47c2209376226353e4c5d80c4f35713f}{cmd\_\-read\_\-from\_\-network} ()
\end{DoxyCompactItemize}
\subsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
enum \{ {\bfseries IDLE}, 
{\bfseries READ\_\-FROM\_\-NETWORK}, 
{\bfseries STOP}
 \}
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_net_reader_af770f94a75655fc02489c9cb1f778181}{
virtual void \hyperlink{class_net_reader_af770f94a75655fc02489c9cb1f778181}{run} ()}
\label{class_net_reader_af770f94a75655fc02489c9cb1f778181}

\begin{DoxyCompactList}\small\item\em Main processing loop. \end{DoxyCompactList}\item 
virtual void \hyperlink{class_net_reader_a6b81e13eba7624570bfd0ed90874069c}{handle\_\-stop} ()
\item 
\hypertarget{class_net_reader_a13ec87275d0da80672ca1b6db0d8db01}{
virtual void \hyperlink{class_net_reader_a13ec87275d0da80672ca1b6db0d8db01}{handle\_\-idle} ()}
\label{class_net_reader_a13ec87275d0da80672ca1b6db0d8db01}

\begin{DoxyCompactList}\small\item\em Command handler. Handles the IDLE state. \end{DoxyCompactList}\item 
virtual void \hyperlink{class_net_reader_adff36260184f5d1207e298574a41becb}{handle\_\-read\_\-from\_\-network} ()
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
const std::string \hyperlink{class_net_reader_adcf200863f3126eaaa825d66de3b2ae6}{\_\-interface}
\item 
\hypertarget{class_net_reader_a315fd6f68c1e8aa65bfb1125e4a07568}{
const int \hyperlink{class_net_reader_a315fd6f68c1e8aa65bfb1125e4a07568}{\_\-snaplen}}
\label{class_net_reader_a315fd6f68c1e8aa65bfb1125e4a07568}

\begin{DoxyCompactList}\small\item\em The total amount of bytes to capture from the packet (e.g. 9000). \end{DoxyCompactList}\item 
const int \hyperlink{class_net_reader_aeee03720b22f775cdbee80a50c39453a}{\_\-payload\_\-length}
\item 
const int \hyperlink{class_net_reader_a2ae2988890c04fd26f274d039fb868d8}{\_\-buffer\_\-size}
\item 
\hypertarget{class_net_reader_aff7f135e9b67c9c0b91b65532c7178ac}{
const bool \hyperlink{class_net_reader_aff7f135e9b67c9c0b91b65532c7178ac}{\_\-promiscuous}}
\label{class_net_reader_aff7f135e9b67c9c0b91b65532c7178ac}

\begin{DoxyCompactList}\small\item\em Whether or not to open the network interface in promiscuous mode. \end{DoxyCompactList}\item 
\hyperlink{class_file_writer}{FileWriter} $\ast$const \hyperlink{class_net_reader_a5c447196aabbe2920be2bad71765ec31}{\_\-fw}
\item 
\hyperlink{class_stats_writer}{StatsWriter} $\ast$const \hyperlink{class_net_reader_a73d95d4fdb1065e26e2e8eed2b64d534}{\_\-sw}
\item 
\hyperlink{class_p_f_r}{PFR} $\ast$ \hyperlink{class_net_reader_acf0a225f9ec8f89f3b3b1e9ff761d916}{\_\-ring}
\item 
boost::uint8\_\-t $\ast$ \hyperlink{class_net_reader_afc35b98235d4d5479f755765d6bb1c97}{\_\-net\_\-buf}
\item 
\hypertarget{class_net_reader_a7a225465439801fc011e7a9d080f02ad}{
enum NetReader:: \{ ... \}  {\bfseries \_\-state}}
\label{class_net_reader_a7a225465439801fc011e7a9d080f02ad}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Manages high speed capture of data from network interface using PF\_\-RING. Data are read in from an assigned interface using the PF\_\-RING API. The data are read in to specially allocated and sized buffers, that have been optimized for disk throughput. Once a buffer is full, it is passed on to a \hyperlink{class_file_writer}{FileWriter} to be written to disk. 

Definition at line 49 of file net\_\-reader.h.



\subsection{Member Enumeration Documentation}
\hypertarget{class_net_reader_ab7f953c3d9d89435f05ba1674fd868c9}{
\subsubsection[{"@320}]{\setlength{\rightskip}{0pt plus 5cm}anonymous enum\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_ab7f953c3d9d89435f05ba1674fd868c9}
State variable. This variable is changed in response to cmd\_\-X() commands applied to this object. The variable is used in the \hyperlink{class_net_reader_af770f94a75655fc02489c9cb1f778181}{run()} method to determine what state the object is currently in, so that the appropriate handle\_\-X() method can be called. 

Definition at line 154 of file net\_\-reader.h.


\begin{DoxyCode}
{ IDLE, READ_FROM_NETWORK, STOP } _state;
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_net_reader_adadbce06c16a6350aba08f468a7b0d83}{
\index{NetReader@{NetReader}!NetReader@{NetReader}}
\index{NetReader@{NetReader}!NetReader@{NetReader}}
\subsubsection[{NetReader}]{\setlength{\rightskip}{0pt plus 5cm}NetReader::NetReader (
\begin{DoxyParamCaption}
\item[{const int}]{id, }
\item[{const std::string}]{interface, }
\item[{const int}]{snaplen, }
\item[{const int}]{payload\_\-length, }
\item[{const int}]{buffer\_\-size, }
\item[{const bool}]{promiscuous, }
\item[{{\bf FileWriter} $\ast$const}]{fw, }
\item[{{\bf StatsWriter} $\ast$const}]{sw, }
\item[{const double}]{command\_\-interval}
\end{DoxyParamCaption}
)}}
\label{class_net_reader_adadbce06c16a6350aba08f468a7b0d83}
Constructor. 
\begin{DoxyParams}{Parameters}
{\em id} & A unique identifies for this object. Used in logging. \\
\hline
{\em interface} & The name of the network interface from which data will be captured. \\
\hline
{\em snaplen} & The total amount of data to be captured (data packet headers from layer2 and up are included in the count). \\
\hline
{\em payload\_\-length} & The total length of the UDP payload. This is the amount of data that needs to be extracted from each packet and then stored to disk. \\
\hline
{\em buffer\_\-size} & The size of the optimal buffers that are used to transfer data from network interface to disk. Typically, these are a multiple of the system page size, and aligned to page size boundaries (e..g, page size of 256B, buffer size of 1048576B). \\
\hline
{\em promiscuous} & Wheter or not to put the network interface into promiscuous mode. \\
\hline
{\em fw} & A pointer to a \hyperlink{class_file_writer}{FileWriter} object. \\
\hline
{\em sw} & A pointer to a \hyperlink{class_stats_writer}{StatsWriter} object. \\
\hline
{\em command\_\-interval} & The main executin thread in \hyperlink{class_net_reader_af770f94a75655fc02489c9cb1f778181}{run()} will attempt to check for new commands every command\_\-interval seconds. The actual interval between checks may be larger than this if the execution thread spends longer than command\_\-interval processing individual tasks. \\
\hline
\end{DoxyParams}
\begin{Desc}
\item[\hyperlink{todo__todo000006}{Todo}]Robustify this. \end{Desc}


Definition at line 43 of file net\_\-reader.cc.


\begin{DoxyCode}
                                           :
  Threaded(id, command_interval),
  _interface(interface),
  _snaplen(snaplen),
  _payload_length(payload_length),
  _buffer_size(buffer_size),
  _promiscuous(promiscuous),
  _fw(fw),
  _sw(sw),
  _ring(0),
  _net_buf(0),
  _state(IDLE) {
  _ring = new PFR(interface.c_str(), snaplen, _promiscuous);
  _net_buf = new boost::uint8_t[snaplen];
}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{class_net_reader_a47c2209376226353e4c5d80c4f35713f}{
\index{NetReader@{NetReader}!cmd\_\-read\_\-from\_\-network@{cmd\_\-read\_\-from\_\-network}}
\index{cmd\_\-read\_\-from\_\-network@{cmd\_\-read\_\-from\_\-network}!NetReader@{NetReader}}
\subsubsection[{cmd\_\-read\_\-from\_\-network}]{\setlength{\rightskip}{0pt plus 5cm}void NetReader::cmd\_\-read\_\-from\_\-network (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{class_net_reader_a47c2209376226353e4c5d80c4f35713f}
External API command. Insert a READ\_\-FROM\_\-NETWORK command into the object's command queue for processing. 

Definition at line 130 of file net\_\-reader.cc.


\begin{DoxyCode}
                                      {
  LOG4CXX_INFO(logger, "Received READ_FROM_NETWORK...");
  _state = READ_FROM_NETWORK;
}
\end{DoxyCode}
\hypertarget{class_net_reader_a8ba627314d064cb636f192974e4daed6}{
\index{NetReader@{NetReader}!cmd\_\-stop@{cmd\_\-stop}}
\index{cmd\_\-stop@{cmd\_\-stop}!NetReader@{NetReader}}
\subsubsection[{cmd\_\-stop}]{\setlength{\rightskip}{0pt plus 5cm}void NetReader::cmd\_\-stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{class_net_reader_a8ba627314d064cb636f192974e4daed6}
External API command. Insert a STOP command into the object's command queue for processing. 

Implements \hyperlink{class_threaded_a52a40998cd6f4b995ceaba12899b4212}{Threaded}.



Definition at line 125 of file net\_\-reader.cc.


\begin{DoxyCode}
                         {
  LOG4CXX_INFO(logger, "Received STOP");
  _state = STOP;
}
\end{DoxyCode}
\hypertarget{class_net_reader_adff36260184f5d1207e298574a41becb}{
\index{NetReader@{NetReader}!handle\_\-read\_\-from\_\-network@{handle\_\-read\_\-from\_\-network}}
\index{handle\_\-read\_\-from\_\-network@{handle\_\-read\_\-from\_\-network}!NetReader@{NetReader}}
\subsubsection[{handle\_\-read\_\-from\_\-network}]{\setlength{\rightskip}{0pt plus 5cm}void NetReader::handle\_\-read\_\-from\_\-network (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{class_net_reader_adff36260184f5d1207e298574a41becb}
Command handler. Handles the READ\_\-FROM\_\-NETWORK state/command. On receiving this command, the \hyperlink{class_net_reader}{NetReader} object will start to read data from the network interface and pass filled buffers to the \hyperlink{class_file_writer}{FileWriter} object. 

Definition at line 174 of file net\_\-reader.cc.


\begin{DoxyCode}
                                         {
  struct pfring_pkthdr hdr;
  int payload_length;
  boost::uint8_t* payload_ptr;
  
  int bytes_read = 0;
  static int remainder_len = 0;
  static boost::uint8_t remainder_buf[9000];
  static bool first_write = true;
  static boost::uint8_t net_buf[9000];
  static PcapPacketHeader pph;

#define DYNAMIC_BUFFER
#ifdef DYNAMIC_BUFFER
  int bytes_left = _buffer_size;
  boost::uint8_t* file_buf = _fw->malloc_buffer();
  if (!file_buf) {
    LOG4CXX_ERROR(logger, "File buffer's full: timedout");
    return;
  }
  assert(file_buf);
#else
  const int BUFFER_SIZE = 1048576;
  int bytes_left = BUFFER_SIZE;
  static boost::uint8_t file_buf[BUFFER_SIZE];
#endif
  boost::uint64_t dropped_packets = 0;
  boost::uint64_t num_packets = 0;
  boost::uint64_t num_bytes = 0;

  if (first_write) {
    memcpy(remainder_buf, PCAP_HEADER, PCAP_HEADER_LENGTH);
    remainder_len = PCAP_HEADER_LENGTH;
    first_write = false;
  }

  // Copy partial packet.
  if (remainder_len > 0) {
    memcpy(file_buf, remainder_buf, remainder_len);
    bytes_read += remainder_len;
    bytes_left -= remainder_len;
    remainder_len = 0;
  }

  // Fill the new file_buf;
  while (bytes_left > 0) {
    if (_ring->get_next_packet(&hdr, &net_buf[PCAP_PACKET_HEADER_LENGTH],
                   _snaplen) > 0) {
      // Successful read.

      // Extract offsets etc. from pfring structures.
      struct pfring_extended_pkthdr& pep(hdr.extended_hdr);
      struct pkt_parsing_info& ppi(pep.parsed_pkt);
      struct pkt_offset po(ppi.offset);
      const boost::uint16_t eth_offset(po.eth_offset);
      const boost::uint16_t l3_offset(po.l3_offset);
      const boost::uint16_t l4_offset(po.l4_offset);
      const boost::uint16_t payload_offset(po.payload_offset);

      // Get payload information.
      // FIXME payload_ptr = &_net_buf[payload_offset];
      payload_ptr = net_buf;
      // FIXME payload_length = hdr.caplen - payload_offset;
      payload_length = hdr.len + PCAP_PACKET_HEADER_LENGTH;

      pph.ts_sec = hdr.ts.tv_sec;
      pph.ts_usec = hdr.ts.tv_usec;
      pph.incl_len = hdr.len;
      pph.orig_len = hdr.len;
      memcpy(net_buf, &pph, PCAP_PACKET_HEADER_LENGTH);

      // Check for validity of capture.
      if (hdr.caplen != _snaplen) {
      // || hdr.caplen != hdr.len
      // || payload_length != _payload_length) {
    LOG4CXX_DEBUG(logger, "Short capture(caplen/snaplen"
              "len/payload_length/PAYLOAD_LENGTH) -> ("
              << hdr.caplen << "/" << _snaplen << "/"
              << hdr.len << "/" << payload_length << "/"
              << _payload_length << ")");
    continue;
      }

      // Update stats.
      num_packets++;
      num_bytes += hdr.len;
    } else {
      LOG4CXX_ERROR(logger, "Error while calling get_next_packet(): "
            << strerror(errno));
      continue;
    }

    // Accumulate or flush data.
    if (bytes_left < payload_length) {
      // Copy fragment into buffer.
      memcpy(&file_buf[bytes_read], payload_ptr, bytes_left);
      bytes_read += bytes_left;
      
      // Copy remainder into remainder_buf.
      remainder_len = payload_length - bytes_left;
      memcpy(remainder_buf, payload_ptr + bytes_left, remainder_len);

#define BUFFERED_WRITE      
#ifdef BUFFERED_WRITE
      if (!_fw->write(file_buf))
    ++dropped_packets;
#else
      _fw->write_unbuffered(file_buf, BUFFER_SIZE);
#endif
      // Update stats.
      _sw->update(num_packets, num_bytes, dropped_packets, 0);
      bytes_left = 0;
      break;
    } else if (bytes_left == payload_length) {
      // Copy captured payload to file buffer.
      memcpy(&file_buf[bytes_read], payload_ptr, payload_length);
      bytes_read += payload_length;
      bytes_left -= payload_length;
#ifdef BUFFERED_WRITE
      if (!_fw->write(file_buf))
    ++dropped_packets;
#else
      _fw->write_unbuffered(file_buf, BUFFER_SIZE);
#endif
    } else {
      // Copy captured payload to file buffer.
      memcpy(&file_buf[bytes_read], payload_ptr, payload_length);
      bytes_read += payload_length;
      bytes_left -= payload_length;
    }
  }
}
\end{DoxyCode}
\hypertarget{class_net_reader_a6b81e13eba7624570bfd0ed90874069c}{
\index{NetReader@{NetReader}!handle\_\-stop@{handle\_\-stop}}
\index{handle\_\-stop@{handle\_\-stop}!NetReader@{NetReader}}
\subsubsection[{handle\_\-stop}]{\setlength{\rightskip}{0pt plus 5cm}void NetReader::handle\_\-stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{class_net_reader_a6b81e13eba7624570bfd0ed90874069c}
Command handler. Handles the STOP command/state. On receiving this command, the \hyperlink{class_file_writer}{FileWriter} object will stop processing and exit the \hyperlink{class_net_reader_af770f94a75655fc02489c9cb1f778181}{run()} method at the next opportunity. 

Implements \hyperlink{class_threaded_a421b31c46443970af90b8fa1df8ea141}{Threaded}.



Definition at line 135 of file net\_\-reader.cc.


\begin{DoxyCode}
                            {
  _running = false;
}
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{class_net_reader_a2ae2988890c04fd26f274d039fb868d8}{
\index{NetReader@{NetReader}!\_\-buffer\_\-size@{\_\-buffer\_\-size}}
\index{\_\-buffer\_\-size@{\_\-buffer\_\-size}!NetReader@{NetReader}}
\subsubsection[{\_\-buffer\_\-size}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf NetReader::\_\-buffer\_\-size}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_a2ae2988890c04fd26f274d039fb868d8}
The size of the buffer being filled. These buffers are optimized for disk throughput and have custom memory allocation and alignment mechanisms. Typically, these buffers are orders of magnitude larger than a packet (e.g. 1 MB v. 9KB). 

Definition at line 127 of file net\_\-reader.h.

\hypertarget{class_net_reader_a5c447196aabbe2920be2bad71765ec31}{
\index{NetReader@{NetReader}!\_\-fw@{\_\-fw}}
\index{\_\-fw@{\_\-fw}!NetReader@{NetReader}}
\subsubsection[{\_\-fw}]{\setlength{\rightskip}{0pt plus 5cm}{\bf FileWriter}$\ast$ const {\bf NetReader::\_\-fw}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_a5c447196aabbe2920be2bad71765ec31}
A pointer to the \hyperlink{class_file_writer}{FileWriter} object that will write the data to disk. Once a buffer is filled, it is passed in to the \hyperlink{class_file_writer}{FileWriter} object where it is queued awaiting transfer to disk. 

Definition at line 135 of file net\_\-reader.h.

\hypertarget{class_net_reader_adcf200863f3126eaaa825d66de3b2ae6}{
\index{NetReader@{NetReader}!\_\-interface@{\_\-interface}}
\index{\_\-interface@{\_\-interface}!NetReader@{NetReader}}
\subsubsection[{\_\-interface}]{\setlength{\rightskip}{0pt plus 5cm}const std::string {\bf NetReader::\_\-interface}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_adcf200863f3126eaaa825d66de3b2ae6}
The name of the network interface from which to capture data (e.g., eth2). 

Definition at line 114 of file net\_\-reader.h.

\hypertarget{class_net_reader_afc35b98235d4d5479f755765d6bb1c97}{
\index{NetReader@{NetReader}!\_\-net\_\-buf@{\_\-net\_\-buf}}
\index{\_\-net\_\-buf@{\_\-net\_\-buf}!NetReader@{NetReader}}
\subsubsection[{\_\-net\_\-buf}]{\setlength{\rightskip}{0pt plus 5cm}boost::uint8\_\-t$\ast$ {\bf NetReader::\_\-net\_\-buf}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_afc35b98235d4d5479f755765d6bb1c97}
A pointer to the temporary buffer used to store data recently captured from the network interface. 

Definition at line 148 of file net\_\-reader.h.

\hypertarget{class_net_reader_aeee03720b22f775cdbee80a50c39453a}{
\index{NetReader@{NetReader}!\_\-payload\_\-length@{\_\-payload\_\-length}}
\index{\_\-payload\_\-length@{\_\-payload\_\-length}!NetReader@{NetReader}}
\subsubsection[{\_\-payload\_\-length}]{\setlength{\rightskip}{0pt plus 5cm}const int {\bf NetReader::\_\-payload\_\-length}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_aeee03720b22f775cdbee80a50c39453a}
The length of the payload (i.e. the amount of data to extract and write to disk). 

Definition at line 121 of file net\_\-reader.h.

\hypertarget{class_net_reader_acf0a225f9ec8f89f3b3b1e9ff761d916}{
\index{NetReader@{NetReader}!\_\-ring@{\_\-ring}}
\index{\_\-ring@{\_\-ring}!NetReader@{NetReader}}
\subsubsection[{\_\-ring}]{\setlength{\rightskip}{0pt plus 5cm}{\bf PFR}$\ast$ {\bf NetReader::\_\-ring}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_acf0a225f9ec8f89f3b3b1e9ff761d916}
A pointer to the PF\_\-RING data structure that tracks the PF\_\-RING state and data structures. 

Definition at line 144 of file net\_\-reader.h.

\hypertarget{class_net_reader_a73d95d4fdb1065e26e2e8eed2b64d534}{
\index{NetReader@{NetReader}!\_\-sw@{\_\-sw}}
\index{\_\-sw@{\_\-sw}!NetReader@{NetReader}}
\subsubsection[{\_\-sw}]{\setlength{\rightskip}{0pt plus 5cm}{\bf StatsWriter}$\ast$ const {\bf NetReader::\_\-sw}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{class_net_reader_a73d95d4fdb1065e26e2e8eed2b64d534}
A pointer to a \hyperlink{class_stats_writer}{StatsWriter} object that will keep track of throughput statistics for this object. The \hyperlink{class_stats_writer}{StatsWriter} will also write these statistics to CSV file on disk. 

Definition at line 140 of file net\_\-reader.h.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/net2disk/net\_\-reader.h\item 
src/net2disk/net\_\-reader.cc\end{DoxyCompactItemize}
