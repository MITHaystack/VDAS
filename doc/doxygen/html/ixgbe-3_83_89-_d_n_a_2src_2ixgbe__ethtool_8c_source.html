<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/ixgbe/ixgbe-3.3.9-DNA/src/ixgbe_ethtool.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_aa6459e1e92664bab04094557f6624be.html">ixgbe</a>      </li>
      <li class="navelem"><a class="el" href="dir_3b56ec236485f9dee0c084116c4cc016.html">ixgbe-3.3.9-DNA</a>      </li>
      <li class="navelem"><a class="el" href="dir_ecb77d0badc0ebf1a0c30c7262560bf3.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ixgbe_ethtool.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Intel 10 Gigabit PCI Express Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">  Copyright(c) 1999 - 2010 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">  under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">  version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">  more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">  The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00024"></a>00024 <span class="comment">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">*******************************************************************************/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">/* ethtool support for ixgbe */</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;linux/pci.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;linux/netdevice.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;linux/ethtool.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;linux/vmalloc.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#ifdef SIOCETHTOOL</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#include &lt;asm/uaccess.h&gt;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;ixgbe.h&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#ifndef ETH_GSTRING_LEN</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#define ETH_GSTRING_LEN 32</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#define IXGBE_ALL_RAR_ENTRIES 16</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>
<a name="l00047"></a>00047 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#include &quot;kcompat_ethtool.c&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#endif</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#ifdef ETHTOOL_GSTATS</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="keyword">struct </span>ixgbe_stats {
<a name="l00052"></a>00052     <span class="keywordtype">char</span> stat_string[ETH_GSTRING_LEN];
<a name="l00053"></a>00053     <span class="keywordtype">int</span> sizeof_stat;
<a name="l00054"></a>00054     <span class="keywordtype">int</span> stat_offset;
<a name="l00055"></a>00055 };
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#define IXGBE_NETDEV_STAT(_net_stat) { \</span>
<a name="l00058"></a>00058 <span class="preprocessor">    .stat_string = #_net_stat, \</span>
<a name="l00059"></a>00059 <span class="preprocessor">    .sizeof_stat = FIELD_SIZEOF(struct net_device_stats, _net_stat), \</span>
<a name="l00060"></a>00060 <span class="preprocessor">    .stat_offset = offsetof(struct net_device_stats, _net_stat) \</span>
<a name="l00061"></a>00061 <span class="preprocessor">}</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>ixgbe_stats ixgbe_gstrings_net_stats[] = {
<a name="l00063"></a>00063     IXGBE_NETDEV_STAT(rx_packets),
<a name="l00064"></a>00064     IXGBE_NETDEV_STAT(tx_packets),
<a name="l00065"></a>00065     IXGBE_NETDEV_STAT(rx_bytes),
<a name="l00066"></a>00066     IXGBE_NETDEV_STAT(tx_bytes),
<a name="l00067"></a>00067     IXGBE_NETDEV_STAT(rx_errors),
<a name="l00068"></a>00068     IXGBE_NETDEV_STAT(tx_errors),
<a name="l00069"></a>00069     IXGBE_NETDEV_STAT(rx_dropped),
<a name="l00070"></a>00070     IXGBE_NETDEV_STAT(tx_dropped),
<a name="l00071"></a>00071     IXGBE_NETDEV_STAT(multicast),
<a name="l00072"></a>00072     IXGBE_NETDEV_STAT(collisions),
<a name="l00073"></a>00073     IXGBE_NETDEV_STAT(rx_over_errors),
<a name="l00074"></a>00074     IXGBE_NETDEV_STAT(rx_crc_errors),
<a name="l00075"></a>00075     IXGBE_NETDEV_STAT(rx_frame_errors),
<a name="l00076"></a>00076     IXGBE_NETDEV_STAT(rx_fifo_errors),
<a name="l00077"></a>00077     IXGBE_NETDEV_STAT(rx_missed_errors),
<a name="l00078"></a>00078     IXGBE_NETDEV_STAT(tx_aborted_errors),
<a name="l00079"></a>00079     IXGBE_NETDEV_STAT(tx_carrier_errors),
<a name="l00080"></a>00080     IXGBE_NETDEV_STAT(tx_fifo_errors),
<a name="l00081"></a>00081     IXGBE_NETDEV_STAT(tx_heartbeat_errors),
<a name="l00082"></a>00082 };
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="preprocessor">#define IXGBE_STAT(_name, _stat) { \</span>
<a name="l00085"></a>00085 <span class="preprocessor">    .stat_string = _name, \</span>
<a name="l00086"></a>00086 <span class="preprocessor">    .sizeof_stat = FIELD_SIZEOF(struct ixgbe_adapter, _stat), \</span>
<a name="l00087"></a>00087 <span class="preprocessor">    .stat_offset = offsetof(struct ixgbe_adapter, _stat) \</span>
<a name="l00088"></a>00088 <span class="preprocessor">}</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span>ixgbe_stats ixgbe_gstrings_stats[] = {
<a name="l00090"></a>00090     IXGBE_STAT(<span class="stringliteral">&quot;rx_pkts_nic&quot;</span>, stats.gprc),
<a name="l00091"></a>00091     IXGBE_STAT(<span class="stringliteral">&quot;tx_pkts_nic&quot;</span>, stats.gptc),
<a name="l00092"></a>00092     IXGBE_STAT(<span class="stringliteral">&quot;rx_bytes_nic&quot;</span>, stats.gorc),
<a name="l00093"></a>00093     IXGBE_STAT(<span class="stringliteral">&quot;tx_bytes_nic&quot;</span>, stats.gotc),
<a name="l00094"></a>00094     IXGBE_STAT(<span class="stringliteral">&quot;lsc_int&quot;</span>, lsc_int),
<a name="l00095"></a>00095     IXGBE_STAT(<span class="stringliteral">&quot;tx_busy&quot;</span>, tx_busy),
<a name="l00096"></a>00096     IXGBE_STAT(<span class="stringliteral">&quot;non_eop_descs&quot;</span>, non_eop_descs),
<a name="l00097"></a>00097 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;rx_dropped_backlog&quot;</span>, rx_dropped_backlog),
<a name="l00099"></a>00099 <span class="preprocessor">#endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;broadcast&quot;</span>, stats.bprc),
<a name="l00101"></a>00101     IXGBE_STAT(<span class="stringliteral">&quot;rx_no_buffer_count&quot;</span>, stats.rnbc[0]) ,
<a name="l00102"></a>00102     IXGBE_STAT(<span class="stringliteral">&quot;tx_timeout_count&quot;</span>, tx_timeout_count),
<a name="l00103"></a>00103     IXGBE_STAT(<span class="stringliteral">&quot;tx_restart_queue&quot;</span>, restart_queue),
<a name="l00104"></a>00104     IXGBE_STAT(<span class="stringliteral">&quot;rx_long_length_errors&quot;</span>, stats.roc),
<a name="l00105"></a>00105     IXGBE_STAT(<span class="stringliteral">&quot;rx_short_length_errors&quot;</span>, stats.ruc),
<a name="l00106"></a>00106     IXGBE_STAT(<span class="stringliteral">&quot;tx_flow_control_xon&quot;</span>, stats.lxontxc),
<a name="l00107"></a>00107     IXGBE_STAT(<span class="stringliteral">&quot;rx_flow_control_xon&quot;</span>, stats.lxonrxc),
<a name="l00108"></a>00108     IXGBE_STAT(<span class="stringliteral">&quot;tx_flow_control_xoff&quot;</span>, stats.lxofftxc),
<a name="l00109"></a>00109     IXGBE_STAT(<span class="stringliteral">&quot;rx_flow_control_xoff&quot;</span>, stats.lxoffrxc),
<a name="l00110"></a>00110     IXGBE_STAT(<span class="stringliteral">&quot;rx_csum_offload_errors&quot;</span>, hw_csum_rx_error),
<a name="l00111"></a>00111 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;low_latency_interrupt&quot;</span>, lli_int),
<a name="l00113"></a>00113 <span class="preprocessor">#endif</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;alloc_rx_page_failed&quot;</span>, alloc_rx_page_failed),
<a name="l00115"></a>00115     IXGBE_STAT(<span class="stringliteral">&quot;alloc_rx_buff_failed&quot;</span>, alloc_rx_buff_failed),
<a name="l00116"></a>00116 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;lro_aggregated&quot;</span>, lro_stats.coal),
<a name="l00118"></a>00118     IXGBE_STAT(<span class="stringliteral">&quot;lro_flushed&quot;</span>, lro_stats.flushed),
<a name="l00119"></a>00119     IXGBE_STAT(<span class="stringliteral">&quot;lro_recycled&quot;</span>, lro_stats.recycled),
<a name="l00120"></a>00120 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l00121"></a>00121     IXGBE_STAT(<span class="stringliteral">&quot;rx_no_dma_resources&quot;</span>, hw_rx_no_dma_resources),
<a name="l00122"></a>00122     IXGBE_STAT(<span class="stringliteral">&quot;hw_rsc_aggregated&quot;</span>, rsc_total_count),
<a name="l00123"></a>00123     IXGBE_STAT(<span class="stringliteral">&quot;hw_rsc_flushed&quot;</span>, rsc_total_flush),
<a name="l00124"></a>00124     IXGBE_STAT(<span class="stringliteral">&quot;rx_flm&quot;</span>, flm),
<a name="l00125"></a>00125 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;fdir_match&quot;</span>, stats.fdirmatch),
<a name="l00127"></a>00127     IXGBE_STAT(<span class="stringliteral">&quot;fdir_miss&quot;</span>, stats.fdirmiss),
<a name="l00128"></a>00128     IXGBE_STAT(<span class="stringliteral">&quot;fdir_overflow&quot;</span>, fdir_overflow),
<a name="l00129"></a>00129 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l00130"></a>00130 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;fcoe_bad_fccrc&quot;</span>, stats.fccrc),
<a name="l00132"></a>00132     IXGBE_STAT(<span class="stringliteral">&quot;fcoe_last_errors&quot;</span>, stats.fclast),
<a name="l00133"></a>00133     IXGBE_STAT(<span class="stringliteral">&quot;rx_fcoe_dropped&quot;</span>, stats.fcoerpdc),
<a name="l00134"></a>00134     IXGBE_STAT(<span class="stringliteral">&quot;rx_fcoe_packets&quot;</span>, stats.fcoeprc),
<a name="l00135"></a>00135     IXGBE_STAT(<span class="stringliteral">&quot;rx_fcoe_dwords&quot;</span>, stats.fcoedwrc),
<a name="l00136"></a>00136     IXGBE_STAT(<span class="stringliteral">&quot;tx_fcoe_packets&quot;</span>, stats.fcoeptc),
<a name="l00137"></a>00137     IXGBE_STAT(<span class="stringliteral">&quot;tx_fcoe_dwords&quot;</span>, stats.fcoedwtc),
<a name="l00138"></a>00138 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l00139"></a>00139 };
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="preprocessor">#define IXGBE_QUEUE_STATS_LEN \</span>
<a name="l00142"></a>00142 <span class="preprocessor">           ((((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;num_tx_queues + \</span>
<a name="l00143"></a>00143 <span class="preprocessor">             ((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;num_rx_queues) * \</span>
<a name="l00144"></a>00144 <span class="preprocessor">             (sizeof(struct ixgbe_queue_stats) / sizeof(u64)))</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_GLOBAL_STATS_LEN  ARRAY_SIZE(ixgbe_gstrings_stats)</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_NETDEV_STATS_LEN ARRAY_SIZE(ixgbe_gstrings_net_stats)</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_PB_STATS_LEN ( \</span>
<a name="l00148"></a>00148 <span class="preprocessor">        (((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;flags &amp; \</span>
<a name="l00149"></a>00149 <span class="preprocessor">         IXGBE_FLAG_DCB_ENABLED) ? \</span>
<a name="l00150"></a>00150 <span class="preprocessor">         (sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxonrxc) + \</span>
<a name="l00151"></a>00151 <span class="preprocessor">          sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxontxc) + \</span>
<a name="l00152"></a>00152 <span class="preprocessor">          sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxoffrxc) + \</span>
<a name="l00153"></a>00153 <span class="preprocessor">          sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxofftxc)) \</span>
<a name="l00154"></a>00154 <span class="preprocessor">         / sizeof(u64) : 0)</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_VF_STATS_LEN \</span>
<a name="l00156"></a>00156 <span class="preprocessor">        ((((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;num_vfs) * \</span>
<a name="l00157"></a>00157 <span class="preprocessor">          (sizeof(struct vf_stats) / sizeof(u64)))</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_STATS_LEN (IXGBE_GLOBAL_STATS_LEN + \</span>
<a name="l00159"></a>00159 <span class="preprocessor">             IXGBE_NETDEV_STATS_LEN + \</span>
<a name="l00160"></a>00160 <span class="preprocessor">             IXGBE_PB_STATS_LEN + \</span>
<a name="l00161"></a>00161 <span class="preprocessor">             IXGBE_QUEUE_STATS_LEN + \</span>
<a name="l00162"></a>00162 <span class="preprocessor">             IXGBE_VF_STATS_LEN)</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>
<a name="l00164"></a>00164 <span class="preprocessor">#endif </span><span class="comment">/* ETHTOOL_GSTATS */</span>
<a name="l00165"></a>00165 <span class="preprocessor">#ifdef ETHTOOL_TEST</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> ixgbe_gstrings_test[][ETH_GSTRING_LEN] = {
<a name="l00167"></a>00167     <span class="stringliteral">&quot;Register test  (offline)&quot;</span>, <span class="stringliteral">&quot;Eeprom test    (offline)&quot;</span>,
<a name="l00168"></a>00168     <span class="stringliteral">&quot;Interrupt test (offline)&quot;</span>, <span class="stringliteral">&quot;Loopback test  (offline)&quot;</span>,
<a name="l00169"></a>00169     <span class="stringliteral">&quot;Link test   (on/offline)&quot;</span>
<a name="l00170"></a>00170 };
<a name="l00171"></a>00171 <span class="preprocessor">#define IXGBE_TEST_LEN sizeof(ixgbe_gstrings_test) / ETH_GSTRING_LEN</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* ETHTOOL_TEST */</span>
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="keywordtype">int</span> ixgbe_get_settings(<span class="keyword">struct</span> net_device *netdev,
<a name="l00175"></a>00175                               <span class="keyword">struct</span> ethtool_cmd *ecmd)
<a name="l00176"></a>00176 {
<a name="l00177"></a>00177     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00178"></a>00178     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00179"></a>00179     u32 link_speed = 0;
<a name="l00180"></a>00180     <span class="keywordtype">bool</span> link_up;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     ecmd-&gt;supported = SUPPORTED_10000baseT_Full;
<a name="l00183"></a>00183     ecmd-&gt;autoneg = AUTONEG_ENABLE;
<a name="l00184"></a>00184     ecmd-&gt;transceiver = XCVR_EXTERNAL;
<a name="l00185"></a>00185     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type == ixgbe_media_type_copper) ||
<a name="l00186"></a>00186         (hw-&gt;phy.multispeed_fiber)) {
<a name="l00187"></a>00187         ecmd-&gt;supported |= (SUPPORTED_1000baseT_Full |
<a name="l00188"></a>00188                             SUPPORTED_Autoneg);
<a name="l00189"></a>00189         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00190"></a>00190         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00191"></a>00191             ecmd-&gt;supported |= SUPPORTED_100baseT_Full;
<a name="l00192"></a>00192             <span class="keywordflow">break</span>;
<a name="l00193"></a>00193         <span class="keywordflow">default</span>:
<a name="l00194"></a>00194             <span class="keywordflow">break</span>;
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197         ecmd-&gt;advertising = ADVERTISED_Autoneg;
<a name="l00198"></a>00198         <span class="keywordflow">if</span> (hw-&gt;phy.autoneg_advertised) {
<a name="l00199"></a>00199             <span class="keywordflow">if</span> (hw-&gt;phy.autoneg_advertised &amp;
<a name="l00200"></a>00200                 IXGBE_LINK_SPEED_100_FULL)
<a name="l00201"></a>00201                 ecmd-&gt;advertising |= ADVERTISED_100baseT_Full;
<a name="l00202"></a>00202             <span class="keywordflow">if</span> (hw-&gt;phy.autoneg_advertised &amp;
<a name="l00203"></a>00203                 IXGBE_LINK_SPEED_10GB_FULL)
<a name="l00204"></a>00204                 ecmd-&gt;advertising |= ADVERTISED_10000baseT_Full;
<a name="l00205"></a>00205             <span class="keywordflow">if</span> (hw-&gt;phy.autoneg_advertised &amp;
<a name="l00206"></a>00206                 IXGBE_LINK_SPEED_1GB_FULL)
<a name="l00207"></a>00207                 ecmd-&gt;advertising |= ADVERTISED_1000baseT_Full;
<a name="l00208"></a>00208         } <span class="keywordflow">else</span> {
<a name="l00209"></a>00209             <span class="comment">/*</span>
<a name="l00210"></a>00210 <span class="comment">             * Default advertised modes in case</span>
<a name="l00211"></a>00211 <span class="comment">             * phy.autoneg_advertised isn&#39;t set.</span>
<a name="l00212"></a>00212 <span class="comment">             */</span>
<a name="l00213"></a>00213             ecmd-&gt;advertising |= (ADVERTISED_10000baseT_Full |
<a name="l00214"></a>00214                           ADVERTISED_1000baseT_Full);
<a name="l00215"></a>00215             <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_X540)
<a name="l00216"></a>00216                 ecmd-&gt;advertising |= ADVERTISED_100baseT_Full;
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="keywordflow">if</span> (hw-&gt;phy.media_type == ixgbe_media_type_copper) {
<a name="l00220"></a>00220             ecmd-&gt;supported |= SUPPORTED_TP;
<a name="l00221"></a>00221             ecmd-&gt;advertising |= ADVERTISED_TP;
<a name="l00222"></a>00222             ecmd-&gt;port = PORT_TP;
<a name="l00223"></a>00223         } <span class="keywordflow">else</span> {
<a name="l00224"></a>00224             ecmd-&gt;supported |= SUPPORTED_FIBRE;
<a name="l00225"></a>00225             ecmd-&gt;advertising |= ADVERTISED_FIBRE;
<a name="l00226"></a>00226             ecmd-&gt;port = PORT_FIBRE;
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;phy.media_type == ixgbe_media_type_backplane) {
<a name="l00229"></a>00229         <span class="comment">/* Set as FIBRE until SERDES defined in kernel */</span>
<a name="l00230"></a>00230         <span class="keywordflow">if</span> (hw-&gt;device_id == IXGBE_DEV_ID_82598_BX) {
<a name="l00231"></a>00231             ecmd-&gt;supported = (SUPPORTED_1000baseT_Full |
<a name="l00232"></a>00232                        SUPPORTED_FIBRE);
<a name="l00233"></a>00233             ecmd-&gt;advertising = (ADVERTISED_1000baseT_Full |
<a name="l00234"></a>00234                          ADVERTISED_FIBRE);
<a name="l00235"></a>00235             ecmd-&gt;port = PORT_FIBRE;
<a name="l00236"></a>00236             ecmd-&gt;autoneg = AUTONEG_DISABLE;
<a name="l00237"></a>00237         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((hw-&gt;device_id == IXGBE_DEV_ID_82599_COMBO_BACKPLANE) ||
<a name="l00238"></a>00238                (hw-&gt;device_id == IXGBE_DEV_ID_82599_KX4_MEZZ)) {
<a name="l00239"></a>00239             ecmd-&gt;supported |= (SUPPORTED_1000baseT_Full |
<a name="l00240"></a>00240                         SUPPORTED_Autoneg |
<a name="l00241"></a>00241                         SUPPORTED_FIBRE);
<a name="l00242"></a>00242             ecmd-&gt;advertising = (ADVERTISED_10000baseT_Full |
<a name="l00243"></a>00243                          ADVERTISED_1000baseT_Full |
<a name="l00244"></a>00244                          ADVERTISED_Autoneg |
<a name="l00245"></a>00245                          ADVERTISED_FIBRE);
<a name="l00246"></a>00246             ecmd-&gt;port = PORT_FIBRE;
<a name="l00247"></a>00247         } <span class="keywordflow">else</span> {
<a name="l00248"></a>00248             ecmd-&gt;supported |= (SUPPORTED_1000baseT_Full |
<a name="l00249"></a>00249                         SUPPORTED_FIBRE);
<a name="l00250"></a>00250             ecmd-&gt;advertising = (ADVERTISED_10000baseT_Full |
<a name="l00251"></a>00251                          ADVERTISED_1000baseT_Full |
<a name="l00252"></a>00252                          ADVERTISED_FIBRE);
<a name="l00253"></a>00253             ecmd-&gt;port = PORT_FIBRE;
<a name="l00254"></a>00254         }
<a name="l00255"></a>00255     } <span class="keywordflow">else</span> {
<a name="l00256"></a>00256         ecmd-&gt;supported |= SUPPORTED_FIBRE;
<a name="l00257"></a>00257         ecmd-&gt;advertising = (ADVERTISED_10000baseT_Full |
<a name="l00258"></a>00258                              ADVERTISED_FIBRE);
<a name="l00259"></a>00259         ecmd-&gt;port = PORT_FIBRE;
<a name="l00260"></a>00260         ecmd-&gt;autoneg = AUTONEG_DISABLE;
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="preprocessor">#ifdef HAVE_ETHTOOL_SFP_DISPLAY_PORT</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span>    <span class="comment">/* Get PHY type */</span>
<a name="l00265"></a>00265     <span class="keywordflow">switch</span> (adapter-&gt;hw.phy.type) {
<a name="l00266"></a>00266     <span class="keywordflow">case</span> ixgbe_phy_tn:
<a name="l00267"></a>00267     <span class="keywordflow">case</span> ixgbe_phy_aq:
<a name="l00268"></a>00268     <span class="keywordflow">case</span> ixgbe_phy_cu_unknown:
<a name="l00269"></a>00269         <span class="comment">/* Copper 10G-BASET */</span>
<a name="l00270"></a>00270         ecmd-&gt;port = PORT_TP;
<a name="l00271"></a>00271         <span class="keywordflow">break</span>;
<a name="l00272"></a>00272     <span class="keywordflow">case</span> ixgbe_phy_qt:
<a name="l00273"></a>00273         ecmd-&gt;port = PORT_FIBRE;
<a name="l00274"></a>00274         <span class="keywordflow">break</span>;
<a name="l00275"></a>00275     <span class="keywordflow">case</span> ixgbe_phy_nl:
<a name="l00276"></a>00276     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_tyco:
<a name="l00277"></a>00277     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_unknown:
<a name="l00278"></a>00278     <span class="keywordflow">case</span> ixgbe_phy_sfp_ftl:
<a name="l00279"></a>00279     <span class="keywordflow">case</span> ixgbe_phy_sfp_avago:
<a name="l00280"></a>00280     <span class="keywordflow">case</span> ixgbe_phy_sfp_intel:
<a name="l00281"></a>00281     <span class="keywordflow">case</span> ixgbe_phy_sfp_unknown:
<a name="l00282"></a>00282         <span class="keywordflow">switch</span> (adapter-&gt;hw.phy.sfp_type) {
<a name="l00283"></a>00283         <span class="comment">/* SFP+ devices, further checking needed */</span>
<a name="l00284"></a>00284         <span class="keywordflow">case</span> ixgbe_sfp_type_da_cu:
<a name="l00285"></a>00285         <span class="keywordflow">case</span> ixgbe_sfp_type_da_cu_core0:
<a name="l00286"></a>00286         <span class="keywordflow">case</span> ixgbe_sfp_type_da_cu_core1:
<a name="l00287"></a>00287             ecmd-&gt;port = PORT_DA;
<a name="l00288"></a>00288             <span class="keywordflow">break</span>;
<a name="l00289"></a>00289         <span class="keywordflow">case</span> ixgbe_sfp_type_sr:
<a name="l00290"></a>00290         <span class="keywordflow">case</span> ixgbe_sfp_type_lr:
<a name="l00291"></a>00291         <span class="keywordflow">case</span> ixgbe_sfp_type_srlr_core0:
<a name="l00292"></a>00292         <span class="keywordflow">case</span> ixgbe_sfp_type_srlr_core1:
<a name="l00293"></a>00293             ecmd-&gt;port = PORT_FIBRE;
<a name="l00294"></a>00294             <span class="keywordflow">break</span>;
<a name="l00295"></a>00295         <span class="keywordflow">case</span> ixgbe_sfp_type_not_present:
<a name="l00296"></a>00296             ecmd-&gt;port = PORT_NONE;
<a name="l00297"></a>00297             <span class="keywordflow">break</span>;
<a name="l00298"></a>00298         <span class="keywordflow">case</span> ixgbe_sfp_type_1g_cu_core0:
<a name="l00299"></a>00299         <span class="keywordflow">case</span> ixgbe_sfp_type_1g_cu_core1:
<a name="l00300"></a>00300             ecmd-&gt;port = PORT_TP;
<a name="l00301"></a>00301             ecmd-&gt;supported = SUPPORTED_TP;
<a name="l00302"></a>00302             ecmd-&gt;advertising = (ADVERTISED_1000baseT_Full |
<a name="l00303"></a>00303                 ADVERTISED_TP);
<a name="l00304"></a>00304             <span class="keywordflow">break</span>;
<a name="l00305"></a>00305         <span class="keywordflow">case</span> ixgbe_sfp_type_unknown:
<a name="l00306"></a>00306         <span class="keywordflow">default</span>:
<a name="l00307"></a>00307             ecmd-&gt;port = PORT_OTHER;
<a name="l00308"></a>00308             <span class="keywordflow">break</span>;
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310         <span class="keywordflow">break</span>;
<a name="l00311"></a>00311     <span class="keywordflow">case</span> ixgbe_phy_xaui:
<a name="l00312"></a>00312         ecmd-&gt;port = PORT_NONE;
<a name="l00313"></a>00313         <span class="keywordflow">break</span>;
<a name="l00314"></a>00314     <span class="keywordflow">case</span> ixgbe_phy_unknown:
<a name="l00315"></a>00315     <span class="keywordflow">case</span> ixgbe_phy_generic:
<a name="l00316"></a>00316     <span class="keywordflow">case</span> ixgbe_phy_sfp_unsupported:
<a name="l00317"></a>00317     <span class="keywordflow">default</span>:
<a name="l00318"></a>00318         ecmd-&gt;port = PORT_OTHER;
<a name="l00319"></a>00319         <span class="keywordflow">break</span>;
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321 <span class="preprocessor">#endif</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>
<a name="l00323"></a>00323     <span class="keywordflow">if</span> (!in_interrupt()) {
<a name="l00324"></a>00324         hw-&gt;mac.ops.check_link(hw, &amp;link_speed, &amp;link_up, <span class="keyword">false</span>);
<a name="l00325"></a>00325     } <span class="keywordflow">else</span> {
<a name="l00326"></a>00326         <span class="comment">/*</span>
<a name="l00327"></a>00327 <span class="comment">         * this case is a special workaround for RHEL5 bonding</span>
<a name="l00328"></a>00328 <span class="comment">         * that calls this routine from interrupt context</span>
<a name="l00329"></a>00329 <span class="comment">         */</span>
<a name="l00330"></a>00330         link_speed = adapter-&gt;link_speed;
<a name="l00331"></a>00331         link_up = adapter-&gt;link_up;
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     <span class="keywordflow">if</span> (link_up) {
<a name="l00335"></a>00335         <span class="keywordflow">switch</span> (link_speed) {
<a name="l00336"></a>00336         <span class="keywordflow">case</span> IXGBE_LINK_SPEED_10GB_FULL:
<a name="l00337"></a>00337             ecmd-&gt;speed = SPEED_10000;
<a name="l00338"></a>00338             <span class="keywordflow">break</span>;
<a name="l00339"></a>00339         <span class="keywordflow">case</span> IXGBE_LINK_SPEED_1GB_FULL:
<a name="l00340"></a>00340             ecmd-&gt;speed = SPEED_1000;
<a name="l00341"></a>00341             <span class="keywordflow">break</span>;
<a name="l00342"></a>00342         <span class="keywordflow">case</span> IXGBE_LINK_SPEED_100_FULL:
<a name="l00343"></a>00343             ecmd-&gt;speed = SPEED_100;
<a name="l00344"></a>00344             <span class="keywordflow">break</span>;
<a name="l00345"></a>00345         <span class="keywordflow">default</span>:
<a name="l00346"></a>00346             <span class="keywordflow">break</span>;
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348         ecmd-&gt;duplex = DUPLEX_FULL;
<a name="l00349"></a>00349     } <span class="keywordflow">else</span> {
<a name="l00350"></a>00350         ecmd-&gt;speed = -1;
<a name="l00351"></a>00351         ecmd-&gt;duplex = -1;
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="keywordflow">return</span> 0;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_settings(<span class="keyword">struct</span> net_device *netdev,
<a name="l00358"></a>00358                               <span class="keyword">struct</span> ethtool_cmd *ecmd)
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00361"></a>00361     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00362"></a>00362     u32 advertised, old;
<a name="l00363"></a>00363     s32 err = 0;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type == ixgbe_media_type_copper) ||
<a name="l00366"></a>00366         (hw-&gt;phy.multispeed_fiber)) {
<a name="l00367"></a>00367         <span class="comment">/* 10000/copper and 1000/copper must autoneg</span>
<a name="l00368"></a>00368 <span class="comment">         * this function does not support any duplex forcing, but can</span>
<a name="l00369"></a>00369 <span class="comment">         * limit the advertising of the adapter to only 10000 or 1000 */</span>
<a name="l00370"></a>00370         <span class="keywordflow">if</span> (ecmd-&gt;autoneg == AUTONEG_DISABLE)
<a name="l00371"></a>00371             <span class="keywordflow">return</span> -EINVAL;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         old = hw-&gt;phy.autoneg_advertised;
<a name="l00374"></a>00374         advertised = 0;
<a name="l00375"></a>00375         <span class="keywordflow">if</span> (ecmd-&gt;advertising &amp; ADVERTISED_10000baseT_Full)
<a name="l00376"></a>00376             advertised |= IXGBE_LINK_SPEED_10GB_FULL;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         <span class="keywordflow">if</span> (ecmd-&gt;advertising &amp; ADVERTISED_1000baseT_Full)
<a name="l00379"></a>00379             advertised |= IXGBE_LINK_SPEED_1GB_FULL;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381         <span class="keywordflow">if</span> (ecmd-&gt;advertising &amp; ADVERTISED_100baseT_Full)
<a name="l00382"></a>00382             advertised |= IXGBE_LINK_SPEED_100_FULL;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <span class="keywordflow">if</span> (old == advertised)
<a name="l00385"></a>00385             <span class="keywordflow">return</span> err;
<a name="l00386"></a>00386         <span class="comment">/* this sets the link speed and restarts auto-neg */</span>
<a name="l00387"></a>00387         hw-&gt;mac.autotry_restart = <span class="keyword">true</span>;
<a name="l00388"></a>00388         err = hw-&gt;mac.ops.setup_link(hw, advertised, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l00389"></a>00389         <span class="keywordflow">if</span> (err) {
<a name="l00390"></a>00390             e_info(probe, <span class="stringliteral">&quot;setup link failed with code %d\n&quot;</span>, err);
<a name="l00391"></a>00391             hw-&gt;mac.ops.setup_link(hw, old, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l00392"></a>00392         }
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394     <span class="keywordflow">return</span> err;
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_pauseparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l00398"></a>00398                                  <span class="keyword">struct</span> ethtool_pauseparam *pause)
<a name="l00399"></a>00399 {
<a name="l00400"></a>00400     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00401"></a>00401     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <span class="comment">/*</span>
<a name="l00404"></a>00404 <span class="comment">     * Flow Control Autoneg isn&#39;t on if</span>
<a name="l00405"></a>00405 <span class="comment">     *  - we didn&#39;t ask for it OR</span>
<a name="l00406"></a>00406 <span class="comment">     *  - it failed, we know this by tx &amp; rx being off</span>
<a name="l00407"></a>00407 <span class="comment">     */</span>
<a name="l00408"></a>00408     <span class="keywordflow">if</span> (hw-&gt;fc.disable_fc_autoneg ||
<a name="l00409"></a>00409         (hw-&gt;fc.current_mode == ixgbe_fc_none))
<a name="l00410"></a>00410         pause-&gt;autoneg = 0;
<a name="l00411"></a>00411     <span class="keywordflow">else</span>
<a name="l00412"></a>00412         pause-&gt;autoneg = 1;
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_rx_pause) {
<a name="l00415"></a>00415         pause-&gt;rx_pause = 1;
<a name="l00416"></a>00416     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_tx_pause) {
<a name="l00417"></a>00417         pause-&gt;tx_pause = 1;
<a name="l00418"></a>00418     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_full) {
<a name="l00419"></a>00419         pause-&gt;rx_pause = 1;
<a name="l00420"></a>00420         pause-&gt;tx_pause = 1;
<a name="l00421"></a>00421 <span class="preprocessor">#ifdef CONFIG_DCB</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_pfc) {
<a name="l00423"></a>00423         pause-&gt;rx_pause = 0;
<a name="l00424"></a>00424         pause-&gt;tx_pause = 0;
<a name="l00425"></a>00425 <span class="preprocessor">#endif</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>    }
<a name="l00427"></a>00427 }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_pauseparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l00430"></a>00430                                 <span class="keyword">struct</span> ethtool_pauseparam *pause)
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00433"></a>00433     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00434"></a>00434     <span class="keyword">struct </span><a class="code" href="structixgbe__fc__info.html">ixgbe_fc_info</a> fc;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436     <span class="keywordflow">if</span> (adapter-&gt;dcb_cfg.pfc_mode_enable ||
<a name="l00437"></a>00437         ((hw-&gt;mac.type == ixgbe_mac_82598EB) &amp;&amp;
<a name="l00438"></a>00438         (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)))
<a name="l00439"></a>00439         <span class="keywordflow">return</span> -EINVAL;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     fc = hw-&gt;fc;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     <span class="keywordflow">if</span> (pause-&gt;autoneg != AUTONEG_ENABLE)
<a name="l00444"></a>00444         fc.disable_fc_autoneg = <span class="keyword">true</span>;
<a name="l00445"></a>00445     <span class="keywordflow">else</span>
<a name="l00446"></a>00446         fc.disable_fc_autoneg = <span class="keyword">false</span>;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="keywordflow">if</span> ((pause-&gt;rx_pause &amp;&amp; pause-&gt;tx_pause) || pause-&gt;autoneg)
<a name="l00449"></a>00449         fc.requested_mode = ixgbe_fc_full;
<a name="l00450"></a>00450     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pause-&gt;rx_pause &amp;&amp; !pause-&gt;tx_pause)
<a name="l00451"></a>00451         fc.requested_mode = ixgbe_fc_rx_pause;
<a name="l00452"></a>00452     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pause-&gt;rx_pause &amp;&amp; pause-&gt;tx_pause)
<a name="l00453"></a>00453         fc.requested_mode = ixgbe_fc_tx_pause;
<a name="l00454"></a>00454     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pause-&gt;rx_pause &amp;&amp; !pause-&gt;tx_pause)
<a name="l00455"></a>00455         fc.requested_mode = ixgbe_fc_none;
<a name="l00456"></a>00456     <span class="keywordflow">else</span>
<a name="l00457"></a>00457         <span class="keywordflow">return</span> -EINVAL;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459     adapter-&gt;last_lfc_mode = fc.requested_mode;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461     <span class="comment">/* if the thing changed then we&#39;ll update and use new autoneg */</span>
<a name="l00462"></a>00462     <span class="keywordflow">if</span> (memcmp(&amp;fc, &amp;hw-&gt;fc, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__fc__info.html">ixgbe_fc_info</a>))) {
<a name="l00463"></a>00463         hw-&gt;fc = fc;
<a name="l00464"></a>00464         <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l00465"></a>00465             ixgbe_reinit_locked(adapter);
<a name="l00466"></a>00466         <span class="keywordflow">else</span>
<a name="l00467"></a>00467             ixgbe_reset(adapter);
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="keywordflow">return</span> 0;
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="keyword">static</span> u32 ixgbe_get_rx_csum(<span class="keyword">struct</span> net_device *netdev)
<a name="l00474"></a>00474 {
<a name="l00475"></a>00475     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00476"></a>00476     <span class="keywordflow">return</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_CSUM_ENABLED);
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_rx_csum(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00482"></a>00482     <span class="keywordflow">if</span> (data)
<a name="l00483"></a>00483         adapter-&gt;flags |= IXGBE_FLAG_RX_CSUM_ENABLED;
<a name="l00484"></a>00484     <span class="keywordflow">else</span>
<a name="l00485"></a>00485         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RX_CSUM_ENABLED;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487     <span class="keywordflow">return</span> 0;
<a name="l00488"></a>00488 }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keyword">static</span> u32 ixgbe_get_tx_csum(<span class="keyword">struct</span> net_device *netdev)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492     <span class="keywordflow">return</span> (netdev-&gt;features &amp; NETIF_F_IP_CSUM) != 0;
<a name="l00493"></a>00493 }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_tx_csum(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00496"></a>00496 {
<a name="l00497"></a>00497     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00498"></a>00498     u32 feature_list;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span>    feature_list = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
<a name="l00502"></a>00502 <span class="preprocessor">#else</span>
<a name="l00503"></a>00503 <span class="preprocessor"></span>    feature_list = NETIF_F_IP_CSUM;
<a name="l00504"></a>00504 <span class="preprocessor">#endif</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span>    <span class="keywordflow">switch</span>(adapter-&gt;hw.mac.type) {
<a name="l00506"></a>00506     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00507"></a>00507     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00508"></a>00508         feature_list |= NETIF_F_SCTP_CSUM;
<a name="l00509"></a>00509         <span class="keywordflow">break</span>;
<a name="l00510"></a>00510     <span class="keywordflow">default</span>:
<a name="l00511"></a>00511         <span class="keywordflow">break</span>;
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513     <span class="keywordflow">if</span> (data)
<a name="l00514"></a>00514         netdev-&gt;features |= feature_list;
<a name="l00515"></a>00515     <span class="keywordflow">else</span>
<a name="l00516"></a>00516         netdev-&gt;features &amp;= ~feature_list;
<a name="l00517"></a>00517         
<a name="l00518"></a>00518     <span class="keywordflow">return</span> 0;
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_tso(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00523"></a>00523 {
<a name="l00524"></a>00524     <span class="keywordflow">if</span> (data) {
<a name="l00525"></a>00525         netdev-&gt;features |= NETIF_F_TSO;
<a name="l00526"></a>00526 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00527"></a>00527 <span class="preprocessor"></span>        netdev-&gt;features |= NETIF_F_TSO6;
<a name="l00528"></a>00528 <span class="preprocessor">#endif</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l00530"></a>00530 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l00531"></a>00531 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00533"></a>00533         <span class="comment">/* disable TSO on all VLANs if they&#39;re present */</span>
<a name="l00534"></a>00534         <span class="keywordflow">if</span> (adapter-&gt;vlgrp) {
<a name="l00535"></a>00535             <span class="keywordtype">int</span> i;
<a name="l00536"></a>00536             <span class="keyword">struct </span>net_device *v_netdev;
<a name="l00537"></a>00537             <span class="keywordflow">for</span> (i = 0; i &lt; VLAN_N_VID; i++) {
<a name="l00538"></a>00538                 v_netdev =
<a name="l00539"></a>00539                        vlan_group_get_device(adapter-&gt;vlgrp, i);
<a name="l00540"></a>00540                 <span class="keywordflow">if</span> (v_netdev) {
<a name="l00541"></a>00541                     v_netdev-&gt;features &amp;= ~NETIF_F_TSO;
<a name="l00542"></a>00542 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>                    v_netdev-&gt;features &amp;= ~NETIF_F_TSO6;
<a name="l00544"></a>00544 <span class="preprocessor">#endif</span>
<a name="l00545"></a>00545 <span class="preprocessor"></span>                    vlan_group_set_device(adapter-&gt;vlgrp, i,
<a name="l00546"></a>00546                                           v_netdev);
<a name="l00547"></a>00547                 }
<a name="l00548"></a>00548             }
<a name="l00549"></a>00549         }
<a name="l00550"></a>00550 <span class="preprocessor">#endif</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l00552"></a>00552         netdev-&gt;features &amp;= ~NETIF_F_TSO;
<a name="l00553"></a>00553 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00554"></a>00554 <span class="preprocessor"></span>        netdev-&gt;features &amp;= ~NETIF_F_TSO6;
<a name="l00555"></a>00555 <span class="preprocessor">#endif</span>
<a name="l00556"></a>00556 <span class="preprocessor"></span>    }
<a name="l00557"></a>00557     <span class="keywordflow">return</span> 0;
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="keyword">static</span> u32 ixgbe_get_msglevel(<span class="keyword">struct</span> net_device *netdev)
<a name="l00562"></a>00562 {
<a name="l00563"></a>00563     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00564"></a>00564     <span class="keywordflow">return</span> adapter-&gt;msg_enable;
<a name="l00565"></a>00565 }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_msglevel(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00570"></a>00570     adapter-&gt;msg_enable = data;
<a name="l00571"></a>00571 }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_regs_len(<span class="keyword">struct</span> net_device *netdev)
<a name="l00574"></a>00574 {
<a name="l00575"></a>00575 <span class="preprocessor">#define IXGBE_REGS_LEN  1128</span>
<a name="l00576"></a>00576 <span class="preprocessor"></span>    <span class="keywordflow">return</span> IXGBE_REGS_LEN * <span class="keyword">sizeof</span>(u32);
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 <span class="preprocessor">#define IXGBE_GET_STAT(_A_, _R_) _A_-&gt;stats._R_</span>
<a name="l00580"></a>00580 <span class="preprocessor"></span>
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_regs(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> ethtool_regs *regs,
<a name="l00583"></a>00583                            <span class="keywordtype">void</span> *p)
<a name="l00584"></a>00584 {
<a name="l00585"></a>00585     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00586"></a>00586     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00587"></a>00587     u32 *regs_buff = p;
<a name="l00588"></a>00588     u8 i;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     memset(p, 0, IXGBE_REGS_LEN * <span class="keyword">sizeof</span>(u32));
<a name="l00591"></a>00591 
<a name="l00592"></a>00592     regs-&gt;version = (1 &lt;&lt; 24) | hw-&gt;revision_id &lt;&lt; 16 | hw-&gt;device_id;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594     <span class="comment">/* General Registers */</span>
<a name="l00595"></a>00595     regs_buff[0] = IXGBE_READ_REG(hw, IXGBE_CTRL);
<a name="l00596"></a>00596     regs_buff[1] = IXGBE_READ_REG(hw, IXGBE_STATUS);
<a name="l00597"></a>00597     regs_buff[2] = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
<a name="l00598"></a>00598     regs_buff[3] = IXGBE_READ_REG(hw, IXGBE_ESDP);
<a name="l00599"></a>00599     regs_buff[4] = IXGBE_READ_REG(hw, IXGBE_EODSDP);
<a name="l00600"></a>00600     regs_buff[5] = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
<a name="l00601"></a>00601     regs_buff[6] = IXGBE_READ_REG(hw, IXGBE_FRTIMER);
<a name="l00602"></a>00602     regs_buff[7] = IXGBE_READ_REG(hw, IXGBE_TCPTIMER);
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="comment">/* NVM Register */</span>
<a name="l00605"></a>00605     regs_buff[8] = IXGBE_READ_REG(hw, IXGBE_EEC);
<a name="l00606"></a>00606     regs_buff[9] = IXGBE_READ_REG(hw, IXGBE_EERD);
<a name="l00607"></a>00607     regs_buff[10] = IXGBE_READ_REG(hw, IXGBE_FLA);
<a name="l00608"></a>00608     regs_buff[11] = IXGBE_READ_REG(hw, IXGBE_EEMNGCTL);
<a name="l00609"></a>00609     regs_buff[12] = IXGBE_READ_REG(hw, IXGBE_EEMNGDATA);
<a name="l00610"></a>00610     regs_buff[13] = IXGBE_READ_REG(hw, IXGBE_FLMNGCTL);
<a name="l00611"></a>00611     regs_buff[14] = IXGBE_READ_REG(hw, IXGBE_FLMNGDATA);
<a name="l00612"></a>00612     regs_buff[15] = IXGBE_READ_REG(hw, IXGBE_FLMNGCNT);
<a name="l00613"></a>00613     regs_buff[16] = IXGBE_READ_REG(hw, IXGBE_FLOP);
<a name="l00614"></a>00614     regs_buff[17] = IXGBE_READ_REG(hw, IXGBE_GRC);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616     <span class="comment">/* Interrupt */</span>
<a name="l00617"></a>00617     <span class="comment">/* don&#39;t read EICR because it can clear interrupt causes, instead</span>
<a name="l00618"></a>00618 <span class="comment">     * read EICS which is a shadow but doesn&#39;t clear EICR */</span>
<a name="l00619"></a>00619     regs_buff[18] = IXGBE_READ_REG(hw, IXGBE_EICS);
<a name="l00620"></a>00620     regs_buff[19] = IXGBE_READ_REG(hw, IXGBE_EICS);
<a name="l00621"></a>00621     regs_buff[20] = IXGBE_READ_REG(hw, IXGBE_EIMS);
<a name="l00622"></a>00622     regs_buff[21] = IXGBE_READ_REG(hw, IXGBE_EIMC);
<a name="l00623"></a>00623     regs_buff[22] = IXGBE_READ_REG(hw, IXGBE_EIAC);
<a name="l00624"></a>00624     regs_buff[23] = IXGBE_READ_REG(hw, IXGBE_EIAM);
<a name="l00625"></a>00625     regs_buff[24] = IXGBE_READ_REG(hw, IXGBE_EITR(0));
<a name="l00626"></a>00626     regs_buff[25] = IXGBE_READ_REG(hw, IXGBE_IVAR(0));
<a name="l00627"></a>00627     regs_buff[26] = IXGBE_READ_REG(hw, IXGBE_MSIXT);
<a name="l00628"></a>00628     regs_buff[27] = IXGBE_READ_REG(hw, IXGBE_MSIXPBA);
<a name="l00629"></a>00629     regs_buff[28] = IXGBE_READ_REG(hw, IXGBE_PBACL(0));
<a name="l00630"></a>00630     regs_buff[29] = IXGBE_READ_REG(hw, IXGBE_GPIE);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     <span class="comment">/* Flow Control */</span>
<a name="l00633"></a>00633     regs_buff[30] = IXGBE_READ_REG(hw, IXGBE_PFCTOP);
<a name="l00634"></a>00634     regs_buff[31] = IXGBE_READ_REG(hw, IXGBE_FCTTV(0));
<a name="l00635"></a>00635     regs_buff[32] = IXGBE_READ_REG(hw, IXGBE_FCTTV(1));
<a name="l00636"></a>00636     regs_buff[33] = IXGBE_READ_REG(hw, IXGBE_FCTTV(2));
<a name="l00637"></a>00637     regs_buff[34] = IXGBE_READ_REG(hw, IXGBE_FCTTV(3));
<a name="l00638"></a>00638     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {
<a name="l00639"></a>00639         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00640"></a>00640         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00641"></a>00641             regs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL(i));
<a name="l00642"></a>00642             regs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH(i));
<a name="l00643"></a>00643             <span class="keywordflow">break</span>;
<a name="l00644"></a>00644         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00645"></a>00645         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00646"></a>00646             regs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL_82599(i));
<a name="l00647"></a>00647             regs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH_82599(i));
<a name="l00648"></a>00648             <span class="keywordflow">break</span>;
<a name="l00649"></a>00649         <span class="keywordflow">default</span>:
<a name="l00650"></a>00650             <span class="keywordflow">break</span>;
<a name="l00651"></a>00651         }
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653     regs_buff[51] = IXGBE_READ_REG(hw, IXGBE_FCRTV);
<a name="l00654"></a>00654     regs_buff[52] = IXGBE_READ_REG(hw, IXGBE_TFCS);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656     <span class="comment">/* Receive DMA */</span>
<a name="l00657"></a>00657     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00658"></a>00658         regs_buff[53 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAL(i));
<a name="l00659"></a>00659     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00660"></a>00660         regs_buff[117 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAH(i));
<a name="l00661"></a>00661     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00662"></a>00662         regs_buff[181 + i] = IXGBE_READ_REG(hw, IXGBE_RDLEN(i));
<a name="l00663"></a>00663     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00664"></a>00664         regs_buff[245 + i] = IXGBE_READ_REG(hw, IXGBE_RDH(i));
<a name="l00665"></a>00665     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00666"></a>00666         regs_buff[309 + i] = IXGBE_READ_REG(hw, IXGBE_RDT(i));
<a name="l00667"></a>00667     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00668"></a>00668         regs_buff[373 + i] = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));
<a name="l00669"></a>00669     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00670"></a>00670         regs_buff[437 + i] = IXGBE_READ_REG(hw, IXGBE_SRRCTL(i));
<a name="l00671"></a>00671     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00672"></a>00672         regs_buff[453 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
<a name="l00673"></a>00673     regs_buff[469] = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
<a name="l00674"></a>00674     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00675"></a>00675         regs_buff[470 + i] = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i));
<a name="l00676"></a>00676     regs_buff[478] = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l00677"></a>00677     regs_buff[479] = IXGBE_READ_REG(hw, IXGBE_DROPEN);
<a name="l00678"></a>00678 
<a name="l00679"></a>00679     <span class="comment">/* Receive */</span>
<a name="l00680"></a>00680     regs_buff[480] = IXGBE_READ_REG(hw, IXGBE_RXCSUM);
<a name="l00681"></a>00681     regs_buff[481] = IXGBE_READ_REG(hw, IXGBE_RFCTL);
<a name="l00682"></a>00682     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00683"></a>00683         regs_buff[482 + i] = IXGBE_READ_REG(hw, IXGBE_RAL(i));
<a name="l00684"></a>00684     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00685"></a>00685         regs_buff[498 + i] = IXGBE_READ_REG(hw, IXGBE_RAH(i));
<a name="l00686"></a>00686     regs_buff[514] = IXGBE_READ_REG(hw, IXGBE_PSRTYPE(0));
<a name="l00687"></a>00687     regs_buff[515] = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l00688"></a>00688     regs_buff[516] = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l00689"></a>00689     regs_buff[517] = IXGBE_READ_REG(hw, IXGBE_MCSTCTRL);
<a name="l00690"></a>00690     regs_buff[518] = IXGBE_READ_REG(hw, IXGBE_MRQC);
<a name="l00691"></a>00691     regs_buff[519] = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
<a name="l00692"></a>00692     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00693"></a>00693         regs_buff[520 + i] = IXGBE_READ_REG(hw, IXGBE_IMIR(i));
<a name="l00694"></a>00694     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00695"></a>00695         regs_buff[528 + i] = IXGBE_READ_REG(hw, IXGBE_IMIREXT(i));
<a name="l00696"></a>00696     regs_buff[536] = IXGBE_READ_REG(hw, IXGBE_IMIRVP);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     <span class="comment">/* Transmit */</span>
<a name="l00699"></a>00699     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00700"></a>00700         regs_buff[537 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAL(i));
<a name="l00701"></a>00701     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00702"></a>00702         regs_buff[569 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAH(i));
<a name="l00703"></a>00703     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00704"></a>00704         regs_buff[601 + i] = IXGBE_READ_REG(hw, IXGBE_TDLEN(i));
<a name="l00705"></a>00705     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00706"></a>00706         regs_buff[633 + i] = IXGBE_READ_REG(hw, IXGBE_TDH(i));
<a name="l00707"></a>00707     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00708"></a>00708         regs_buff[665 + i] = IXGBE_READ_REG(hw, IXGBE_TDT(i));
<a name="l00709"></a>00709     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00710"></a>00710         regs_buff[697 + i] = IXGBE_READ_REG(hw, IXGBE_TXDCTL(i));
<a name="l00711"></a>00711     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00712"></a>00712         regs_buff[729 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAL(i));
<a name="l00713"></a>00713     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00714"></a>00714         regs_buff[761 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAH(i));
<a name="l00715"></a>00715     regs_buff[793] = IXGBE_READ_REG(hw, IXGBE_DTXCTL);
<a name="l00716"></a>00716     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00717"></a>00717         regs_buff[794 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));
<a name="l00718"></a>00718     regs_buff[810] = IXGBE_READ_REG(hw, IXGBE_TIPG);
<a name="l00719"></a>00719     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00720"></a>00720         regs_buff[811 + i] = IXGBE_READ_REG(hw, IXGBE_TXPBSIZE(i));
<a name="l00721"></a>00721     regs_buff[819] = IXGBE_READ_REG(hw, IXGBE_MNGTXMAP);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723     <span class="comment">/* Wake Up */</span>
<a name="l00724"></a>00724     regs_buff[820] = IXGBE_READ_REG(hw, IXGBE_WUC);
<a name="l00725"></a>00725     regs_buff[821] = IXGBE_READ_REG(hw, IXGBE_WUFC);
<a name="l00726"></a>00726     regs_buff[822] = IXGBE_READ_REG(hw, IXGBE_WUS);
<a name="l00727"></a>00727     regs_buff[823] = IXGBE_READ_REG(hw, IXGBE_IPAV);
<a name="l00728"></a>00728     regs_buff[824] = IXGBE_READ_REG(hw, IXGBE_IP4AT);
<a name="l00729"></a>00729     regs_buff[825] = IXGBE_READ_REG(hw, IXGBE_IP6AT);
<a name="l00730"></a>00730     regs_buff[826] = IXGBE_READ_REG(hw, IXGBE_WUPL);
<a name="l00731"></a>00731     regs_buff[827] = IXGBE_READ_REG(hw, IXGBE_WUPM);
<a name="l00732"></a>00732     regs_buff[828] = IXGBE_READ_REG(hw, IXGBE_FHFT(0));
<a name="l00733"></a>00733 
<a name="l00734"></a>00734     <span class="comment">/* DCB */</span>
<a name="l00735"></a>00735     regs_buff[829] = IXGBE_READ_REG(hw, IXGBE_RMCS);
<a name="l00736"></a>00736     regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_DPMCS);
<a name="l00737"></a>00737     regs_buff[831] = IXGBE_READ_REG(hw, IXGBE_PDPMCS);
<a name="l00738"></a>00738     regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RUPPBMR);
<a name="l00739"></a>00739     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00740"></a>00740         regs_buff[833 + i] = IXGBE_READ_REG(hw, IXGBE_RT2CR(i));
<a name="l00741"></a>00741     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00742"></a>00742         regs_buff[841 + i] = IXGBE_READ_REG(hw, IXGBE_RT2SR(i));
<a name="l00743"></a>00743     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00744"></a>00744         regs_buff[849 + i] = IXGBE_READ_REG(hw, IXGBE_TDTQ2TCCR(i));
<a name="l00745"></a>00745     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00746"></a>00746         regs_buff[857 + i] = IXGBE_READ_REG(hw, IXGBE_TDTQ2TCSR(i));
<a name="l00747"></a>00747     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00748"></a>00748         regs_buff[865 + i] = IXGBE_READ_REG(hw, IXGBE_TDPT2TCCR(i));
<a name="l00749"></a>00749     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00750"></a>00750         regs_buff[873 + i] = IXGBE_READ_REG(hw, IXGBE_TDPT2TCSR(i));
<a name="l00751"></a>00751 
<a name="l00752"></a>00752     <span class="comment">/* Statistics */</span>
<a name="l00753"></a>00753     regs_buff[881] = IXGBE_GET_STAT(adapter, crcerrs);
<a name="l00754"></a>00754     regs_buff[882] = IXGBE_GET_STAT(adapter, illerrc);
<a name="l00755"></a>00755     regs_buff[883] = IXGBE_GET_STAT(adapter, errbc);
<a name="l00756"></a>00756     regs_buff[884] = IXGBE_GET_STAT(adapter, mspdc);
<a name="l00757"></a>00757     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00758"></a>00758         regs_buff[885 + i] = IXGBE_GET_STAT(adapter, mpc[i]);
<a name="l00759"></a>00759     regs_buff[893] = IXGBE_GET_STAT(adapter, mlfc);
<a name="l00760"></a>00760     regs_buff[894] = IXGBE_GET_STAT(adapter, mrfc);
<a name="l00761"></a>00761     regs_buff[895] = IXGBE_GET_STAT(adapter, rlec);
<a name="l00762"></a>00762     regs_buff[896] = IXGBE_GET_STAT(adapter, lxontxc);
<a name="l00763"></a>00763     regs_buff[897] = IXGBE_GET_STAT(adapter, lxonrxc);
<a name="l00764"></a>00764     regs_buff[898] = IXGBE_GET_STAT(adapter, lxofftxc);
<a name="l00765"></a>00765     regs_buff[899] = IXGBE_GET_STAT(adapter, lxoffrxc);
<a name="l00766"></a>00766     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00767"></a>00767         regs_buff[900 + i] = IXGBE_GET_STAT(adapter, pxontxc[i]);
<a name="l00768"></a>00768     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00769"></a>00769         regs_buff[908 + i] = IXGBE_GET_STAT(adapter, pxonrxc[i]);
<a name="l00770"></a>00770     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00771"></a>00771         regs_buff[916 + i] = IXGBE_GET_STAT(adapter, pxofftxc[i]);
<a name="l00772"></a>00772     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00773"></a>00773         regs_buff[924 + i] = IXGBE_GET_STAT(adapter, pxoffrxc[i]);
<a name="l00774"></a>00774     regs_buff[932] = IXGBE_GET_STAT(adapter, prc64);
<a name="l00775"></a>00775     regs_buff[933] = IXGBE_GET_STAT(adapter, prc127);
<a name="l00776"></a>00776     regs_buff[934] = IXGBE_GET_STAT(adapter, prc255);
<a name="l00777"></a>00777     regs_buff[935] = IXGBE_GET_STAT(adapter, prc511);
<a name="l00778"></a>00778     regs_buff[936] = IXGBE_GET_STAT(adapter, prc1023);
<a name="l00779"></a>00779     regs_buff[937] = IXGBE_GET_STAT(adapter, prc1522);
<a name="l00780"></a>00780     regs_buff[938] = IXGBE_GET_STAT(adapter, gprc);
<a name="l00781"></a>00781     regs_buff[939] = IXGBE_GET_STAT(adapter, bprc);
<a name="l00782"></a>00782     regs_buff[940] = IXGBE_GET_STAT(adapter, mprc);
<a name="l00783"></a>00783     regs_buff[941] = IXGBE_GET_STAT(adapter, gptc);
<a name="l00784"></a>00784     regs_buff[942] = IXGBE_GET_STAT(adapter, gorc);
<a name="l00785"></a>00785     regs_buff[944] = IXGBE_GET_STAT(adapter, gotc);
<a name="l00786"></a>00786     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00787"></a>00787         regs_buff[946 + i] = IXGBE_GET_STAT(adapter, rnbc[i]);
<a name="l00788"></a>00788     regs_buff[954] = IXGBE_GET_STAT(adapter, ruc);
<a name="l00789"></a>00789     regs_buff[955] = IXGBE_GET_STAT(adapter, rfc);
<a name="l00790"></a>00790     regs_buff[956] = IXGBE_GET_STAT(adapter, roc);
<a name="l00791"></a>00791     regs_buff[957] = IXGBE_GET_STAT(adapter, rjc);
<a name="l00792"></a>00792     regs_buff[958] = IXGBE_GET_STAT(adapter, mngprc);
<a name="l00793"></a>00793     regs_buff[959] = IXGBE_GET_STAT(adapter, mngpdc);
<a name="l00794"></a>00794     regs_buff[960] = IXGBE_GET_STAT(adapter, mngptc);
<a name="l00795"></a>00795     regs_buff[961] = IXGBE_GET_STAT(adapter, tor);
<a name="l00796"></a>00796     regs_buff[963] = IXGBE_GET_STAT(adapter, tpr);
<a name="l00797"></a>00797     regs_buff[964] = IXGBE_GET_STAT(adapter, tpt);
<a name="l00798"></a>00798     regs_buff[965] = IXGBE_GET_STAT(adapter, ptc64);
<a name="l00799"></a>00799     regs_buff[966] = IXGBE_GET_STAT(adapter, ptc127);
<a name="l00800"></a>00800     regs_buff[967] = IXGBE_GET_STAT(adapter, ptc255);
<a name="l00801"></a>00801     regs_buff[968] = IXGBE_GET_STAT(adapter, ptc511);
<a name="l00802"></a>00802     regs_buff[969] = IXGBE_GET_STAT(adapter, ptc1023);
<a name="l00803"></a>00803     regs_buff[970] = IXGBE_GET_STAT(adapter, ptc1522);
<a name="l00804"></a>00804     regs_buff[971] = IXGBE_GET_STAT(adapter, mptc);
<a name="l00805"></a>00805     regs_buff[972] = IXGBE_GET_STAT(adapter, bptc);
<a name="l00806"></a>00806     regs_buff[973] = IXGBE_GET_STAT(adapter, xec);
<a name="l00807"></a>00807     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00808"></a>00808         regs_buff[974 + i] = IXGBE_GET_STAT(adapter, qprc[i]);
<a name="l00809"></a>00809     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00810"></a>00810         regs_buff[990 + i] = IXGBE_GET_STAT(adapter, qptc[i]);
<a name="l00811"></a>00811     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00812"></a>00812         regs_buff[1006 + i] = IXGBE_GET_STAT(adapter, qbrc[i]);
<a name="l00813"></a>00813     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00814"></a>00814         regs_buff[1022 + i] = IXGBE_GET_STAT(adapter, qbtc[i]);
<a name="l00815"></a>00815 
<a name="l00816"></a>00816     <span class="comment">/* MAC */</span>
<a name="l00817"></a>00817     regs_buff[1038] = IXGBE_READ_REG(hw, IXGBE_PCS1GCFIG);
<a name="l00818"></a>00818     regs_buff[1039] = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);
<a name="l00819"></a>00819     regs_buff[1040] = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);
<a name="l00820"></a>00820     regs_buff[1041] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG0);
<a name="l00821"></a>00821     regs_buff[1042] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG1);
<a name="l00822"></a>00822     regs_buff[1043] = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
<a name="l00823"></a>00823     regs_buff[1044] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);
<a name="l00824"></a>00824     regs_buff[1045] = IXGBE_READ_REG(hw, IXGBE_PCS1GANNP);
<a name="l00825"></a>00825     regs_buff[1046] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLPNP);
<a name="l00826"></a>00826     regs_buff[1047] = IXGBE_READ_REG(hw, IXGBE_HLREG0);
<a name="l00827"></a>00827     regs_buff[1048] = IXGBE_READ_REG(hw, IXGBE_HLREG1);
<a name="l00828"></a>00828     regs_buff[1049] = IXGBE_READ_REG(hw, IXGBE_PAP);
<a name="l00829"></a>00829     regs_buff[1050] = IXGBE_READ_REG(hw, IXGBE_MACA);
<a name="l00830"></a>00830     regs_buff[1051] = IXGBE_READ_REG(hw, IXGBE_APAE);
<a name="l00831"></a>00831     regs_buff[1052] = IXGBE_READ_REG(hw, IXGBE_ARD);
<a name="l00832"></a>00832     regs_buff[1053] = IXGBE_READ_REG(hw, IXGBE_AIS);
<a name="l00833"></a>00833     regs_buff[1054] = IXGBE_READ_REG(hw, IXGBE_MSCA);
<a name="l00834"></a>00834     regs_buff[1055] = IXGBE_READ_REG(hw, IXGBE_MSRWD);
<a name="l00835"></a>00835     regs_buff[1056] = IXGBE_READ_REG(hw, IXGBE_MLADD);
<a name="l00836"></a>00836     regs_buff[1057] = IXGBE_READ_REG(hw, IXGBE_MHADD);
<a name="l00837"></a>00837     regs_buff[1058] = IXGBE_READ_REG(hw, IXGBE_TREG);
<a name="l00838"></a>00838     regs_buff[1059] = IXGBE_READ_REG(hw, IXGBE_PCSS1);
<a name="l00839"></a>00839     regs_buff[1060] = IXGBE_READ_REG(hw, IXGBE_PCSS2);
<a name="l00840"></a>00840     regs_buff[1061] = IXGBE_READ_REG(hw, IXGBE_XPCSS);
<a name="l00841"></a>00841     regs_buff[1062] = IXGBE_READ_REG(hw, IXGBE_SERDESC);
<a name="l00842"></a>00842     regs_buff[1063] = IXGBE_READ_REG(hw, IXGBE_MACS);
<a name="l00843"></a>00843     regs_buff[1064] = IXGBE_READ_REG(hw, IXGBE_AUTOC);
<a name="l00844"></a>00844     regs_buff[1065] = IXGBE_READ_REG(hw, IXGBE_LINKS);
<a name="l00845"></a>00845     regs_buff[1066] = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
<a name="l00846"></a>00846     regs_buff[1067] = IXGBE_READ_REG(hw, IXGBE_AUTOC3);
<a name="l00847"></a>00847     regs_buff[1068] = IXGBE_READ_REG(hw, IXGBE_ANLP1);
<a name="l00848"></a>00848     regs_buff[1069] = IXGBE_READ_REG(hw, IXGBE_ANLP2);
<a name="l00849"></a>00849     regs_buff[1070] = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     <span class="comment">/* Diagnostic */</span>
<a name="l00852"></a>00852     regs_buff[1071] = IXGBE_READ_REG(hw, IXGBE_RDSTATCTL);
<a name="l00853"></a>00853     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00854"></a>00854         regs_buff[1072 + i] = IXGBE_READ_REG(hw, IXGBE_RDSTAT(i));
<a name="l00855"></a>00855     regs_buff[1080] = IXGBE_READ_REG(hw, IXGBE_RDHMPN);
<a name="l00856"></a>00856     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
<a name="l00857"></a>00857         regs_buff[1081 + i] = IXGBE_READ_REG(hw, IXGBE_RIC_DW(i));
<a name="l00858"></a>00858     regs_buff[1085] = IXGBE_READ_REG(hw, IXGBE_RDPROBE);
<a name="l00859"></a>00859     regs_buff[1086] = IXGBE_READ_REG(hw, IXGBE_TDSTATCTL);
<a name="l00860"></a>00860     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00861"></a>00861         regs_buff[1087 + i] = IXGBE_READ_REG(hw, IXGBE_TDSTAT(i));
<a name="l00862"></a>00862     regs_buff[1095] = IXGBE_READ_REG(hw, IXGBE_TDHMPN);
<a name="l00863"></a>00863     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
<a name="l00864"></a>00864         regs_buff[1096 + i] = IXGBE_READ_REG(hw, IXGBE_TIC_DW(i));
<a name="l00865"></a>00865     regs_buff[1100] = IXGBE_READ_REG(hw, IXGBE_TDPROBE);
<a name="l00866"></a>00866     regs_buff[1101] = IXGBE_READ_REG(hw, IXGBE_TXBUFCTRL);
<a name="l00867"></a>00867     regs_buff[1102] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA0);
<a name="l00868"></a>00868     regs_buff[1103] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA1);
<a name="l00869"></a>00869     regs_buff[1104] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA2);
<a name="l00870"></a>00870     regs_buff[1105] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA3);
<a name="l00871"></a>00871     regs_buff[1106] = IXGBE_READ_REG(hw, IXGBE_RXBUFCTRL);
<a name="l00872"></a>00872     regs_buff[1107] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA0);
<a name="l00873"></a>00873     regs_buff[1108] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA1);
<a name="l00874"></a>00874     regs_buff[1109] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA2);
<a name="l00875"></a>00875     regs_buff[1110] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA3);
<a name="l00876"></a>00876     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00877"></a>00877         regs_buff[1111 + i] = IXGBE_READ_REG(hw, IXGBE_PCIE_DIAG(i));
<a name="l00878"></a>00878     regs_buff[1119] = IXGBE_READ_REG(hw, IXGBE_RFVAL);
<a name="l00879"></a>00879     regs_buff[1120] = IXGBE_READ_REG(hw, IXGBE_MDFTC1);
<a name="l00880"></a>00880     regs_buff[1121] = IXGBE_READ_REG(hw, IXGBE_MDFTC2);
<a name="l00881"></a>00881     regs_buff[1122] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO1);
<a name="l00882"></a>00882     regs_buff[1123] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO2);
<a name="l00883"></a>00883     regs_buff[1124] = IXGBE_READ_REG(hw, IXGBE_MDFTS);
<a name="l00884"></a>00884     regs_buff[1125] = IXGBE_READ_REG(hw, IXGBE_PCIEECCCTL);
<a name="l00885"></a>00885     regs_buff[1126] = IXGBE_READ_REG(hw, IXGBE_PBTXECC);
<a name="l00886"></a>00886     regs_buff[1127] = IXGBE_READ_REG(hw, IXGBE_PBRXECC);
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_eeprom_len(<span class="keyword">struct</span> net_device *netdev)
<a name="l00890"></a>00890 {
<a name="l00891"></a>00891     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00892"></a>00892     <span class="keywordflow">return</span> adapter-&gt;hw.eeprom.word_size * 2;
<a name="l00893"></a>00893 }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_eeprom(<span class="keyword">struct</span> net_device *netdev,
<a name="l00896"></a>00896                             <span class="keyword">struct</span> <a class="code" href="structethtool__eeprom.html">ethtool_eeprom</a> *eeprom, u8 *bytes)
<a name="l00897"></a>00897 {
<a name="l00898"></a>00898     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00899"></a>00899     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00900"></a>00900     u16 *eeprom_buff;
<a name="l00901"></a>00901     <span class="keywordtype">int</span> first_word, last_word, eeprom_len;
<a name="l00902"></a>00902     <span class="keywordtype">int</span> ret_val = 0;
<a name="l00903"></a>00903     u16 i;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905     <span class="keywordflow">if</span> (eeprom-&gt;len == 0)
<a name="l00906"></a>00906         <span class="keywordflow">return</span> -EINVAL;
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     eeprom-&gt;magic = hw-&gt;vendor_id | (hw-&gt;device_id &lt;&lt; 16);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     first_word = eeprom-&gt;offset &gt;&gt; 1;
<a name="l00911"></a>00911     last_word = (eeprom-&gt;offset + eeprom-&gt;len - 1) &gt;&gt; 1;
<a name="l00912"></a>00912     eeprom_len = last_word - first_word + 1;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     eeprom_buff = kmalloc(<span class="keyword">sizeof</span>(u16) * eeprom_len, GFP_KERNEL);
<a name="l00915"></a>00915     <span class="keywordflow">if</span> (!eeprom_buff)
<a name="l00916"></a>00916         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918     <span class="keywordflow">for</span> (i = 0; i &lt; eeprom_len; i++) {
<a name="l00919"></a>00919         <span class="keywordflow">if</span> ((ret_val = ixgbe_read_eeprom(hw, first_word + i,
<a name="l00920"></a>00920                          &amp;eeprom_buff[i])))
<a name="l00921"></a>00921             <span class="keywordflow">break</span>;
<a name="l00922"></a>00922     }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924     <span class="comment">/* Device&#39;s eeprom is always little-endian, word addressable */</span>
<a name="l00925"></a>00925     <span class="keywordflow">for</span> (i = 0; i &lt; eeprom_len; i++)
<a name="l00926"></a>00926         le16_to_cpus(&amp;eeprom_buff[i]);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928     memcpy(bytes, (u8 *)eeprom_buff + (eeprom-&gt;offset &amp; 1), eeprom-&gt;len);
<a name="l00929"></a>00929     kfree(eeprom_buff);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <span class="keywordflow">return</span> ret_val;
<a name="l00932"></a>00932 }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_eeprom(<span class="keyword">struct</span> net_device *netdev,
<a name="l00935"></a>00935                             <span class="keyword">struct</span> <a class="code" href="structethtool__eeprom.html">ethtool_eeprom</a> *eeprom, u8 *bytes)
<a name="l00936"></a>00936 {
<a name="l00937"></a>00937     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00938"></a>00938     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00939"></a>00939     u16 *eeprom_buff;
<a name="l00940"></a>00940     <span class="keywordtype">void</span> *ptr;
<a name="l00941"></a>00941     <span class="keywordtype">int</span> max_len, first_word, last_word, ret_val = 0;
<a name="l00942"></a>00942     u16 i;
<a name="l00943"></a>00943 
<a name="l00944"></a>00944     <span class="keywordflow">if</span> (eeprom-&gt;len == 0)
<a name="l00945"></a>00945         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l00946"></a>00946 
<a name="l00947"></a>00947     <span class="keywordflow">if</span> (eeprom-&gt;magic != (hw-&gt;vendor_id | (hw-&gt;device_id &lt;&lt; 16)))
<a name="l00948"></a>00948         <span class="keywordflow">return</span> -EFAULT;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     max_len = hw-&gt;eeprom.word_size * 2;
<a name="l00951"></a>00951 
<a name="l00952"></a>00952     first_word = eeprom-&gt;offset &gt;&gt; 1;
<a name="l00953"></a>00953     last_word = (eeprom-&gt;offset + eeprom-&gt;len - 1) &gt;&gt; 1;
<a name="l00954"></a>00954     eeprom_buff = kmalloc(max_len, GFP_KERNEL);
<a name="l00955"></a>00955     <span class="keywordflow">if</span> (!eeprom_buff)
<a name="l00956"></a>00956         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00957"></a>00957 
<a name="l00958"></a>00958     ptr = (<span class="keywordtype">void</span> *)eeprom_buff;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="keywordflow">if</span> (eeprom-&gt;offset &amp; 1) {
<a name="l00961"></a>00961         <span class="comment">/* need read/modify/write of first changed EEPROM word */</span>
<a name="l00962"></a>00962         <span class="comment">/* only the second byte of the word is being modified */</span>
<a name="l00963"></a>00963         ret_val = ixgbe_read_eeprom(hw, first_word, &amp;eeprom_buff[0]);
<a name="l00964"></a>00964         ptr++;
<a name="l00965"></a>00965     }
<a name="l00966"></a>00966     <span class="keywordflow">if</span> (((eeprom-&gt;offset + eeprom-&gt;len) &amp; 1) &amp;&amp; (ret_val == 0)) {
<a name="l00967"></a>00967         <span class="comment">/* need read/modify/write of last changed EEPROM word */</span>
<a name="l00968"></a>00968         <span class="comment">/* only the first byte of the word is being modified */</span>
<a name="l00969"></a>00969         ret_val = ixgbe_read_eeprom(hw, last_word,
<a name="l00970"></a>00970                           &amp;eeprom_buff[last_word - first_word]);
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     <span class="comment">/* Device&#39;s eeprom is always little-endian, word addressable */</span>
<a name="l00974"></a>00974     <span class="keywordflow">for</span> (i = 0; i &lt; last_word - first_word + 1; i++)
<a name="l00975"></a>00975         le16_to_cpus(&amp;eeprom_buff[i]);
<a name="l00976"></a>00976 
<a name="l00977"></a>00977     memcpy(ptr, bytes, eeprom-&gt;len);
<a name="l00978"></a>00978 
<a name="l00979"></a>00979     <span class="keywordflow">for</span> (i = 0; i &lt;= (last_word - first_word); i++)
<a name="l00980"></a>00980         ret_val |= ixgbe_write_eeprom(hw, first_word + i, eeprom_buff[i]);
<a name="l00981"></a>00981 
<a name="l00982"></a>00982     <span class="comment">/* Update the checksum */</span>
<a name="l00983"></a>00983     ixgbe_update_eeprom_checksum(hw);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985     kfree(eeprom_buff);
<a name="l00986"></a>00986     <span class="keywordflow">return</span> ret_val;
<a name="l00987"></a>00987 }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_drvinfo(<span class="keyword">struct</span> net_device *netdev,
<a name="l00990"></a>00990                               <span class="keyword">struct</span> ethtool_drvinfo *drvinfo)
<a name="l00991"></a>00991 {
<a name="l00992"></a>00992     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00993"></a>00993     <span class="keywordtype">char</span> firmware_version[32];
<a name="l00994"></a>00994 
<a name="l00995"></a>00995     strncpy(drvinfo-&gt;driver, ixgbe_driver_name,
<a name="l00996"></a>00996             <span class="keyword">sizeof</span>(drvinfo-&gt;driver) - 1);
<a name="l00997"></a>00997     strncpy(drvinfo-&gt;version, ixgbe_driver_version,
<a name="l00998"></a>00998             <span class="keyword">sizeof</span>(drvinfo-&gt;version) - 1);
<a name="l00999"></a>00999 
<a name="l01000"></a>01000     snprintf(firmware_version, <span class="keyword">sizeof</span>(firmware_version), <span class="stringliteral">&quot;%d.%d-%d&quot;</span>,
<a name="l01001"></a>01001              (adapter-&gt;eeprom_version &amp; 0xF000) &gt;&gt; 12,
<a name="l01002"></a>01002              (adapter-&gt;eeprom_version &amp; 0x0FF0) &gt;&gt; 4,
<a name="l01003"></a>01003              adapter-&gt;eeprom_version &amp; 0x000F);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005     strncpy(drvinfo-&gt;fw_version, firmware_version,
<a name="l01006"></a>01006             <span class="keyword">sizeof</span>(drvinfo-&gt;fw_version) -1);
<a name="l01007"></a>01007     strncpy(drvinfo-&gt;bus_info, pci_name(adapter-&gt;pdev),
<a name="l01008"></a>01008             <span class="keyword">sizeof</span>(drvinfo-&gt;bus_info) - 1);
<a name="l01009"></a>01009     drvinfo-&gt;n_stats = IXGBE_STATS_LEN;
<a name="l01010"></a>01010     drvinfo-&gt;testinfo_len = IXGBE_TEST_LEN;
<a name="l01011"></a>01011     drvinfo-&gt;regdump_len = ixgbe_get_regs_len(netdev);
<a name="l01012"></a>01012 }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_ringparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l01015"></a>01015                                 <span class="keyword">struct</span> ethtool_ringparam *ring)
<a name="l01016"></a>01016 {
<a name="l01017"></a>01017     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01018"></a>01018     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[0];
<a name="l01019"></a>01019     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = adapter-&gt;rx_ring[0];
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     ring-&gt;rx_max_pending = IXGBE_MAX_RXD;
<a name="l01022"></a>01022     ring-&gt;tx_max_pending = IXGBE_MAX_TXD;
<a name="l01023"></a>01023     ring-&gt;rx_mini_max_pending = 0;
<a name="l01024"></a>01024     ring-&gt;rx_jumbo_max_pending = 0;
<a name="l01025"></a>01025     ring-&gt;rx_pending = rx_ring-&gt;count;
<a name="l01026"></a>01026     ring-&gt;tx_pending = tx_ring-&gt;count;
<a name="l01027"></a>01027     ring-&gt;rx_mini_pending = 0;
<a name="l01028"></a>01028     ring-&gt;rx_jumbo_pending = 0;
<a name="l01029"></a>01029 }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_ringparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l01032"></a>01032                                <span class="keyword">struct</span> ethtool_ringparam *ring)
<a name="l01033"></a>01033 {
<a name="l01034"></a>01034     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01035"></a>01035     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *temp_tx_ring, *temp_rx_ring;
<a name="l01036"></a>01036     <span class="keywordtype">int</span> i, err = 0;
<a name="l01037"></a>01037     u32 new_rx_count, new_tx_count;
<a name="l01038"></a>01038     <span class="keywordtype">bool</span> need_update = <span class="keyword">false</span>;
<a name="l01039"></a>01039 
<a name="l01040"></a>01040     <span class="keywordflow">if</span> ((ring-&gt;rx_mini_pending) || (ring-&gt;rx_jumbo_pending))
<a name="l01041"></a>01041         <span class="keywordflow">return</span> -EINVAL;
<a name="l01042"></a>01042 
<a name="l01043"></a>01043     new_rx_count = max(ring-&gt;rx_pending, (u32)IXGBE_MIN_RXD);
<a name="l01044"></a>01044     new_rx_count = min(new_rx_count, (u32)IXGBE_MAX_RXD);
<a name="l01045"></a>01045     new_rx_count = ALIGN(new_rx_count, IXGBE_REQ_RX_DESCRIPTOR_MULTIPLE);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047     new_tx_count = max(ring-&gt;tx_pending, (u32)IXGBE_MIN_TXD);
<a name="l01048"></a>01048     new_tx_count = min(new_tx_count, (u32)IXGBE_MAX_TXD);
<a name="l01049"></a>01049     new_tx_count = ALIGN(new_tx_count, IXGBE_REQ_TX_DESCRIPTOR_MULTIPLE);
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="keywordflow">if</span> ((new_tx_count == adapter-&gt;tx_ring[0]-&gt;count) &amp;&amp;
<a name="l01052"></a>01052         (new_rx_count == adapter-&gt;rx_ring[0]-&gt;count)) {
<a name="l01053"></a>01053         <span class="comment">/* nothing to do */</span>
<a name="l01054"></a>01054         <span class="keywordflow">return</span> 0;
<a name="l01055"></a>01055     }
<a name="l01056"></a>01056 
<a name="l01057"></a>01057     <span class="keywordflow">while</span> (test_and_set_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l01058"></a>01058         usleep_range(1000, 2000);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060     <span class="keywordflow">if</span> (!netif_running(adapter-&gt;netdev)) {
<a name="l01061"></a>01061         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l01062"></a>01062             adapter-&gt;tx_ring[i]-&gt;count = new_tx_count;
<a name="l01063"></a>01063         for (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l01064"></a>01064             adapter-&gt;rx_ring[i]-&gt;count = new_rx_count;
<a name="l01065"></a>01065         adapter-&gt;tx_ring_count = new_tx_count;
<a name="l01066"></a>01066         adapter-&gt;rx_ring_count = new_rx_count;
<a name="l01067"></a>01067         <span class="keywordflow">goto</span> clear_reset;
<a name="l01068"></a>01068     }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070     temp_tx_ring = vmalloc(adapter-&gt;num_tx_queues * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01071"></a>01071     <span class="keywordflow">if</span> (!temp_tx_ring) {
<a name="l01072"></a>01072         err = -ENOMEM;
<a name="l01073"></a>01073         <span class="keywordflow">goto</span> clear_reset;
<a name="l01074"></a>01074     }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076     <span class="keywordflow">if</span> (new_tx_count != adapter-&gt;tx_ring_count) {
<a name="l01077"></a>01077         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l01078"></a>01078             memcpy(&amp;temp_tx_ring[i], adapter-&gt;tx_ring[i],
<a name="l01079"></a>01079                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01080"></a>01080             temp_tx_ring[i].count = new_tx_count;
<a name="l01081"></a>01081             err = ixgbe_setup_tx_resources(&amp;temp_tx_ring[i]);
<a name="l01082"></a>01082             <span class="keywordflow">if</span> (err) {
<a name="l01083"></a>01083                 <span class="keywordflow">while</span> (i) {
<a name="l01084"></a>01084                     i--;
<a name="l01085"></a>01085                     ixgbe_free_tx_resources(&amp;temp_tx_ring[i]);
<a name="l01086"></a>01086                 }
<a name="l01087"></a>01087                 <span class="keywordflow">goto</span> clear_reset;
<a name="l01088"></a>01088             }
<a name="l01089"></a>01089         }
<a name="l01090"></a>01090         need_update = <span class="keyword">true</span>;
<a name="l01091"></a>01091     }
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     temp_rx_ring = vmalloc(adapter-&gt;num_rx_queues * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01094"></a>01094     <span class="keywordflow">if</span> (!temp_rx_ring) {
<a name="l01095"></a>01095         err = -ENOMEM;
<a name="l01096"></a>01096         <span class="keywordflow">goto</span> err_setup;
<a name="l01097"></a>01097     }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099     <span class="keywordflow">if</span> (new_rx_count != adapter-&gt;rx_ring_count) {
<a name="l01100"></a>01100         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01101"></a>01101             memcpy(&amp;temp_rx_ring[i], adapter-&gt;rx_ring[i],
<a name="l01102"></a>01102                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01103"></a>01103             temp_rx_ring[i].count = new_rx_count;
<a name="l01104"></a>01104             err = ixgbe_setup_rx_resources(&amp;temp_rx_ring[i]);
<a name="l01105"></a>01105             <span class="keywordflow">if</span> (err) {
<a name="l01106"></a>01106                 <span class="keywordflow">while</span> (i) {
<a name="l01107"></a>01107                     i--;
<a name="l01108"></a>01108                     ixgbe_free_rx_resources(&amp;temp_rx_ring[i]);
<a name="l01109"></a>01109                 }
<a name="l01110"></a>01110                 <span class="keywordflow">goto</span> err_setup;
<a name="l01111"></a>01111             }
<a name="l01112"></a>01112         }
<a name="l01113"></a>01113         need_update = <span class="keyword">true</span>;
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="comment">/* if rings need to be updated, here&#39;s the place to do it in one shot */</span>
<a name="l01117"></a>01117     <span class="keywordflow">if</span> (need_update) {
<a name="l01118"></a>01118         ixgbe_down(adapter);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120         <span class="comment">/* tx */</span>
<a name="l01121"></a>01121         <span class="keywordflow">if</span> (new_tx_count != adapter-&gt;tx_ring_count) {
<a name="l01122"></a>01122             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l01123"></a>01123                 ixgbe_free_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l01124"></a>01124                 memcpy(adapter-&gt;tx_ring[i], &amp;temp_tx_ring[i],
<a name="l01125"></a>01125                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01126"></a>01126             }
<a name="l01127"></a>01127             adapter-&gt;tx_ring_count = new_tx_count;
<a name="l01128"></a>01128         }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130         <span class="comment">/* rx */</span>
<a name="l01131"></a>01131         <span class="keywordflow">if</span> (new_rx_count != adapter-&gt;rx_ring_count) {
<a name="l01132"></a>01132             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01133"></a>01133                 ixgbe_free_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l01134"></a>01134                 memcpy(adapter-&gt;rx_ring[i], &amp;temp_rx_ring[i],
<a name="l01135"></a>01135                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01136"></a>01136             }
<a name="l01137"></a>01137             adapter-&gt;rx_ring_count = new_rx_count;
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139         ixgbe_up(adapter);
<a name="l01140"></a>01140     }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142     vfree(temp_rx_ring);
<a name="l01143"></a>01143 err_setup:
<a name="l01144"></a>01144     vfree(temp_tx_ring);
<a name="l01145"></a>01145 clear_reset:
<a name="l01146"></a>01146     clear_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state);
<a name="l01147"></a>01147     <span class="keywordflow">return</span> err;
<a name="l01148"></a>01148 }
<a name="l01149"></a>01149 
<a name="l01150"></a>01150 <span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l01151"></a>01151 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_stats_count(<span class="keyword">struct</span> net_device *netdev)
<a name="l01152"></a>01152 {
<a name="l01153"></a>01153     <span class="keywordflow">return</span> IXGBE_STATS_LEN;
<a name="l01154"></a>01154 }
<a name="l01155"></a>01155 
<a name="l01156"></a>01156 <span class="preprocessor">#else </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l01157"></a>01157 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_sset_count(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> sset)
<a name="l01158"></a>01158 {
<a name="l01159"></a>01159 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01161"></a>01161 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l01162"></a>01162 
<a name="l01163"></a>01163     <span class="keywordflow">switch</span> (sset) {
<a name="l01164"></a>01164     <span class="keywordflow">case</span> ETH_SS_TEST:
<a name="l01165"></a>01165         <span class="keywordflow">return</span> IXGBE_TEST_LEN;
<a name="l01166"></a>01166     <span class="keywordflow">case</span> ETH_SS_STATS:
<a name="l01167"></a>01167         <span class="keywordflow">return</span> IXGBE_STATS_LEN;
<a name="l01168"></a>01168 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l01169"></a>01169 <span class="preprocessor"></span>    <span class="keywordflow">case</span> ETH_SS_NTUPLE_FILTERS:
<a name="l01170"></a>01170         <span class="comment">/* return enough space for the mask and all filters */</span>
<a name="l01171"></a>01171         <span class="keywordflow">return</span> ((adapter-&gt;fdir_filter_count + 1) *
<a name="l01172"></a>01172                 ETHTOOL_MAX_NTUPLE_STRING_PER_ENTRY);
<a name="l01173"></a>01173 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l01174"></a>01174     <span class="keywordflow">default</span>:
<a name="l01175"></a>01175         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l01176"></a>01176     }
<a name="l01177"></a>01177 }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l01180"></a>01180 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_ethtool_stats(<span class="keyword">struct</span> net_device *netdev,
<a name="l01181"></a>01181                                     <span class="keyword">struct</span> <a class="code" href="structethtool__stats.html">ethtool_stats</a> *stats, u64 *data)
<a name="l01182"></a>01182 {
<a name="l01183"></a>01183     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01184"></a>01184 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l01185"></a>01185 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *net_stats = &amp;netdev-&gt;stats;
<a name="l01186"></a>01186 <span class="preprocessor">#else</span>
<a name="l01187"></a>01187 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *net_stats = &amp;adapter-&gt;net_stats;
<a name="l01188"></a>01188 <span class="preprocessor">#endif</span>
<a name="l01189"></a>01189 <span class="preprocessor"></span>    u64 *queue_stat;
<a name="l01190"></a>01190     <span class="keywordtype">int</span> stat_count = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__queue__stats.html">ixgbe_queue_stats</a>) / sizeof(u64);
<a name="l01191"></a>01191     <span class="keywordtype">int</span> i, j, k;
<a name="l01192"></a>01192     <span class="keywordtype">char</span> *p;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194     ixgbe_update_stats(adapter);
<a name="l01195"></a>01195 
<a name="l01196"></a>01196     <span class="keywordflow">for</span> (i = 0; i &lt; IXGBE_NETDEV_STATS_LEN; i++) {
<a name="l01197"></a>01197         p = (<span class="keywordtype">char</span> *)net_stats + ixgbe_gstrings_net_stats[i].stat_offset;
<a name="l01198"></a>01198         data[i] = (ixgbe_gstrings_net_stats[i].sizeof_stat ==
<a name="l01199"></a>01199             <span class="keyword">sizeof</span>(u64)) ? *(u64 *)p : *(u32 *)p;
<a name="l01200"></a>01200     }
<a name="l01201"></a>01201     <span class="keywordflow">for</span> (j = 0; j &lt; IXGBE_GLOBAL_STATS_LEN; j++, i++) {
<a name="l01202"></a>01202         p = (<span class="keywordtype">char</span> *)adapter + ixgbe_gstrings_stats[j].stat_offset;
<a name="l01203"></a>01203         data[i] = (ixgbe_gstrings_stats[j].sizeof_stat ==
<a name="l01204"></a>01204                    <span class="keyword">sizeof</span>(u64)) ? *(u64 *)p : *(u32 *)p;
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206     <span class="keywordflow">for</span> (j = 0; j &lt; adapter-&gt;num_tx_queues; j++) {
<a name="l01207"></a>01207         queue_stat = (u64 *)&amp;adapter-&gt;tx_ring[j]-&gt;stats;
<a name="l01208"></a>01208         for (k = 0; k &lt; stat_count; k++)
<a name="l01209"></a>01209             data[i + k] = queue_stat[k];
<a name="l01210"></a>01210         i += k;
<a name="l01211"></a>01211     }
<a name="l01212"></a>01212     <span class="keywordflow">for</span> (j = 0; j &lt; adapter-&gt;num_rx_queues; j++) {
<a name="l01213"></a>01213         queue_stat = (u64 *)&amp;adapter-&gt;rx_ring[j]-&gt;stats;
<a name="l01214"></a>01214         for (k = 0; k &lt; stat_count; k++)
<a name="l01215"></a>01215             data[i + k] = queue_stat[k];
<a name="l01216"></a>01216         i += k;
<a name="l01217"></a>01217     }
<a name="l01218"></a>01218     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l01219"></a>01219         <span class="keywordflow">for</span> (j = 0; j &lt; MAX_TX_PACKET_BUFFERS; j++) {
<a name="l01220"></a>01220             data[i++] = adapter-&gt;stats.pxontxc[j];
<a name="l01221"></a>01221             data[i++] = adapter-&gt;stats.pxofftxc[j];
<a name="l01222"></a>01222         }
<a name="l01223"></a>01223         <span class="keywordflow">for</span> (j = 0; j &lt; MAX_RX_PACKET_BUFFERS; j++) {
<a name="l01224"></a>01224             data[i++] = adapter-&gt;stats.pxonrxc[j];
<a name="l01225"></a>01225             data[i++] = adapter-&gt;stats.pxoffrxc[j];
<a name="l01226"></a>01226         }
<a name="l01227"></a>01227     }
<a name="l01228"></a>01228     stat_count = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structvf__stats.html">vf_stats</a>) / sizeof(u64);
<a name="l01229"></a>01229     <span class="keywordflow">for</span>(j = 0; j &lt; adapter-&gt;num_vfs; j++) {
<a name="l01230"></a>01230         queue_stat = (u64 *)&amp;adapter-&gt;vfinfo[j].vfstats;
<a name="l01231"></a>01231         for (k = 0; k &lt; stat_count; k++) {
<a name="l01232"></a>01232             data[i + k] = queue_stat[k];
<a name="l01233"></a>01233         }
<a name="l01234"></a>01234         queue_stat = (u64 *)&amp;adapter-&gt;vfinfo[j].saved_rst_vfstats;
<a name="l01235"></a>01235         for (k = 0; k &lt; stat_count; k++) {
<a name="l01236"></a>01236             data[i + k] += queue_stat[k];
<a name="l01237"></a>01237         }
<a name="l01238"></a>01238         i += k;
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240 }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_strings(<span class="keyword">struct</span> net_device *netdev, u32 stringset,
<a name="l01243"></a>01243                               u8 *data)
<a name="l01244"></a>01244 {
<a name="l01245"></a>01245     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01246"></a>01246     <span class="keywordtype">char</span> *p = (<span class="keywordtype">char</span> *)data;
<a name="l01247"></a>01247     <span class="keywordtype">int</span> i;
<a name="l01248"></a>01248 
<a name="l01249"></a>01249     <span class="keywordflow">switch</span> (stringset) {
<a name="l01250"></a>01250     <span class="keywordflow">case</span> ETH_SS_TEST:
<a name="l01251"></a>01251         memcpy(data, *ixgbe_gstrings_test,
<a name="l01252"></a>01252                IXGBE_TEST_LEN * ETH_GSTRING_LEN);
<a name="l01253"></a>01253         <span class="keywordflow">break</span>;
<a name="l01254"></a>01254     <span class="keywordflow">case</span> ETH_SS_STATS:
<a name="l01255"></a>01255         <span class="keywordflow">for</span> (i = 0; i &lt; IXGBE_NETDEV_STATS_LEN; i++) {
<a name="l01256"></a>01256             memcpy(p, ixgbe_gstrings_net_stats[i].stat_string,
<a name="l01257"></a>01257                    ETH_GSTRING_LEN);
<a name="l01258"></a>01258             p += ETH_GSTRING_LEN;
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260         <span class="keywordflow">for</span> (i = 0; i &lt; IXGBE_GLOBAL_STATS_LEN; i++) {
<a name="l01261"></a>01261             memcpy(p, ixgbe_gstrings_stats[i].stat_string,
<a name="l01262"></a>01262                    ETH_GSTRING_LEN);
<a name="l01263"></a>01263             p += ETH_GSTRING_LEN;
<a name="l01264"></a>01264         }
<a name="l01265"></a>01265         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l01266"></a>01266             sprintf(p, <span class="stringliteral">&quot;tx_queue_%u_packets&quot;</span>, i);
<a name="l01267"></a>01267             p += ETH_GSTRING_LEN;
<a name="l01268"></a>01268             sprintf(p, <span class="stringliteral">&quot;tx_queue_%u_bytes&quot;</span>, i);
<a name="l01269"></a>01269             p += ETH_GSTRING_LEN;
<a name="l01270"></a>01270         }
<a name="l01271"></a>01271         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01272"></a>01272             sprintf(p, <span class="stringliteral">&quot;rx_queue_%u_packets&quot;</span>, i);
<a name="l01273"></a>01273             p += ETH_GSTRING_LEN;
<a name="l01274"></a>01274             sprintf(p, <span class="stringliteral">&quot;rx_queue_%u_bytes&quot;</span>, i);
<a name="l01275"></a>01275             p += ETH_GSTRING_LEN;
<a name="l01276"></a>01276         }
<a name="l01277"></a>01277         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l01278"></a>01278             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TX_PACKET_BUFFERS; i++) {
<a name="l01279"></a>01279                 sprintf(p, <span class="stringliteral">&quot;tx_pb_%u_pxon&quot;</span>, i);
<a name="l01280"></a>01280                 p += ETH_GSTRING_LEN;
<a name="l01281"></a>01281                 sprintf(p, <span class="stringliteral">&quot;tx_pb_%u_pxoff&quot;</span>, i);
<a name="l01282"></a>01282                 p += ETH_GSTRING_LEN;
<a name="l01283"></a>01283             }
<a name="l01284"></a>01284             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_RX_PACKET_BUFFERS; i++) {
<a name="l01285"></a>01285                 sprintf(p, <span class="stringliteral">&quot;rx_pb_%u_pxon&quot;</span>, i);
<a name="l01286"></a>01286                 p += ETH_GSTRING_LEN;
<a name="l01287"></a>01287                 sprintf(p, <span class="stringliteral">&quot;rx_pb_%u_pxoff&quot;</span>, i);
<a name="l01288"></a>01288                 p += ETH_GSTRING_LEN;
<a name="l01289"></a>01289             }
<a name="l01290"></a>01290         }
<a name="l01291"></a>01291         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l01292"></a>01292             sprintf(p, <span class="stringliteral">&quot;VF %d Rx Packets&quot;</span>, i);
<a name="l01293"></a>01293             p += ETH_GSTRING_LEN;
<a name="l01294"></a>01294             sprintf(p, <span class="stringliteral">&quot;VF %d Rx Bytes&quot;</span>, i);
<a name="l01295"></a>01295             p += ETH_GSTRING_LEN;
<a name="l01296"></a>01296             sprintf(p, <span class="stringliteral">&quot;VF %d Tx Packets&quot;</span>, i);
<a name="l01297"></a>01297             p += ETH_GSTRING_LEN;
<a name="l01298"></a>01298             sprintf(p, <span class="stringliteral">&quot;VF %d Tx Bytes&quot;</span>, i);
<a name="l01299"></a>01299             p += ETH_GSTRING_LEN;
<a name="l01300"></a>01300             sprintf(p, <span class="stringliteral">&quot;VF %d MC Packets&quot;</span>, i);
<a name="l01301"></a>01301             p += ETH_GSTRING_LEN;
<a name="l01302"></a>01302         }
<a name="l01303"></a>01303         <span class="comment">/* BUG_ON(p - data != IXGBE_STATS_LEN * ETH_GSTRING_LEN); */</span>
<a name="l01304"></a>01304         <span class="keywordflow">break</span>;
<a name="l01305"></a>01305     }
<a name="l01306"></a>01306 }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_link_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01309"></a>01309 {
<a name="l01310"></a>01310     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01311"></a>01311     <span class="keywordtype">bool</span> link_up;
<a name="l01312"></a>01312     u32 link_speed = 0;
<a name="l01313"></a>01313     *data = 0;
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     hw-&gt;mac.ops.check_link(hw, &amp;link_speed, &amp;link_up, <span class="keyword">true</span>);
<a name="l01316"></a>01316     <span class="keywordflow">if</span> (link_up)
<a name="l01317"></a>01317         <span class="keywordflow">return</span> *data;
<a name="l01318"></a>01318     <span class="keywordflow">else</span>
<a name="l01319"></a>01319         *data = 1;
<a name="l01320"></a>01320     <span class="keywordflow">return</span> *data;
<a name="l01321"></a>01321 }
<a name="l01322"></a>01322 
<a name="l01323"></a>01323 <span class="comment">/* ethtool register test data */</span>
<a name="l01324"></a>01324 <span class="keyword">struct </span>ixgbe_reg_test {
<a name="l01325"></a>01325     u16 reg;
<a name="l01326"></a>01326     u8  array_len;
<a name="l01327"></a>01327     u8  test_type;
<a name="l01328"></a>01328     u32 mask;
<a name="l01329"></a>01329     u32 write;
<a name="l01330"></a>01330 };
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 <span class="comment">/* In the hardware, registers are laid out either singly, in arrays</span>
<a name="l01333"></a>01333 <span class="comment"> * spaced 0x40 bytes apart, or in contiguous tables.  We assume</span>
<a name="l01334"></a>01334 <span class="comment"> * most tests take place on arrays or single registers (handled</span>
<a name="l01335"></a>01335 <span class="comment"> * as a single-element array) and special-case the tables.</span>
<a name="l01336"></a>01336 <span class="comment"> * Table tests are always pattern tests.</span>
<a name="l01337"></a>01337 <span class="comment"> *</span>
<a name="l01338"></a>01338 <span class="comment"> * We also make provision for some required setup steps by specifying</span>
<a name="l01339"></a>01339 <span class="comment"> * registers to be written without any read-back testing.</span>
<a name="l01340"></a>01340 <span class="comment"> */</span>
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 <span class="preprocessor">#define PATTERN_TEST    1</span>
<a name="l01343"></a>01343 <span class="preprocessor"></span><span class="preprocessor">#define SET_READ_TEST   2</span>
<a name="l01344"></a>01344 <span class="preprocessor"></span><span class="preprocessor">#define WRITE_NO_TEST   3</span>
<a name="l01345"></a>01345 <span class="preprocessor"></span><span class="preprocessor">#define TABLE32_TEST    4</span>
<a name="l01346"></a>01346 <span class="preprocessor"></span><span class="preprocessor">#define TABLE64_TEST_LO 5</span>
<a name="l01347"></a>01347 <span class="preprocessor"></span><span class="preprocessor">#define TABLE64_TEST_HI 6</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span>
<a name="l01349"></a>01349 <span class="comment">/* default 82599 register test */</span>
<a name="l01350"></a>01350 <span class="keyword">static</span> <span class="keyword">struct </span>ixgbe_reg_test reg_test_82599[] = {
<a name="l01351"></a>01351     { IXGBE_FCRTL_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01352"></a>01352     { IXGBE_FCRTH_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01353"></a>01353     { IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01354"></a>01354     { IXGBE_VLNCTRL, 1, PATTERN_TEST, 0x00000000, 0x00000000 },
<a name="l01355"></a>01355     { IXGBE_RDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFF80 },
<a name="l01356"></a>01356     { IXGBE_RDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01357"></a>01357     { IXGBE_RDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },
<a name="l01358"></a>01358     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, IXGBE_RXDCTL_ENABLE },
<a name="l01359"></a>01359     { IXGBE_RDT(0), 4, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },
<a name="l01360"></a>01360     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, 0 },
<a name="l01361"></a>01361     { IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01362"></a>01362     { IXGBE_FCTTV(0), 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01363"></a>01363     { IXGBE_TDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },
<a name="l01364"></a>01364     { IXGBE_TDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01365"></a>01365     { IXGBE_TDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFF80 },
<a name="l01366"></a>01366     { IXGBE_RXCTRL, 1, SET_READ_TEST, 0x00000001, 0x00000001 },
<a name="l01367"></a>01367     { IXGBE_RAL(0), 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01368"></a>01368     { IXGBE_RAL(0), 16, TABLE64_TEST_HI, 0x8001FFFF, 0x800CFFFF },
<a name="l01369"></a>01369     { IXGBE_MTA(0), 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01370"></a>01370     { 0, 0, 0, 0 }
<a name="l01371"></a>01371 };
<a name="l01372"></a>01372 
<a name="l01373"></a>01373 <span class="comment">/* default 82598 register test */</span>
<a name="l01374"></a>01374 <span class="keyword">static</span> <span class="keyword">struct </span>ixgbe_reg_test reg_test_82598[] = {
<a name="l01375"></a>01375     { IXGBE_FCRTL(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01376"></a>01376     { IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01377"></a>01377     { IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01378"></a>01378     { IXGBE_VLNCTRL, 1, PATTERN_TEST, 0x00000000, 0x00000000 },
<a name="l01379"></a>01379     { IXGBE_RDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },
<a name="l01380"></a>01380     { IXGBE_RDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01381"></a>01381     { IXGBE_RDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },
<a name="l01382"></a>01382     <span class="comment">/* Enable all four RX queues before testing. */</span>
<a name="l01383"></a>01383     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, IXGBE_RXDCTL_ENABLE },
<a name="l01384"></a>01384     <span class="comment">/* RDH is read-only for 82598, only test RDT. */</span>
<a name="l01385"></a>01385     { IXGBE_RDT(0), 4, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },
<a name="l01386"></a>01386     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, 0 },
<a name="l01387"></a>01387     { IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01388"></a>01388     { IXGBE_FCTTV(0), 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01389"></a>01389     { IXGBE_TIPG, 1, PATTERN_TEST, 0x000000FF, 0x000000FF },
<a name="l01390"></a>01390     { IXGBE_TDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },
<a name="l01391"></a>01391     { IXGBE_TDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01392"></a>01392     { IXGBE_TDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },
<a name="l01393"></a>01393     { IXGBE_RXCTRL, 1, SET_READ_TEST, 0x00000003, 0x00000003 },
<a name="l01394"></a>01394     { IXGBE_DTXCTL, 1, SET_READ_TEST, 0x00000005, 0x00000005 },
<a name="l01395"></a>01395     { IXGBE_RAL(0), 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01396"></a>01396     { IXGBE_RAL(0), 16, TABLE64_TEST_HI, 0x800CFFFF, 0x800CFFFF },
<a name="l01397"></a>01397     { IXGBE_MTA(0), 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01398"></a>01398     { 0, 0, 0, 0 }
<a name="l01399"></a>01399 };
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 <span class="preprocessor">#define REG_PATTERN_TEST(R, M, W)                                             \</span>
<a name="l01402"></a>01402 <span class="preprocessor">{                                                                             \</span>
<a name="l01403"></a>01403 <span class="preprocessor">    u32 pat, val, before;                                                 \</span>
<a name="l01404"></a>01404 <span class="preprocessor">    const u32 _test[] = {0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF}; \</span>
<a name="l01405"></a>01405 <span class="preprocessor">    for (pat = 0; pat &lt; ARRAY_SIZE(_test); pat++) {                       \</span>
<a name="l01406"></a>01406 <span class="preprocessor">        before = readl(adapter-&gt;hw.hw_addr + R);                      \</span>
<a name="l01407"></a>01407 <span class="preprocessor">        writel((_test[pat] &amp; W), (adapter-&gt;hw.hw_addr + R));          \</span>
<a name="l01408"></a>01408 <span class="preprocessor">        val = readl(adapter-&gt;hw.hw_addr + R);                         \</span>
<a name="l01409"></a>01409 <span class="preprocessor">        if (val != (_test[pat] &amp; W &amp; M)) {                            \</span>
<a name="l01410"></a>01410 <span class="preprocessor">            e_err(drv, &quot;pattern test reg %04X failed: got &quot;\</span>
<a name="l01411"></a>01411 <span class="preprocessor">                  &quot;0x%08X expected 0x%08X\n&quot;,         \</span>
<a name="l01412"></a>01412 <span class="preprocessor">                R, val, (_test[pat] &amp; W &amp; M));                \</span>
<a name="l01413"></a>01413 <span class="preprocessor">            *data = R;                                            \</span>
<a name="l01414"></a>01414 <span class="preprocessor">            writel(before, adapter-&gt;hw.hw_addr + R);              \</span>
<a name="l01415"></a>01415 <span class="preprocessor">            return 1;                                             \</span>
<a name="l01416"></a>01416 <span class="preprocessor">        }                                                             \</span>
<a name="l01417"></a>01417 <span class="preprocessor">        writel(before, adapter-&gt;hw.hw_addr + R);                      \</span>
<a name="l01418"></a>01418 <span class="preprocessor">    }                                                                     \</span>
<a name="l01419"></a>01419 <span class="preprocessor">}</span>
<a name="l01420"></a>01420 <span class="preprocessor"></span>
<a name="l01421"></a>01421 <span class="preprocessor">#define REG_SET_AND_CHECK(R, M, W)                                            \</span>
<a name="l01422"></a>01422 <span class="preprocessor">{                                                                             \</span>
<a name="l01423"></a>01423 <span class="preprocessor">    u32 val, before;                                                      \</span>
<a name="l01424"></a>01424 <span class="preprocessor">    before = readl(adapter-&gt;hw.hw_addr + R);                              \</span>
<a name="l01425"></a>01425 <span class="preprocessor">    writel((W &amp; M), (adapter-&gt;hw.hw_addr + R));                           \</span>
<a name="l01426"></a>01426 <span class="preprocessor">    val = readl(adapter-&gt;hw.hw_addr + R);                                 \</span>
<a name="l01427"></a>01427 <span class="preprocessor">    if ((W &amp; M) != (val &amp; M)) {                                           \</span>
<a name="l01428"></a>01428 <span class="preprocessor">        e_err(drv, &quot;set/check reg %04X test failed: got 0x%08X &quot;\</span>
<a name="l01429"></a>01429 <span class="preprocessor">              &quot;expected 0x%08X\n&quot;, R, (val &amp; M), (W &amp; M)); \</span>
<a name="l01430"></a>01430 <span class="preprocessor">        *data = R;                                                    \</span>
<a name="l01431"></a>01431 <span class="preprocessor">        writel(before, (adapter-&gt;hw.hw_addr + R));                    \</span>
<a name="l01432"></a>01432 <span class="preprocessor">        return 1;                                                     \</span>
<a name="l01433"></a>01433 <span class="preprocessor">    }                                                                     \</span>
<a name="l01434"></a>01434 <span class="preprocessor">    writel(before, (adapter-&gt;hw.hw_addr + R));                            \</span>
<a name="l01435"></a>01435 <span class="preprocessor">}</span>
<a name="l01436"></a>01436 <span class="preprocessor"></span>
<a name="l01437"></a>01437 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_reg_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439     <span class="keyword">struct </span>ixgbe_reg_test *test;
<a name="l01440"></a>01440     u32 value, status_before, status_after;
<a name="l01441"></a>01441     u32 i, toggle;
<a name="l01442"></a>01442 
<a name="l01443"></a>01443     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01444"></a>01444     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01445"></a>01445         toggle = 0x7FFFF3FF;
<a name="l01446"></a>01446         test = reg_test_82598;
<a name="l01447"></a>01447         <span class="keywordflow">break</span>;
<a name="l01448"></a>01448     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01449"></a>01449     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01450"></a>01450         toggle = 0x7FFFF30F;
<a name="l01451"></a>01451         test = reg_test_82599;
<a name="l01452"></a>01452         <span class="keywordflow">break</span>;
<a name="l01453"></a>01453     <span class="keywordflow">default</span>:
<a name="l01454"></a>01454         *data = 1;
<a name="l01455"></a>01455         <span class="keywordflow">return</span> 1;
<a name="l01456"></a>01456         <span class="keywordflow">break</span>;
<a name="l01457"></a>01457     }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     <span class="comment">/*</span>
<a name="l01460"></a>01460 <span class="comment">     * Because the status register is such a special case,</span>
<a name="l01461"></a>01461 <span class="comment">     * we handle it separately from the rest of the register</span>
<a name="l01462"></a>01462 <span class="comment">     * tests.  Some bits are read-only, some toggle, and some</span>
<a name="l01463"></a>01463 <span class="comment">     * are writeable on newer MACs.</span>
<a name="l01464"></a>01464 <span class="comment">     */</span>
<a name="l01465"></a>01465     status_before = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_STATUS);
<a name="l01466"></a>01466     value = (IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_STATUS) &amp; toggle);
<a name="l01467"></a>01467     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_STATUS, toggle);
<a name="l01468"></a>01468     status_after = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_STATUS) &amp; toggle;
<a name="l01469"></a>01469     <span class="keywordflow">if</span> (value != status_after) {
<a name="l01470"></a>01470         e_err(drv, <span class="stringliteral">&quot;failed STATUS register test got: &quot;</span>
<a name="l01471"></a>01471               <span class="stringliteral">&quot;0x%08X expected: 0x%08X\n&quot;</span>, status_after, value);
<a name="l01472"></a>01472         *data = 1;
<a name="l01473"></a>01473         <span class="keywordflow">return</span> 1;
<a name="l01474"></a>01474     }
<a name="l01475"></a>01475     <span class="comment">/* restore previous status */</span>
<a name="l01476"></a>01476     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_STATUS, status_before);
<a name="l01477"></a>01477 
<a name="l01478"></a>01478     <span class="comment">/*</span>
<a name="l01479"></a>01479 <span class="comment">     * Perform the remainder of the register test, looping through</span>
<a name="l01480"></a>01480 <span class="comment">     * the test table until we either fail or reach the null entry.</span>
<a name="l01481"></a>01481 <span class="comment">     */</span>
<a name="l01482"></a>01482     <span class="keywordflow">while</span> (test-&gt;reg) {
<a name="l01483"></a>01483         <span class="keywordflow">for</span> (i = 0; i &lt; test-&gt;array_len; i++) {
<a name="l01484"></a>01484             <span class="keywordflow">switch</span> (test-&gt;test_type) {
<a name="l01485"></a>01485             <span class="keywordflow">case</span> PATTERN_TEST:
<a name="l01486"></a>01486                 REG_PATTERN_TEST(test-&gt;reg + (i * 0x40),
<a name="l01487"></a>01487                         test-&gt;mask,
<a name="l01488"></a>01488                         test-&gt;write);
<a name="l01489"></a>01489                 <span class="keywordflow">break</span>;
<a name="l01490"></a>01490             <span class="keywordflow">case</span> SET_READ_TEST:
<a name="l01491"></a>01491                 REG_SET_AND_CHECK(test-&gt;reg + (i * 0x40),
<a name="l01492"></a>01492                         test-&gt;mask,
<a name="l01493"></a>01493                         test-&gt;write);
<a name="l01494"></a>01494                 <span class="keywordflow">break</span>;
<a name="l01495"></a>01495             <span class="keywordflow">case</span> WRITE_NO_TEST:
<a name="l01496"></a>01496                 writel(test-&gt;write,
<a name="l01497"></a>01497                        (adapter-&gt;hw.hw_addr + test-&gt;reg)
<a name="l01498"></a>01498                        + (i * 0x40));
<a name="l01499"></a>01499                 <span class="keywordflow">break</span>;
<a name="l01500"></a>01500             <span class="keywordflow">case</span> TABLE32_TEST:
<a name="l01501"></a>01501                 REG_PATTERN_TEST(test-&gt;reg + (i * 4),
<a name="l01502"></a>01502                         test-&gt;mask,
<a name="l01503"></a>01503                         test-&gt;write);
<a name="l01504"></a>01504                 <span class="keywordflow">break</span>;
<a name="l01505"></a>01505             <span class="keywordflow">case</span> TABLE64_TEST_LO:
<a name="l01506"></a>01506                 REG_PATTERN_TEST(test-&gt;reg + (i * 8),
<a name="l01507"></a>01507                         test-&gt;mask,
<a name="l01508"></a>01508                         test-&gt;write);
<a name="l01509"></a>01509                 <span class="keywordflow">break</span>;
<a name="l01510"></a>01510             <span class="keywordflow">case</span> TABLE64_TEST_HI:
<a name="l01511"></a>01511                 REG_PATTERN_TEST((test-&gt;reg + 4) + (i * 8),
<a name="l01512"></a>01512                         test-&gt;mask,
<a name="l01513"></a>01513                         test-&gt;write);
<a name="l01514"></a>01514                 <span class="keywordflow">break</span>;
<a name="l01515"></a>01515             }
<a name="l01516"></a>01516         }
<a name="l01517"></a>01517         test++;
<a name="l01518"></a>01518     }
<a name="l01519"></a>01519 
<a name="l01520"></a>01520     *data = 0;
<a name="l01521"></a>01521     <span class="keywordflow">return</span> 0;
<a name="l01522"></a>01522 }
<a name="l01523"></a>01523 
<a name="l01524"></a>01524 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_eeprom_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01525"></a>01525 {
<a name="l01526"></a>01526     <span class="keywordflow">if</span> (ixgbe_validate_eeprom_checksum(&amp;adapter-&gt;hw, NULL))
<a name="l01527"></a>01527         *data = 1;
<a name="l01528"></a>01528     <span class="keywordflow">else</span>
<a name="l01529"></a>01529         *data = 0;
<a name="l01530"></a>01530     <span class="keywordflow">return</span> *data;
<a name="l01531"></a>01531 }
<a name="l01532"></a>01532 
<a name="l01533"></a>01533 <span class="keyword">static</span> irqreturn_t ixgbe_test_intr(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l01534"></a>01534 {
<a name="l01535"></a>01535     <span class="keyword">struct </span>net_device *netdev = (<span class="keyword">struct </span>net_device *) data;
<a name="l01536"></a>01536     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01537"></a>01537 
<a name="l01538"></a>01538     adapter-&gt;test_icr |= IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_EICR);
<a name="l01539"></a>01539 
<a name="l01540"></a>01540     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l01541"></a>01541 }
<a name="l01542"></a>01542 
<a name="l01543"></a>01543 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_intr_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01544"></a>01544 {
<a name="l01545"></a>01545     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01546"></a>01546     u32 mask, i = 0, shared_int = <span class="keyword">true</span>;
<a name="l01547"></a>01547     u32 irq = adapter-&gt;pdev-&gt;irq;
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     *data = 0;
<a name="l01550"></a>01550 
<a name="l01551"></a>01551     <span class="comment">/* Hook up test interrupt handler just for this test */</span>
<a name="l01552"></a>01552     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l01553"></a>01553         <span class="comment">/* NOTE: we don&#39;t test MSI-X interrupts here, yet */</span>
<a name="l01554"></a>01554         <span class="keywordflow">return</span> 0;
<a name="l01555"></a>01555     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED) {
<a name="l01556"></a>01556         shared_int = <span class="keyword">false</span>;
<a name="l01557"></a>01557         <span class="keywordflow">if</span> (request_irq(irq, &amp;ixgbe_test_intr, 0, netdev-&gt;name,
<a name="l01558"></a>01558                 netdev)) {
<a name="l01559"></a>01559             *data = 1;
<a name="l01560"></a>01560             <span class="keywordflow">return</span> -1;
<a name="l01561"></a>01561         }
<a name="l01562"></a>01562     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!request_irq(irq, &amp;ixgbe_test_intr, IRQF_PROBE_SHARED,
<a name="l01563"></a>01563                             netdev-&gt;name, netdev)) {
<a name="l01564"></a>01564         shared_int = <span class="keyword">false</span>;
<a name="l01565"></a>01565     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (request_irq(irq, &amp;ixgbe_test_intr, IRQF_SHARED,
<a name="l01566"></a>01566                            netdev-&gt;name, netdev)) {
<a name="l01567"></a>01567         *data = 1;
<a name="l01568"></a>01568         <span class="keywordflow">return</span> -1;
<a name="l01569"></a>01569     }
<a name="l01570"></a>01570     e_info(hw, <span class="stringliteral">&quot;testing %s interrupt\n&quot;</span>,
<a name="l01571"></a>01571            (shared_int ? <span class="stringliteral">&quot;shared&quot;</span> : <span class="stringliteral">&quot;unshared&quot;</span>));
<a name="l01572"></a>01572 
<a name="l01573"></a>01573     <span class="comment">/* Disable all the interrupts */</span>
<a name="l01574"></a>01574     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, 0xFFFFFFFF);
<a name="l01575"></a>01575     usleep_range(10000, 20000);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577     <span class="comment">/* Test each interrupt */</span>
<a name="l01578"></a>01578     <span class="keywordflow">for</span> (; i &lt; 10; i++) {
<a name="l01579"></a>01579         <span class="comment">/* Interrupt to test */</span>
<a name="l01580"></a>01580         mask = 1 &lt;&lt; i;
<a name="l01581"></a>01581 
<a name="l01582"></a>01582         <span class="keywordflow">if</span> (!shared_int) {
<a name="l01583"></a>01583             <span class="comment">/*</span>
<a name="l01584"></a>01584 <span class="comment">             * Disable the interrupts to be reported in</span>
<a name="l01585"></a>01585 <span class="comment">             * the cause register and then force the same</span>
<a name="l01586"></a>01586 <span class="comment">             * interrupt and see if one gets posted.  If</span>
<a name="l01587"></a>01587 <span class="comment">             * an interrupt was posted to the bus, the</span>
<a name="l01588"></a>01588 <span class="comment">             * test failed.</span>
<a name="l01589"></a>01589 <span class="comment">             */</span>
<a name="l01590"></a>01590             adapter-&gt;test_icr = 0;
<a name="l01591"></a>01591             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC,
<a name="l01592"></a>01592                             ~mask &amp; 0x00007FFF);
<a name="l01593"></a>01593             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS,
<a name="l01594"></a>01594                             ~mask &amp; 0x00007FFF);
<a name="l01595"></a>01595             usleep_range(10000, 20000);
<a name="l01596"></a>01596 
<a name="l01597"></a>01597             <span class="keywordflow">if</span> (adapter-&gt;test_icr &amp; mask) {
<a name="l01598"></a>01598                 *data = 3;
<a name="l01599"></a>01599                 <span class="keywordflow">break</span>;
<a name="l01600"></a>01600             }
<a name="l01601"></a>01601         }
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         <span class="comment">/*</span>
<a name="l01604"></a>01604 <span class="comment">         * Enable the interrupt to be reported in the cause</span>
<a name="l01605"></a>01605 <span class="comment">         * register and then force the same interrupt and see</span>
<a name="l01606"></a>01606 <span class="comment">         * if one gets posted.  If an interrupt was not posted</span>
<a name="l01607"></a>01607 <span class="comment">         * to the bus, the test failed.</span>
<a name="l01608"></a>01608 <span class="comment">         */</span>
<a name="l01609"></a>01609         adapter-&gt;test_icr = 0;
<a name="l01610"></a>01610         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMS, mask);
<a name="l01611"></a>01611         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS, mask);
<a name="l01612"></a>01612         usleep_range(10000, 20000);
<a name="l01613"></a>01613 
<a name="l01614"></a>01614         <span class="keywordflow">if</span> (!(adapter-&gt;test_icr &amp;mask)) {
<a name="l01615"></a>01615             *data = 4;
<a name="l01616"></a>01616             <span class="keywordflow">break</span>;
<a name="l01617"></a>01617         }
<a name="l01618"></a>01618 
<a name="l01619"></a>01619         <span class="keywordflow">if</span> (!shared_int) {
<a name="l01620"></a>01620             <span class="comment">/*</span>
<a name="l01621"></a>01621 <span class="comment">             * Disable the other interrupts to be reported in</span>
<a name="l01622"></a>01622 <span class="comment">             * the cause register and then force the other</span>
<a name="l01623"></a>01623 <span class="comment">             * interrupts and see if any get posted.  If</span>
<a name="l01624"></a>01624 <span class="comment">             * an interrupt was posted to the bus, the</span>
<a name="l01625"></a>01625 <span class="comment">             * test failed.</span>
<a name="l01626"></a>01626 <span class="comment">             */</span>
<a name="l01627"></a>01627             adapter-&gt;test_icr = 0;
<a name="l01628"></a>01628             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC,
<a name="l01629"></a>01629                             ~mask &amp; 0x00007FFF);
<a name="l01630"></a>01630             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS,
<a name="l01631"></a>01631                             ~mask &amp; 0x00007FFF);
<a name="l01632"></a>01632             usleep_range(10000, 20000);
<a name="l01633"></a>01633 
<a name="l01634"></a>01634             <span class="keywordflow">if</span> (adapter-&gt;test_icr) {
<a name="l01635"></a>01635                 *data = 5;
<a name="l01636"></a>01636                 <span class="keywordflow">break</span>;
<a name="l01637"></a>01637             }
<a name="l01638"></a>01638         }
<a name="l01639"></a>01639     }
<a name="l01640"></a>01640 
<a name="l01641"></a>01641     <span class="comment">/* Disable all the interrupts */</span>
<a name="l01642"></a>01642     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, 0xFFFFFFFF);
<a name="l01643"></a>01643     usleep_range(10000, 20000);
<a name="l01644"></a>01644 
<a name="l01645"></a>01645     <span class="comment">/* Unhook test interrupt handler */</span>
<a name="l01646"></a>01646     free_irq(irq, netdev);
<a name="l01647"></a>01647 
<a name="l01648"></a>01648     <span class="keywordflow">return</span> *data;
<a name="l01649"></a>01649 }
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_desc_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01652"></a>01652 {
<a name="l01653"></a>01653     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = &amp;adapter-&gt;test_tx_ring;
<a name="l01654"></a>01654     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = &amp;adapter-&gt;test_rx_ring;
<a name="l01655"></a>01655     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01656"></a>01656     u32 reg_ctl;
<a name="l01657"></a>01657 
<a name="l01658"></a>01658     <span class="comment">/* shut down the DMA engines now so they can be reinitialized later */</span>
<a name="l01659"></a>01659 
<a name="l01660"></a>01660     <span class="comment">/* first Rx */</span>
<a name="l01661"></a>01661     reg_ctl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l01662"></a>01662     reg_ctl &amp;= ~IXGBE_RXCTRL_RXEN;
<a name="l01663"></a>01663     IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, reg_ctl);
<a name="l01664"></a>01664     ixgbe_disable_rx_queue(adapter, rx_ring);
<a name="l01665"></a>01665 
<a name="l01666"></a>01666     <span class="comment">/* now Tx */</span>
<a name="l01667"></a>01667     IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(tx_ring-&gt;reg_idx), 0);
<a name="l01668"></a>01668 
<a name="l01669"></a>01669     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l01670"></a>01670     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01671"></a>01671     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01672"></a>01672         reg_ctl = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);
<a name="l01673"></a>01673         reg_ctl &amp;= ~IXGBE_DMATXCTL_TE;
<a name="l01674"></a>01674         IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, reg_ctl);
<a name="l01675"></a>01675         <span class="keywordflow">break</span>;
<a name="l01676"></a>01676     <span class="keywordflow">default</span>:
<a name="l01677"></a>01677         <span class="keywordflow">break</span>;
<a name="l01678"></a>01678     }
<a name="l01679"></a>01679 
<a name="l01680"></a>01680     ixgbe_reset(adapter);
<a name="l01681"></a>01681 
<a name="l01682"></a>01682     ixgbe_free_tx_resources(&amp;adapter-&gt;test_tx_ring);
<a name="l01683"></a>01683     ixgbe_free_rx_resources(&amp;adapter-&gt;test_rx_ring);
<a name="l01684"></a>01684 }
<a name="l01685"></a>01685 
<a name="l01686"></a>01686 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_desc_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01687"></a>01687 {
<a name="l01688"></a>01688     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = &amp;adapter-&gt;test_tx_ring;
<a name="l01689"></a>01689     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = &amp;adapter-&gt;test_rx_ring;
<a name="l01690"></a>01690     u32 rctl, reg_data;
<a name="l01691"></a>01691     <span class="keywordtype">int</span> ret_val;
<a name="l01692"></a>01692     <span class="keywordtype">int</span> err;
<a name="l01693"></a>01693 
<a name="l01694"></a>01694     <span class="comment">/* Setup Tx descriptor ring and Tx buffers */</span>
<a name="l01695"></a>01695     tx_ring-&gt;count = IXGBE_DEFAULT_TXD;
<a name="l01696"></a>01696     tx_ring-&gt;queue_index = 0;
<a name="l01697"></a>01697     tx_ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l01698"></a>01698     tx_ring-&gt;netdev = adapter-&gt;netdev;
<a name="l01699"></a>01699     tx_ring-&gt;reg_idx = adapter-&gt;tx_ring[0]-&gt;reg_idx;
<a name="l01700"></a>01700     tx_ring-&gt;numa_node = adapter-&gt;node;
<a name="l01701"></a>01701 
<a name="l01702"></a>01702     err = ixgbe_setup_tx_resources(tx_ring);
<a name="l01703"></a>01703     <span class="keywordflow">if</span> (err)
<a name="l01704"></a>01704         <span class="keywordflow">return</span> 1;
<a name="l01705"></a>01705 
<a name="l01706"></a>01706     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01707"></a>01707     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01708"></a>01708     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01709"></a>01709         reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_DMATXCTL);
<a name="l01710"></a>01710         reg_data |= IXGBE_DMATXCTL_TE;
<a name="l01711"></a>01711         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DMATXCTL, reg_data);
<a name="l01712"></a>01712         <span class="keywordflow">break</span>;
<a name="l01713"></a>01713     <span class="keywordflow">default</span>:
<a name="l01714"></a>01714         <span class="keywordflow">break</span>;
<a name="l01715"></a>01715     }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717     ixgbe_configure_tx_ring(adapter, tx_ring);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719     <span class="comment">/* Setup Rx Descriptor ring and Rx buffers */</span>
<a name="l01720"></a>01720     rx_ring-&gt;count = IXGBE_DEFAULT_RXD;
<a name="l01721"></a>01721     rx_ring-&gt;queue_index = 0;
<a name="l01722"></a>01722     rx_ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l01723"></a>01723     rx_ring-&gt;netdev = adapter-&gt;netdev;
<a name="l01724"></a>01724     rx_ring-&gt;reg_idx = adapter-&gt;rx_ring[0]-&gt;reg_idx;
<a name="l01725"></a>01725     rx_ring-&gt;rx_buf_len = IXGBE_RXBUFFER_2048;
<a name="l01726"></a>01726     rx_ring-&gt;numa_node = adapter-&gt;node;
<a name="l01727"></a>01727 
<a name="l01728"></a>01728     err = ixgbe_setup_rx_resources(rx_ring);
<a name="l01729"></a>01729     <span class="keywordflow">if</span> (err) {
<a name="l01730"></a>01730         ret_val = 4;
<a name="l01731"></a>01731         <span class="keywordflow">goto</span> err_nomem;
<a name="l01732"></a>01732     }
<a name="l01733"></a>01733 
<a name="l01734"></a>01734     rctl = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL);
<a name="l01735"></a>01735     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL, rctl &amp; ~IXGBE_RXCTRL_RXEN);
<a name="l01736"></a>01736 
<a name="l01737"></a>01737     ixgbe_configure_rx_ring(adapter, rx_ring);
<a name="l01738"></a>01738 
<a name="l01739"></a>01739     rctl |= IXGBE_RXCTRL_RXEN | IXGBE_RXCTRL_DMBYPS;
<a name="l01740"></a>01740     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL, rctl);
<a name="l01741"></a>01741 
<a name="l01742"></a>01742     <span class="keywordflow">return</span> 0;
<a name="l01743"></a>01743 
<a name="l01744"></a>01744 err_nomem:
<a name="l01745"></a>01745     ixgbe_free_desc_rings(adapter);
<a name="l01746"></a>01746     <span class="keywordflow">return</span> ret_val;
<a name="l01747"></a>01747 }
<a name="l01748"></a>01748 
<a name="l01749"></a>01749 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_loopback_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01750"></a>01750 {
<a name="l01751"></a>01751     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01752"></a>01752     u32 reg_data;
<a name="l01753"></a>01753 
<a name="l01754"></a>01754     <span class="comment">/* right now we only support MAC loopback in the driver */</span>
<a name="l01755"></a>01755     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0);
<a name="l01756"></a>01756     <span class="comment">/* Setup MAC loopback */</span>
<a name="l01757"></a>01757     reg_data |= IXGBE_HLREG0_LPBK;
<a name="l01758"></a>01758     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0, reg_data);
<a name="l01759"></a>01759 
<a name="l01760"></a>01760     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_FCTRL);
<a name="l01761"></a>01761     reg_data |= IXGBE_FCTRL_BAM | IXGBE_FCTRL_SBP | IXGBE_FCTRL_MPE;
<a name="l01762"></a>01762     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FCTRL, reg_data);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_AUTOC);
<a name="l01765"></a>01765     reg_data &amp;= ~IXGBE_AUTOC_LMS_MASK;
<a name="l01766"></a>01766     reg_data |= IXGBE_AUTOC_LMS_10G_LINK_NO_AN | IXGBE_AUTOC_FLU;
<a name="l01767"></a>01767     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_AUTOC, reg_data);
<a name="l01768"></a>01768     IXGBE_WRITE_FLUSH(&amp;adapter-&gt;hw);
<a name="l01769"></a>01769     usleep_range(10000, 20000);
<a name="l01770"></a>01770 
<a name="l01771"></a>01771     <span class="comment">/* Disable Atlas Tx lanes; re-enabled in reset path */</span>
<a name="l01772"></a>01772     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB) {
<a name="l01773"></a>01773         u8 atlas;
<a name="l01774"></a>01774 
<a name="l01775"></a>01775         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &amp;atlas);
<a name="l01776"></a>01776         atlas |= IXGBE_ATLAS_PDN_TX_REG_EN;
<a name="l01777"></a>01777         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, atlas);
<a name="l01778"></a>01778 
<a name="l01779"></a>01779         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, &amp;atlas);
<a name="l01780"></a>01780         atlas |= IXGBE_ATLAS_PDN_TX_10G_QL_ALL;
<a name="l01781"></a>01781         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, atlas);
<a name="l01782"></a>01782 
<a name="l01783"></a>01783         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, &amp;atlas);
<a name="l01784"></a>01784         atlas |= IXGBE_ATLAS_PDN_TX_1G_QL_ALL;
<a name="l01785"></a>01785         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, atlas);
<a name="l01786"></a>01786 
<a name="l01787"></a>01787         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, &amp;atlas);
<a name="l01788"></a>01788         atlas |= IXGBE_ATLAS_PDN_TX_AN_QL_ALL;
<a name="l01789"></a>01789         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, atlas);
<a name="l01790"></a>01790     }
<a name="l01791"></a>01791 
<a name="l01792"></a>01792     <span class="keywordflow">return</span> 0;
<a name="l01793"></a>01793 }
<a name="l01794"></a>01794 
<a name="l01795"></a>01795 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_loopback_cleanup(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01796"></a>01796 {
<a name="l01797"></a>01797     u32 reg_data;
<a name="l01798"></a>01798 
<a name="l01799"></a>01799     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0);
<a name="l01800"></a>01800     reg_data &amp;= ~IXGBE_HLREG0_LPBK;
<a name="l01801"></a>01801     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0, reg_data);
<a name="l01802"></a>01802 }
<a name="l01803"></a>01803 
<a name="l01804"></a>01804 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_create_lbtest_frame(<span class="keyword">struct</span> sk_buff *skb,
<a name="l01805"></a>01805                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frame_size)
<a name="l01806"></a>01806 {
<a name="l01807"></a>01807     memset(skb-&gt;data, 0xFF, frame_size);
<a name="l01808"></a>01808     frame_size &amp;= ~1;
<a name="l01809"></a>01809     memset(&amp;skb-&gt;data[frame_size / 2], 0xAA, frame_size / 2 - 1);
<a name="l01810"></a>01810     memset(&amp;skb-&gt;data[frame_size / 2 + 10], 0xBE, 1);
<a name="l01811"></a>01811     memset(&amp;skb-&gt;data[frame_size / 2 + 12], 0xAF, 1);
<a name="l01812"></a>01812 }
<a name="l01813"></a>01813 
<a name="l01814"></a>01814 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_check_lbtest_frame(<span class="keyword">struct</span> sk_buff *skb,
<a name="l01815"></a>01815                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frame_size)
<a name="l01816"></a>01816 {
<a name="l01817"></a>01817     frame_size &amp;= ~1;
<a name="l01818"></a>01818     <span class="keywordflow">if</span> (*(skb-&gt;data + 3) == 0xFF) {
<a name="l01819"></a>01819         <span class="keywordflow">if</span> ((*(skb-&gt;data + frame_size / 2 + 10) == 0xBE) &amp;&amp;
<a name="l01820"></a>01820             (*(skb-&gt;data + frame_size / 2 + 12) == 0xAF)) {
<a name="l01821"></a>01821             <span class="keywordflow">return</span> 0;
<a name="l01822"></a>01822         }
<a name="l01823"></a>01823     }
<a name="l01824"></a>01824     <span class="keywordflow">return</span> 13;
<a name="l01825"></a>01825 }
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 <span class="keyword">static</span> u16 ixgbe_clean_test_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01828"></a>01828                                   <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l01829"></a>01829                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size)
<a name="l01830"></a>01830 {
<a name="l01831"></a>01831     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc;
<a name="l01832"></a>01832     <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *rx_buffer_info;
<a name="l01833"></a>01833     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info;
<a name="l01834"></a>01834     <span class="keyword">const</span> <span class="keywordtype">int</span> bufsz = rx_ring-&gt;rx_buf_len;
<a name="l01835"></a>01835     u32 staterr;
<a name="l01836"></a>01836     u16 rx_ntc, tx_ntc, count = 0;
<a name="l01837"></a>01837 
<a name="l01838"></a>01838     <span class="comment">/* initialize next to clean and descriptor values */</span>
<a name="l01839"></a>01839     rx_ntc = rx_ring-&gt;next_to_clean;
<a name="l01840"></a>01840     tx_ntc = tx_ring-&gt;next_to_clean;
<a name="l01841"></a>01841     rx_desc = IXGBE_RX_DESC_ADV(rx_ring, rx_ntc);
<a name="l01842"></a>01842     staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l01843"></a>01843 
<a name="l01844"></a>01844     <span class="keywordflow">while</span> (staterr &amp; IXGBE_RXD_STAT_DD) {
<a name="l01845"></a>01845         <span class="comment">/* check Rx buffer */</span>
<a name="l01846"></a>01846         rx_buffer_info = &amp;rx_ring-&gt;rx_buffer_info[rx_ntc];
<a name="l01847"></a>01847 
<a name="l01848"></a>01848         <span class="comment">/* unmap Rx buffer, will be remapped by alloc_rx_buffers */</span>
<a name="l01849"></a>01849         dma_unmap_single(rx_ring-&gt;dev,
<a name="l01850"></a>01850                          rx_buffer_info-&gt;dma,
<a name="l01851"></a>01851                  bufsz,
<a name="l01852"></a>01852                  DMA_FROM_DEVICE);
<a name="l01853"></a>01853         rx_buffer_info-&gt;dma = 0;
<a name="l01854"></a>01854 
<a name="l01855"></a>01855         <span class="comment">/* verify contents of skb */</span>
<a name="l01856"></a>01856         <span class="keywordflow">if</span> (!ixgbe_check_lbtest_frame(rx_buffer_info-&gt;skb, size))
<a name="l01857"></a>01857             count++;
<a name="l01858"></a>01858 
<a name="l01859"></a>01859         <span class="comment">/* unmap buffer on Tx side */</span>
<a name="l01860"></a>01860         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[tx_ntc];
<a name="l01861"></a>01861         ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer_info);
<a name="l01862"></a>01862 
<a name="l01863"></a>01863         <span class="comment">/* increment Rx/Tx next to clean counters */</span>
<a name="l01864"></a>01864         rx_ntc++;
<a name="l01865"></a>01865         <span class="keywordflow">if</span> (rx_ntc == rx_ring-&gt;count)
<a name="l01866"></a>01866             rx_ntc = 0;
<a name="l01867"></a>01867         tx_ntc++;
<a name="l01868"></a>01868         <span class="keywordflow">if</span> (tx_ntc == tx_ring-&gt;count)
<a name="l01869"></a>01869             tx_ntc = 0;
<a name="l01870"></a>01870 
<a name="l01871"></a>01871         <span class="comment">/* fetch next descriptor */</span>
<a name="l01872"></a>01872         rx_desc = IXGBE_RX_DESC_ADV(rx_ring, rx_ntc);
<a name="l01873"></a>01873         staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l01874"></a>01874     }
<a name="l01875"></a>01875 
<a name="l01876"></a>01876     <span class="comment">/* re-map buffers to ring, store next to clean values */</span>
<a name="l01877"></a>01877     ixgbe_alloc_rx_buffers(rx_ring, count);
<a name="l01878"></a>01878     rx_ring-&gt;next_to_clean = rx_ntc;
<a name="l01879"></a>01879     tx_ring-&gt;next_to_clean = tx_ntc;
<a name="l01880"></a>01880 
<a name="l01881"></a>01881     <span class="keywordflow">return</span> count;
<a name="l01882"></a>01882 }
<a name="l01883"></a>01883 
<a name="l01884"></a>01884 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_run_loopback_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01885"></a>01885 {
<a name="l01886"></a>01886     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = &amp;adapter-&gt;test_tx_ring;
<a name="l01887"></a>01887     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = &amp;adapter-&gt;test_rx_ring;
<a name="l01888"></a>01888     <span class="keywordtype">int</span> i, j, lc, good_cnt, ret_val = 0;
<a name="l01889"></a>01889     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 1024;
<a name="l01890"></a>01890     netdev_tx_t tx_ret_val;
<a name="l01891"></a>01891     <span class="keyword">struct </span>sk_buff *skb;
<a name="l01892"></a>01892 
<a name="l01893"></a>01893     <span class="comment">/* allocate test skb */</span>
<a name="l01894"></a>01894     skb = alloc_skb(size, GFP_KERNEL);
<a name="l01895"></a>01895     <span class="keywordflow">if</span> (!skb)
<a name="l01896"></a>01896         <span class="keywordflow">return</span> 11;
<a name="l01897"></a>01897 
<a name="l01898"></a>01898     <span class="comment">/* place data into test skb */</span>
<a name="l01899"></a>01899     ixgbe_create_lbtest_frame(skb, size);
<a name="l01900"></a>01900     skb_put(skb, size);
<a name="l01901"></a>01901 
<a name="l01902"></a>01902     <span class="comment">/*</span>
<a name="l01903"></a>01903 <span class="comment">     * Calculate the loop count based on the largest descriptor ring</span>
<a name="l01904"></a>01904 <span class="comment">     * The idea is to wrap the largest ring a number of times using 64</span>
<a name="l01905"></a>01905 <span class="comment">     * send/receive pairs during each loop</span>
<a name="l01906"></a>01906 <span class="comment">     */</span>
<a name="l01907"></a>01907 
<a name="l01908"></a>01908     <span class="keywordflow">if</span> (rx_ring-&gt;count &lt;= tx_ring-&gt;count)
<a name="l01909"></a>01909         lc = ((tx_ring-&gt;count / 64) * 2) + 1;
<a name="l01910"></a>01910     <span class="keywordflow">else</span>
<a name="l01911"></a>01911         lc = ((rx_ring-&gt;count / 64) * 2) + 1;
<a name="l01912"></a>01912 
<a name="l01913"></a>01913     <span class="keywordflow">for</span> (j = 0; j &lt;= lc; j++) {
<a name="l01914"></a>01914         <span class="comment">/* reset count of good packets */</span>
<a name="l01915"></a>01915         good_cnt = 0;
<a name="l01916"></a>01916 
<a name="l01917"></a>01917         <span class="comment">/* place 64 packets on the transmit queue*/</span>
<a name="l01918"></a>01918         <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++) {
<a name="l01919"></a>01919             skb_get(skb);
<a name="l01920"></a>01920             tx_ret_val = ixgbe_xmit_frame_ring(skb,
<a name="l01921"></a>01921                                adapter,
<a name="l01922"></a>01922                                tx_ring);
<a name="l01923"></a>01923             <span class="keywordflow">if</span> (tx_ret_val == NETDEV_TX_OK)
<a name="l01924"></a>01924                 good_cnt++;
<a name="l01925"></a>01925         }
<a name="l01926"></a>01926 
<a name="l01927"></a>01927         <span class="keywordflow">if</span> (good_cnt != 64) {
<a name="l01928"></a>01928             ret_val = 12;
<a name="l01929"></a>01929             <span class="keywordflow">break</span>;
<a name="l01930"></a>01930         }
<a name="l01931"></a>01931 
<a name="l01932"></a>01932         <span class="comment">/* allow 200 milliseconds for packets to go from Tx to Rx */</span>
<a name="l01933"></a>01933         msleep(200);
<a name="l01934"></a>01934 
<a name="l01935"></a>01935         good_cnt = ixgbe_clean_test_rings(rx_ring, tx_ring, size);
<a name="l01936"></a>01936         <span class="keywordflow">if</span> (good_cnt != 64) {
<a name="l01937"></a>01937             ret_val = 13;
<a name="l01938"></a>01938             <span class="keywordflow">break</span>;
<a name="l01939"></a>01939         }
<a name="l01940"></a>01940     }
<a name="l01941"></a>01941 
<a name="l01942"></a>01942     <span class="comment">/* free the original skb */</span>
<a name="l01943"></a>01943     kfree_skb(skb);
<a name="l01944"></a>01944 
<a name="l01945"></a>01945     <span class="keywordflow">return</span> ret_val;
<a name="l01946"></a>01946 }
<a name="l01947"></a>01947 
<a name="l01948"></a>01948 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_loopback_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01949"></a>01949 {
<a name="l01950"></a>01950     *data = ixgbe_setup_desc_rings(adapter);
<a name="l01951"></a>01951     <span class="keywordflow">if</span> (*data)
<a name="l01952"></a>01952         <span class="keywordflow">goto</span> out;
<a name="l01953"></a>01953     *data = ixgbe_setup_loopback_test(adapter);
<a name="l01954"></a>01954     <span class="keywordflow">if</span> (*data)
<a name="l01955"></a>01955         <span class="keywordflow">goto</span> err_loopback;
<a name="l01956"></a>01956     *data = ixgbe_run_loopback_test(adapter);
<a name="l01957"></a>01957     ixgbe_loopback_cleanup(adapter);
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 err_loopback:
<a name="l01960"></a>01960     ixgbe_free_desc_rings(adapter);
<a name="l01961"></a>01961 out:
<a name="l01962"></a>01962     <span class="keywordflow">return</span> *data;
<a name="l01963"></a>01963 }
<a name="l01964"></a>01964 
<a name="l01965"></a>01965 <span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l01966"></a>01966 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_diag_test_count(<span class="keyword">struct</span> net_device *netdev)
<a name="l01967"></a>01967 {
<a name="l01968"></a>01968     <span class="keywordflow">return</span> IXGBE_TEST_LEN;
<a name="l01969"></a>01969 }
<a name="l01970"></a>01970 
<a name="l01971"></a>01971 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l01972"></a>01972 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_diag_test(<span class="keyword">struct</span> net_device *netdev,
<a name="l01973"></a>01973                             <span class="keyword">struct</span> <a class="code" href="structethtool__test.html">ethtool_test</a> *eth_test, u64 *data)
<a name="l01974"></a>01974 {
<a name="l01975"></a>01975     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01976"></a>01976     <span class="keywordtype">bool</span> if_running = netif_running(netdev);
<a name="l01977"></a>01977 
<a name="l01978"></a>01978     set_bit(__IXGBE_TESTING, &amp;adapter-&gt;state);
<a name="l01979"></a>01979     <span class="keywordflow">if</span> (eth_test-&gt;flags == ETH_TEST_FL_OFFLINE) {
<a name="l01980"></a>01980         <span class="comment">/* Offline tests */</span>
<a name="l01981"></a>01981 
<a name="l01982"></a>01982         e_info(hw, <span class="stringliteral">&quot;offline testing starting\n&quot;</span>);
<a name="l01983"></a>01983 
<a name="l01984"></a>01984         <span class="comment">/* Link test performed before hardware reset so autoneg doesn&#39;t</span>
<a name="l01985"></a>01985 <span class="comment">         * interfere with test result */</span>
<a name="l01986"></a>01986         <span class="keywordflow">if</span> (ixgbe_link_test(adapter, &amp;data[4]))
<a name="l01987"></a>01987             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l01988"></a>01988 
<a name="l01989"></a>01989         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l01990"></a>01990             <span class="keywordtype">int</span> i;
<a name="l01991"></a>01991             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l01992"></a>01992                 <span class="keywordflow">if</span> (adapter-&gt;vfinfo[i].clear_to_send) {
<a name="l01993"></a>01993                     e_warn(drv, <span class="stringliteral">&quot;Please take active VFS &quot;</span>
<a name="l01994"></a>01994                            <span class="stringliteral">&quot;offline and restart the &quot;</span>
<a name="l01995"></a>01995                            <span class="stringliteral">&quot;adapter before running NIC &quot;</span>
<a name="l01996"></a>01996                            <span class="stringliteral">&quot;diagnostics\n&quot;</span>);
<a name="l01997"></a>01997                     data[0] = 1;
<a name="l01998"></a>01998                     data[1] = 1;
<a name="l01999"></a>01999                     data[2] = 1;
<a name="l02000"></a>02000                     data[3] = 1;
<a name="l02001"></a>02001                     eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02002"></a>02002                     clear_bit(__IXGBE_TESTING,
<a name="l02003"></a>02003                           &amp;adapter-&gt;state);
<a name="l02004"></a>02004                     <span class="keywordflow">goto</span> skip_ol_tests;
<a name="l02005"></a>02005                 }
<a name="l02006"></a>02006             }
<a name="l02007"></a>02007         }
<a name="l02008"></a>02008 
<a name="l02009"></a>02009         <span class="keywordflow">if</span> (if_running)
<a name="l02010"></a>02010             <span class="comment">/* indicate we&#39;re in test mode */</span>
<a name="l02011"></a>02011             dev_close(netdev);
<a name="l02012"></a>02012         <span class="keywordflow">else</span>
<a name="l02013"></a>02013             ixgbe_reset(adapter);
<a name="l02014"></a>02014 
<a name="l02015"></a>02015         e_info(hw, <span class="stringliteral">&quot;register testing starting\n&quot;</span>);
<a name="l02016"></a>02016         <span class="keywordflow">if</span> (ixgbe_reg_test(adapter, &amp;data[0]))
<a name="l02017"></a>02017             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02018"></a>02018 
<a name="l02019"></a>02019         ixgbe_reset(adapter);
<a name="l02020"></a>02020         e_info(hw, <span class="stringliteral">&quot;eeprom testing starting\n&quot;</span>);
<a name="l02021"></a>02021         <span class="keywordflow">if</span> (ixgbe_eeprom_test(adapter, &amp;data[1]))
<a name="l02022"></a>02022             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02023"></a>02023 
<a name="l02024"></a>02024         ixgbe_reset(adapter);
<a name="l02025"></a>02025         e_info(hw, <span class="stringliteral">&quot;interrupt testing starting\n&quot;</span>);
<a name="l02026"></a>02026         <span class="keywordflow">if</span> (ixgbe_intr_test(adapter, &amp;data[2]))
<a name="l02027"></a>02027             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02028"></a>02028 
<a name="l02029"></a>02029         <span class="comment">/* If SRIOV or VMDq is enabled then skip MAC</span>
<a name="l02030"></a>02030 <span class="comment">         * loopback diagnostic. */</span>
<a name="l02031"></a>02031         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_SRIOV_ENABLED |
<a name="l02032"></a>02032                       IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l02033"></a>02033             e_info(hw, <span class="stringliteral">&quot;skip MAC loopback diagnostic in VT mode\n&quot;</span>);
<a name="l02034"></a>02034             data[3] = 0;
<a name="l02035"></a>02035             <span class="keywordflow">goto</span> skip_loopback;
<a name="l02036"></a>02036         }
<a name="l02037"></a>02037 
<a name="l02038"></a>02038         ixgbe_reset(adapter);
<a name="l02039"></a>02039         e_info(hw, <span class="stringliteral">&quot;loopback testing starting\n&quot;</span>);
<a name="l02040"></a>02040         <span class="keywordflow">if</span> (ixgbe_loopback_test(adapter, &amp;data[3]))
<a name="l02041"></a>02041             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02042"></a>02042 
<a name="l02043"></a>02043 skip_loopback:
<a name="l02044"></a>02044         ixgbe_reset(adapter);
<a name="l02045"></a>02045 
<a name="l02046"></a>02046         clear_bit(__IXGBE_TESTING, &amp;adapter-&gt;state);
<a name="l02047"></a>02047         <span class="keywordflow">if</span> (if_running)
<a name="l02048"></a>02048             dev_open(netdev);
<a name="l02049"></a>02049     } <span class="keywordflow">else</span> {
<a name="l02050"></a>02050         e_info(hw, <span class="stringliteral">&quot;online testing starting\n&quot;</span>);
<a name="l02051"></a>02051         <span class="comment">/* Online tests */</span>
<a name="l02052"></a>02052         <span class="keywordflow">if</span> (ixgbe_link_test(adapter, &amp;data[4]))
<a name="l02053"></a>02053             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02054"></a>02054 
<a name="l02055"></a>02055         <span class="comment">/* Online tests aren&#39;t run; pass by default */</span>
<a name="l02056"></a>02056         data[0] = 0;
<a name="l02057"></a>02057         data[1] = 0;
<a name="l02058"></a>02058         data[2] = 0;
<a name="l02059"></a>02059         data[3] = 0;
<a name="l02060"></a>02060 
<a name="l02061"></a>02061         clear_bit(__IXGBE_TESTING, &amp;adapter-&gt;state);
<a name="l02062"></a>02062     }
<a name="l02063"></a>02063 skip_ol_tests:
<a name="l02064"></a>02064     msleep_interruptible(4 * 1000);
<a name="l02065"></a>02065 }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_wol_exclusion(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02068"></a>02068                                <span class="keyword">struct</span> <a class="code" href="structethtool__wolinfo.html">ethtool_wolinfo</a> *wol)
<a name="l02069"></a>02069 {
<a name="l02070"></a>02070     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02071"></a>02071     <span class="keywordtype">int</span> retval = 1;
<a name="l02072"></a>02072 
<a name="l02073"></a>02073     <span class="comment">/* WOL not supported except for the following */</span>
<a name="l02074"></a>02074     <span class="keywordflow">switch</span>(hw-&gt;device_id) {
<a name="l02075"></a>02075     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_SFP:
<a name="l02076"></a>02076         <span class="comment">/* Only this subdevice supports WOL */</span>
<a name="l02077"></a>02077         <span class="keywordflow">if</span> (hw-&gt;subsystem_device_id != IXGBE_SUBDEV_ID_82599_SFP) {
<a name="l02078"></a>02078             wol-&gt;supported = 0;
<a name="l02079"></a>02079             <span class="keywordflow">break</span>;
<a name="l02080"></a>02080         }
<a name="l02081"></a>02081         retval = 0;
<a name="l02082"></a>02082         <span class="keywordflow">break</span>;
<a name="l02083"></a>02083     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_COMBO_BACKPLANE:
<a name="l02084"></a>02084         <span class="comment">/* All except this subdevice support WOL */</span>
<a name="l02085"></a>02085         <span class="keywordflow">if</span> (hw-&gt;subsystem_device_id ==
<a name="l02086"></a>02086             IXGBE_SUBDEV_ID_82599_KX4_KR_MEZZ) {
<a name="l02087"></a>02087             wol-&gt;supported = 0;
<a name="l02088"></a>02088             <span class="keywordflow">break</span>;
<a name="l02089"></a>02089         }
<a name="l02090"></a>02090         retval = 0;
<a name="l02091"></a>02091         <span class="keywordflow">break</span>;
<a name="l02092"></a>02092     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_KX4:
<a name="l02093"></a>02093         retval = 0;
<a name="l02094"></a>02094         <span class="keywordflow">break</span>;
<a name="l02095"></a>02095     <span class="keywordflow">default</span>:
<a name="l02096"></a>02096         wol-&gt;supported = 0;
<a name="l02097"></a>02097     }
<a name="l02098"></a>02098 
<a name="l02099"></a>02099     <span class="keywordflow">return</span> retval;
<a name="l02100"></a>02100 }
<a name="l02101"></a>02101 
<a name="l02102"></a>02102 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_wol(<span class="keyword">struct</span> net_device *netdev,
<a name="l02103"></a>02103                           <span class="keyword">struct</span> <a class="code" href="structethtool__wolinfo.html">ethtool_wolinfo</a> *wol)
<a name="l02104"></a>02104 {
<a name="l02105"></a>02105     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02106"></a>02106 
<a name="l02107"></a>02107     wol-&gt;supported = WAKE_UCAST | WAKE_MCAST |
<a name="l02108"></a>02108                      WAKE_BCAST | WAKE_MAGIC;
<a name="l02109"></a>02109     wol-&gt;wolopts = 0;
<a name="l02110"></a>02110 
<a name="l02111"></a>02111     <span class="keywordflow">if</span> (ixgbe_wol_exclusion(adapter, wol) ||
<a name="l02112"></a>02112         !device_can_wakeup(&amp;adapter-&gt;pdev-&gt;dev))
<a name="l02113"></a>02113         <span class="keywordflow">return</span>;
<a name="l02114"></a>02114 
<a name="l02115"></a>02115     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_EX)
<a name="l02116"></a>02116         wol-&gt;wolopts |= WAKE_UCAST;
<a name="l02117"></a>02117     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_MC)
<a name="l02118"></a>02118         wol-&gt;wolopts |= WAKE_MCAST;
<a name="l02119"></a>02119     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_BC)
<a name="l02120"></a>02120         wol-&gt;wolopts |= WAKE_BCAST;
<a name="l02121"></a>02121     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_MAG)
<a name="l02122"></a>02122         wol-&gt;wolopts |= WAKE_MAGIC;
<a name="l02123"></a>02123 }
<a name="l02124"></a>02124 
<a name="l02125"></a>02125 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_wol(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structethtool__wolinfo.html">ethtool_wolinfo</a> *wol)
<a name="l02126"></a>02126 {
<a name="l02127"></a>02127     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02128"></a>02128 
<a name="l02129"></a>02129     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
<a name="l02130"></a>02130         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l02131"></a>02131 
<a name="l02132"></a>02132     <span class="keywordflow">if</span> (ixgbe_wol_exclusion(adapter, wol))
<a name="l02133"></a>02133         <span class="keywordflow">return</span> wol-&gt;wolopts ? -EOPNOTSUPP : 0;
<a name="l02134"></a>02134 
<a name="l02135"></a>02135     adapter-&gt;wol = 0;
<a name="l02136"></a>02136 
<a name="l02137"></a>02137     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_UCAST)
<a name="l02138"></a>02138         adapter-&gt;wol |= IXGBE_WUFC_EX;
<a name="l02139"></a>02139     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_MCAST)
<a name="l02140"></a>02140         adapter-&gt;wol |= IXGBE_WUFC_MC;
<a name="l02141"></a>02141     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_BCAST)
<a name="l02142"></a>02142         adapter-&gt;wol |= IXGBE_WUFC_BC;
<a name="l02143"></a>02143     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_MAGIC)
<a name="l02144"></a>02144         adapter-&gt;wol |= IXGBE_WUFC_MAG;
<a name="l02145"></a>02145 
<a name="l02146"></a>02146     device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148     <span class="keywordflow">return</span> 0;
<a name="l02149"></a>02149 }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_nway_reset(<span class="keyword">struct</span> net_device *netdev)
<a name="l02152"></a>02152 {
<a name="l02153"></a>02153     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02154"></a>02154 
<a name="l02155"></a>02155     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l02156"></a>02156         ixgbe_reinit_locked(adapter);
<a name="l02157"></a>02157 
<a name="l02158"></a>02158     <span class="keywordflow">return</span> 0;
<a name="l02159"></a>02159 }
<a name="l02160"></a>02160 
<a name="l02161"></a>02161 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_phys_id(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l02162"></a>02162 {
<a name="l02163"></a>02163     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02164"></a>02164     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02165"></a>02165     u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
<a name="l02166"></a>02166     u32 i;
<a name="l02167"></a>02167 
<a name="l02168"></a>02168     <span class="keywordflow">if</span> (!data || data &gt; 300)
<a name="l02169"></a>02169         data = 300;
<a name="l02170"></a>02170 
<a name="l02171"></a>02171     <span class="keywordflow">for</span> (i = 0; i &lt; (data * 1000); i += 400) {
<a name="l02172"></a>02172         ixgbe_led_on(hw, IXGBE_LED_ON);
<a name="l02173"></a>02173         msleep_interruptible(200);
<a name="l02174"></a>02174         ixgbe_led_off(hw, IXGBE_LED_ON);
<a name="l02175"></a>02175         msleep_interruptible(200);
<a name="l02176"></a>02176     }
<a name="l02177"></a>02177 
<a name="l02178"></a>02178     <span class="comment">/* Restore LED settings */</span>
<a name="l02179"></a>02179     IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
<a name="l02180"></a>02180 
<a name="l02181"></a>02181     <span class="keywordflow">return</span> 0;
<a name="l02182"></a>02182 }
<a name="l02183"></a>02183 
<a name="l02184"></a>02184 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_coalesce(<span class="keyword">struct</span> net_device *netdev,
<a name="l02185"></a>02185                               <span class="keyword">struct</span> ethtool_coalesce *ec)
<a name="l02186"></a>02186 {
<a name="l02187"></a>02187     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02188"></a>02188 
<a name="l02189"></a>02189 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02190"></a>02190 <span class="preprocessor"></span>    ec-&gt;tx_max_coalesced_frames_irq = adapter-&gt;tx_work_limit;
<a name="l02191"></a>02191     ec-&gt;rx_max_coalesced_frames_irq = adapter-&gt;rx_work_limit;
<a name="l02192"></a>02192 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02193"></a>02193 
<a name="l02194"></a>02194     <span class="comment">/* only valid if in constant ITR mode */</span>
<a name="l02195"></a>02195     <span class="keywordflow">switch</span> (adapter-&gt;rx_itr_setting) {
<a name="l02196"></a>02196     <span class="keywordflow">case</span> 0:
<a name="l02197"></a>02197         <span class="comment">/* throttling disabled */</span>
<a name="l02198"></a>02198         ec-&gt;rx_coalesce_usecs = 0;
<a name="l02199"></a>02199         <span class="keywordflow">break</span>;
<a name="l02200"></a>02200     <span class="keywordflow">case</span> 1:
<a name="l02201"></a>02201         <span class="comment">/* dynamic ITR mode */</span>
<a name="l02202"></a>02202         ec-&gt;rx_coalesce_usecs = 1;
<a name="l02203"></a>02203         <span class="keywordflow">break</span>;
<a name="l02204"></a>02204     <span class="keywordflow">default</span>:
<a name="l02205"></a>02205         <span class="comment">/* fixed interrupt rate mode */</span>
<a name="l02206"></a>02206         ec-&gt;rx_coalesce_usecs = 1000000/adapter-&gt;rx_eitr_param;
<a name="l02207"></a>02207         <span class="keywordflow">break</span>;
<a name="l02208"></a>02208     }
<a name="l02209"></a>02209 
<a name="l02210"></a>02210     <span class="comment">/* if in mixed tx/rx queues per vector mode, report only rx settings */</span>
<a name="l02211"></a>02211     <span class="keywordflow">if</span> (adapter-&gt;q_vector[0]-&gt;tx.count &amp;&amp; adapter-&gt;q_vector[0]-&gt;rx.count)
<a name="l02212"></a>02212         <span class="keywordflow">return</span> 0;
<a name="l02213"></a>02213 
<a name="l02214"></a>02214     <span class="comment">/* only valid if in constant ITR mode */</span>
<a name="l02215"></a>02215     <span class="keywordflow">switch</span> (adapter-&gt;tx_itr_setting) {
<a name="l02216"></a>02216     <span class="keywordflow">case</span> 0:
<a name="l02217"></a>02217         <span class="comment">/* throttling disabled */</span>
<a name="l02218"></a>02218         ec-&gt;tx_coalesce_usecs = 0;
<a name="l02219"></a>02219         <span class="keywordflow">break</span>;
<a name="l02220"></a>02220     <span class="keywordflow">case</span> 1:
<a name="l02221"></a>02221         <span class="comment">/* dynamic ITR mode */</span>
<a name="l02222"></a>02222         ec-&gt;tx_coalesce_usecs = 1;
<a name="l02223"></a>02223         <span class="keywordflow">break</span>;
<a name="l02224"></a>02224     <span class="keywordflow">default</span>:
<a name="l02225"></a>02225         ec-&gt;tx_coalesce_usecs = 1000000/adapter-&gt;tx_eitr_param;
<a name="l02226"></a>02226         <span class="keywordflow">break</span>;
<a name="l02227"></a>02227     }
<a name="l02228"></a>02228 
<a name="l02229"></a>02229     <span class="keywordflow">return</span> 0;
<a name="l02230"></a>02230 }
<a name="l02231"></a>02231 
<a name="l02232"></a>02232 <span class="comment">/*</span>
<a name="l02233"></a>02233 <span class="comment"> * this function must be called before setting the new value of</span>
<a name="l02234"></a>02234 <span class="comment"> * rx_itr_setting</span>
<a name="l02235"></a>02235 <span class="comment"> */</span>
<a name="l02236"></a>02236 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_update_rsc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02237"></a>02237                                <span class="keyword">struct</span> ethtool_coalesce *ec)
<a name="l02238"></a>02238 {
<a name="l02239"></a>02239     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02240"></a>02240 
<a name="l02241"></a>02241     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE))
<a name="l02242"></a>02242         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02243"></a>02243 
<a name="l02244"></a>02244     <span class="comment">/* if interrupt rate is too high then disable RSC */</span>
<a name="l02245"></a>02245     <span class="keywordflow">if</span> (ec-&gt;rx_coalesce_usecs != 1 &amp;&amp;
<a name="l02246"></a>02246         ec-&gt;rx_coalesce_usecs &lt;= 1000000/IXGBE_MAX_RSC_INT_RATE) {
<a name="l02247"></a>02247         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l02248"></a>02248             e_info(probe, <span class="stringliteral">&quot;rx-usecs set too low, disabling RSC\n&quot;</span>);
<a name="l02249"></a>02249             adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_ENABLED;
<a name="l02250"></a>02250             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02251"></a>02251         }
<a name="l02252"></a>02252     } <span class="keywordflow">else</span> {
<a name="l02253"></a>02253         <span class="comment">/* check the feature flag value and enable RSC if necessary */</span>
<a name="l02254"></a>02254         <span class="keywordflow">if</span> ((netdev-&gt;features &amp; NETIF_F_LRO) &amp;&amp;
<a name="l02255"></a>02255             !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED)) {
<a name="l02256"></a>02256             e_info(probe, <span class="stringliteral">&quot;rx-usecs set to %d, re-enabling RSC\n&quot;</span>,
<a name="l02257"></a>02257                    ec-&gt;rx_coalesce_usecs);
<a name="l02258"></a>02258             adapter-&gt;flags2 |= IXGBE_FLAG2_RSC_ENABLED;
<a name="l02259"></a>02259             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02260"></a>02260         }
<a name="l02261"></a>02261     }
<a name="l02262"></a>02262     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02263"></a>02263 }
<a name="l02264"></a>02264 
<a name="l02265"></a>02265 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_coalesce(<span class="keyword">struct</span> net_device *netdev,
<a name="l02266"></a>02266                               <span class="keyword">struct</span> ethtool_coalesce *ec)
<a name="l02267"></a>02267 {
<a name="l02268"></a>02268     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02269"></a>02269     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l02270"></a>02270     <span class="keywordtype">int</span> i;
<a name="l02271"></a>02271     <span class="keywordtype">int</span> num_vectors;
<a name="l02272"></a>02272     <span class="keywordtype">bool</span> need_reset = <span class="keyword">false</span>;
<a name="l02273"></a>02273 
<a name="l02274"></a>02274     <span class="comment">/* don&#39;t accept tx specific changes if we&#39;ve got mixed RxTx vectors */</span>
<a name="l02275"></a>02275     <span class="keywordflow">if</span> (adapter-&gt;q_vector[0]-&gt;tx.count &amp;&amp; adapter-&gt;q_vector[0]-&gt;rx.count
<a name="l02276"></a>02276         &amp;&amp; ec-&gt;tx_coalesce_usecs)
<a name="l02277"></a>02277         <span class="keywordflow">return</span> -EINVAL;
<a name="l02278"></a>02278 
<a name="l02279"></a>02279 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02280"></a>02280 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ec-&gt;tx_max_coalesced_frames_irq)
<a name="l02281"></a>02281         adapter-&gt;tx_work_limit = ec-&gt;tx_max_coalesced_frames_irq;
<a name="l02282"></a>02282     <span class="keywordflow">if</span> (ec-&gt;rx_max_coalesced_frames_irq)
<a name="l02283"></a>02283         adapter-&gt;rx_work_limit = ec-&gt;rx_max_coalesced_frames_irq;
<a name="l02284"></a>02284 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02285"></a>02285 
<a name="l02286"></a>02286     <span class="keywordflow">if</span> (ec-&gt;rx_coalesce_usecs &gt; 1) {
<a name="l02287"></a>02287         <span class="comment">/* check the limits */</span>
<a name="l02288"></a>02288         <span class="keywordflow">if</span> ((1000000/ec-&gt;rx_coalesce_usecs &gt; IXGBE_MAX_INT_RATE) ||
<a name="l02289"></a>02289             (1000000/ec-&gt;rx_coalesce_usecs &lt; IXGBE_MIN_INT_RATE))
<a name="l02290"></a>02290             <span class="keywordflow">return</span> -EINVAL;
<a name="l02291"></a>02291 
<a name="l02292"></a>02292         <span class="comment">/* check the old value and enable RSC if necessary */</span>
<a name="l02293"></a>02293         need_reset = ixgbe_update_rsc(adapter, ec);
<a name="l02294"></a>02294 
<a name="l02295"></a>02295         <span class="comment">/* store the value in ints/second */</span>
<a name="l02296"></a>02296         adapter-&gt;rx_eitr_param = 1000000/ec-&gt;rx_coalesce_usecs;
<a name="l02297"></a>02297 
<a name="l02298"></a>02298         <span class="comment">/* static value of interrupt rate */</span>
<a name="l02299"></a>02299         adapter-&gt;rx_itr_setting = adapter-&gt;rx_eitr_param;
<a name="l02300"></a>02300         <span class="comment">/* clear the lower bit as its used for dynamic state */</span>
<a name="l02301"></a>02301         adapter-&gt;rx_itr_setting &amp;= ~1;
<a name="l02302"></a>02302     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ec-&gt;rx_coalesce_usecs == 1) {
<a name="l02303"></a>02303         <span class="comment">/* check the old value and enable RSC if necessary */</span>
<a name="l02304"></a>02304         need_reset = ixgbe_update_rsc(adapter, ec);
<a name="l02305"></a>02305 
<a name="l02306"></a>02306         <span class="comment">/* 1 means dynamic mode */</span>
<a name="l02307"></a>02307         adapter-&gt;rx_eitr_param = 20000;
<a name="l02308"></a>02308         adapter-&gt;rx_itr_setting = 1;
<a name="l02309"></a>02309     } <span class="keywordflow">else</span> {
<a name="l02310"></a>02310         <span class="comment">/* check the old value and enable RSC if necessary */</span>
<a name="l02311"></a>02311         need_reset = ixgbe_update_rsc(adapter, ec);
<a name="l02312"></a>02312         <span class="comment">/*</span>
<a name="l02313"></a>02313 <span class="comment">         * any other value means disable eitr, which is best</span>
<a name="l02314"></a>02314 <span class="comment">         * served by setting the interrupt rate very high</span>
<a name="l02315"></a>02315 <span class="comment">         */</span>
<a name="l02316"></a>02316         adapter-&gt;rx_eitr_param = IXGBE_MAX_INT_RATE;
<a name="l02317"></a>02317         adapter-&gt;rx_itr_setting = 0;
<a name="l02318"></a>02318     }
<a name="l02319"></a>02319 
<a name="l02320"></a>02320     <span class="keywordflow">if</span> (ec-&gt;tx_coalesce_usecs &gt; 1) {
<a name="l02321"></a>02321         <span class="comment">/*</span>
<a name="l02322"></a>02322 <span class="comment">         * don&#39;t have to worry about max_int as above because</span>
<a name="l02323"></a>02323 <span class="comment">         * tx vectors don&#39;t do hardware RSC (an rx function)</span>
<a name="l02324"></a>02324 <span class="comment">         */</span>
<a name="l02325"></a>02325         <span class="comment">/* check the limits */</span>
<a name="l02326"></a>02326         <span class="keywordflow">if</span> ((1000000/ec-&gt;tx_coalesce_usecs &gt; IXGBE_MAX_INT_RATE) ||
<a name="l02327"></a>02327             (1000000/ec-&gt;tx_coalesce_usecs &lt; IXGBE_MIN_INT_RATE))
<a name="l02328"></a>02328             <span class="keywordflow">return</span> -EINVAL;
<a name="l02329"></a>02329 
<a name="l02330"></a>02330         <span class="comment">/* store the value in ints/second */</span>
<a name="l02331"></a>02331         adapter-&gt;tx_eitr_param = 1000000/ec-&gt;tx_coalesce_usecs;
<a name="l02332"></a>02332 
<a name="l02333"></a>02333         <span class="comment">/* static value of interrupt rate */</span>
<a name="l02334"></a>02334         adapter-&gt;tx_itr_setting = adapter-&gt;tx_eitr_param;
<a name="l02335"></a>02335 
<a name="l02336"></a>02336         <span class="comment">/* clear the lower bit as its used for dynamic state */</span>
<a name="l02337"></a>02337         adapter-&gt;tx_itr_setting &amp;= ~1;
<a name="l02338"></a>02338     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ec-&gt;tx_coalesce_usecs == 1) {
<a name="l02339"></a>02339         <span class="comment">/* 1 means dynamic mode */</span>
<a name="l02340"></a>02340         adapter-&gt;tx_eitr_param = 10000;
<a name="l02341"></a>02341         adapter-&gt;tx_itr_setting = 1;
<a name="l02342"></a>02342     } <span class="keywordflow">else</span> {
<a name="l02343"></a>02343         adapter-&gt;tx_eitr_param = IXGBE_MAX_INT_RATE;
<a name="l02344"></a>02344         adapter-&gt;tx_itr_setting = 0;
<a name="l02345"></a>02345     }
<a name="l02346"></a>02346 
<a name="l02347"></a>02347     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l02348"></a>02348         num_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02349"></a>02349     <span class="keywordflow">else</span>
<a name="l02350"></a>02350         num_vectors = 1;
<a name="l02351"></a>02351 
<a name="l02352"></a>02352     <span class="keywordflow">for</span> (i = 0; i &lt; num_vectors; i++) {
<a name="l02353"></a>02353         q_vector = adapter-&gt;q_vector[i];
<a name="l02354"></a>02354 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02355"></a>02355 <span class="preprocessor"></span>        q_vector-&gt;tx.work_limit = adapter-&gt;tx_work_limit;
<a name="l02356"></a>02356         q_vector-&gt;rx.work_limit = adapter-&gt;rx_work_limit;
<a name="l02357"></a>02357 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02358"></a>02358         <span class="keywordflow">if</span> (q_vector-&gt;tx.count &amp;&amp; !q_vector-&gt;rx.count)
<a name="l02359"></a>02359             <span class="comment">/* tx only */</span>
<a name="l02360"></a>02360             q_vector-&gt;eitr = adapter-&gt;tx_eitr_param;
<a name="l02361"></a>02361         <span class="keywordflow">else</span>
<a name="l02362"></a>02362             <span class="comment">/* rx only or mixed */</span>
<a name="l02363"></a>02363             q_vector-&gt;eitr = adapter-&gt;rx_eitr_param;
<a name="l02364"></a>02364         ixgbe_write_eitr(q_vector);
<a name="l02365"></a>02365     }
<a name="l02366"></a>02366 
<a name="l02367"></a>02367     <span class="comment">/*</span>
<a name="l02368"></a>02368 <span class="comment">     * do reset here at the end to make sure EITR==0 case is handled</span>
<a name="l02369"></a>02369 <span class="comment">     * correctly w.r.t stopping tx, and changing TXDCTL.WTHRESH settings</span>
<a name="l02370"></a>02370 <span class="comment">     * also locks in RSC enable/disable which requires reset</span>
<a name="l02371"></a>02371 <span class="comment">     */</span>
<a name="l02372"></a>02372     <span class="keywordflow">if</span> (need_reset) {
<a name="l02373"></a>02373         <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l02374"></a>02374             ixgbe_reinit_locked(adapter);
<a name="l02375"></a>02375         <span class="keywordflow">else</span>
<a name="l02376"></a>02376             ixgbe_reset(adapter);
<a name="l02377"></a>02377     }
<a name="l02378"></a>02378 
<a name="l02379"></a>02379     <span class="keywordflow">return</span> 0;
<a name="l02380"></a>02380 }
<a name="l02381"></a>02381 
<a name="l02382"></a>02382 <span class="preprocessor">#ifdef ETHTOOL_GFLAGS</span>
<a name="l02383"></a>02383 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_flags(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l02384"></a>02384 {
<a name="l02385"></a>02385     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02386"></a>02386     <span class="keywordtype">bool</span> need_reset = <span class="keyword">false</span>;
<a name="l02387"></a>02387     <span class="keywordtype">int</span> rc;
<a name="l02388"></a>02388 
<a name="l02389"></a>02389     rc = ethtool_op_set_flags(netdev, data, ETH_FLAG_LRO | ETH_FLAG_NTUPLE |
<a name="l02390"></a>02390                     ETH_FLAG_RXVLAN | ETH_FLAG_TXVLAN);
<a name="l02391"></a>02391     <span class="keywordflow">if</span> (rc)
<a name="l02392"></a>02392         <span class="keywordflow">return</span> rc;
<a name="l02393"></a>02393 
<a name="l02394"></a>02394     <span class="comment">/* if state changes we need to update adapter-&gt;flags and reset */</span>
<a name="l02395"></a>02395     <span class="keywordflow">if</span> ((adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE) &amp;&amp;
<a name="l02396"></a>02396         (!!(data &amp; ETH_FLAG_LRO) !=
<a name="l02397"></a>02397          !!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED))) {
<a name="l02398"></a>02398         <span class="keywordflow">if</span> ((data &amp; ETH_FLAG_LRO) &amp;&amp;
<a name="l02399"></a>02399             (!adapter-&gt;rx_itr_setting ||
<a name="l02400"></a>02400              (adapter-&gt;rx_itr_setting &gt; IXGBE_MAX_RSC_INT_RATE))) {
<a name="l02401"></a>02401             e_info(probe, <span class="stringliteral">&quot;rx-usecs set too low, &quot;</span>
<a name="l02402"></a>02402                    <span class="stringliteral">&quot;not enabling RSC\n&quot;</span>);
<a name="l02403"></a>02403         } <span class="keywordflow">else</span> {
<a name="l02404"></a>02404             adapter-&gt;flags2 ^= IXGBE_FLAG2_RSC_ENABLED;
<a name="l02405"></a>02405             <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02406"></a>02406             <span class="keywordtype">int</span> i;
<a name="l02407"></a>02407             <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02408"></a>02408                 <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l02409"></a>02409                     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;rx_ring[i];
<a name="l02410"></a>02410                     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l02411"></a>02411                         set_ring_rsc_enabled(ring);
<a name="l02412"></a>02412                         ixgbe_configure_rscctl(adapter, ring);
<a name="l02413"></a>02413                     } <span class="keywordflow">else</span> {
<a name="l02414"></a>02414                         ixgbe_clear_rscctl(adapter, ring);
<a name="l02415"></a>02415                     }
<a name="l02416"></a>02416                 }
<a name="l02417"></a>02417                 <span class="keywordflow">break</span>;
<a name="l02418"></a>02418             <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02419"></a>02419                 need_reset = <span class="keyword">true</span>;
<a name="l02420"></a>02420                 <span class="keywordflow">break</span>;
<a name="l02421"></a>02421             <span class="keywordflow">default</span>:
<a name="l02422"></a>02422                 <span class="keywordflow">break</span>;
<a name="l02423"></a>02423             }
<a name="l02424"></a>02424         }
<a name="l02425"></a>02425 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l02426"></a>02426 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l02427"></a>02427 <span class="comment">     * Cast both to bool and verify if they are set the same</span>
<a name="l02428"></a>02428 <span class="comment">     * and don&#39;t set LRO if device is RSC capable.</span>
<a name="l02429"></a>02429 <span class="comment">     */</span>
<a name="l02430"></a>02430     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE) &amp;&amp;
<a name="l02431"></a>02431            (!!(data &amp; ETH_FLAG_LRO) !=
<a name="l02432"></a>02432             !!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED))) {
<a name="l02433"></a>02433         <span class="keywordtype">int</span> i;
<a name="l02434"></a>02434         adapter-&gt;flags2 ^= IXGBE_FLAG2_SWLRO_ENABLED;
<a name="l02435"></a>02435         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l02436"></a>02436             <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED)
<a name="l02437"></a>02437                 set_ring_lro_enabled(adapter-&gt;rx_ring[i]);
<a name="l02438"></a>02438             <span class="keywordflow">else</span>
<a name="l02439"></a>02439                 clear_ring_lro_enabled(adapter-&gt;rx_ring[i]);
<a name="l02440"></a>02440         }
<a name="l02441"></a>02441 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l02442"></a>02442     }
<a name="l02443"></a>02443 
<a name="l02444"></a>02444 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l02445"></a>02445 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l02446"></a>02446 <span class="comment">     * Check if Flow Director n-tuple support was enabled or disabled.  If</span>
<a name="l02447"></a>02447 <span class="comment">     * the state changed, we need to reset.</span>
<a name="l02448"></a>02448 <span class="comment">     */</span>
<a name="l02449"></a>02449     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)) {
<a name="l02450"></a>02450         <span class="comment">/* turn off ATR, enable perfect filters and reset */</span>
<a name="l02451"></a>02451         <span class="keywordflow">if</span> (data &amp; ETH_FLAG_NTUPLE) {
<a name="l02452"></a>02452             adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l02453"></a>02453             adapter-&gt;flags |= IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
<a name="l02454"></a>02454             need_reset = <span class="keyword">true</span>;
<a name="l02455"></a>02455         }
<a name="l02456"></a>02456     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(data &amp; ETH_FLAG_NTUPLE)) {
<a name="l02457"></a>02457         <span class="comment">/* turn off Flow Director, set ATR and reset */</span>
<a name="l02458"></a>02458         adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
<a name="l02459"></a>02459         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED)
<a name="l02460"></a>02460             adapter-&gt;flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l02461"></a>02461         need_reset = <span class="keyword">true</span>;
<a name="l02462"></a>02462     }
<a name="l02463"></a>02463 
<a name="l02464"></a>02464 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l02465"></a>02465     <span class="keywordflow">if</span> (need_reset) {
<a name="l02466"></a>02466         <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l02467"></a>02467             ixgbe_reinit_locked(adapter);
<a name="l02468"></a>02468         <span class="keywordflow">else</span>
<a name="l02469"></a>02469             ixgbe_reset(adapter);
<a name="l02470"></a>02470     }
<a name="l02471"></a>02471 
<a name="l02472"></a>02472     <span class="keywordflow">return</span> 0;
<a name="l02473"></a>02473 }
<a name="l02474"></a>02474 
<a name="l02475"></a>02475 <span class="preprocessor">#endif </span><span class="comment">/* ETHTOOL_GFLAGS */</span>
<a name="l02476"></a>02476 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l02477"></a>02477 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_fdir_set_sw_index(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02478"></a>02478                     <span class="keyword">struct</span> <a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *input)
<a name="l02479"></a>02479 {
<a name="l02480"></a>02480     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l02481"></a>02481     <span class="keyword">struct </span><a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *filter;
<a name="l02482"></a>02482     u16 sw_idx;
<a name="l02483"></a>02483 
<a name="l02484"></a>02484     <span class="comment">/* limit bucket hash to available values */</span>
<a name="l02485"></a>02485     input-&gt;filter.formatted.bkt_hash &amp;= (1024 &lt;&lt; adapter-&gt;fdir_pballoc) - 1;
<a name="l02486"></a>02486 
<a name="l02487"></a>02487     <span class="comment">/*</span>
<a name="l02488"></a>02488 <span class="comment">     * set software index to bucket_hash + 1 in order to guarantee</span>
<a name="l02489"></a>02489 <span class="comment">     * that between the two at least one bit is set.</span>
<a name="l02490"></a>02490 <span class="comment">     */</span>
<a name="l02491"></a>02491     sw_idx = input-&gt;filter.formatted.bkt_hash + 1;
<a name="l02492"></a>02492 
<a name="l02493"></a>02493     hlist_for_each_entry_safe(filter, node, node2,
<a name="l02494"></a>02494                   &amp;adapter-&gt;fdir_filter_list, fdir_node) {
<a name="l02495"></a>02495         <span class="comment">/* hash not found, no matching entry */</span>
<a name="l02496"></a>02496         <span class="keywordflow">if</span> (filter-&gt;filter.formatted.bkt_hash &gt;
<a name="l02497"></a>02497             input-&gt;filter.formatted.bkt_hash)
<a name="l02498"></a>02498             <span class="keywordflow">break</span>;
<a name="l02499"></a>02499 
<a name="l02500"></a>02500         <span class="comment">/* we still haven&#39;t found the hash yet, keep looking */</span>
<a name="l02501"></a>02501         <span class="keywordflow">if</span> (filter-&gt;filter.formatted.bkt_hash !=
<a name="l02502"></a>02502             input-&gt;filter.formatted.bkt_hash)
<a name="l02503"></a>02503             <span class="keywordflow">continue</span>;
<a name="l02504"></a>02504 
<a name="l02505"></a>02505         <span class="comment">/* hash found and matching SW index exists, check next one */</span>
<a name="l02506"></a>02506         <span class="keywordflow">if</span> (sw_idx == filter-&gt;sw_idx)
<a name="l02507"></a>02507             sw_idx++;
<a name="l02508"></a>02508 
<a name="l02509"></a>02509         <span class="comment">/*</span>
<a name="l02510"></a>02510 <span class="comment">         * if matching filter found we remove it from the list and</span>
<a name="l02511"></a>02511 <span class="comment">         * take it&#39;s software index as our own</span>
<a name="l02512"></a>02512 <span class="comment">         */</span>
<a name="l02513"></a>02513         <span class="keywordflow">if</span> (!memcmp(&amp;input-&gt;filter, &amp;filter-&gt;filter,
<a name="l02514"></a>02514                 <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a>))) {
<a name="l02515"></a>02515             sw_idx = filter-&gt;sw_idx;
<a name="l02516"></a>02516             hlist_del(&amp;filter-&gt;fdir_node);
<a name="l02517"></a>02517             kfree(filter);
<a name="l02518"></a>02518             adapter-&gt;fdir_filter_count--;
<a name="l02519"></a>02519             <span class="keywordflow">break</span>;
<a name="l02520"></a>02520         }
<a name="l02521"></a>02521     }
<a name="l02522"></a>02522 
<a name="l02523"></a>02523     input-&gt;sw_idx = sw_idx;
<a name="l02524"></a>02524 }
<a name="l02525"></a>02525 
<a name="l02526"></a>02526 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_fdir_record_filter(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02527"></a>02527                      <span class="keyword">struct</span> <a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *input)
<a name="l02528"></a>02528 {
<a name="l02529"></a>02529     <span class="keyword">struct </span>hlist_node *node, *node2, *parent;
<a name="l02530"></a>02530     <span class="keyword">struct </span><a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *filter;
<a name="l02531"></a>02531     
<a name="l02532"></a>02532     parent = NULL;
<a name="l02533"></a>02533 
<a name="l02534"></a>02534     hlist_for_each_entry_safe(filter, node, node2,
<a name="l02535"></a>02535                   &amp;adapter-&gt;fdir_filter_list, fdir_node) {
<a name="l02536"></a>02536         <span class="comment">/* hash not found, no matching entry */</span>
<a name="l02537"></a>02537         <span class="keywordflow">if</span> (filter-&gt;filter.formatted.bkt_hash &gt;
<a name="l02538"></a>02538             input-&gt;filter.formatted.bkt_hash)
<a name="l02539"></a>02539             <span class="keywordflow">break</span>;
<a name="l02540"></a>02540         <span class="comment">/* sw index greater than location in list */</span>
<a name="l02541"></a>02541         <span class="keywordflow">if</span> ((filter-&gt;filter.formatted.bkt_hash ==
<a name="l02542"></a>02542              input-&gt;filter.formatted.bkt_hash) &amp;&amp;
<a name="l02543"></a>02543             (filter-&gt;sw_idx &gt; input-&gt;sw_idx))
<a name="l02544"></a>02544             <span class="keywordflow">break</span>;
<a name="l02545"></a>02545         parent = node;
<a name="l02546"></a>02546     }
<a name="l02547"></a>02547 
<a name="l02548"></a>02548     INIT_HLIST_NODE(&amp;input-&gt;fdir_node);
<a name="l02549"></a>02549     <span class="keywordflow">if</span> (parent)
<a name="l02550"></a>02550         hlist_add_after(parent, &amp;input-&gt;fdir_node);
<a name="l02551"></a>02551     <span class="keywordflow">else</span>
<a name="l02552"></a>02552         hlist_add_head(&amp;input-&gt;fdir_node, &amp;adapter-&gt;fdir_filter_list);
<a name="l02553"></a>02553     adapter-&gt;fdir_filter_count++;
<a name="l02554"></a>02554 }
<a name="l02555"></a>02555 
<a name="l02556"></a>02556 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_rx_ntuple(<span class="keyword">struct</span> net_device *dev,
<a name="l02557"></a>02557                                <span class="keyword">struct</span> ethtool_rx_ntuple *cmd)
<a name="l02558"></a>02558 {
<a name="l02559"></a>02559     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l02560"></a>02560     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02561"></a>02561     <span class="keyword">struct </span>ethtool_rx_ntuple_flow_spec *fs = &amp;cmd-&gt;fs;
<a name="l02562"></a>02562     <span class="keyword">struct </span><a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *input;
<a name="l02563"></a>02563     <span class="keyword">union </span><a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a> mask;
<a name="l02564"></a>02564     <span class="keywordtype">int</span> err;
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l02567"></a>02567         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l02568"></a>02568 
<a name="l02569"></a>02569     <span class="comment">/*</span>
<a name="l02570"></a>02570 <span class="comment">     * Don&#39;t allow programming if the action is a queue greater than</span>
<a name="l02571"></a>02571 <span class="comment">     * the number of online Rx queues.</span>
<a name="l02572"></a>02572 <span class="comment">     */</span>
<a name="l02573"></a>02573     <span class="keywordflow">if</span> ((fs-&gt;action &gt;= adapter-&gt;num_rx_queues) ||
<a name="l02574"></a>02574         (fs-&gt;action &lt; ETHTOOL_RXNTUPLE_ACTION_CLEAR))
<a name="l02575"></a>02575         <span class="keywordflow">return</span> -EINVAL;
<a name="l02576"></a>02576 
<a name="l02577"></a>02577     input = kzalloc(<span class="keyword">sizeof</span>(*input), GFP_ATOMIC);
<a name="l02578"></a>02578     <span class="keywordflow">if</span> (!input)
<a name="l02579"></a>02579         <span class="keywordflow">return</span> -ENOMEM;
<a name="l02580"></a>02580 
<a name="l02581"></a>02581     memset(&amp;mask, 0, <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a>));
<a name="l02582"></a>02582 
<a name="l02583"></a>02583     <span class="comment">/* record flow type */</span>
<a name="l02584"></a>02584     <span class="keywordflow">switch</span> (fs-&gt;flow_type) {
<a name="l02585"></a>02585     <span class="keywordflow">case</span> TCP_V4_FLOW:
<a name="l02586"></a>02586         input-&gt;filter.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;
<a name="l02587"></a>02587         mask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |
<a name="l02588"></a>02588                        IXGBE_ATR_L4TYPE_MASK;
<a name="l02589"></a>02589         <span class="keywordflow">break</span>;
<a name="l02590"></a>02590     <span class="keywordflow">case</span> UDP_V4_FLOW:
<a name="l02591"></a>02591         input-&gt;filter.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_UDPV4;
<a name="l02592"></a>02592         mask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |
<a name="l02593"></a>02593                        IXGBE_ATR_L4TYPE_MASK;
<a name="l02594"></a>02594         <span class="keywordflow">break</span>;
<a name="l02595"></a>02595     <span class="keywordflow">case</span> SCTP_V4_FLOW:
<a name="l02596"></a>02596         input-&gt;filter.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_SCTPV4;
<a name="l02597"></a>02597         mask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |
<a name="l02598"></a>02598                        IXGBE_ATR_L4TYPE_MASK;
<a name="l02599"></a>02599         <span class="keywordflow">break</span>;
<a name="l02600"></a>02600     <span class="keywordflow">case</span> IP_USER_FLOW:
<a name="l02601"></a>02601         input-&gt;filter.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_IPV4;
<a name="l02602"></a>02602         mask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK;
<a name="l02603"></a>02603         <span class="keywordflow">break</span>;
<a name="l02604"></a>02604     <span class="keywordflow">default</span>:
<a name="l02605"></a>02605         e_err(drv, <span class="stringliteral">&quot;Unrecognized flow type\n&quot;</span>);
<a name="l02606"></a>02606         <span class="keywordflow">goto</span> err_out;
<a name="l02607"></a>02607     }
<a name="l02608"></a>02608 
<a name="l02609"></a>02609     <span class="comment">/* copy vlan tag minus the CFI bit */</span>
<a name="l02610"></a>02610     <span class="keywordflow">if</span> (fs-&gt;vlan_tag || fs-&gt;vlan_tag_mask) {
<a name="l02611"></a>02611         input-&gt;filter.formatted.vlan_id = htons(fs-&gt;vlan_tag &amp; 0xEFFF);
<a name="l02612"></a>02612         mask.formatted.vlan_id = htons(~fs-&gt;vlan_tag_mask &amp; 0xEFFF);
<a name="l02613"></a>02613         <span class="keywordflow">switch</span> (fs-&gt;vlan_tag_mask &amp; 0xEFFF) {
<a name="l02614"></a>02614         <span class="comment">/* all of these are valid vlan-mask values */</span>
<a name="l02615"></a>02615         <span class="keywordflow">case</span> 0xEFFF:
<a name="l02616"></a>02616         <span class="keywordflow">case</span> 0xE000:
<a name="l02617"></a>02617         <span class="keywordflow">case</span> 0x0FFF:
<a name="l02618"></a>02618         <span class="keywordflow">case</span> 0x0000:
<a name="l02619"></a>02619             <span class="keywordflow">break</span>;
<a name="l02620"></a>02620         <span class="comment">/* exit with error if vlan-mask is invalid */</span>
<a name="l02621"></a>02621         <span class="keywordflow">default</span>:
<a name="l02622"></a>02622             e_err(drv, <span class="stringliteral">&quot;Partial VLAN ID or priority mask in &quot;</span>
<a name="l02623"></a>02623                   <span class="stringliteral">&quot;vlan-mask is not supported by hardware\n&quot;</span>);
<a name="l02624"></a>02624             <span class="keywordflow">goto</span> err_out;
<a name="l02625"></a>02625         }
<a name="l02626"></a>02626     }
<a name="l02627"></a>02627 
<a name="l02628"></a>02628     <span class="comment">/* make sure we only use the first 2 bytes of user data */</span>
<a name="l02629"></a>02629     <span class="keywordflow">if</span> (fs-&gt;data || fs-&gt;data_mask) {
<a name="l02630"></a>02630         input-&gt;filter.formatted.flex_bytes = htons(fs-&gt;data &amp; 0xFFFF);
<a name="l02631"></a>02631         mask.formatted.flex_bytes = htons(~fs-&gt;data_mask &amp; 0xFFFF);
<a name="l02632"></a>02632         <span class="keywordflow">switch</span> (fs-&gt;data_mask &amp; 0xFFFF) {
<a name="l02633"></a>02633         <span class="comment">/* all of these are valid flex_byte values */</span>
<a name="l02634"></a>02634         <span class="keywordflow">case</span> 0xFFFF:
<a name="l02635"></a>02635         <span class="keywordflow">case</span> 0x0000:
<a name="l02636"></a>02636             <span class="keywordflow">break</span>;
<a name="l02637"></a>02637         <span class="comment">/* exit with error if flex_mask is invalid */</span>
<a name="l02638"></a>02638         <span class="keywordflow">default</span>:
<a name="l02639"></a>02639             e_err(drv, <span class="stringliteral">&quot;Partial flex_byte mask is not supported &quot;</span>
<a name="l02640"></a>02640                   <span class="stringliteral">&quot;by hardware\n&quot;</span>);
<a name="l02641"></a>02641             <span class="keywordflow">goto</span> err_out;
<a name="l02642"></a>02642         }
<a name="l02643"></a>02643         input-&gt;filter.formatted.vm_pool = fs-&gt;data &gt;&gt; 16;
<a name="l02644"></a>02644         mask.formatted.vm_pool = ~fs-&gt;data_mask &gt;&gt; 16;
<a name="l02645"></a>02645         <span class="keywordflow">switch</span> (fs-&gt;data_mask &amp; 0xFF0000) {
<a name="l02646"></a>02646         <span class="comment">/* all of these are valid vm_pool mask values */</span>
<a name="l02647"></a>02647         <span class="keywordflow">case</span> 0xFF0000:
<a name="l02648"></a>02648         <span class="keywordflow">case</span> 0x000000:
<a name="l02649"></a>02649             <span class="keywordflow">break</span>;
<a name="l02650"></a>02650         <span class="comment">/* exit with error if vm_pool mask is invalid */</span>
<a name="l02651"></a>02651         <span class="keywordflow">default</span>:
<a name="l02652"></a>02652             e_err(drv, <span class="stringliteral">&quot;Partial vm_pool mask is not supported by &quot;</span>
<a name="l02653"></a>02653                   <span class="stringliteral">&quot;hardware\n&quot;</span>);
<a name="l02654"></a>02654             <span class="keywordflow">goto</span> err_out;
<a name="l02655"></a>02655         }
<a name="l02656"></a>02656     } 
<a name="l02657"></a>02657 
<a name="l02658"></a>02658     <span class="comment">/*</span>
<a name="l02659"></a>02659 <span class="comment">     * Copy input into formatted structures</span>
<a name="l02660"></a>02660 <span class="comment">     *</span>
<a name="l02661"></a>02661 <span class="comment">     * These assignments are based on the following logic</span>
<a name="l02662"></a>02662 <span class="comment">     * If neither input or mask are set assume value is masked out.</span>
<a name="l02663"></a>02663 <span class="comment">     * If either are set then assign both.</span>
<a name="l02664"></a>02664 <span class="comment">     */</span>
<a name="l02665"></a>02665     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.ip4src || fs-&gt;m_u.tcp_ip4_spec.ip4src) {
<a name="l02666"></a>02666         input-&gt;filter.formatted.src_ip[0] = fs-&gt;h_u.tcp_ip4_spec.ip4src;
<a name="l02667"></a>02667         mask.formatted.src_ip[0] = ~fs-&gt;m_u.tcp_ip4_spec.ip4src;
<a name="l02668"></a>02668     }
<a name="l02669"></a>02669 
<a name="l02670"></a>02670     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.ip4dst || fs-&gt;m_u.tcp_ip4_spec.ip4dst) {
<a name="l02671"></a>02671         input-&gt;filter.formatted.dst_ip[0] = fs-&gt;h_u.tcp_ip4_spec.ip4dst;
<a name="l02672"></a>02672         mask.formatted.dst_ip[0] = ~fs-&gt;m_u.tcp_ip4_spec.ip4dst;
<a name="l02673"></a>02673     }
<a name="l02674"></a>02674     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.psrc || fs-&gt;m_u.tcp_ip4_spec.psrc) {
<a name="l02675"></a>02675         input-&gt;filter.formatted.src_port = fs-&gt;h_u.tcp_ip4_spec.psrc;
<a name="l02676"></a>02676         mask.formatted.src_port = ~fs-&gt;m_u.tcp_ip4_spec.psrc;
<a name="l02677"></a>02677     }
<a name="l02678"></a>02678     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.pdst || fs-&gt;m_u.tcp_ip4_spec.pdst) {
<a name="l02679"></a>02679         input-&gt;filter.formatted.dst_port = fs-&gt;h_u.tcp_ip4_spec.pdst;
<a name="l02680"></a>02680         mask.formatted.dst_port = ~fs-&gt;m_u.tcp_ip4_spec.pdst;
<a name="l02681"></a>02681     }
<a name="l02682"></a>02682 
<a name="l02683"></a>02683     <span class="comment">/* determine if we need to drop or route the packet */</span>
<a name="l02684"></a>02684     <span class="keywordflow">if</span> (fs-&gt;action &lt; 0)
<a name="l02685"></a>02685         input-&gt;action = IXGBE_FDIR_DROP_QUEUE;
<a name="l02686"></a>02686     <span class="keywordflow">else</span>
<a name="l02687"></a>02687         input-&gt;action = adapter-&gt;rx_ring[fs-&gt;action]-&gt;reg_idx;
<a name="l02688"></a>02688 
<a name="l02689"></a>02689     spin_lock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l02690"></a>02690 
<a name="l02691"></a>02691     <span class="keywordflow">if</span> (hlist_empty(&amp;adapter-&gt;fdir_filter_list)) {
<a name="l02692"></a>02692         <span class="comment">/* save mask and program input mask into HW */</span>
<a name="l02693"></a>02693         memcpy(&amp;adapter-&gt;fdir_mask, &amp;mask, <span class="keyword">sizeof</span>(mask));
<a name="l02694"></a>02694         err = ixgbe_fdir_set_input_mask_82599(hw, &amp;mask);
<a name="l02695"></a>02695         <span class="keywordflow">if</span> (err) {
<a name="l02696"></a>02696             e_err(drv, <span class="stringliteral">&quot;Error writing mask\n&quot;</span>);
<a name="l02697"></a>02697             <span class="keywordflow">goto</span> err_out_w_lock;
<a name="l02698"></a>02698         }
<a name="l02699"></a>02699     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (memcmp(&amp;adapter-&gt;fdir_mask, &amp;mask, <span class="keyword">sizeof</span>(mask))) {
<a name="l02700"></a>02700         e_err(drv, <span class="stringliteral">&quot;Only one mask supported per port\n&quot;</span>);
<a name="l02701"></a>02701         <span class="keywordflow">goto</span> err_out_w_lock;
<a name="l02702"></a>02702     }
<a name="l02703"></a>02703 
<a name="l02704"></a>02704     <span class="comment">/* apply mask and compute/store hash */</span>
<a name="l02705"></a>02705     ixgbe_atr_compute_perfect_hash_82599(&amp;input-&gt;filter, &amp;mask);
<a name="l02706"></a>02706 
<a name="l02707"></a>02707     ixgbe_fdir_set_sw_index(adapter, input);
<a name="l02708"></a>02708 
<a name="l02709"></a>02709     <span class="keywordflow">if</span> (fs-&gt;action == ETHTOOL_RXNTUPLE_ACTION_CLEAR) {
<a name="l02710"></a>02710         <span class="comment">/* erase filter from memory */</span>
<a name="l02711"></a>02711         err = ixgbe_fdir_erase_perfect_filter_82599(hw,
<a name="l02712"></a>02712                                 &amp;input-&gt;filter,
<a name="l02713"></a>02713                                 input-&gt;sw_idx);
<a name="l02714"></a>02714         <span class="keywordflow">if</span> (err)
<a name="l02715"></a>02715             <span class="keywordflow">goto</span> err_out_w_lock;
<a name="l02716"></a>02716 
<a name="l02717"></a>02717         kfree(input);
<a name="l02718"></a>02718     } <span class="keywordflow">else</span> {
<a name="l02719"></a>02719         <span class="comment">/* Don&#39;t exceed the available space for filters in the HW */</span>
<a name="l02720"></a>02720         <span class="keywordflow">if</span> (adapter-&gt;fdir_filter_count &gt;=
<a name="l02721"></a>02721             ((1024 &lt;&lt; adapter-&gt;fdir_pballoc) - 2))
<a name="l02722"></a>02722             <span class="keywordflow">goto</span> err_out_w_lock;
<a name="l02723"></a>02723 
<a name="l02724"></a>02724         <span class="comment">/* program filters to filter memory */</span>
<a name="l02725"></a>02725         err = ixgbe_fdir_write_perfect_filter_82599(hw,
<a name="l02726"></a>02726                                 &amp;input-&gt;filter,
<a name="l02727"></a>02727                                 input-&gt;sw_idx,
<a name="l02728"></a>02728                                 input-&gt;action);
<a name="l02729"></a>02729         <span class="keywordflow">if</span> (err)
<a name="l02730"></a>02730             <span class="keywordflow">goto</span> err_out_w_lock;
<a name="l02731"></a>02731 
<a name="l02732"></a>02732         ixgbe_fdir_record_filter(adapter, input);
<a name="l02733"></a>02733     }
<a name="l02734"></a>02734 
<a name="l02735"></a>02735     spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l02736"></a>02736 
<a name="l02737"></a>02737     <span class="keywordflow">return</span> 0;
<a name="l02738"></a>02738 err_out_w_lock:
<a name="l02739"></a>02739     spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l02740"></a>02740 err_out:
<a name="l02741"></a>02741     kfree(input);
<a name="l02742"></a>02742     <span class="keywordflow">return</span> -1;
<a name="l02743"></a>02743 }
<a name="l02744"></a>02744 
<a name="l02745"></a>02745 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_rx_ntuple(<span class="keyword">struct</span> net_device *netdev, u32 stringset,
<a name="l02746"></a>02746                    <span class="keywordtype">void</span> *data)
<a name="l02747"></a>02747 {
<a name="l02748"></a>02748     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02749"></a>02749     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l02750"></a>02750     <span class="keyword">struct </span><a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *filter;
<a name="l02751"></a>02751     <span class="keywordtype">char</span> *p = (<span class="keywordtype">char</span> *)data;
<a name="l02752"></a>02752     <span class="keywordtype">int</span> num_strings = 0;
<a name="l02753"></a>02753     <span class="keywordtype">int</span> i = 0;
<a name="l02754"></a>02754 
<a name="l02755"></a>02755     <span class="keywordflow">if</span> (!hlist_empty(&amp;adapter-&gt;fdir_filter_list)) {
<a name="l02756"></a>02756         <span class="keyword">union </span><a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a> *mask = &amp;adapter-&gt;fdir_mask;
<a name="l02757"></a>02757 
<a name="l02758"></a>02758         sprintf(p, <span class="stringliteral">&quot;Input Mask:\n&quot;</span>);
<a name="l02759"></a>02759         p += ETH_GSTRING_LEN;
<a name="l02760"></a>02760         num_strings++;
<a name="l02761"></a>02761 
<a name="l02762"></a>02762         sprintf(p, <span class="stringliteral">&quot;\tVT Mask: 0x%02x\n&quot;</span>, mask-&gt;formatted.vm_pool);
<a name="l02763"></a>02763         p += ETH_GSTRING_LEN;
<a name="l02764"></a>02764         num_strings++;
<a name="l02765"></a>02765         <span class="keywordflow">switch</span> (mask-&gt;formatted.flow_type &amp; IXGBE_ATR_L4TYPE_MASK) {
<a name="l02766"></a>02766         <span class="keywordflow">case</span> 0x0:
<a name="l02767"></a>02767             sprintf(p, <span class="stringliteral">&quot;\tFlow Mask: L4 header ignored\n&quot;</span>); 
<a name="l02768"></a>02768             p += ETH_GSTRING_LEN;
<a name="l02769"></a>02769             num_strings++;
<a name="l02770"></a>02770             <span class="keywordflow">break</span>;
<a name="l02771"></a>02771         <span class="keywordflow">case</span> IXGBE_ATR_L4TYPE_MASK:
<a name="l02772"></a>02772             sprintf(p, <span class="stringliteral">&quot;\tFlow Mask: L4 header checked\n&quot;</span>); 
<a name="l02773"></a>02773             p += ETH_GSTRING_LEN;
<a name="l02774"></a>02774             num_strings++;
<a name="l02775"></a>02775             <span class="keywordflow">break</span>;
<a name="l02776"></a>02776         <span class="keywordflow">default</span>:
<a name="l02777"></a>02777             sprintf(p, <span class="stringliteral">&quot;\tFlow Type Mask: Unknown\n&quot;</span>);  
<a name="l02778"></a>02778             p += ETH_GSTRING_LEN;
<a name="l02779"></a>02779             num_strings++;
<a name="l02780"></a>02780             <span class="keywordflow">break</span>;
<a name="l02781"></a>02781         }
<a name="l02782"></a>02782         sprintf(p, <span class="stringliteral">&quot;\tVLAN mask: 0x%04x\n&quot;</span>,
<a name="l02783"></a>02783             ntohs(~mask-&gt;formatted.vlan_id));
<a name="l02784"></a>02784         p += ETH_GSTRING_LEN;
<a name="l02785"></a>02785         num_strings++;
<a name="l02786"></a>02786         sprintf(p, <span class="stringliteral">&quot;\tSrc IP mask: 0x%08x\n&quot;</span>,
<a name="l02787"></a>02787             ntohl(~mask-&gt;formatted.src_ip[0]));
<a name="l02788"></a>02788         p += ETH_GSTRING_LEN;
<a name="l02789"></a>02789         num_strings++;
<a name="l02790"></a>02790         sprintf(p, <span class="stringliteral">&quot;\tDest IP mask: 0x%08x\n&quot;</span>,
<a name="l02791"></a>02791             ntohl(~mask-&gt;formatted.dst_ip[0]));
<a name="l02792"></a>02792         p += ETH_GSTRING_LEN;
<a name="l02793"></a>02793         num_strings++;
<a name="l02794"></a>02794         sprintf(p, <span class="stringliteral">&quot;\tSrc Port mask: 0x%04x\n&quot;</span>,
<a name="l02795"></a>02795             ntohs(~mask-&gt;formatted.src_port));
<a name="l02796"></a>02796         p += ETH_GSTRING_LEN;
<a name="l02797"></a>02797         num_strings++;
<a name="l02798"></a>02798         sprintf(p, <span class="stringliteral">&quot;\tDest Port mask: 0x%04x\n&quot;</span>,
<a name="l02799"></a>02799             ntohs(~mask-&gt;formatted.dst_port));
<a name="l02800"></a>02800         p += ETH_GSTRING_LEN;
<a name="l02801"></a>02801         num_strings++;
<a name="l02802"></a>02802         sprintf(p, <span class="stringliteral">&quot;\tEtherType mask: 0x%04x\n&quot;</span>,
<a name="l02803"></a>02803             ntohs(~mask-&gt;formatted.flex_bytes));
<a name="l02804"></a>02804         p += ETH_GSTRING_LEN;
<a name="l02805"></a>02805         num_strings++;
<a name="l02806"></a>02806     }
<a name="l02807"></a>02807 
<a name="l02808"></a>02808     hlist_for_each_entry_safe(filter, node, node2,
<a name="l02809"></a>02809                   &amp;adapter-&gt;fdir_filter_list, fdir_node) {
<a name="l02810"></a>02810         sprintf(p, <span class="stringliteral">&quot;Filter %d:\n&quot;</span>, i);
<a name="l02811"></a>02811         p += ETH_GSTRING_LEN;
<a name="l02812"></a>02812         num_strings++;
<a name="l02813"></a>02813         sprintf(p, <span class="stringliteral">&quot;\tBucket Hash: 0x%04x\n&quot;</span>,
<a name="l02814"></a>02814             filter-&gt;filter.formatted.bkt_hash);
<a name="l02815"></a>02815         p += ETH_GSTRING_LEN;
<a name="l02816"></a>02816         num_strings++;
<a name="l02817"></a>02817         sprintf(p, <span class="stringliteral">&quot;\tSoftware Index: 0x%04x\n&quot;</span>,
<a name="l02818"></a>02818             filter-&gt;sw_idx);
<a name="l02819"></a>02819         p += ETH_GSTRING_LEN;
<a name="l02820"></a>02820         num_strings++;
<a name="l02821"></a>02821         <span class="keywordflow">if</span> (filter-&gt;action == (MAX_RX_QUEUES - 1))
<a name="l02822"></a>02822             sprintf(p, <span class="stringliteral">&quot;\tAction: Drop\n&quot;</span>);
<a name="l02823"></a>02823         <span class="keywordflow">else</span>
<a name="l02824"></a>02824             sprintf(p, <span class="stringliteral">&quot;\tAction: Directed to queue %d\n&quot;</span>,
<a name="l02825"></a>02825                 filter-&gt;action);
<a name="l02826"></a>02826         p += ETH_GSTRING_LEN;
<a name="l02827"></a>02827         num_strings++;
<a name="l02828"></a>02828 
<a name="l02829"></a>02829         sprintf(p, <span class="stringliteral">&quot;\tVT Pool: 0x%02x\n&quot;</span>,
<a name="l02830"></a>02830             filter-&gt;filter.formatted.vm_pool);
<a name="l02831"></a>02831         p += ETH_GSTRING_LEN;
<a name="l02832"></a>02832         num_strings++;
<a name="l02833"></a>02833         <span class="keywordflow">switch</span> (filter-&gt;filter.formatted.flow_type) {
<a name="l02834"></a>02834         <span class="keywordflow">case</span> IXGBE_ATR_FLOW_TYPE_IPV4:
<a name="l02835"></a>02835             sprintf(p, <span class="stringliteral">&quot;\tFlow Type: Raw IP\n&quot;</span>);    
<a name="l02836"></a>02836             p += ETH_GSTRING_LEN;
<a name="l02837"></a>02837             num_strings++;
<a name="l02838"></a>02838             <span class="keywordflow">break</span>;
<a name="l02839"></a>02839         <span class="keywordflow">case</span> IXGBE_ATR_FLOW_TYPE_TCPV4:
<a name="l02840"></a>02840             sprintf(p, <span class="stringliteral">&quot;\tFlow Type: TCP\n&quot;</span>);   
<a name="l02841"></a>02841             p += ETH_GSTRING_LEN;
<a name="l02842"></a>02842             num_strings++;
<a name="l02843"></a>02843             <span class="keywordflow">break</span>;
<a name="l02844"></a>02844         <span class="keywordflow">case</span> IXGBE_ATR_FLOW_TYPE_UDPV4:
<a name="l02845"></a>02845             sprintf(p, <span class="stringliteral">&quot;\tFlow Type: UDP\n&quot;</span>);   
<a name="l02846"></a>02846             p += ETH_GSTRING_LEN;
<a name="l02847"></a>02847             num_strings++;
<a name="l02848"></a>02848             <span class="keywordflow">break</span>;
<a name="l02849"></a>02849         <span class="keywordflow">case</span> IXGBE_ATR_FLOW_TYPE_SCTPV4:
<a name="l02850"></a>02850             sprintf(p, <span class="stringliteral">&quot;\tFlow Type: STCP\n&quot;</span>);  
<a name="l02851"></a>02851             p += ETH_GSTRING_LEN;
<a name="l02852"></a>02852             num_strings++;
<a name="l02853"></a>02853             <span class="keywordflow">break</span>;
<a name="l02854"></a>02854         <span class="keywordflow">default</span>:
<a name="l02855"></a>02855             sprintf(p, <span class="stringliteral">&quot;\tFlow Type: Unknown\n&quot;</span>);   
<a name="l02856"></a>02856             p += ETH_GSTRING_LEN;
<a name="l02857"></a>02857             num_strings++;
<a name="l02858"></a>02858             <span class="keywordflow">break</span>;
<a name="l02859"></a>02859         }
<a name="l02860"></a>02860         sprintf(p, <span class="stringliteral">&quot;\tVLAN: 0x%04x\n&quot;</span>,
<a name="l02861"></a>02861             ntohs(filter-&gt;filter.formatted.vlan_id));
<a name="l02862"></a>02862         p += ETH_GSTRING_LEN;
<a name="l02863"></a>02863         num_strings++;
<a name="l02864"></a>02864         sprintf(p, <span class="stringliteral">&quot;\tSrc IP addr: 0x%08x\n&quot;</span>,
<a name="l02865"></a>02865             ntohl(filter-&gt;filter.formatted.src_ip[0]));
<a name="l02866"></a>02866         p += ETH_GSTRING_LEN;
<a name="l02867"></a>02867         num_strings++;
<a name="l02868"></a>02868         sprintf(p, <span class="stringliteral">&quot;\tDest IP addr: 0x%08x\n&quot;</span>,
<a name="l02869"></a>02869             ntohl(filter-&gt;filter.formatted.dst_ip[0]));
<a name="l02870"></a>02870         p += ETH_GSTRING_LEN;
<a name="l02871"></a>02871         num_strings++;
<a name="l02872"></a>02872         sprintf(p, <span class="stringliteral">&quot;\tSrc Port: 0x%04x\n&quot;</span>,
<a name="l02873"></a>02873             ntohs(filter-&gt;filter.formatted.src_port));
<a name="l02874"></a>02874         p += ETH_GSTRING_LEN;
<a name="l02875"></a>02875         num_strings++;
<a name="l02876"></a>02876         sprintf(p, <span class="stringliteral">&quot;\tDest Port: 0x%04x\n&quot;</span>,
<a name="l02877"></a>02877             ntohs(filter-&gt;filter.formatted.dst_port));
<a name="l02878"></a>02878         p += ETH_GSTRING_LEN;
<a name="l02879"></a>02879         num_strings++;
<a name="l02880"></a>02880         sprintf(p, <span class="stringliteral">&quot;\tEtherType: 0x%04x\n&quot;</span>,
<a name="l02881"></a>02881             ntohs(filter-&gt;filter.formatted.flex_bytes));
<a name="l02882"></a>02882         p += ETH_GSTRING_LEN;
<a name="l02883"></a>02883         num_strings++;
<a name="l02884"></a>02884         i++;
<a name="l02885"></a>02885     }
<a name="l02886"></a>02886     <span class="keywordflow">return</span> num_strings;
<a name="l02887"></a>02887 }
<a name="l02888"></a>02888 
<a name="l02889"></a>02889 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l02890"></a>02890 <span class="keyword">static</span> <span class="keyword">struct </span>ethtool_ops ixgbe_ethtool_ops = {
<a name="l02891"></a>02891     .get_settings           = ixgbe_get_settings,
<a name="l02892"></a>02892     .set_settings           = ixgbe_set_settings,
<a name="l02893"></a>02893     .get_drvinfo            = ixgbe_get_drvinfo,
<a name="l02894"></a>02894     .get_regs_len           = ixgbe_get_regs_len,
<a name="l02895"></a>02895     .get_regs               = ixgbe_get_regs,
<a name="l02896"></a>02896     .get_wol                = ixgbe_get_wol,
<a name="l02897"></a>02897     .set_wol                = ixgbe_set_wol,
<a name="l02898"></a>02898     .nway_reset             = ixgbe_nway_reset,
<a name="l02899"></a>02899     .get_link               = ethtool_op_get_link,
<a name="l02900"></a>02900     .get_eeprom_len         = ixgbe_get_eeprom_len,
<a name="l02901"></a>02901     .get_eeprom             = ixgbe_get_eeprom,
<a name="l02902"></a>02902     .set_eeprom             = ixgbe_set_eeprom,
<a name="l02903"></a>02903     .get_ringparam          = ixgbe_get_ringparam,
<a name="l02904"></a>02904     .set_ringparam          = ixgbe_set_ringparam,
<a name="l02905"></a>02905     .get_pauseparam         = ixgbe_get_pauseparam,
<a name="l02906"></a>02906     .set_pauseparam         = ixgbe_set_pauseparam,
<a name="l02907"></a>02907     .get_rx_csum            = ixgbe_get_rx_csum,
<a name="l02908"></a>02908     .set_rx_csum            = ixgbe_set_rx_csum,
<a name="l02909"></a>02909     .get_tx_csum            = ixgbe_get_tx_csum,
<a name="l02910"></a>02910     .set_tx_csum            = ixgbe_set_tx_csum,
<a name="l02911"></a>02911     .get_sg                 = ethtool_op_get_sg,
<a name="l02912"></a>02912     .set_sg                 = ethtool_op_set_sg,
<a name="l02913"></a>02913     .get_msglevel           = ixgbe_get_msglevel,
<a name="l02914"></a>02914     .set_msglevel           = ixgbe_set_msglevel,
<a name="l02915"></a>02915 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l02916"></a>02916 <span class="preprocessor"></span>    .get_tso                = ethtool_op_get_tso,
<a name="l02917"></a>02917     .set_tso                = ixgbe_set_tso,
<a name="l02918"></a>02918 <span class="preprocessor">#endif</span>
<a name="l02919"></a>02919 <span class="preprocessor"></span><span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l02920"></a>02920 <span class="preprocessor"></span>    .self_test_count    = ixgbe_diag_test_count,
<a name="l02921"></a>02921 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l02922"></a>02922     .self_test              = ixgbe_diag_test,
<a name="l02923"></a>02923     .get_strings            = ixgbe_get_strings,
<a name="l02924"></a>02924     .phys_id                = ixgbe_phys_id,
<a name="l02925"></a>02925 <span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l02926"></a>02926 <span class="preprocessor"></span>    .get_stats_count    = ixgbe_get_stats_count,
<a name="l02927"></a>02927 <span class="preprocessor">#else </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l02928"></a>02928     .get_sset_count         = ixgbe_get_sset_count,
<a name="l02929"></a>02929 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l02930"></a>02930     .get_ethtool_stats      = ixgbe_get_ethtool_stats,
<a name="l02931"></a>02931 <span class="preprocessor">#ifdef HAVE_ETHTOOL_GET_PERM_ADDR</span>
<a name="l02932"></a>02932 <span class="preprocessor"></span>    .get_perm_addr          = ethtool_op_get_perm_addr,
<a name="l02933"></a>02933 <span class="preprocessor">#endif</span>
<a name="l02934"></a>02934 <span class="preprocessor"></span>    .get_coalesce           = ixgbe_get_coalesce,
<a name="l02935"></a>02935     .set_coalesce           = ixgbe_set_coalesce,
<a name="l02936"></a>02936 <span class="preprocessor">#ifdef ETHTOOL_GFLAGS</span>
<a name="l02937"></a>02937 <span class="preprocessor"></span>    .get_flags              = ethtool_op_get_flags,
<a name="l02938"></a>02938     .set_flags              = ixgbe_set_flags,
<a name="l02939"></a>02939 <span class="preprocessor">#endif</span>
<a name="l02940"></a>02940 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l02941"></a>02941 <span class="preprocessor"></span>    .set_rx_ntuple          = ixgbe_set_rx_ntuple,
<a name="l02942"></a>02942     .get_rx_ntuple          = ixgbe_get_rx_ntuple,
<a name="l02943"></a>02943 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l02944"></a>02944 };
<a name="l02945"></a>02945 
<a name="l02946"></a>02946 <span class="keywordtype">void</span> ixgbe_set_ethtool_ops(<span class="keyword">struct</span> net_device *netdev)
<a name="l02947"></a>02947 {
<a name="l02948"></a>02948     SET_ETHTOOL_OPS(netdev, &amp;ixgbe_ethtool_ops);
<a name="l02949"></a>02949 }
<a name="l02950"></a>02950 <span class="preprocessor">#endif </span><span class="comment">/* SIOCETHTOOL */</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:27 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
