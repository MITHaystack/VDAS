<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/broadcom/netxtreme2-5.2.50/bnx2i_sles11-2.0.1e-05/driver/bnx2i_hwi.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_2eb02fd92a965ecd821875a0a052753b.html">broadcom</a>      </li>
      <li class="navelem"><a class="el" href="dir_0a4992c25a025ec51f35cbf57fa02bf7.html">netxtreme2-5.2.50</a>      </li>
      <li class="navelem"><a class="el" href="dir_9068ea9a8110d47a584a325eea2f8003.html">bnx2i_sles11-2.0.1e-05</a>      </li>
      <li class="navelem"><a class="el" href="dir_053aa95974aa42da3692c44002ab0932.html">driver</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">bnx2i_hwi.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* bnx2i_hwi.c: Broadcom NetXtreme II iSCSI driver.</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (c) 2006 - 2008 Broadcom Corporation</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (c) 2007, 2008 Mike Christie</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment"> * the Free Software Foundation.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * Written by: Anil Veerabhadrappa (anilgv@broadcom.com)</span>
<a name="l00012"></a>00012 <span class="comment"> * Maintain by: Eddie Wai (eddie.wai@broadcom.com)</span>
<a name="l00013"></a>00013 <span class="comment"> */</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;scsi/scsi_tcq.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;scsi/libiscsi.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;bnx2i.h&quot;</span>
<a name="l00018"></a>00018 
<a name="l00025"></a>00025 <span class="keyword">static</span> u32 bnx2i_get_cid_num(<span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00026"></a>00026 {
<a name="l00027"></a>00027     u32 cid;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type))
<a name="l00030"></a>00030         cid = ep-&gt;ep_cid;
<a name="l00031"></a>00031     <span class="keywordflow">else</span>
<a name="l00032"></a>00032         cid = GET_CID_NUM(ep-&gt;ep_cid);
<a name="l00033"></a>00033     <span class="keywordflow">return</span> cid;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00043"></a>00043 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_adjust_qp_size(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045     u32 num_elements_per_pg;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_5706, &amp;hba-&gt;cnic_dev_type) ||
<a name="l00048"></a>00048         test_bit(BNX2I_NX2_DEV_5708, &amp;hba-&gt;cnic_dev_type) ||
<a name="l00049"></a>00049         test_bit(BNX2I_NX2_DEV_5709, &amp;hba-&gt;cnic_dev_type)) {
<a name="l00050"></a>00050         <span class="keywordflow">if</span> (!is_power_of_2(hba-&gt;max_sqes))
<a name="l00051"></a>00051             hba-&gt;max_sqes = __rounddown_pow_of_two(hba-&gt;max_sqes);
<a name="l00052"></a>00052 
<a name="l00053"></a>00053         <span class="keywordflow">if</span> (!is_power_of_2(hba-&gt;max_rqes))
<a name="l00054"></a>00054             hba-&gt;max_rqes = __rounddown_pow_of_two(hba-&gt;max_rqes);
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057     <span class="comment">/* Adjust each queue size if the user selection does not</span>
<a name="l00058"></a>00058 <span class="comment">     * yield integral num of page buffers</span>
<a name="l00059"></a>00059 <span class="comment">     */</span>
<a name="l00060"></a>00060     <span class="comment">/* adjust SQ */</span>
<a name="l00061"></a>00061     num_elements_per_pg = PAGE_SIZE / BNX2I_SQ_WQE_SIZE;
<a name="l00062"></a>00062     <span class="keywordflow">if</span> (hba-&gt;max_sqes &lt; num_elements_per_pg)
<a name="l00063"></a>00063         hba-&gt;max_sqes = num_elements_per_pg;
<a name="l00064"></a>00064     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hba-&gt;max_sqes % num_elements_per_pg)
<a name="l00065"></a>00065         hba-&gt;max_sqes = (hba-&gt;max_sqes + num_elements_per_pg - 1) &amp;
<a name="l00066"></a>00066                  ~(num_elements_per_pg - 1);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068     <span class="comment">/* adjust CQ */</span>
<a name="l00069"></a>00069     num_elements_per_pg = PAGE_SIZE / BNX2I_CQE_SIZE;
<a name="l00070"></a>00070     <span class="keywordflow">if</span> (hba-&gt;max_cqes &lt; num_elements_per_pg)
<a name="l00071"></a>00071         hba-&gt;max_cqes = num_elements_per_pg;
<a name="l00072"></a>00072     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hba-&gt;max_cqes % num_elements_per_pg)
<a name="l00073"></a>00073         hba-&gt;max_cqes = (hba-&gt;max_cqes + num_elements_per_pg - 1) &amp;
<a name="l00074"></a>00074                  ~(num_elements_per_pg - 1);
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <span class="comment">/* adjust RQ */</span>
<a name="l00077"></a>00077     num_elements_per_pg = PAGE_SIZE / BNX2I_RQ_WQE_SIZE;
<a name="l00078"></a>00078     <span class="keywordflow">if</span> (hba-&gt;max_rqes &lt; num_elements_per_pg)
<a name="l00079"></a>00079         hba-&gt;max_rqes = num_elements_per_pg;
<a name="l00080"></a>00080     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hba-&gt;max_rqes % num_elements_per_pg)
<a name="l00081"></a>00081         hba-&gt;max_rqes = (hba-&gt;max_rqes + num_elements_per_pg - 1) &amp;
<a name="l00082"></a>00082                  ~(num_elements_per_pg - 1);
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 
<a name="l00092"></a>00092 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_get_link_state(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094     <span class="keywordflow">if</span> (test_bit(__LINK_STATE_NOCARRIER, &amp;hba-&gt;netdev-&gt;state))
<a name="l00095"></a>00095         set_bit(ADAPTER_STATE_LINK_DOWN, &amp;hba-&gt;adapter_state);
<a name="l00096"></a>00096     <span class="keywordflow">else</span>
<a name="l00097"></a>00097         clear_bit(ADAPTER_STATE_LINK_DOWN, &amp;hba-&gt;adapter_state);
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 
<a name="l00109"></a>00109 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_iscsi_license_error(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, u32 error_code)
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111     <span class="keywordflow">if</span> (error_code == ISCSI_KCQE_COMPLETION_STATUS_ISCSI_NOT_SUPPORTED)
<a name="l00112"></a>00112         <span class="comment">/* iSCSI offload not supported on this device */</span>
<a name="l00113"></a>00113         printk(KERN_ERR <span class="stringliteral">&quot;bnx2i: iSCSI not supported, dev=%s\n&quot;</span>,
<a name="l00114"></a>00114                 hba-&gt;netdev-&gt;name);
<a name="l00115"></a>00115     <span class="keywordflow">if</span> (error_code == ISCSI_KCQE_COMPLETION_STATUS_LOM_ISCSI_NOT_ENABLED)
<a name="l00116"></a>00116         <span class="comment">/* iSCSI offload not supported on this LOM device */</span>
<a name="l00117"></a>00117         printk(KERN_ERR <span class="stringliteral">&quot;bnx2i: LOM is not enable to &quot;</span>
<a name="l00118"></a>00118                 <span class="stringliteral">&quot;offload iSCSI connections, dev=%s\n&quot;</span>,
<a name="l00119"></a>00119                 hba-&gt;netdev-&gt;name);
<a name="l00120"></a>00120     set_bit(ADAPTER_STATE_INIT_FAILED, &amp;hba-&gt;adapter_state);
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00133"></a>00133 <span class="keywordtype">void</span> bnx2i_arm_cq_event_coalescing(<span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep, u8 action)
<a name="l00134"></a>00134 {
<a name="l00135"></a>00135     <span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__cq__db.html">bnx2i_5771x_cq_db</a> *cq_db;
<a name="l00136"></a>00136     u16 cq_index;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="keywordflow">if</span> (!test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type))
<a name="l00139"></a>00139         <span class="keywordflow">return</span>;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     <span class="keywordflow">if</span> (action == CNIC_ARM_CQE) {
<a name="l00142"></a>00142         cq_index = ep-&gt;qp.cqe_exp_seq_sn +
<a name="l00143"></a>00143                ep-&gt;num_active_cmds / event_coal_div;
<a name="l00144"></a>00144         cq_index %= (ep-&gt;qp.cqe_size * 2 + 1);
<a name="l00145"></a>00145         <span class="keywordflow">if</span> (!cq_index)
<a name="l00146"></a>00146             cq_index = 1;
<a name="l00147"></a>00147         cq_db = (<span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__cq__db.html">bnx2i_5771x_cq_db</a> *) ep-&gt;qp.cq_pgtbl_virt;
<a name="l00148"></a>00148         cq_db-&gt;sqn[0] = cq_index;
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00164"></a>00164 <span class="keywordtype">void</span> bnx2i_get_rq_buf(<span class="keyword">struct</span> <a class="code" href="structbnx2i__conn.html">bnx2i_conn</a> *<a class="code" href="structbnx2i__conn.html">bnx2i_conn</a>, <span class="keywordtype">char</span> *ptr, <span class="keywordtype">int</span> len)
<a name="l00165"></a>00165 {
<a name="l00166"></a>00166     <span class="keywordflow">if</span> (!bnx2i_conn-&gt;ep-&gt;qp.rqe_left)
<a name="l00167"></a>00167         <span class="keywordflow">return</span>;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     bnx2i_conn-&gt;ep-&gt;qp.rqe_left--;
<a name="l00170"></a>00170     memcpy(ptr, (u8 *) bnx2i_conn-&gt;ep-&gt;qp.rq_cons_qe, len);
<a name="l00171"></a>00171     <span class="keywordflow">if</span> (bnx2i_conn-&gt;ep-&gt;qp.rq_cons_qe == bnx2i_conn-&gt;ep-&gt;qp.rq_last_qe) {
<a name="l00172"></a>00172         bnx2i_conn-&gt;ep-&gt;qp.rq_cons_qe = bnx2i_conn-&gt;ep-&gt;qp.rq_first_qe;
<a name="l00173"></a>00173         bnx2i_conn-&gt;ep-&gt;qp.rq_cons_idx = 0;
<a name="l00174"></a>00174     } <span class="keywordflow">else</span> {
<a name="l00175"></a>00175         bnx2i_conn-&gt;ep-&gt;qp.rq_cons_qe++;
<a name="l00176"></a>00176         bnx2i_conn-&gt;ep-&gt;qp.rq_cons_idx++;
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_ring_577xx_doorbell(<span class="keyword">struct</span> bnx2i_conn *conn)
<a name="l00182"></a>00182 {
<a name="l00183"></a>00183     <span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__dbell.html">bnx2i_5771x_dbell</a> dbell;
<a name="l00184"></a>00184     u32 msg;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     memset(&amp;dbell, 0, <span class="keyword">sizeof</span>(dbell));
<a name="l00187"></a>00187     dbell.dbell.header = (B577XX_ISCSI_CONNECTION_TYPE &lt;&lt;
<a name="l00188"></a>00188                   B577XX_DOORBELL_HDR_CONN_TYPE_SHIFT);
<a name="l00189"></a>00189     msg = *((u32 *)&amp;dbell);
<a name="l00190"></a>00190     <span class="comment">/* TODO : get doorbell register mapping */</span>
<a name="l00191"></a>00191     writel(cpu_to_le32(msg), conn-&gt;ep-&gt;qp.ctx_base);
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00202"></a>00202 <span class="keywordtype">void</span> bnx2i_put_rq_buf(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn, <span class="keywordtype">int</span> count)
<a name="l00203"></a>00203 {
<a name="l00204"></a>00204     <span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__sq__rq__db.html">bnx2i_5771x_sq_rq_db</a> *rq_db;
<a name="l00205"></a>00205     u16 hi_bit = (bnx2i_conn-&gt;ep-&gt;qp.rq_prod_idx &amp; 0x8000);
<a name="l00206"></a>00206     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = bnx2i_conn-&gt;ep;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     ep-&gt;qp.rqe_left += count;
<a name="l00209"></a>00209     ep-&gt;qp.rq_prod_idx &amp;= 0x7FFF;
<a name="l00210"></a>00210     ep-&gt;qp.rq_prod_idx += count;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (ep-&gt;qp.rq_prod_idx &gt; bnx2i_conn-&gt;hba-&gt;max_rqes) {
<a name="l00213"></a>00213         ep-&gt;qp.rq_prod_idx %= bnx2i_conn-&gt;hba-&gt;max_rqes;
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (!hi_bit)
<a name="l00215"></a>00215             ep-&gt;qp.rq_prod_idx |= 0x8000;
<a name="l00216"></a>00216     } <span class="keywordflow">else</span>
<a name="l00217"></a>00217         ep-&gt;qp.rq_prod_idx |= hi_bit;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type)) {
<a name="l00220"></a>00220         rq_db = (<span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__sq__rq__db.html">bnx2i_5771x_sq_rq_db</a> *) ep-&gt;qp.rq_pgtbl_virt;
<a name="l00221"></a>00221         rq_db-&gt;prod_idx = ep-&gt;qp.rq_prod_idx;
<a name="l00222"></a>00222         <span class="comment">/* no need to ring hardware doorbell for 57710 */</span>
<a name="l00223"></a>00223     } <span class="keywordflow">else</span> {
<a name="l00224"></a>00224         writew(ep-&gt;qp.rq_prod_idx,
<a name="l00225"></a>00225                ep-&gt;qp.ctx_base + CNIC_RECV_DOORBELL);
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227     mmiowb();
<a name="l00228"></a>00228 }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 
<a name="l00240"></a>00240 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_ring_sq_dbell(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn, u16 count)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242     <span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__sq__rq__db.html">bnx2i_5771x_sq_rq_db</a> *sq_db;
<a name="l00243"></a>00243     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = bnx2i_conn-&gt;ep;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     ep-&gt;num_active_cmds++;
<a name="l00246"></a>00246     wmb();  <span class="comment">/* flush SQ WQE memory before the doorbell is rung */</span>
<a name="l00247"></a>00247     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type)) {
<a name="l00248"></a>00248         sq_db = (<span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__sq__rq__db.html">bnx2i_5771x_sq_rq_db</a> *) ep-&gt;qp.sq_pgtbl_virt;
<a name="l00249"></a>00249         sq_db-&gt;prod_idx = ep-&gt;qp.sq_prod_idx;
<a name="l00250"></a>00250         bnx2i_ring_577xx_doorbell(bnx2i_conn);
<a name="l00251"></a>00251     } <span class="keywordflow">else</span> {
<a name="l00252"></a>00252         writew(count, ep-&gt;qp.ctx_base + CNIC_SEND_DOORBELL);
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     mmiowb(); <span class="comment">/* flush posted PCI writes */</span>
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 
<a name="l00266"></a>00266 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_ring_dbell_update_sq_params(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l00267"></a>00267                           <span class="keywordtype">int</span> count)
<a name="l00268"></a>00268 {
<a name="l00269"></a>00269     <span class="keywordtype">int</span> tmp_cnt;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     <span class="keywordflow">if</span> (count == 1) {
<a name="l00272"></a>00272         <span class="keywordflow">if</span> (bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe ==
<a name="l00273"></a>00273             bnx2i_conn-&gt;ep-&gt;qp.sq_last_qe)
<a name="l00274"></a>00274             bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe =
<a name="l00275"></a>00275                         bnx2i_conn-&gt;ep-&gt;qp.sq_first_qe;
<a name="l00276"></a>00276         <span class="keywordflow">else</span>
<a name="l00277"></a>00277             bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe++;
<a name="l00278"></a>00278     } <span class="keywordflow">else</span> {
<a name="l00279"></a>00279         <span class="keywordflow">if</span> ((bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe + count) &lt;=
<a name="l00280"></a>00280             bnx2i_conn-&gt;ep-&gt;qp.sq_last_qe)
<a name="l00281"></a>00281             bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe += count;
<a name="l00282"></a>00282         <span class="keywordflow">else</span> {
<a name="l00283"></a>00283             tmp_cnt = bnx2i_conn-&gt;ep-&gt;qp.sq_last_qe -
<a name="l00284"></a>00284                 bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe;
<a name="l00285"></a>00285             bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe =
<a name="l00286"></a>00286                 &amp;bnx2i_conn-&gt;ep-&gt;qp.sq_first_qe[count -
<a name="l00287"></a>00287                                 (tmp_cnt + 1)];
<a name="l00288"></a>00288         }
<a name="l00289"></a>00289     }
<a name="l00290"></a>00290     bnx2i_conn-&gt;ep-&gt;qp.sq_prod_idx += count;
<a name="l00291"></a>00291     <span class="comment">/* Ring the doorbell */</span>
<a name="l00292"></a>00292     bnx2i_ring_sq_dbell(bnx2i_conn, (u16)bnx2i_conn-&gt;ep-&gt;qp.sq_prod_idx);
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 
<a name="l00304"></a>00304 <span class="keywordtype">int</span> bnx2i_send_iscsi_login(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l00305"></a>00305                <span class="keyword">struct</span> iscsi_task *task)
<a name="l00306"></a>00306 {
<a name="l00307"></a>00307     <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *<a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a>;
<a name="l00308"></a>00308     <span class="keyword">struct </span><a class="code" href="structbnx2i__login__request.html">bnx2i_login_request</a> *login_wqe;
<a name="l00309"></a>00309     <span class="keyword">struct </span>iscsi_login *login_hdr;
<a name="l00310"></a>00310     u32 dword;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     bnx2i_cmd = (<span class="keyword">struct </span>bnx2i_cmd *)task-&gt;dd_data;
<a name="l00313"></a>00313     login_hdr = (<span class="keyword">struct</span> iscsi_login *)task-&gt;hdr;
<a name="l00314"></a>00314     login_wqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__login__request.html">bnx2i_login_request</a> *)
<a name="l00315"></a>00315                         bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317     login_wqe-&gt;op_code = login_hdr-&gt;opcode;
<a name="l00318"></a>00318     login_wqe-&gt;op_attr = login_hdr-&gt;flags;
<a name="l00319"></a>00319     login_wqe-&gt;version_max = login_hdr-&gt;max_version;
<a name="l00320"></a>00320     login_wqe-&gt;version_min = login_hdr-&gt;min_version;
<a name="l00321"></a>00321     login_wqe-&gt;data_length = ntoh24(login_hdr-&gt;dlength);
<a name="l00322"></a>00322     login_wqe-&gt;isid_lo = *((u32 *) login_hdr-&gt;isid);
<a name="l00323"></a>00323     login_wqe-&gt;isid_hi = *((u16 *) login_hdr-&gt;isid + 2);
<a name="l00324"></a>00324     login_wqe-&gt;tsih = login_hdr-&gt;tsih;
<a name="l00325"></a>00325     login_wqe-&gt;itt = task-&gt;itt |
<a name="l00326"></a>00326         (ISCSI_TASK_TYPE_MPATH &lt;&lt; ISCSI_LOGIN_REQUEST_TYPE_SHIFT);
<a name="l00327"></a>00327     login_wqe-&gt;cid = login_hdr-&gt;cid;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     login_wqe-&gt;cmd_sn = be32_to_cpu(login_hdr-&gt;cmdsn);
<a name="l00330"></a>00330     login_wqe-&gt;exp_stat_sn = be32_to_cpu(login_hdr-&gt;exp_statsn);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332     login_wqe-&gt;resp_bd_list_addr_lo = (u32) bnx2i_conn-&gt;gen_pdu.resp_bd_dma;
<a name="l00333"></a>00333     login_wqe-&gt;resp_bd_list_addr_hi =
<a name="l00334"></a>00334         (u32) ((u64) bnx2i_conn-&gt;gen_pdu.resp_bd_dma &gt;&gt; 32);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     dword = ((1 &lt;&lt; ISCSI_LOGIN_REQUEST_NUM_RESP_BDS_SHIFT) |
<a name="l00337"></a>00337          (bnx2i_conn-&gt;gen_pdu.resp_buf_size &lt;&lt;
<a name="l00338"></a>00338           ISCSI_LOGIN_REQUEST_RESP_BUFFER_LENGTH_SHIFT));
<a name="l00339"></a>00339     login_wqe-&gt;resp_buffer = dword;
<a name="l00340"></a>00340     login_wqe-&gt;flags = 0;
<a name="l00341"></a>00341     login_wqe-&gt;bd_list_addr_lo = (u32) bnx2i_conn-&gt;gen_pdu.req_bd_dma;
<a name="l00342"></a>00342     login_wqe-&gt;bd_list_addr_hi =
<a name="l00343"></a>00343         (u32) ((u64) bnx2i_conn-&gt;gen_pdu.req_bd_dma &gt;&gt; 32);
<a name="l00344"></a>00344     login_wqe-&gt;num_bds = 1;
<a name="l00345"></a>00345     login_wqe-&gt;cq_index = 0; <span class="comment">/* CQ# used for completion, 5771x only */</span>
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     bnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);
<a name="l00348"></a>00348     <span class="keywordflow">return</span> 0;
<a name="l00349"></a>00349 }
<a name="l00350"></a>00350 
<a name="l00359"></a>00359 <span class="keywordtype">int</span> bnx2i_send_iscsi_tmf(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l00360"></a>00360              <span class="keyword">struct</span> iscsi_task *mtask)
<a name="l00361"></a>00361 {
<a name="l00362"></a>00362     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l00363"></a>00363     <span class="keyword">struct </span>iscsi_tm *tmfabort_hdr;
<a name="l00364"></a>00364     <span class="keyword">struct </span>scsi_cmnd *ref_sc;
<a name="l00365"></a>00365     <span class="keyword">struct </span>iscsi_task *ctask;
<a name="l00366"></a>00366     <span class="keyword">struct </span>bnx2i_cmd *bnx2i_cmd;
<a name="l00367"></a>00367     <span class="keyword">struct </span><a class="code" href="structbnx2i__tmf__request.html">bnx2i_tmf_request</a> *tmfabort_wqe;
<a name="l00368"></a>00368     u32 dword;
<a name="l00369"></a>00369         u32 scsi_lun[2];
<a name="l00370"></a>00370 
<a name="l00371"></a>00371     bnx2i_cmd = (<span class="keyword">struct </span>bnx2i_cmd *)mtask-&gt;dd_data;
<a name="l00372"></a>00372     tmfabort_hdr = (<span class="keyword">struct</span> iscsi_tm *)mtask-&gt;hdr;
<a name="l00373"></a>00373     tmfabort_wqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__tmf__request.html">bnx2i_tmf_request</a> *)
<a name="l00374"></a>00374                         bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     tmfabort_wqe-&gt;op_code = tmfabort_hdr-&gt;opcode;
<a name="l00377"></a>00377     tmfabort_wqe-&gt;op_attr = 0;
<a name="l00378"></a>00378     tmfabort_wqe-&gt;op_attr =
<a name="l00379"></a>00379         ISCSI_TMF_REQUEST_ALWAYS_ONE | ISCSI_TM_FUNC_ABORT_TASK;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     tmfabort_wqe-&gt;itt = (mtask-&gt;itt | (ISCSI_TASK_TYPE_MPATH &lt;&lt; 14));
<a name="l00382"></a>00382     tmfabort_wqe-&gt;reserved2 = 0;
<a name="l00383"></a>00383     tmfabort_wqe-&gt;cmd_sn = be32_to_cpu(tmfabort_hdr-&gt;cmdsn);
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     ctask = iscsi_itt_to_task(conn, tmfabort_hdr-&gt;rtt);
<a name="l00386"></a>00386     <span class="keywordflow">if</span> (!ctask || !ctask-&gt;sc)
<a name="l00387"></a>00387         <span class="comment">/*</span>
<a name="l00388"></a>00388 <span class="comment">         * the iscsi layer must have completed the cmd while this</span>
<a name="l00389"></a>00389 <span class="comment">         * was starting up.</span>
<a name="l00390"></a>00390 <span class="comment">                 * Note.  In the case of a SCSI cmd timeout, the task&#39;s sc is</span>
<a name="l00391"></a>00391 <span class="comment">                 *        still active; hence ctask-&gt;sc != 0</span>
<a name="l00392"></a>00392 <span class="comment">         */</span>
<a name="l00393"></a>00393         <span class="keywordflow">return</span> 0;
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     ref_sc = ctask-&gt;sc;
<a name="l00396"></a>00396 
<a name="l00397"></a>00397         <span class="comment">/* Retrieve LUN directly from the ref_sc */</span>
<a name="l00398"></a>00398         int_to_scsilun(ref_sc-&gt;device-&gt;lun, (<span class="keyword">struct</span> scsi_lun *) scsi_lun);
<a name="l00399"></a>00399         tmfabort_wqe-&gt;lun[0] = be32_to_cpu(scsi_lun[0]);
<a name="l00400"></a>00400         tmfabort_wqe-&gt;lun[1] = be32_to_cpu(scsi_lun[1]);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     <span class="keywordflow">if</span> (ref_sc-&gt;sc_data_direction == DMA_TO_DEVICE)
<a name="l00403"></a>00403         dword = (ISCSI_TASK_TYPE_WRITE &lt;&lt; ISCSI_CMD_REQUEST_TYPE_SHIFT);
<a name="l00404"></a>00404     <span class="keywordflow">else</span>
<a name="l00405"></a>00405         dword = (ISCSI_TASK_TYPE_READ &lt;&lt; ISCSI_CMD_REQUEST_TYPE_SHIFT);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         tmfabort_wqe-&gt;ref_itt = (dword | (tmfabort_hdr-&gt;rtt &amp; ISCSI_ITT_MASK));
<a name="l00408"></a>00408     tmfabort_wqe-&gt;ref_cmd_sn = be32_to_cpu(tmfabort_hdr-&gt;refcmdsn);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     tmfabort_wqe-&gt;bd_list_addr_lo = (u32) bnx2i_conn-&gt;hba-&gt;mp_bd_dma;
<a name="l00411"></a>00411     tmfabort_wqe-&gt;bd_list_addr_hi = (u32)
<a name="l00412"></a>00412                 ((u64) bnx2i_conn-&gt;hba-&gt;mp_bd_dma &gt;&gt; 32);
<a name="l00413"></a>00413     tmfabort_wqe-&gt;num_bds = 1;
<a name="l00414"></a>00414     tmfabort_wqe-&gt;cq_index = 0; <span class="comment">/* CQ# used for completion, 5771x only */</span>
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     bnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);
<a name="l00417"></a>00417     <span class="keywordflow">return</span> 0;
<a name="l00418"></a>00418 }
<a name="l00419"></a>00419 
<a name="l00428"></a>00428 <span class="keywordtype">int</span> bnx2i_send_iscsi_scsicmd(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l00429"></a>00429                  <span class="keyword">struct</span> bnx2i_cmd *cmd)
<a name="l00430"></a>00430 {
<a name="l00431"></a>00431     <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd__request.html">bnx2i_cmd_request</a> *scsi_cmd_wqe;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     scsi_cmd_wqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__cmd__request.html">bnx2i_cmd_request</a> *)
<a name="l00434"></a>00434                         bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe;
<a name="l00435"></a>00435     memcpy(scsi_cmd_wqe, &amp;cmd-&gt;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd__request.html">bnx2i_cmd_request</a>));
<a name="l00436"></a>00436     scsi_cmd_wqe-&gt;cq_index = 0; <span class="comment">/* CQ# used for completion, 5771x only */</span>
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     bnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);
<a name="l00439"></a>00439     <span class="keywordflow">return</span> 0;
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00455"></a>00455 <span class="keywordtype">int</span> bnx2i_send_iscsi_nopout(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l00456"></a>00456                 <span class="keyword">struct</span> iscsi_task *task, u32 ttt,
<a name="l00457"></a>00457                 <span class="keywordtype">char</span> *datap, <span class="keywordtype">int</span> data_len, <span class="keywordtype">int</span> unsol)
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = bnx2i_conn-&gt;ep;
<a name="l00460"></a>00460     <span class="keyword">struct </span>bnx2i_cmd *bnx2i_cmd;
<a name="l00461"></a>00461     <span class="keyword">struct </span><a class="code" href="structbnx2i__nop__out__request.html">bnx2i_nop_out_request</a> *nopout_wqe;
<a name="l00462"></a>00462     <span class="keyword">struct </span>iscsi_nopout *nopout_hdr;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     bnx2i_cmd = (<span class="keyword">struct </span>bnx2i_cmd *)task-&gt;dd_data;
<a name="l00465"></a>00465     nopout_hdr = (<span class="keyword">struct</span> iscsi_nopout *)task-&gt;hdr;
<a name="l00466"></a>00466     nopout_wqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__nop__out__request.html">bnx2i_nop_out_request</a> *)ep-&gt;qp.sq_prod_qe;
<a name="l00467"></a>00467     nopout_wqe-&gt;op_code = nopout_hdr-&gt;opcode;
<a name="l00468"></a>00468     nopout_wqe-&gt;op_attr = ISCSI_FLAG_CMD_FINAL;
<a name="l00469"></a>00469     memcpy(nopout_wqe-&gt;lun, nopout_hdr-&gt;lun, 8);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type)) {
<a name="l00472"></a>00472         u32 tmp = nopout_hdr-&gt;lun[0];
<a name="l00473"></a>00473         <span class="comment">/* 57710 requires LUN field to be swapped */</span>
<a name="l00474"></a>00474         nopout_hdr-&gt;lun[0] = nopout_hdr-&gt;lun[1];
<a name="l00475"></a>00475         nopout_hdr-&gt;lun[1] = tmp;
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478     nopout_wqe-&gt;itt = ((u16)task-&gt;itt |
<a name="l00479"></a>00479                (ISCSI_TASK_TYPE_MPATH &lt;&lt;
<a name="l00480"></a>00480                 ISCSI_TMF_REQUEST_TYPE_SHIFT));
<a name="l00481"></a>00481     nopout_wqe-&gt;ttt = ttt;
<a name="l00482"></a>00482     nopout_wqe-&gt;flags = 0;
<a name="l00483"></a>00483     <span class="keywordflow">if</span> (!unsol)
<a name="l00484"></a>00484         nopout_wqe-&gt;flags = ISCSI_NOP_OUT_REQUEST_LOCAL_COMPLETION;
<a name="l00485"></a>00485     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nopout_hdr-&gt;itt == RESERVED_ITT)
<a name="l00486"></a>00486         nopout_wqe-&gt;flags = ISCSI_NOP_OUT_REQUEST_LOCAL_COMPLETION;
<a name="l00487"></a>00487 
<a name="l00488"></a>00488     nopout_wqe-&gt;cmd_sn = be32_to_cpu(nopout_hdr-&gt;cmdsn);
<a name="l00489"></a>00489     nopout_wqe-&gt;data_length = data_len;
<a name="l00490"></a>00490     <span class="keywordflow">if</span> (data_len) {
<a name="l00491"></a>00491         <span class="comment">/* handle payload data, not required in first release */</span>
<a name="l00492"></a>00492         printk(KERN_ALERT <span class="stringliteral">&quot;NOPOUT: WARNING!! payload len != 0\n&quot;</span>);
<a name="l00493"></a>00493     } <span class="keywordflow">else</span> {
<a name="l00494"></a>00494         nopout_wqe-&gt;bd_list_addr_lo = (u32)
<a name="l00495"></a>00495                     bnx2i_conn-&gt;hba-&gt;mp_bd_dma;
<a name="l00496"></a>00496         nopout_wqe-&gt;bd_list_addr_hi =
<a name="l00497"></a>00497             (u32) ((u64) bnx2i_conn-&gt;hba-&gt;mp_bd_dma &gt;&gt; 32);
<a name="l00498"></a>00498         nopout_wqe-&gt;num_bds = 1;
<a name="l00499"></a>00499     }
<a name="l00500"></a>00500     nopout_wqe-&gt;cq_index = 0; <span class="comment">/* CQ# used for completion, 5771x only */</span>
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     bnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);
<a name="l00503"></a>00503     <span class="keywordflow">return</span> 0;
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 
<a name="l00515"></a>00515 <span class="keywordtype">int</span> bnx2i_send_iscsi_logout(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l00516"></a>00516                 <span class="keyword">struct</span> iscsi_task *task)
<a name="l00517"></a>00517 {
<a name="l00518"></a>00518     <span class="keyword">struct </span>bnx2i_cmd *bnx2i_cmd;
<a name="l00519"></a>00519     <span class="keyword">struct </span><a class="code" href="structbnx2i__logout__request.html">bnx2i_logout_request</a> *logout_wqe;
<a name="l00520"></a>00520     <span class="keyword">struct </span>iscsi_logout *logout_hdr;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522     bnx2i_cmd = (<span class="keyword">struct </span>bnx2i_cmd *)task-&gt;dd_data;
<a name="l00523"></a>00523     logout_hdr = (<span class="keyword">struct</span> iscsi_logout *)task-&gt;hdr;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525     logout_wqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__logout__request.html">bnx2i_logout_request</a> *)
<a name="l00526"></a>00526                         bnx2i_conn-&gt;ep-&gt;qp.sq_prod_qe;
<a name="l00527"></a>00527     memset(logout_wqe, 0x00, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbnx2i__logout__request.html">bnx2i_logout_request</a>));
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     logout_wqe-&gt;op_code = logout_hdr-&gt;opcode;
<a name="l00530"></a>00530     logout_wqe-&gt;cmd_sn = be32_to_cpu(logout_hdr-&gt;cmdsn);
<a name="l00531"></a>00531     logout_wqe-&gt;op_attr =
<a name="l00532"></a>00532             logout_hdr-&gt;flags | ISCSI_LOGOUT_REQUEST_ALWAYS_ONE;
<a name="l00533"></a>00533     logout_wqe-&gt;itt = ((u16)task-&gt;itt |
<a name="l00534"></a>00534                (ISCSI_TASK_TYPE_MPATH &lt;&lt;
<a name="l00535"></a>00535                 ISCSI_LOGOUT_REQUEST_TYPE_SHIFT));
<a name="l00536"></a>00536     logout_wqe-&gt;data_length = 0;
<a name="l00537"></a>00537     logout_wqe-&gt;cid = 0;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539     logout_wqe-&gt;bd_list_addr_lo = (u32) bnx2i_conn-&gt;hba-&gt;mp_bd_dma;
<a name="l00540"></a>00540     logout_wqe-&gt;bd_list_addr_hi = (u32)
<a name="l00541"></a>00541                 ((u64) bnx2i_conn-&gt;hba-&gt;mp_bd_dma &gt;&gt; 32);
<a name="l00542"></a>00542     logout_wqe-&gt;num_bds = 1;
<a name="l00543"></a>00543     logout_wqe-&gt;cq_index = 0; <span class="comment">/* CQ# used for completion, 5771x only */</span>
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     bnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);
<a name="l00546"></a>00546     <span class="keywordflow">return</span> 0;
<a name="l00547"></a>00547 }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 
<a name="l00556"></a>00556 <span class="keywordtype">void</span> bnx2i_update_iscsi_conn(<span class="keyword">struct</span> iscsi_conn *conn)
<a name="l00557"></a>00557 {
<a name="l00558"></a>00558     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l00559"></a>00559     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = bnx2i_conn-&gt;hba;
<a name="l00560"></a>00560     <span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *kwqe_arr[2];
<a name="l00561"></a>00561     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__update.html">iscsi_kwqe_conn_update</a> *update_wqe;
<a name="l00562"></a>00562     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__update.html">iscsi_kwqe_conn_update</a> conn_update_kwqe;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     update_wqe = &amp;conn_update_kwqe;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     update_wqe-&gt;hdr.op_code = ISCSI_KWQE_OPCODE_UPDATE_CONN;
<a name="l00567"></a>00567     update_wqe-&gt;hdr.flags =
<a name="l00568"></a>00568         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     <span class="comment">/* 5771x requires conn context id to be passed as is */</span>
<a name="l00571"></a>00571     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;bnx2i_conn-&gt;ep-&gt;hba-&gt;cnic_dev_type))
<a name="l00572"></a>00572         update_wqe-&gt;context_id = bnx2i_conn-&gt;ep-&gt;ep_cid;
<a name="l00573"></a>00573     <span class="keywordflow">else</span>
<a name="l00574"></a>00574         update_wqe-&gt;context_id = (bnx2i_conn-&gt;ep-&gt;ep_cid &gt;&gt; 7);
<a name="l00575"></a>00575     update_wqe-&gt;conn_flags = 0;
<a name="l00576"></a>00576     <span class="keywordflow">if</span> (conn-&gt;hdrdgst_en)
<a name="l00577"></a>00577         update_wqe-&gt;conn_flags |= ISCSI_KWQE_CONN_UPDATE_HEADER_DIGEST;
<a name="l00578"></a>00578     <span class="keywordflow">if</span> (conn-&gt;datadgst_en)
<a name="l00579"></a>00579         update_wqe-&gt;conn_flags |= ISCSI_KWQE_CONN_UPDATE_DATA_DIGEST;
<a name="l00580"></a>00580     <span class="keywordflow">if</span> (conn-&gt;session-&gt;initial_r2t_en)
<a name="l00581"></a>00581         update_wqe-&gt;conn_flags |= ISCSI_KWQE_CONN_UPDATE_INITIAL_R2T;
<a name="l00582"></a>00582     <span class="keywordflow">if</span> (conn-&gt;session-&gt;imm_data_en)
<a name="l00583"></a>00583         update_wqe-&gt;conn_flags |= ISCSI_KWQE_CONN_UPDATE_IMMEDIATE_DATA;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585     update_wqe-&gt;max_send_pdu_length = conn-&gt;max_xmit_dlength;
<a name="l00586"></a>00586     update_wqe-&gt;max_recv_pdu_length = conn-&gt;max_recv_dlength;
<a name="l00587"></a>00587     update_wqe-&gt;first_burst_length = conn-&gt;session-&gt;first_burst;
<a name="l00588"></a>00588     update_wqe-&gt;max_burst_length = conn-&gt;session-&gt;max_burst;
<a name="l00589"></a>00589     update_wqe-&gt;exp_stat_sn = conn-&gt;exp_statsn;
<a name="l00590"></a>00590     update_wqe-&gt;max_outstanding_r2ts = conn-&gt;session-&gt;max_r2t;
<a name="l00591"></a>00591     update_wqe-&gt;session_error_recovery_level = conn-&gt;session-&gt;erl;
<a name="l00592"></a>00592     iscsi_conn_printk(KERN_ALERT, conn,
<a name="l00593"></a>00593               <span class="stringliteral">&quot;bnx2i: conn update - MBL 0x%x FBL 0x%x&quot;</span>
<a name="l00594"></a>00594               <span class="stringliteral">&quot;MRDSL_I 0x%x MRDSL_T 0x%x \n&quot;</span>,
<a name="l00595"></a>00595               update_wqe-&gt;max_burst_length,
<a name="l00596"></a>00596               update_wqe-&gt;first_burst_length,
<a name="l00597"></a>00597               update_wqe-&gt;max_recv_pdu_length,
<a name="l00598"></a>00598               update_wqe-&gt;max_send_pdu_length);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     kwqe_arr[0] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) update_wqe;
<a name="l00601"></a>00601     <span class="keywordflow">if</span> (hba-&gt;cnic &amp;&amp; hba-&gt;cnic-&gt;submit_kwqes)
<a name="l00602"></a>00602         hba-&gt;cnic-&gt;submit_kwqes(hba-&gt;cnic, kwqe_arr, 1);
<a name="l00603"></a>00603 }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 
<a name="l00612"></a>00612 <span class="keywordtype">void</span> bnx2i_ep_ofld_timer(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l00613"></a>00613 {
<a name="l00614"></a>00614     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *) data;
<a name="l00615"></a>00615 
<a name="l00616"></a>00616     <span class="keywordflow">if</span> (ep-&gt;state == EP_STATE_OFLD_START) {
<a name="l00617"></a>00617         printk(KERN_ALERT <span class="stringliteral">&quot;ofld_timer: CONN_OFLD timeout\n&quot;</span>);
<a name="l00618"></a>00618         ep-&gt;state = EP_STATE_OFLD_FAILED;
<a name="l00619"></a>00619     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep-&gt;state == EP_STATE_DISCONN_START) {
<a name="l00620"></a>00620         printk(KERN_ALERT <span class="stringliteral">&quot;ofld_timer: CONN_DISCON timeout\n&quot;</span>);
<a name="l00621"></a>00621         ep-&gt;state = EP_STATE_DISCONN_TIMEDOUT;
<a name="l00622"></a>00622     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep-&gt;state == EP_STATE_CLEANUP_START) {
<a name="l00623"></a>00623         printk(KERN_ALERT <span class="stringliteral">&quot;ofld_timer: CONN_CLEANUP timeout\n&quot;</span>);
<a name="l00624"></a>00624         ep-&gt;state = EP_STATE_CLEANUP_FAILED;
<a name="l00625"></a>00625     }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627     wake_up_interruptible(&amp;ep-&gt;ofld_wait);
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 
<a name="l00631"></a>00631 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_power_of2(u32 val)
<a name="l00632"></a>00632 {
<a name="l00633"></a>00633     u32 power = 0;
<a name="l00634"></a>00634     <span class="keywordflow">if</span> (val &amp; (val - 1))
<a name="l00635"></a>00635         <span class="keywordflow">return</span> power;
<a name="l00636"></a>00636     val--;
<a name="l00637"></a>00637     <span class="keywordflow">while</span> (val) {
<a name="l00638"></a>00638         val = val &gt;&gt; 1;
<a name="l00639"></a>00639         power++;
<a name="l00640"></a>00640     }
<a name="l00641"></a>00641     <span class="keywordflow">return</span> power;
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 
<a name="l00653"></a>00653 <span class="keywordtype">void</span> bnx2i_send_cmd_cleanup_req(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, <span class="keyword">struct</span> bnx2i_cmd *cmd)
<a name="l00654"></a>00654 {
<a name="l00655"></a>00655     <span class="keyword">struct </span><a class="code" href="structbnx2i__cleanup__request.html">bnx2i_cleanup_request</a> *cmd_cleanup;
<a name="l00656"></a>00656 
<a name="l00657"></a>00657     cmd_cleanup =
<a name="l00658"></a>00658         (<span class="keyword">struct </span><a class="code" href="structbnx2i__cleanup__request.html">bnx2i_cleanup_request</a> *)cmd-&gt;conn-&gt;ep-&gt;qp.sq_prod_qe;
<a name="l00659"></a>00659     memset(cmd_cleanup, 0x00, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbnx2i__cleanup__request.html">bnx2i_cleanup_request</a>));
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     cmd_cleanup-&gt;op_code = ISCSI_OPCODE_CLEANUP_REQUEST;
<a name="l00662"></a>00662     cmd_cleanup-&gt;itt = cmd-&gt;req.itt;
<a name="l00663"></a>00663     cmd_cleanup-&gt;cq_index = 0; <span class="comment">/* CQ# used for completion, 5771x only */</span>
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     bnx2i_ring_dbell_update_sq_params(cmd-&gt;conn, 1);
<a name="l00666"></a>00666 }
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 
<a name="l00677"></a>00677 <span class="keywordtype">void</span> bnx2i_send_conn_destroy(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679     <span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *kwqe_arr[2];
<a name="l00680"></a>00680     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__destroy.html">iscsi_kwqe_conn_destroy</a> conn_cleanup;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     memset(&amp;conn_cleanup, 0x00, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structiscsi__kwqe__conn__destroy.html">iscsi_kwqe_conn_destroy</a>));
<a name="l00683"></a>00683 
<a name="l00684"></a>00684     conn_cleanup.hdr.op_code = ISCSI_KWQE_OPCODE_DESTROY_CONN;
<a name="l00685"></a>00685     conn_cleanup.hdr.flags =
<a name="l00686"></a>00686         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l00687"></a>00687     <span class="comment">/* 5771x requires conn context id to be passed as is */</span>
<a name="l00688"></a>00688     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type))
<a name="l00689"></a>00689         conn_cleanup.context_id = ep-&gt;ep_cid;
<a name="l00690"></a>00690     <span class="keywordflow">else</span>
<a name="l00691"></a>00691         conn_cleanup.context_id = (ep-&gt;ep_cid &gt;&gt; 7);
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     conn_cleanup.reserved0 = (u16)ep-&gt;ep_iscsi_cid;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     kwqe_arr[0] = (<span class="keyword">struct</span> <a class="code" href="structkwqe.html">kwqe</a> *) &amp;conn_cleanup;
<a name="l00696"></a>00696     <span class="keywordflow">if</span> (hba-&gt;cnic &amp;&amp; hba-&gt;cnic-&gt;submit_kwqes)
<a name="l00697"></a>00697         hba-&gt;cnic-&gt;submit_kwqes(hba-&gt;cnic, kwqe_arr, 1);
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700 
<a name="l00708"></a>00708 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_570x_send_conn_ofld_req(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00709"></a>00709                       <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00710"></a>00710 {
<a name="l00711"></a>00711     <span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *kwqe_arr[2];
<a name="l00712"></a>00712     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload1.html">iscsi_kwqe_conn_offload1</a> ofld_req1;
<a name="l00713"></a>00713     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload2.html">iscsi_kwqe_conn_offload2</a> ofld_req2;
<a name="l00714"></a>00714     dma_addr_t dma_addr;
<a name="l00715"></a>00715     <span class="keywordtype">int</span> num_kwqes = 2;
<a name="l00716"></a>00716     u32 *ptbl;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     ofld_req1.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN1;
<a name="l00719"></a>00719     ofld_req1.hdr.flags =
<a name="l00720"></a>00720         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     ofld_req1.iscsi_conn_id = (u16) ep-&gt;ep_iscsi_cid;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724     dma_addr = ep-&gt;qp.sq_pgtbl_phys;
<a name="l00725"></a>00725     ofld_req1.sq_page_table_addr_lo = (u32) dma_addr;
<a name="l00726"></a>00726     ofld_req1.sq_page_table_addr_hi = (u32) ((u64) dma_addr &gt;&gt; 32);
<a name="l00727"></a>00727 
<a name="l00728"></a>00728     dma_addr = ep-&gt;qp.cq_pgtbl_phys;
<a name="l00729"></a>00729     ofld_req1.cq_page_table_addr_lo = (u32) dma_addr;
<a name="l00730"></a>00730     ofld_req1.cq_page_table_addr_hi = (u32) ((u64) dma_addr &gt;&gt; 32);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732     ofld_req2.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN2;
<a name="l00733"></a>00733     ofld_req2.hdr.flags =
<a name="l00734"></a>00734         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     dma_addr = ep-&gt;qp.rq_pgtbl_phys;
<a name="l00737"></a>00737     ofld_req2.rq_page_table_addr_lo = (u32) dma_addr;
<a name="l00738"></a>00738     ofld_req2.rq_page_table_addr_hi = (u32) ((u64) dma_addr &gt;&gt; 32);
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     ptbl = (u32 *) ep-&gt;qp.sq_pgtbl_virt;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     ofld_req2.sq_first_pte.hi = *ptbl++;
<a name="l00743"></a>00743     ofld_req2.sq_first_pte.lo = *ptbl;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     ptbl = (u32 *) ep-&gt;qp.cq_pgtbl_virt;
<a name="l00746"></a>00746     ofld_req2.cq_first_pte.hi = *ptbl++;
<a name="l00747"></a>00747     ofld_req2.cq_first_pte.lo = *ptbl;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     kwqe_arr[0] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) &amp;ofld_req1;
<a name="l00750"></a>00750     kwqe_arr[1] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) &amp;ofld_req2;
<a name="l00751"></a>00751     ofld_req2.num_additional_wqes = 0;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     <span class="keywordflow">if</span> (hba-&gt;cnic &amp;&amp; hba-&gt;cnic-&gt;submit_kwqes)
<a name="l00754"></a>00754         hba-&gt;cnic-&gt;submit_kwqes(hba-&gt;cnic, kwqe_arr, num_kwqes);
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 
<a name="l00765"></a>00765 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_5771x_send_conn_ofld_req(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00766"></a>00766                        <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00767"></a>00767 {
<a name="l00768"></a>00768     <span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *kwqe_arr[5];
<a name="l00769"></a>00769     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload1.html">iscsi_kwqe_conn_offload1</a> ofld_req1;
<a name="l00770"></a>00770     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload2.html">iscsi_kwqe_conn_offload2</a> ofld_req2;
<a name="l00771"></a>00771     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload3.html">iscsi_kwqe_conn_offload3</a> ofld_req3[1];
<a name="l00772"></a>00772     dma_addr_t dma_addr;
<a name="l00773"></a>00773     <span class="keywordtype">int</span> num_kwqes = 2;
<a name="l00774"></a>00774     u32 *ptbl;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     ofld_req1.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN1;
<a name="l00777"></a>00777     ofld_req1.hdr.flags =
<a name="l00778"></a>00778         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     ofld_req1.iscsi_conn_id = (u16) ep-&gt;ep_iscsi_cid;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782     dma_addr = ep-&gt;qp.sq_pgtbl_phys + ISCSI_SQ_DB_SIZE;
<a name="l00783"></a>00783     ofld_req1.sq_page_table_addr_lo = (u32) dma_addr;
<a name="l00784"></a>00784     ofld_req1.sq_page_table_addr_hi = (u32) ((u64) dma_addr &gt;&gt; 32);
<a name="l00785"></a>00785 
<a name="l00786"></a>00786     dma_addr = ep-&gt;qp.cq_pgtbl_phys + ISCSI_CQ_DB_SIZE;
<a name="l00787"></a>00787     ofld_req1.cq_page_table_addr_lo = (u32) dma_addr;
<a name="l00788"></a>00788     ofld_req1.cq_page_table_addr_hi = (u32) ((u64) dma_addr &gt;&gt; 32);
<a name="l00789"></a>00789 
<a name="l00790"></a>00790     ofld_req2.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN2;
<a name="l00791"></a>00791     ofld_req2.hdr.flags =
<a name="l00792"></a>00792         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794     dma_addr = ep-&gt;qp.rq_pgtbl_phys + ISCSI_RQ_DB_SIZE;
<a name="l00795"></a>00795     ofld_req2.rq_page_table_addr_lo = (u32) dma_addr;
<a name="l00796"></a>00796     ofld_req2.rq_page_table_addr_hi = (u32) ((u64) dma_addr &gt;&gt; 32);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798     ptbl = (u32 *)((u8 *)ep-&gt;qp.sq_pgtbl_virt + ISCSI_SQ_DB_SIZE);
<a name="l00799"></a>00799     ofld_req2.sq_first_pte.hi = *ptbl++;
<a name="l00800"></a>00800     ofld_req2.sq_first_pte.lo = *ptbl;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802     ptbl = (u32 *)((u8 *)ep-&gt;qp.cq_pgtbl_virt + ISCSI_CQ_DB_SIZE);
<a name="l00803"></a>00803     ofld_req2.cq_first_pte.hi = *ptbl++;
<a name="l00804"></a>00804     ofld_req2.cq_first_pte.lo = *ptbl;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806     kwqe_arr[0] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) &amp;ofld_req1;
<a name="l00807"></a>00807     kwqe_arr[1] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) &amp;ofld_req2;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     ofld_req2.num_additional_wqes = 1;
<a name="l00810"></a>00810     memset(ofld_req3, 0x00, <span class="keyword">sizeof</span>(ofld_req3[0]));
<a name="l00811"></a>00811     ptbl = (u32 *)((u8 *)ep-&gt;qp.rq_pgtbl_virt + ISCSI_RQ_DB_SIZE);
<a name="l00812"></a>00812     ofld_req3[0].qp_first_pte[0].hi = *ptbl++;
<a name="l00813"></a>00813     ofld_req3[0].qp_first_pte[0].lo = *ptbl;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     kwqe_arr[2] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) ofld_req3;
<a name="l00816"></a>00816     <span class="comment">/* need if we decide to go with multiple KCQE&#39;s per conn */</span>
<a name="l00817"></a>00817     num_kwqes += 1;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819     <span class="keywordflow">if</span> (hba-&gt;cnic &amp;&amp; hba-&gt;cnic-&gt;submit_kwqes)
<a name="l00820"></a>00820         hba-&gt;cnic-&gt;submit_kwqes(hba-&gt;cnic, kwqe_arr, num_kwqes);
<a name="l00821"></a>00821 }
<a name="l00822"></a>00822 
<a name="l00831"></a>00831 <span class="keywordtype">void</span> bnx2i_send_conn_ofld_req(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00832"></a>00832 {
<a name="l00833"></a>00833     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;hba-&gt;cnic_dev_type))
<a name="l00834"></a>00834         bnx2i_5771x_send_conn_ofld_req(hba, ep);
<a name="l00835"></a>00835     <span class="keywordflow">else</span>
<a name="l00836"></a>00836         bnx2i_570x_send_conn_ofld_req(hba, ep);
<a name="l00837"></a>00837 }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 
<a name="l00848"></a>00848 <span class="keyword">static</span> <span class="keywordtype">void</span> setup_qp_page_tables(<span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00849"></a>00849 {
<a name="l00850"></a>00850     <span class="keywordtype">int</span> num_pages;
<a name="l00851"></a>00851     u32 *ptbl;
<a name="l00852"></a>00852     dma_addr_t page;
<a name="l00853"></a>00853     <span class="keywordtype">int</span> cnic_dev_10g;
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type))
<a name="l00856"></a>00856         cnic_dev_10g = 1;
<a name="l00857"></a>00857     <span class="keywordflow">else</span>
<a name="l00858"></a>00858         cnic_dev_10g = 0;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860     <span class="comment">/* SQ page table */</span>
<a name="l00861"></a>00861     memset(ep-&gt;qp.sq_pgtbl_virt, 0, ep-&gt;qp.sq_pgtbl_size);
<a name="l00862"></a>00862     num_pages = ep-&gt;qp.sq_mem_size / PAGE_SIZE;
<a name="l00863"></a>00863     page = ep-&gt;qp.sq_phys;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865     <span class="keywordflow">if</span> (cnic_dev_10g)
<a name="l00866"></a>00866         ptbl = (u32 *)((u8 *)ep-&gt;qp.sq_pgtbl_virt + ISCSI_SQ_DB_SIZE);
<a name="l00867"></a>00867     <span class="keywordflow">else</span>
<a name="l00868"></a>00868         ptbl = (u32 *) ep-&gt;qp.sq_pgtbl_virt;
<a name="l00869"></a>00869     while (num_pages--) {
<a name="l00870"></a>00870         <span class="keywordflow">if</span> (cnic_dev_10g) {
<a name="l00871"></a>00871             <span class="comment">/* PTE is written in little endian format for 57710 */</span>
<a name="l00872"></a>00872             *ptbl = (u32) page;
<a name="l00873"></a>00873             ptbl++;
<a name="l00874"></a>00874             *ptbl = (u32) ((u64) page &gt;&gt; 32);
<a name="l00875"></a>00875             ptbl++;
<a name="l00876"></a>00876             page += PAGE_SIZE;
<a name="l00877"></a>00877         } <span class="keywordflow">else</span> {
<a name="l00878"></a>00878             <span class="comment">/* PTE is written in big endian format for</span>
<a name="l00879"></a>00879 <span class="comment">             * 5706/5708/5709 devices */</span>
<a name="l00880"></a>00880             *ptbl = (u32) ((u64) page &gt;&gt; 32);
<a name="l00881"></a>00881             ptbl++;
<a name="l00882"></a>00882             *ptbl = (u32) page;
<a name="l00883"></a>00883             ptbl++;
<a name="l00884"></a>00884             page += PAGE_SIZE;
<a name="l00885"></a>00885         }
<a name="l00886"></a>00886     }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888     <span class="comment">/* RQ page table */</span>
<a name="l00889"></a>00889     memset(ep-&gt;qp.rq_pgtbl_virt, 0, ep-&gt;qp.rq_pgtbl_size);
<a name="l00890"></a>00890     num_pages = ep-&gt;qp.rq_mem_size / PAGE_SIZE;
<a name="l00891"></a>00891     page = ep-&gt;qp.rq_phys;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893     <span class="keywordflow">if</span> (cnic_dev_10g)
<a name="l00894"></a>00894         ptbl = (u32 *)((u8 *)ep-&gt;qp.rq_pgtbl_virt + ISCSI_RQ_DB_SIZE);
<a name="l00895"></a>00895     <span class="keywordflow">else</span>
<a name="l00896"></a>00896         ptbl = (u32 *) ep-&gt;qp.rq_pgtbl_virt;
<a name="l00897"></a>00897     while (num_pages--) {
<a name="l00898"></a>00898         <span class="keywordflow">if</span> (cnic_dev_10g) {
<a name="l00899"></a>00899             <span class="comment">/* PTE is written in little endian format for 57710 */</span>
<a name="l00900"></a>00900             *ptbl = (u32) page;
<a name="l00901"></a>00901             ptbl++;
<a name="l00902"></a>00902             *ptbl = (u32) ((u64) page &gt;&gt; 32);
<a name="l00903"></a>00903             ptbl++;
<a name="l00904"></a>00904             page += PAGE_SIZE;
<a name="l00905"></a>00905         } <span class="keywordflow">else</span> {
<a name="l00906"></a>00906             <span class="comment">/* PTE is written in big endian format for</span>
<a name="l00907"></a>00907 <span class="comment">             * 5706/5708/5709 devices */</span>
<a name="l00908"></a>00908             *ptbl = (u32) ((u64) page &gt;&gt; 32);
<a name="l00909"></a>00909             ptbl++;
<a name="l00910"></a>00910             *ptbl = (u32) page;
<a name="l00911"></a>00911             ptbl++;
<a name="l00912"></a>00912             page += PAGE_SIZE;
<a name="l00913"></a>00913         }
<a name="l00914"></a>00914     }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     <span class="comment">/* CQ page table */</span>
<a name="l00917"></a>00917     memset(ep-&gt;qp.cq_pgtbl_virt, 0, ep-&gt;qp.cq_pgtbl_size);
<a name="l00918"></a>00918     num_pages = ep-&gt;qp.cq_mem_size / PAGE_SIZE;
<a name="l00919"></a>00919     page = ep-&gt;qp.cq_phys;
<a name="l00920"></a>00920 
<a name="l00921"></a>00921     <span class="keywordflow">if</span> (cnic_dev_10g)
<a name="l00922"></a>00922         ptbl = (u32 *)((u8 *)ep-&gt;qp.cq_pgtbl_virt + ISCSI_CQ_DB_SIZE);
<a name="l00923"></a>00923     <span class="keywordflow">else</span>
<a name="l00924"></a>00924         ptbl = (u32 *) ep-&gt;qp.cq_pgtbl_virt;
<a name="l00925"></a>00925     while (num_pages--) {
<a name="l00926"></a>00926         <span class="keywordflow">if</span> (cnic_dev_10g) {
<a name="l00927"></a>00927             <span class="comment">/* PTE is written in little endian format for 57710 */</span>
<a name="l00928"></a>00928             *ptbl = (u32) page;
<a name="l00929"></a>00929             ptbl++;
<a name="l00930"></a>00930             *ptbl = (u32) ((u64) page &gt;&gt; 32);
<a name="l00931"></a>00931             ptbl++;
<a name="l00932"></a>00932             page += PAGE_SIZE;
<a name="l00933"></a>00933         } <span class="keywordflow">else</span> {
<a name="l00934"></a>00934             <span class="comment">/* PTE is written in big endian format for</span>
<a name="l00935"></a>00935 <span class="comment">             * 5706/5708/5709 devices */</span>
<a name="l00936"></a>00936             *ptbl = (u32) ((u64) page &gt;&gt; 32);
<a name="l00937"></a>00937             ptbl++;
<a name="l00938"></a>00938             *ptbl = (u32) page;
<a name="l00939"></a>00939             ptbl++;
<a name="l00940"></a>00940             page += PAGE_SIZE;
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942     }
<a name="l00943"></a>00943 }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945 
<a name="l00956"></a>00956 <span class="keywordtype">int</span> bnx2i_alloc_qp_resc(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00957"></a>00957 {
<a name="l00958"></a>00958     <span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__cq__db.html">bnx2i_5771x_cq_db</a> *cq_db;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     ep-&gt;hba = hba;
<a name="l00961"></a>00961     ep-&gt;conn = NULL;
<a name="l00962"></a>00962     ep-&gt;ep_cid = ep-&gt;ep_iscsi_cid = ep-&gt;ep_pg_cid = 0;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     <span class="comment">/* Allocate page table memory for SQ which is page aligned */</span>
<a name="l00965"></a>00965     ep-&gt;qp.sq_mem_size = hba-&gt;max_sqes * BNX2I_SQ_WQE_SIZE;
<a name="l00966"></a>00966     ep-&gt;qp.sq_mem_size =
<a name="l00967"></a>00967         (ep-&gt;qp.sq_mem_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l00968"></a>00968     ep-&gt;qp.sq_pgtbl_size =
<a name="l00969"></a>00969         (ep-&gt;qp.sq_mem_size / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *);
<a name="l00970"></a>00970     ep-&gt;qp.sq_pgtbl_size =
<a name="l00971"></a>00971         (ep-&gt;qp.sq_pgtbl_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     ep-&gt;qp.sq_pgtbl_virt =
<a name="l00974"></a>00974         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.sq_pgtbl_size,
<a name="l00975"></a>00975                    &amp;ep-&gt;qp.sq_pgtbl_phys, GFP_KERNEL);
<a name="l00976"></a>00976     <span class="keywordflow">if</span> (!ep-&gt;qp.sq_pgtbl_virt) {
<a name="l00977"></a>00977         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unable to alloc SQ PT mem (%d)\n&quot;</span>,
<a name="l00978"></a>00978                   ep-&gt;qp.sq_pgtbl_size);
<a name="l00979"></a>00979         <span class="keywordflow">goto</span> mem_alloc_err;
<a name="l00980"></a>00980     }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982     <span class="comment">/* Allocate memory area for actual SQ element */</span>
<a name="l00983"></a>00983     ep-&gt;qp.sq_virt =
<a name="l00984"></a>00984         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.sq_mem_size,
<a name="l00985"></a>00985                    &amp;ep-&gt;qp.sq_phys, GFP_KERNEL);
<a name="l00986"></a>00986     <span class="keywordflow">if</span> (!ep-&gt;qp.sq_virt) {
<a name="l00987"></a>00987         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unable to alloc SQ BD memory %d\n&quot;</span>,
<a name="l00988"></a>00988                   ep-&gt;qp.sq_mem_size);
<a name="l00989"></a>00989         <span class="keywordflow">goto</span> mem_alloc_err;
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992     memset(ep-&gt;qp.sq_virt, 0x00, ep-&gt;qp.sq_mem_size);
<a name="l00993"></a>00993     ep-&gt;qp.sq_first_qe = ep-&gt;qp.sq_virt;
<a name="l00994"></a>00994     ep-&gt;qp.sq_prod_qe = ep-&gt;qp.sq_first_qe;
<a name="l00995"></a>00995     ep-&gt;qp.sq_cons_qe = ep-&gt;qp.sq_first_qe;
<a name="l00996"></a>00996     ep-&gt;qp.sq_last_qe = &amp;ep-&gt;qp.sq_first_qe[hba-&gt;max_sqes - 1];
<a name="l00997"></a>00997     ep-&gt;qp.sq_prod_idx = 0;
<a name="l00998"></a>00998     ep-&gt;qp.sq_cons_idx = 0;
<a name="l00999"></a>00999     ep-&gt;qp.sqe_left = hba-&gt;max_sqes;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001     <span class="comment">/* Allocate page table memory for CQ which is page aligned */</span>
<a name="l01002"></a>01002     ep-&gt;qp.cq_mem_size = hba-&gt;max_cqes * BNX2I_CQE_SIZE;
<a name="l01003"></a>01003     ep-&gt;qp.cq_mem_size =
<a name="l01004"></a>01004         (ep-&gt;qp.cq_mem_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l01005"></a>01005     ep-&gt;qp.cq_pgtbl_size =
<a name="l01006"></a>01006         (ep-&gt;qp.cq_mem_size / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *);
<a name="l01007"></a>01007     ep-&gt;qp.cq_pgtbl_size =
<a name="l01008"></a>01008         (ep-&gt;qp.cq_pgtbl_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l01009"></a>01009 
<a name="l01010"></a>01010     ep-&gt;qp.cq_pgtbl_virt =
<a name="l01011"></a>01011         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.cq_pgtbl_size,
<a name="l01012"></a>01012                    &amp;ep-&gt;qp.cq_pgtbl_phys, GFP_KERNEL);
<a name="l01013"></a>01013     <span class="keywordflow">if</span> (!ep-&gt;qp.cq_pgtbl_virt) {
<a name="l01014"></a>01014         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unable to alloc CQ PT memory %d\n&quot;</span>,
<a name="l01015"></a>01015                   ep-&gt;qp.cq_pgtbl_size);
<a name="l01016"></a>01016         <span class="keywordflow">goto</span> mem_alloc_err;
<a name="l01017"></a>01017     }
<a name="l01018"></a>01018 
<a name="l01019"></a>01019     <span class="comment">/* Allocate memory area for actual CQ element */</span>
<a name="l01020"></a>01020     ep-&gt;qp.cq_virt =
<a name="l01021"></a>01021         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.cq_mem_size,
<a name="l01022"></a>01022                    &amp;ep-&gt;qp.cq_phys, GFP_KERNEL);
<a name="l01023"></a>01023     <span class="keywordflow">if</span> (!ep-&gt;qp.cq_virt) {
<a name="l01024"></a>01024         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unable to alloc CQ BD memory %d\n&quot;</span>,
<a name="l01025"></a>01025                   ep-&gt;qp.cq_mem_size);
<a name="l01026"></a>01026         <span class="keywordflow">goto</span> mem_alloc_err;
<a name="l01027"></a>01027     }
<a name="l01028"></a>01028     memset(ep-&gt;qp.cq_virt, 0x00, ep-&gt;qp.cq_mem_size);
<a name="l01029"></a>01029 
<a name="l01030"></a>01030     ep-&gt;qp.cq_first_qe = ep-&gt;qp.cq_virt;
<a name="l01031"></a>01031     ep-&gt;qp.cq_prod_qe = ep-&gt;qp.cq_first_qe;
<a name="l01032"></a>01032     ep-&gt;qp.cq_cons_qe = ep-&gt;qp.cq_first_qe;
<a name="l01033"></a>01033     ep-&gt;qp.cq_last_qe = &amp;ep-&gt;qp.cq_first_qe[hba-&gt;max_cqes - 1];
<a name="l01034"></a>01034     ep-&gt;qp.cq_prod_idx = 0;
<a name="l01035"></a>01035     ep-&gt;qp.cq_cons_idx = 0;
<a name="l01036"></a>01036     ep-&gt;qp.cqe_left = hba-&gt;max_cqes;
<a name="l01037"></a>01037     ep-&gt;qp.cqe_exp_seq_sn = ISCSI_INITIAL_SN;
<a name="l01038"></a>01038     ep-&gt;qp.cqe_size = hba-&gt;max_cqes;
<a name="l01039"></a>01039 
<a name="l01040"></a>01040     <span class="comment">/* Invalidate all EQ CQE index, req only for 57710 */</span>
<a name="l01041"></a>01041     cq_db = (<span class="keyword">struct </span><a class="code" href="structbnx2i__5771x__cq__db.html">bnx2i_5771x_cq_db</a> *) ep-&gt;qp.cq_pgtbl_virt;
<a name="l01042"></a>01042     memset(cq_db-&gt;sqn, 0xFF, <span class="keyword">sizeof</span>(cq_db-&gt;sqn[0]) * BNX2X_MAX_CQS);
<a name="l01043"></a>01043 
<a name="l01044"></a>01044     <span class="comment">/* Allocate page table memory for RQ which is page aligned */</span>
<a name="l01045"></a>01045     ep-&gt;qp.rq_mem_size = hba-&gt;max_rqes * BNX2I_RQ_WQE_SIZE;
<a name="l01046"></a>01046     ep-&gt;qp.rq_mem_size =
<a name="l01047"></a>01047         (ep-&gt;qp.rq_mem_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l01048"></a>01048     ep-&gt;qp.rq_pgtbl_size =
<a name="l01049"></a>01049         (ep-&gt;qp.rq_mem_size / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *);
<a name="l01050"></a>01050     ep-&gt;qp.rq_pgtbl_size =
<a name="l01051"></a>01051         (ep-&gt;qp.rq_pgtbl_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l01052"></a>01052 
<a name="l01053"></a>01053     ep-&gt;qp.rq_pgtbl_virt =
<a name="l01054"></a>01054         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.rq_pgtbl_size,
<a name="l01055"></a>01055                    &amp;ep-&gt;qp.rq_pgtbl_phys, GFP_KERNEL);
<a name="l01056"></a>01056     <span class="keywordflow">if</span> (!ep-&gt;qp.rq_pgtbl_virt) {
<a name="l01057"></a>01057         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unable to alloc RQ PT mem %d\n&quot;</span>,
<a name="l01058"></a>01058                   ep-&gt;qp.rq_pgtbl_size);
<a name="l01059"></a>01059         <span class="keywordflow">goto</span> mem_alloc_err;
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061 
<a name="l01062"></a>01062     <span class="comment">/* Allocate memory area for actual RQ element */</span>
<a name="l01063"></a>01063     ep-&gt;qp.rq_virt =
<a name="l01064"></a>01064         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.rq_mem_size,
<a name="l01065"></a>01065                    &amp;ep-&gt;qp.rq_phys, GFP_KERNEL);
<a name="l01066"></a>01066     <span class="keywordflow">if</span> (!ep-&gt;qp.rq_virt) {
<a name="l01067"></a>01067         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unable to alloc RQ BD memory %d\n&quot;</span>,
<a name="l01068"></a>01068                   ep-&gt;qp.rq_mem_size);
<a name="l01069"></a>01069         <span class="keywordflow">goto</span> mem_alloc_err;
<a name="l01070"></a>01070     }
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     ep-&gt;qp.rq_first_qe = ep-&gt;qp.rq_virt;
<a name="l01073"></a>01073     ep-&gt;qp.rq_prod_qe = ep-&gt;qp.rq_first_qe;
<a name="l01074"></a>01074     ep-&gt;qp.rq_cons_qe = ep-&gt;qp.rq_first_qe;
<a name="l01075"></a>01075     ep-&gt;qp.rq_last_qe = &amp;ep-&gt;qp.rq_first_qe[hba-&gt;max_rqes - 1];
<a name="l01076"></a>01076     ep-&gt;qp.rq_prod_idx = 0x8000;
<a name="l01077"></a>01077     ep-&gt;qp.rq_cons_idx = 0;
<a name="l01078"></a>01078     ep-&gt;qp.rqe_left = hba-&gt;max_rqes;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080     setup_qp_page_tables(ep);
<a name="l01081"></a>01081 
<a name="l01082"></a>01082     <span class="keywordflow">return</span> 0;
<a name="l01083"></a>01083 
<a name="l01084"></a>01084 mem_alloc_err:
<a name="l01085"></a>01085     bnx2i_free_qp_resc(hba, ep);
<a name="l01086"></a>01086     <span class="keywordflow">return</span> -ENOMEM;
<a name="l01087"></a>01087 }
<a name="l01088"></a>01088 
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 
<a name="l01098"></a>01098 <span class="keywordtype">void</span> bnx2i_free_qp_resc(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l01099"></a>01099 {
<a name="l01100"></a>01100     <span class="keywordflow">if</span> (ep-&gt;qp.ctx_base) {
<a name="l01101"></a>01101         iounmap(ep-&gt;qp.ctx_base);
<a name="l01102"></a>01102         ep-&gt;qp.ctx_base = NULL;
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104     <span class="comment">/* Free SQ mem */</span>
<a name="l01105"></a>01105     <span class="keywordflow">if</span> (ep-&gt;qp.sq_pgtbl_virt) {
<a name="l01106"></a>01106         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.sq_pgtbl_size,
<a name="l01107"></a>01107                   ep-&gt;qp.sq_pgtbl_virt, ep-&gt;qp.sq_pgtbl_phys);
<a name="l01108"></a>01108         ep-&gt;qp.sq_pgtbl_virt = NULL;
<a name="l01109"></a>01109         ep-&gt;qp.sq_pgtbl_phys = 0;
<a name="l01110"></a>01110     }
<a name="l01111"></a>01111     <span class="keywordflow">if</span> (ep-&gt;qp.sq_virt) {
<a name="l01112"></a>01112         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.sq_mem_size,
<a name="l01113"></a>01113                   ep-&gt;qp.sq_virt, ep-&gt;qp.sq_phys);
<a name="l01114"></a>01114         ep-&gt;qp.sq_virt = NULL;
<a name="l01115"></a>01115         ep-&gt;qp.sq_phys = 0;
<a name="l01116"></a>01116     }
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     <span class="comment">/* Free RQ mem */</span>
<a name="l01119"></a>01119     <span class="keywordflow">if</span> (ep-&gt;qp.rq_pgtbl_virt) {
<a name="l01120"></a>01120         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.rq_pgtbl_size,
<a name="l01121"></a>01121                   ep-&gt;qp.rq_pgtbl_virt, ep-&gt;qp.rq_pgtbl_phys);
<a name="l01122"></a>01122         ep-&gt;qp.rq_pgtbl_virt = NULL;
<a name="l01123"></a>01123         ep-&gt;qp.rq_pgtbl_phys = 0;
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     <span class="keywordflow">if</span> (ep-&gt;qp.rq_virt) {
<a name="l01126"></a>01126         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.rq_mem_size,
<a name="l01127"></a>01127                   ep-&gt;qp.rq_virt, ep-&gt;qp.rq_phys);
<a name="l01128"></a>01128         ep-&gt;qp.rq_virt = NULL;
<a name="l01129"></a>01129         ep-&gt;qp.rq_phys = 0;
<a name="l01130"></a>01130     }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132     <span class="comment">/* Free CQ mem */</span>
<a name="l01133"></a>01133     <span class="keywordflow">if</span> (ep-&gt;qp.cq_pgtbl_virt) {
<a name="l01134"></a>01134         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.cq_pgtbl_size,
<a name="l01135"></a>01135                   ep-&gt;qp.cq_pgtbl_virt, ep-&gt;qp.cq_pgtbl_phys);
<a name="l01136"></a>01136         ep-&gt;qp.cq_pgtbl_virt = NULL;
<a name="l01137"></a>01137         ep-&gt;qp.cq_pgtbl_phys = 0;
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139     <span class="keywordflow">if</span> (ep-&gt;qp.cq_virt) {
<a name="l01140"></a>01140         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ep-&gt;qp.cq_mem_size,
<a name="l01141"></a>01141                   ep-&gt;qp.cq_virt, ep-&gt;qp.cq_phys);
<a name="l01142"></a>01142         ep-&gt;qp.cq_virt = NULL;
<a name="l01143"></a>01143         ep-&gt;qp.cq_phys = 0;
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145 }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147 
<a name="l01159"></a>01159 <span class="keywordtype">int</span> bnx2i_send_fw_iscsi_init_msg(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l01160"></a>01160 {
<a name="l01161"></a>01161     <span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *kwqe_arr[3];
<a name="l01162"></a>01162     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__init1.html">iscsi_kwqe_init1</a> iscsi_init;
<a name="l01163"></a>01163     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__init2.html">iscsi_kwqe_init2</a> iscsi_init2;
<a name="l01164"></a>01164     <span class="keywordtype">int</span> rc = 0;
<a name="l01165"></a>01165     u64 mask64;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167     bnx2i_adjust_qp_size(hba);
<a name="l01168"></a>01168 
<a name="l01169"></a>01169     iscsi_init.flags =
<a name="l01170"></a>01170         ISCSI_PAGE_SIZE_4K &lt;&lt; ISCSI_KWQE_INIT1_PAGE_SIZE_SHIFT;
<a name="l01171"></a>01171     <span class="keywordflow">if</span> (en_tcp_dack)
<a name="l01172"></a>01172         iscsi_init.flags |= ISCSI_KWQE_INIT1_DELAYED_ACK_ENABLE;
<a name="l01173"></a>01173     iscsi_init.reserved0 = 0;
<a name="l01174"></a>01174     iscsi_init.num_cqs = 1;
<a name="l01175"></a>01175     iscsi_init.hdr.op_code = ISCSI_KWQE_OPCODE_INIT1;
<a name="l01176"></a>01176     iscsi_init.hdr.flags =
<a name="l01177"></a>01177         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     iscsi_init.dummy_buffer_addr_lo = (u32) hba-&gt;dummy_buf_dma;
<a name="l01180"></a>01180     iscsi_init.dummy_buffer_addr_hi =
<a name="l01181"></a>01181         (u32) ((u64) hba-&gt;dummy_buf_dma &gt;&gt; 32);
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     hba-&gt;ctx_ccell_tasks =
<a name="l01184"></a>01184             ((hba-&gt;num_ccell &amp; 0xFFFF) | (hba-&gt;max_sqes &lt;&lt; 16));
<a name="l01185"></a>01185     iscsi_init.num_ccells_per_conn = hba-&gt;num_ccell;
<a name="l01186"></a>01186     iscsi_init.num_tasks_per_conn = hba-&gt;max_sqes;
<a name="l01187"></a>01187     iscsi_init.sq_wqes_per_page = PAGE_SIZE / BNX2I_SQ_WQE_SIZE;
<a name="l01188"></a>01188     iscsi_init.sq_num_wqes = hba-&gt;max_sqes;
<a name="l01189"></a>01189     iscsi_init.cq_log_wqes_per_page =
<a name="l01190"></a>01190         (u8) bnx2i_power_of2(PAGE_SIZE / BNX2I_CQE_SIZE);
<a name="l01191"></a>01191     iscsi_init.cq_num_wqes = hba-&gt;max_cqes;
<a name="l01192"></a>01192     iscsi_init.cq_num_pages = (hba-&gt;max_cqes * BNX2I_CQE_SIZE +
<a name="l01193"></a>01193                    (PAGE_SIZE - 1)) / PAGE_SIZE;
<a name="l01194"></a>01194     iscsi_init.sq_num_pages = (hba-&gt;max_sqes * BNX2I_SQ_WQE_SIZE +
<a name="l01195"></a>01195                    (PAGE_SIZE - 1)) / PAGE_SIZE;
<a name="l01196"></a>01196     iscsi_init.rq_buffer_size = BNX2I_RQ_WQE_SIZE;
<a name="l01197"></a>01197     iscsi_init.rq_num_wqes = hba-&gt;max_rqes;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199 
<a name="l01200"></a>01200     iscsi_init2.hdr.op_code = ISCSI_KWQE_OPCODE_INIT2;
<a name="l01201"></a>01201     iscsi_init2.hdr.flags =
<a name="l01202"></a>01202         (ISCSI_KWQE_LAYER_CODE &lt;&lt; ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);
<a name="l01203"></a>01203     iscsi_init2.max_cq_sqn = hba-&gt;max_cqes * 2 + 1;
<a name="l01204"></a>01204     mask64 = 0x0ULL;
<a name="l01205"></a>01205     mask64 |= (
<a name="l01206"></a>01206         <span class="comment">/* CISCO MDS */</span>
<a name="l01207"></a>01207         (1UL &lt;&lt;
<a name="l01208"></a>01208           ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_TTT_NOT_RSRV) |
<a name="l01209"></a>01209         <span class="comment">/* HP MSA1510i */</span>
<a name="l01210"></a>01210         (1UL &lt;&lt;
<a name="l01211"></a>01211           ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_EXP_DATASN) |
<a name="l01212"></a>01212         <span class="comment">/* EMC */</span>
<a name="l01213"></a>01213         (1ULL &lt;&lt; ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_LUN));
<a name="l01214"></a>01214     <span class="keywordflow">if</span> (error_mask1)
<a name="l01215"></a>01215         iscsi_init2.error_bit_map[0] = error_mask1;
<a name="l01216"></a>01216     <span class="keywordflow">else</span>
<a name="l01217"></a>01217         iscsi_init2.error_bit_map[0] = (u32) mask64;
<a name="l01218"></a>01218 
<a name="l01219"></a>01219     <span class="keywordflow">if</span> (error_mask2)
<a name="l01220"></a>01220         iscsi_init2.error_bit_map[1] = error_mask2;
<a name="l01221"></a>01221     <span class="keywordflow">else</span>
<a name="l01222"></a>01222         iscsi_init2.error_bit_map[1] = (u32) (mask64 &gt;&gt; 32);
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     iscsi_error_mask = mask64;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     kwqe_arr[0] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) &amp;iscsi_init;
<a name="l01227"></a>01227     kwqe_arr[1] = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *) &amp;iscsi_init2;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keywordflow">if</span> (hba-&gt;cnic &amp;&amp; hba-&gt;cnic-&gt;submit_kwqes)
<a name="l01230"></a>01230         rc = hba-&gt;cnic-&gt;submit_kwqes(hba-&gt;cnic, kwqe_arr, 2);
<a name="l01231"></a>01231     <span class="keywordflow">return</span> rc;
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 
<a name="l01242"></a>01242 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_process_scsi_cmd_resp(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01243"></a>01243                        <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01244"></a>01244                        <span class="keyword">struct</span> <a class="code" href="structcqe.html">cqe</a> *<a class="code" href="structcqe.html">cqe</a>)
<a name="l01245"></a>01245 {
<a name="l01246"></a>01246     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01247"></a>01247     <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd__response.html">bnx2i_cmd_response</a> *resp_cqe;
<a name="l01248"></a>01248     <span class="keyword">struct </span>bnx2i_cmd *bnx2i_cmd;
<a name="l01249"></a>01249     <span class="keyword">struct </span>iscsi_task *task;
<a name="l01250"></a>01250     <span class="keyword">struct </span>iscsi_cmd_rsp *hdr;
<a name="l01251"></a>01251     u32 data_len;
<a name="l01252"></a>01252 
<a name="l01253"></a>01253     resp_cqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__cmd__response.html">bnx2i_cmd_response</a> *)cqe;
<a name="l01254"></a>01254     spin_lock(&amp;session-&gt;lock);
<a name="l01255"></a>01255     task = iscsi_itt_to_task(conn,
<a name="l01256"></a>01256                  resp_cqe-&gt;itt &amp; ISCSI_CMD_RESPONSE_INDEX);
<a name="l01257"></a>01257     <span class="keywordflow">if</span> (!task)
<a name="l01258"></a>01258         <span class="keywordflow">goto</span> fail;
<a name="l01259"></a>01259 
<a name="l01260"></a>01260     bnx2i_cmd = task-&gt;dd_data;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     <span class="keywordflow">if</span> (bnx2i_cmd-&gt;req.op_attr &amp; ISCSI_CMD_REQUEST_READ) {
<a name="l01263"></a>01263         conn-&gt;datain_pdus_cnt +=
<a name="l01264"></a>01264             resp_cqe-&gt;task_stat.read_stat.num_data_outs;
<a name="l01265"></a>01265         conn-&gt;rxdata_octets +=
<a name="l01266"></a>01266             bnx2i_cmd-&gt;req.total_data_transfer_length;
<a name="l01267"></a>01267     } <span class="keywordflow">else</span> {
<a name="l01268"></a>01268         conn-&gt;dataout_pdus_cnt +=
<a name="l01269"></a>01269             resp_cqe-&gt;task_stat.read_stat.num_data_outs;
<a name="l01270"></a>01270         conn-&gt;r2t_pdus_cnt +=
<a name="l01271"></a>01271             resp_cqe-&gt;task_stat.read_stat.num_r2ts;
<a name="l01272"></a>01272         conn-&gt;txdata_octets +=
<a name="l01273"></a>01273             bnx2i_cmd-&gt;req.total_data_transfer_length;
<a name="l01274"></a>01274     }
<a name="l01275"></a>01275     bnx2i_iscsi_unmap_sg_list(bnx2i_cmd);
<a name="l01276"></a>01276 
<a name="l01277"></a>01277     hdr = (<span class="keyword">struct </span>iscsi_cmd_rsp *)task-&gt;hdr;
<a name="l01278"></a>01278     resp_cqe = (<span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd__response.html">bnx2i_cmd_response</a> *)cqe;
<a name="l01279"></a>01279     hdr-&gt;opcode = resp_cqe-&gt;op_code;
<a name="l01280"></a>01280     hdr-&gt;max_cmdsn = cpu_to_be32(resp_cqe-&gt;max_cmd_sn);
<a name="l01281"></a>01281     hdr-&gt;exp_cmdsn = cpu_to_be32(resp_cqe-&gt;exp_cmd_sn);
<a name="l01282"></a>01282     hdr-&gt;response = resp_cqe-&gt;response;
<a name="l01283"></a>01283     hdr-&gt;cmd_status = resp_cqe-&gt;status;
<a name="l01284"></a>01284     hdr-&gt;flags = resp_cqe-&gt;response_flags;
<a name="l01285"></a>01285     hdr-&gt;residual_count = cpu_to_be32(resp_cqe-&gt;residual_count);
<a name="l01286"></a>01286 
<a name="l01287"></a>01287     <span class="keywordflow">if</span> (resp_cqe-&gt;op_code == ISCSI_OP_SCSI_DATA_IN)
<a name="l01288"></a>01288         <span class="keywordflow">goto</span> done;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290     <span class="keywordflow">if</span> (resp_cqe-&gt;status) {
<a name="l01291"></a>01291         data_len = resp_cqe-&gt;data_length;
<a name="l01292"></a>01292         <span class="keywordflow">if</span> (!data_len) {
<a name="l01293"></a>01293             <span class="comment">/* CHK_CONDITION len is qualify in libiscsi */</span>
<a name="l01294"></a>01294             <span class="keywordflow">goto</span> done;
<a name="l01295"></a>01295         }
<a name="l01296"></a>01296         <span class="keywordflow">if</span> (data_len &gt; BNX2I_RQ_WQE_SIZE) {
<a name="l01297"></a>01297             iscsi_conn_printk(KERN_ERR, conn,
<a name="l01298"></a>01298                       <span class="stringliteral">&quot;sense data len %d &gt; RQ sz\n&quot;</span>,
<a name="l01299"></a>01299                       data_len);
<a name="l01300"></a>01300             data_len = BNX2I_RQ_WQE_SIZE;
<a name="l01301"></a>01301         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (data_len &gt; ISCSI_DEF_MAX_RECV_SEG_LEN) {
<a name="l01302"></a>01302             iscsi_conn_printk(KERN_ERR, conn,
<a name="l01303"></a>01303                       <span class="stringliteral">&quot;sense data len %d &gt; conn data\n&quot;</span>,
<a name="l01304"></a>01304                       data_len);
<a name="l01305"></a>01305             data_len = ISCSI_DEF_MAX_RECV_SEG_LEN;
<a name="l01306"></a>01306         }
<a name="l01307"></a>01307         <span class="comment">/* Must consume RQ entry for all data_len &gt; 0 */</span>
<a name="l01308"></a>01308         bnx2i_get_rq_buf(bnx2i_cmd-&gt;conn, conn-&gt;data, data_len);
<a name="l01309"></a>01309         bnx2i_put_rq_buf(bnx2i_cmd-&gt;conn, 1);
<a name="l01310"></a>01310     }
<a name="l01311"></a>01311 done:
<a name="l01312"></a>01312     __iscsi_complete_pdu(conn, (<span class="keyword">struct</span> iscsi_hdr *)hdr,
<a name="l01313"></a>01313                  conn-&gt;data, data_len);
<a name="l01314"></a>01314 fail:
<a name="l01315"></a>01315     spin_unlock(&amp;session-&gt;lock);
<a name="l01316"></a>01316     <span class="keywordflow">return</span> 0;
<a name="l01317"></a>01317 }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319 
<a name="l01328"></a>01328 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_process_login_resp(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01329"></a>01329                     <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01330"></a>01330                     <span class="keyword">struct</span> cqe *cqe)
<a name="l01331"></a>01331 {
<a name="l01332"></a>01332     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01333"></a>01333     <span class="keyword">struct </span>iscsi_task *task;
<a name="l01334"></a>01334     <span class="keyword">struct </span><a class="code" href="structbnx2i__login__response.html">bnx2i_login_response</a> *login;
<a name="l01335"></a>01335     <span class="keyword">struct </span>iscsi_login_rsp *resp_hdr;
<a name="l01336"></a>01336     <span class="keywordtype">int</span> pld_len;
<a name="l01337"></a>01337     <span class="keywordtype">int</span> pad_len;
<a name="l01338"></a>01338 
<a name="l01339"></a>01339     login = (<span class="keyword">struct </span><a class="code" href="structbnx2i__login__response.html">bnx2i_login_response</a> *) cqe;
<a name="l01340"></a>01340     spin_lock(&amp;session-&gt;lock);
<a name="l01341"></a>01341     task = iscsi_itt_to_task(conn,
<a name="l01342"></a>01342                  login-&gt;itt &amp; ISCSI_LOGIN_RESPONSE_INDEX);
<a name="l01343"></a>01343     <span class="keywordflow">if</span> (!task)
<a name="l01344"></a>01344         <span class="keywordflow">goto</span> done;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346     resp_hdr = (<span class="keyword">struct </span>iscsi_login_rsp *) &amp;bnx2i_conn-&gt;gen_pdu.resp_hdr;
<a name="l01347"></a>01347     memset(resp_hdr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iscsi_hdr));
<a name="l01348"></a>01348     resp_hdr-&gt;opcode = login-&gt;op_code;
<a name="l01349"></a>01349     resp_hdr-&gt;flags = login-&gt;response_flags;
<a name="l01350"></a>01350     resp_hdr-&gt;max_version = login-&gt;version_max;
<a name="l01351"></a>01351     resp_hdr-&gt;active_version = login-&gt;version_active;;
<a name="l01352"></a>01352     resp_hdr-&gt;hlength = 0;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354     hton24(resp_hdr-&gt;dlength, login-&gt;data_length);
<a name="l01355"></a>01355     memcpy(resp_hdr-&gt;isid, &amp;login-&gt;isid_lo, 6);
<a name="l01356"></a>01356     resp_hdr-&gt;tsih = cpu_to_be16(login-&gt;tsih);
<a name="l01357"></a>01357     resp_hdr-&gt;itt = task-&gt;hdr-&gt;itt;
<a name="l01358"></a>01358     resp_hdr-&gt;statsn = cpu_to_be32(login-&gt;stat_sn);
<a name="l01359"></a>01359     resp_hdr-&gt;exp_cmdsn = cpu_to_be32(login-&gt;exp_cmd_sn);
<a name="l01360"></a>01360     resp_hdr-&gt;max_cmdsn = cpu_to_be32(login-&gt;max_cmd_sn);
<a name="l01361"></a>01361     resp_hdr-&gt;status_class = login-&gt;status_class;
<a name="l01362"></a>01362     resp_hdr-&gt;status_detail = login-&gt;status_detail;
<a name="l01363"></a>01363     pld_len = login-&gt;data_length;
<a name="l01364"></a>01364     bnx2i_conn-&gt;gen_pdu.resp_wr_ptr =
<a name="l01365"></a>01365                     bnx2i_conn-&gt;gen_pdu.resp_buf + pld_len;
<a name="l01366"></a>01366 
<a name="l01367"></a>01367     pad_len = 0;
<a name="l01368"></a>01368     <span class="keywordflow">if</span> (pld_len &amp; 0x3)
<a name="l01369"></a>01369         pad_len = 4 - (pld_len % 4);
<a name="l01370"></a>01370 
<a name="l01371"></a>01371     <span class="keywordflow">if</span> (pad_len) {
<a name="l01372"></a>01372         <span class="keywordtype">int</span> i = 0;
<a name="l01373"></a>01373         <span class="keywordflow">for</span> (i = 0; i &lt; pad_len; i++) {
<a name="l01374"></a>01374             bnx2i_conn-&gt;gen_pdu.resp_wr_ptr[0] = 0;
<a name="l01375"></a>01375             bnx2i_conn-&gt;gen_pdu.resp_wr_ptr++;
<a name="l01376"></a>01376         }
<a name="l01377"></a>01377     }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 
<a name="l01380"></a>01380     __iscsi_complete_pdu(conn, (<span class="keyword">struct</span> iscsi_hdr *)resp_hdr,
<a name="l01381"></a>01381         bnx2i_conn-&gt;gen_pdu.resp_buf,
<a name="l01382"></a>01382         bnx2i_conn-&gt;gen_pdu.resp_wr_ptr - bnx2i_conn-&gt;gen_pdu.resp_buf);
<a name="l01383"></a>01383 done:
<a name="l01384"></a>01384     spin_unlock(&amp;session-&gt;lock);
<a name="l01385"></a>01385     <span class="keywordflow">return</span> 0;
<a name="l01386"></a>01386 }
<a name="l01387"></a>01387 
<a name="l01396"></a>01396 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_process_tmf_resp(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01397"></a>01397                   <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01398"></a>01398                   <span class="keyword">struct</span> cqe *cqe)
<a name="l01399"></a>01399 {
<a name="l01400"></a>01400     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01401"></a>01401     <span class="keyword">struct </span>iscsi_task *task;
<a name="l01402"></a>01402     <span class="keyword">struct </span><a class="code" href="structbnx2i__tmf__response.html">bnx2i_tmf_response</a> *tmf_cqe;
<a name="l01403"></a>01403     <span class="keyword">struct </span>iscsi_tm_rsp *resp_hdr;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405     tmf_cqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__tmf__response.html">bnx2i_tmf_response</a> *)cqe;
<a name="l01406"></a>01406     spin_lock(&amp;session-&gt;lock);
<a name="l01407"></a>01407     task = iscsi_itt_to_task(conn,
<a name="l01408"></a>01408                  tmf_cqe-&gt;itt &amp; ISCSI_TMF_RESPONSE_INDEX);
<a name="l01409"></a>01409     <span class="keywordflow">if</span> (!task)
<a name="l01410"></a>01410         <span class="keywordflow">goto</span> done;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412     resp_hdr = (<span class="keyword">struct </span>iscsi_tm_rsp *) &amp;bnx2i_conn-&gt;gen_pdu.resp_hdr;
<a name="l01413"></a>01413     memset(resp_hdr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iscsi_hdr));
<a name="l01414"></a>01414     resp_hdr-&gt;opcode = tmf_cqe-&gt;op_code;
<a name="l01415"></a>01415     resp_hdr-&gt;max_cmdsn = cpu_to_be32(tmf_cqe-&gt;max_cmd_sn);
<a name="l01416"></a>01416     resp_hdr-&gt;exp_cmdsn = cpu_to_be32(tmf_cqe-&gt;exp_cmd_sn);
<a name="l01417"></a>01417     resp_hdr-&gt;itt = task-&gt;hdr-&gt;itt;
<a name="l01418"></a>01418     resp_hdr-&gt;response = tmf_cqe-&gt;response;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420     __iscsi_complete_pdu(conn, (<span class="keyword">struct</span> iscsi_hdr *)resp_hdr, NULL, 0);
<a name="l01421"></a>01421 done:
<a name="l01422"></a>01422     spin_unlock(&amp;session-&gt;lock);
<a name="l01423"></a>01423     <span class="keywordflow">return</span> 0;
<a name="l01424"></a>01424 }
<a name="l01425"></a>01425 
<a name="l01435"></a>01435 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_process_logout_resp(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01436"></a>01436                      <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01437"></a>01437                      <span class="keyword">struct</span> cqe *cqe)
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01440"></a>01440     <span class="keyword">struct </span>iscsi_task *task;
<a name="l01441"></a>01441     <span class="keyword">struct </span><a class="code" href="structbnx2i__logout__response.html">bnx2i_logout_response</a> *logout;
<a name="l01442"></a>01442     <span class="keyword">struct </span>iscsi_logout_rsp *resp_hdr;
<a name="l01443"></a>01443 
<a name="l01444"></a>01444     logout = (<span class="keyword">struct </span><a class="code" href="structbnx2i__logout__response.html">bnx2i_logout_response</a> *) cqe;
<a name="l01445"></a>01445     spin_lock(&amp;session-&gt;lock);
<a name="l01446"></a>01446     task = iscsi_itt_to_task(conn,
<a name="l01447"></a>01447                  logout-&gt;itt &amp; ISCSI_LOGOUT_RESPONSE_INDEX);
<a name="l01448"></a>01448     <span class="keywordflow">if</span> (!task)
<a name="l01449"></a>01449         <span class="keywordflow">goto</span> done;
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     resp_hdr = (<span class="keyword">struct </span>iscsi_logout_rsp *) &amp;bnx2i_conn-&gt;gen_pdu.resp_hdr;
<a name="l01452"></a>01452     memset(resp_hdr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iscsi_hdr));
<a name="l01453"></a>01453     resp_hdr-&gt;opcode = logout-&gt;op_code;
<a name="l01454"></a>01454     resp_hdr-&gt;flags = logout-&gt;response;
<a name="l01455"></a>01455     resp_hdr-&gt;hlength = 0;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457     resp_hdr-&gt;itt = task-&gt;hdr-&gt;itt;
<a name="l01458"></a>01458     resp_hdr-&gt;statsn = task-&gt;hdr-&gt;exp_statsn;
<a name="l01459"></a>01459     resp_hdr-&gt;exp_cmdsn = cpu_to_be32(logout-&gt;exp_cmd_sn);
<a name="l01460"></a>01460     resp_hdr-&gt;max_cmdsn = cpu_to_be32(logout-&gt;max_cmd_sn);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462     resp_hdr-&gt;t2wait = cpu_to_be32(logout-&gt;time_to_wait);
<a name="l01463"></a>01463     resp_hdr-&gt;t2retain = cpu_to_be32(logout-&gt;time_to_retain);
<a name="l01464"></a>01464 
<a name="l01465"></a>01465     __iscsi_complete_pdu(conn, (<span class="keyword">struct</span> iscsi_hdr *)resp_hdr, NULL, 0);
<a name="l01466"></a>01466 done:
<a name="l01467"></a>01467     spin_unlock(&amp;session-&gt;lock);
<a name="l01468"></a>01468     <span class="keywordflow">return</span> 0;
<a name="l01469"></a>01469 }
<a name="l01470"></a>01470 
<a name="l01479"></a>01479 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_nopin_local_cmpl(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01480"></a>01480                        <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01481"></a>01481                        <span class="keyword">struct</span> cqe *cqe)
<a name="l01482"></a>01482 {
<a name="l01483"></a>01483     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01484"></a>01484     <span class="keyword">struct </span><a class="code" href="structbnx2i__nop__in__msg.html">bnx2i_nop_in_msg</a> *nop_in;
<a name="l01485"></a>01485     <span class="keyword">struct </span>iscsi_task *task;
<a name="l01486"></a>01486 
<a name="l01487"></a>01487     nop_in = (<span class="keyword">struct </span><a class="code" href="structbnx2i__nop__in__msg.html">bnx2i_nop_in_msg</a> *)cqe;
<a name="l01488"></a>01488     spin_lock(&amp;session-&gt;lock);
<a name="l01489"></a>01489     task = iscsi_itt_to_task(conn,
<a name="l01490"></a>01490                  nop_in-&gt;itt &amp; ISCSI_NOP_IN_MSG_INDEX);
<a name="l01491"></a>01491     <span class="keywordflow">if</span> (task)
<a name="l01492"></a>01492         iscsi_put_task(task);
<a name="l01493"></a>01493     spin_unlock(&amp;session-&gt;lock);
<a name="l01494"></a>01494 }
<a name="l01495"></a>01495 
<a name="l01504"></a>01504 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_unsol_pdu_adjust_rq(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn)
<a name="l01505"></a>01505 {
<a name="l01506"></a>01506     <span class="keywordtype">char</span> dummy_rq_data[2];
<a name="l01507"></a>01507     bnx2i_get_rq_buf(bnx2i_conn, dummy_rq_data, 1);
<a name="l01508"></a>01508     bnx2i_put_rq_buf(bnx2i_conn, 1);
<a name="l01509"></a>01509 }
<a name="l01510"></a>01510 
<a name="l01511"></a>01511 
<a name="l01520"></a>01520 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_process_nopin_mesg(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01521"></a>01521                      <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01522"></a>01522                      <span class="keyword">struct</span> cqe *cqe)
<a name="l01523"></a>01523 {
<a name="l01524"></a>01524     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01525"></a>01525     <span class="keyword">struct </span>iscsi_task *task;
<a name="l01526"></a>01526     <span class="keyword">struct </span><a class="code" href="structbnx2i__nop__in__msg.html">bnx2i_nop_in_msg</a> *nop_in;
<a name="l01527"></a>01527     <span class="keyword">struct </span>iscsi_nopin *hdr;
<a name="l01528"></a>01528     u32 itt;
<a name="l01529"></a>01529     <span class="keywordtype">int</span> tgt_async_nop = 0;
<a name="l01530"></a>01530 
<a name="l01531"></a>01531     nop_in = (<span class="keyword">struct </span><a class="code" href="structbnx2i__nop__in__msg.html">bnx2i_nop_in_msg</a> *)cqe;
<a name="l01532"></a>01532     itt = nop_in-&gt;itt &amp; ISCSI_NOP_IN_MSG_INDEX;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     spin_lock(&amp;session-&gt;lock);
<a name="l01535"></a>01535     hdr = (<span class="keyword">struct </span>iscsi_nopin *)&amp;bnx2i_conn-&gt;gen_pdu.resp_hdr;
<a name="l01536"></a>01536     memset(hdr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iscsi_hdr));
<a name="l01537"></a>01537     hdr-&gt;opcode = nop_in-&gt;op_code;
<a name="l01538"></a>01538     hdr-&gt;max_cmdsn = cpu_to_be32(nop_in-&gt;max_cmd_sn);
<a name="l01539"></a>01539     hdr-&gt;exp_cmdsn = cpu_to_be32(nop_in-&gt;exp_cmd_sn);
<a name="l01540"></a>01540     hdr-&gt;ttt = cpu_to_be32(nop_in-&gt;ttt);
<a name="l01541"></a>01541 
<a name="l01542"></a>01542     <span class="keywordflow">if</span> (itt == (u16) RESERVED_ITT) {
<a name="l01543"></a>01543         bnx2i_unsol_pdu_adjust_rq(bnx2i_conn);
<a name="l01544"></a>01544         hdr-&gt;itt = RESERVED_ITT;
<a name="l01545"></a>01545         tgt_async_nop = 1;
<a name="l01546"></a>01546         <span class="keywordflow">goto</span> done;
<a name="l01547"></a>01547     }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     <span class="comment">/* this is a response to one of our nop-outs */</span>
<a name="l01550"></a>01550     task = iscsi_itt_to_task(conn, itt);
<a name="l01551"></a>01551     <span class="keywordflow">if</span> (task) {
<a name="l01552"></a>01552         hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
<a name="l01553"></a>01553         hdr-&gt;itt = task-&gt;hdr-&gt;itt;
<a name="l01554"></a>01554         hdr-&gt;ttt = cpu_to_be32(nop_in-&gt;ttt);
<a name="l01555"></a>01555         memcpy(hdr-&gt;lun, nop_in-&gt;lun, 8);
<a name="l01556"></a>01556     }
<a name="l01557"></a>01557 done:
<a name="l01558"></a>01558     __iscsi_complete_pdu(conn, (<span class="keyword">struct</span> iscsi_hdr *)hdr, NULL, 0);
<a name="l01559"></a>01559     spin_unlock(&amp;session-&gt;lock);
<a name="l01560"></a>01560 
<a name="l01561"></a>01561     <span class="keywordflow">return</span> tgt_async_nop;
<a name="l01562"></a>01562 }
<a name="l01563"></a>01563 
<a name="l01564"></a>01564 
<a name="l01573"></a>01573 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_async_mesg(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01574"></a>01574                      <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01575"></a>01575                      <span class="keyword">struct</span> cqe *cqe)
<a name="l01576"></a>01576 {
<a name="l01577"></a>01577     <span class="keyword">struct </span><a class="code" href="structbnx2i__async__msg.html">bnx2i_async_msg</a> *async_cqe;
<a name="l01578"></a>01578     <span class="keyword">struct </span>iscsi_async *resp_hdr;
<a name="l01579"></a>01579     u8 async_event;
<a name="l01580"></a>01580 
<a name="l01581"></a>01581     bnx2i_unsol_pdu_adjust_rq(bnx2i_conn);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583     async_cqe = (<span class="keyword">struct </span><a class="code" href="structbnx2i__async__msg.html">bnx2i_async_msg</a> *)cqe;
<a name="l01584"></a>01584     async_event = async_cqe-&gt;async_event;
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     <span class="keywordflow">if</span> (async_event == ISCSI_ASYNC_MSG_SCSI_EVENT) {
<a name="l01587"></a>01587         <span class="comment">/* TODO mnc - can&#39;t we just copy the scsi sense buffer</span>
<a name="l01588"></a>01588 <span class="comment">         * to the conn-&gt;data buffer</span>
<a name="l01589"></a>01589 <span class="comment">         * Anil - currently there is no interface to push this</span>
<a name="l01590"></a>01590 <span class="comment">         *    up to SCSI layer. So far we have not seen any</span>
<a name="l01591"></a>01591 <span class="comment">         *    target generating one. So could be one those</span>
<a name="l01592"></a>01592 <span class="comment">         *    fancy unused feature</span>
<a name="l01593"></a>01593 <span class="comment">         *</span>
<a name="l01594"></a>01594 <span class="comment">         * For iser/tcp we pass this to libiscsi which does</span>
<a name="l01595"></a>01595 <span class="comment">         * iscsi_recv_pdu to send it to userspace.</span>
<a name="l01596"></a>01596 <span class="comment">         *</span>
<a name="l01597"></a>01597 <span class="comment">         * This event is used by Cisco to signal that a lun</span>
<a name="l01598"></a>01598 <span class="comment">         * has been added or removed. It is also used by</span>
<a name="l01599"></a>01599 <span class="comment">         * EMC celerra or centerra boxes, and EMC will ping</span>
<a name="l01600"></a>01600 <span class="comment">         * you one day :), so we have to do something.</span>
<a name="l01601"></a>01601 <span class="comment">         */</span>
<a name="l01602"></a>01602         iscsi_conn_printk(KERN_ALERT, bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l01603"></a>01603                   <span class="stringliteral">&quot;async: scsi events not supported\n&quot;</span>);
<a name="l01604"></a>01604         <span class="keywordflow">return</span>;
<a name="l01605"></a>01605     }
<a name="l01606"></a>01606 
<a name="l01607"></a>01607     spin_lock(&amp;session-&gt;lock);
<a name="l01608"></a>01608     resp_hdr = (<span class="keyword">struct </span>iscsi_async *) &amp;bnx2i_conn-&gt;gen_pdu.resp_hdr;
<a name="l01609"></a>01609     memset(resp_hdr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iscsi_hdr));
<a name="l01610"></a>01610     resp_hdr-&gt;opcode = async_cqe-&gt;op_code;
<a name="l01611"></a>01611     resp_hdr-&gt;flags = 0x80;
<a name="l01612"></a>01612 
<a name="l01613"></a>01613     memcpy(resp_hdr-&gt;lun, async_cqe-&gt;lun, 8);
<a name="l01614"></a>01614     resp_hdr-&gt;exp_cmdsn = cpu_to_be32(async_cqe-&gt;exp_cmd_sn);
<a name="l01615"></a>01615     resp_hdr-&gt;max_cmdsn = cpu_to_be32(async_cqe-&gt;max_cmd_sn);
<a name="l01616"></a>01616 
<a name="l01617"></a>01617     resp_hdr-&gt;async_event = async_cqe-&gt;async_event;
<a name="l01618"></a>01618     resp_hdr-&gt;async_vcode = async_cqe-&gt;async_vcode;
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     resp_hdr-&gt;param1 = cpu_to_be16(async_cqe-&gt;param1);
<a name="l01621"></a>01621     resp_hdr-&gt;param2 = cpu_to_be16(async_cqe-&gt;param2);
<a name="l01622"></a>01622     resp_hdr-&gt;param3 = cpu_to_be16(async_cqe-&gt;param3);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624     __iscsi_complete_pdu(bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l01625"></a>01625                  (<span class="keyword">struct</span> iscsi_hdr *)resp_hdr, NULL, 0);
<a name="l01626"></a>01626     spin_unlock(&amp;session-&gt;lock);
<a name="l01627"></a>01627 }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 
<a name="l01638"></a>01638 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_reject_mesg(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01639"></a>01639                       <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01640"></a>01640                       <span class="keyword">struct</span> cqe *cqe)
<a name="l01641"></a>01641 {
<a name="l01642"></a>01642     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01643"></a>01643     <span class="keyword">struct </span><a class="code" href="structbnx2i__reject__msg.html">bnx2i_reject_msg</a> *reject;
<a name="l01644"></a>01644     <span class="keyword">struct </span>iscsi_reject *hdr;
<a name="l01645"></a>01645 
<a name="l01646"></a>01646     reject = (<span class="keyword">struct </span><a class="code" href="structbnx2i__reject__msg.html">bnx2i_reject_msg</a> *) cqe;
<a name="l01647"></a>01647     <span class="keywordflow">if</span> (reject-&gt;data_length) {
<a name="l01648"></a>01648         bnx2i_get_rq_buf(bnx2i_conn, conn-&gt;data, reject-&gt;data_length);
<a name="l01649"></a>01649         bnx2i_put_rq_buf(bnx2i_conn, 1);
<a name="l01650"></a>01650     } <span class="keywordflow">else</span>
<a name="l01651"></a>01651         bnx2i_unsol_pdu_adjust_rq(bnx2i_conn);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653     spin_lock(&amp;session-&gt;lock);
<a name="l01654"></a>01654     hdr = (<span class="keyword">struct </span>iscsi_reject *) &amp;bnx2i_conn-&gt;gen_pdu.resp_hdr;
<a name="l01655"></a>01655     memset(hdr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iscsi_hdr));
<a name="l01656"></a>01656     hdr-&gt;opcode = reject-&gt;op_code;
<a name="l01657"></a>01657     hdr-&gt;reason = reject-&gt;reason;
<a name="l01658"></a>01658     hton24(hdr-&gt;dlength, reject-&gt;data_length);
<a name="l01659"></a>01659     hdr-&gt;max_cmdsn = cpu_to_be32(reject-&gt;max_cmd_sn);
<a name="l01660"></a>01660     hdr-&gt;exp_cmdsn = cpu_to_be32(reject-&gt;exp_cmd_sn);
<a name="l01661"></a>01661     hdr-&gt;ffffffff = cpu_to_be32(RESERVED_ITT);
<a name="l01662"></a>01662     __iscsi_complete_pdu(conn, (<span class="keyword">struct</span> iscsi_hdr *)hdr, conn-&gt;data,
<a name="l01663"></a>01663                  reject-&gt;data_length);
<a name="l01664"></a>01664     spin_unlock(&amp;session-&gt;lock);
<a name="l01665"></a>01665 }
<a name="l01666"></a>01666 
<a name="l01675"></a>01675 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_cmd_cleanup_resp(<span class="keyword">struct</span> iscsi_session *session,
<a name="l01676"></a>01676                        <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn,
<a name="l01677"></a>01677                        <span class="keyword">struct</span> cqe *cqe)
<a name="l01678"></a>01678 {
<a name="l01679"></a>01679     <span class="keyword">struct </span><a class="code" href="structbnx2i__cleanup__response.html">bnx2i_cleanup_response</a> *cmd_clean_rsp;
<a name="l01680"></a>01680     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01681"></a>01681     <span class="keyword">struct </span>iscsi_task *task;
<a name="l01682"></a>01682 
<a name="l01683"></a>01683     cmd_clean_rsp = (<span class="keyword">struct </span><a class="code" href="structbnx2i__cleanup__response.html">bnx2i_cleanup_response</a> *)cqe;
<a name="l01684"></a>01684     spin_lock(&amp;session-&gt;lock);
<a name="l01685"></a>01685     task = iscsi_itt_to_task(conn,
<a name="l01686"></a>01686             cmd_clean_rsp-&gt;itt &amp; ISCSI_CLEANUP_RESPONSE_INDEX);
<a name="l01687"></a>01687     <span class="keywordflow">if</span> (!task)
<a name="l01688"></a>01688         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: cmd clean ITT %x not active\n&quot;</span>,
<a name="l01689"></a>01689             cmd_clean_rsp-&gt;itt &amp; ISCSI_CLEANUP_RESPONSE_INDEX);
<a name="l01690"></a>01690     spin_unlock(&amp;session-&gt;lock);
<a name="l01691"></a>01691     complete(&amp;bnx2i_conn-&gt;cmd_cleanup_cmpl);
<a name="l01692"></a>01692 }
<a name="l01693"></a>01693 
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 
<a name="l01702"></a>01702 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_new_cqes(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn)
<a name="l01703"></a>01703 {
<a name="l01704"></a>01704     <span class="keyword">struct </span>iscsi_conn *conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01705"></a>01705     <span class="keyword">struct </span>iscsi_session *session = conn-&gt;session;
<a name="l01706"></a>01706     <span class="keyword">struct </span><a class="code" href="structqp__info.html">qp_info</a> *qp = &amp;bnx2i_conn-&gt;ep-&gt;qp;
<a name="l01707"></a>01707     <span class="keyword">struct </span><a class="code" href="structbnx2i__nop__in__msg.html">bnx2i_nop_in_msg</a> *nopin;
<a name="l01708"></a>01708     <span class="keywordtype">int</span> tgt_async_msg;
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     <span class="keywordflow">while</span> (1) {
<a name="l01711"></a>01711         nopin = (<span class="keyword">struct </span><a class="code" href="structbnx2i__nop__in__msg.html">bnx2i_nop_in_msg</a> *) qp-&gt;cq_cons_qe;
<a name="l01712"></a>01712         if (nopin-&gt;cq_req_sn != qp-&gt;cqe_exp_seq_sn)
<a name="l01713"></a>01713             <span class="keywordflow">break</span>;
<a name="l01714"></a>01714 
<a name="l01715"></a>01715         <span class="keywordflow">if</span> (unlikely(test_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx)))
<a name="l01716"></a>01716             <span class="keywordflow">break</span>;
<a name="l01717"></a>01717 
<a name="l01718"></a>01718         tgt_async_msg = 0;
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         <span class="keywordflow">switch</span> (nopin-&gt;op_code) {
<a name="l01721"></a>01721         <span class="keywordflow">case</span> ISCSI_OP_SCSI_CMD_RSP:
<a name="l01722"></a>01722         <span class="keywordflow">case</span> ISCSI_OP_SCSI_DATA_IN:
<a name="l01723"></a>01723             bnx2i_process_scsi_cmd_resp(session, bnx2i_conn,
<a name="l01724"></a>01724                             qp-&gt;cq_cons_qe);
<a name="l01725"></a>01725             <span class="keywordflow">break</span>;
<a name="l01726"></a>01726         <span class="keywordflow">case</span> ISCSI_OP_LOGIN_RSP:
<a name="l01727"></a>01727             bnx2i_process_login_resp(session, bnx2i_conn,
<a name="l01728"></a>01728                          qp-&gt;cq_cons_qe);
<a name="l01729"></a>01729             <span class="keywordflow">break</span>;
<a name="l01730"></a>01730         <span class="keywordflow">case</span> ISCSI_OP_SCSI_TMFUNC_RSP:
<a name="l01731"></a>01731             bnx2i_process_tmf_resp(session, bnx2i_conn,
<a name="l01732"></a>01732                            qp-&gt;cq_cons_qe);
<a name="l01733"></a>01733             <span class="keywordflow">break</span>;
<a name="l01734"></a>01734         <span class="keywordflow">case</span> ISCSI_OP_LOGOUT_RSP:
<a name="l01735"></a>01735             bnx2i_process_logout_resp(session, bnx2i_conn,
<a name="l01736"></a>01736                           qp-&gt;cq_cons_qe);
<a name="l01737"></a>01737             <span class="keywordflow">break</span>;
<a name="l01738"></a>01738         <span class="keywordflow">case</span> ISCSI_OP_NOOP_IN:
<a name="l01739"></a>01739             <span class="keywordflow">if</span> (bnx2i_process_nopin_mesg(session, bnx2i_conn,
<a name="l01740"></a>01740                              qp-&gt;cq_cons_qe))
<a name="l01741"></a>01741                 tgt_async_msg = 1;
<a name="l01742"></a>01742             <span class="keywordflow">break</span>;
<a name="l01743"></a>01743         <span class="keywordflow">case</span> ISCSI_OPCODE_NOPOUT_LOCAL_COMPLETION:
<a name="l01744"></a>01744             bnx2i_process_nopin_local_cmpl(session, bnx2i_conn,
<a name="l01745"></a>01745                                qp-&gt;cq_cons_qe);
<a name="l01746"></a>01746             <span class="keywordflow">break</span>;
<a name="l01747"></a>01747         <span class="keywordflow">case</span> ISCSI_OP_ASYNC_EVENT:
<a name="l01748"></a>01748             bnx2i_process_async_mesg(session, bnx2i_conn,
<a name="l01749"></a>01749                          qp-&gt;cq_cons_qe);
<a name="l01750"></a>01750             tgt_async_msg = 1;
<a name="l01751"></a>01751             <span class="keywordflow">break</span>;
<a name="l01752"></a>01752         <span class="keywordflow">case</span> ISCSI_OP_REJECT:
<a name="l01753"></a>01753             bnx2i_process_reject_mesg(session, bnx2i_conn,
<a name="l01754"></a>01754                           qp-&gt;cq_cons_qe);
<a name="l01755"></a>01755             <span class="keywordflow">break</span>;
<a name="l01756"></a>01756         <span class="keywordflow">case</span> ISCSI_OPCODE_CLEANUP_RESPONSE:
<a name="l01757"></a>01757             bnx2i_process_cmd_cleanup_resp(session, bnx2i_conn,
<a name="l01758"></a>01758                                qp-&gt;cq_cons_qe);
<a name="l01759"></a>01759             <span class="keywordflow">break</span>;
<a name="l01760"></a>01760         <span class="keywordflow">default</span>:
<a name="l01761"></a>01761             printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unknown opcode 0x%x\n&quot;</span>,
<a name="l01762"></a>01762                       nopin-&gt;op_code);
<a name="l01763"></a>01763         }
<a name="l01764"></a>01764 
<a name="l01765"></a>01765         <span class="keywordflow">if</span> (!tgt_async_msg)
<a name="l01766"></a>01766             bnx2i_conn-&gt;ep-&gt;num_active_cmds--;
<a name="l01767"></a>01767 
<a name="l01768"></a>01768         <span class="comment">/* clear out in production version only, till beta keep opcode</span>
<a name="l01769"></a>01769 <span class="comment">         * field intact, will be helpful in debugging (context dump)</span>
<a name="l01770"></a>01770 <span class="comment">         * nopin-&gt;op_code = 0;</span>
<a name="l01771"></a>01771 <span class="comment">         */</span>
<a name="l01772"></a>01772         qp-&gt;cqe_exp_seq_sn++;
<a name="l01773"></a>01773         <span class="keywordflow">if</span> (qp-&gt;cqe_exp_seq_sn == (qp-&gt;cqe_size * 2 + 1))
<a name="l01774"></a>01774             qp-&gt;cqe_exp_seq_sn = ISCSI_INITIAL_SN;
<a name="l01775"></a>01775 
<a name="l01776"></a>01776         <span class="keywordflow">if</span> (qp-&gt;cq_cons_qe == qp-&gt;cq_last_qe) {
<a name="l01777"></a>01777             qp-&gt;cq_cons_qe = qp-&gt;cq_first_qe;
<a name="l01778"></a>01778             qp-&gt;cq_cons_idx = 0;
<a name="l01779"></a>01779         } <span class="keywordflow">else</span> {
<a name="l01780"></a>01780             qp-&gt;cq_cons_qe++;
<a name="l01781"></a>01781             qp-&gt;cq_cons_idx++;
<a name="l01782"></a>01782         }
<a name="l01783"></a>01783     }
<a name="l01784"></a>01784     bnx2i_arm_cq_event_coalescing(bnx2i_conn-&gt;ep, CNIC_ARM_CQE);
<a name="l01785"></a>01785 }
<a name="l01786"></a>01786 
<a name="l01795"></a>01795 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_fastpath_notification(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l01796"></a>01796                     <span class="keyword">struct</span> <a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *new_cqe_kcqe)
<a name="l01797"></a>01797 {
<a name="l01798"></a>01798     <span class="keyword">struct </span>bnx2i_conn *conn;
<a name="l01799"></a>01799     u32 iscsi_cid;
<a name="l01800"></a>01800 
<a name="l01801"></a>01801     iscsi_cid = new_cqe_kcqe-&gt;iscsi_conn_id;
<a name="l01802"></a>01802     conn = bnx2i_get_conn_from_id(hba, iscsi_cid);
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     <span class="keywordflow">if</span> (!conn) {
<a name="l01805"></a>01805         printk(KERN_ALERT <span class="stringliteral">&quot;fpn - hba %p, cid #%x not valid\n&quot;</span>, hba, iscsi_cid);
<a name="l01806"></a>01806         <span class="keywordflow">return</span>;
<a name="l01807"></a>01807     }
<a name="l01808"></a>01808     <span class="keywordflow">if</span> (!conn-&gt;ep) {
<a name="l01809"></a>01809         printk(KERN_ALERT <span class="stringliteral">&quot;fpn - cid #%x - ep not bound\n&quot;</span>, iscsi_cid);
<a name="l01810"></a>01810         <span class="keywordflow">return</span>;
<a name="l01811"></a>01811     }
<a name="l01812"></a>01812 
<a name="l01813"></a>01813     bnx2i_process_new_cqes(conn);
<a name="l01814"></a>01814 }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 
<a name="l01824"></a>01824 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_update_conn_cmpl(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l01825"></a>01825                        <span class="keyword">struct</span> <a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *update_kcqe)
<a name="l01826"></a>01826 {
<a name="l01827"></a>01827     <span class="keyword">struct </span>bnx2i_conn *conn;
<a name="l01828"></a>01828     u32 iscsi_cid;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830     iscsi_cid = update_kcqe-&gt;iscsi_conn_id;
<a name="l01831"></a>01831     conn = bnx2i_get_conn_from_id(hba, iscsi_cid);
<a name="l01832"></a>01832 
<a name="l01833"></a>01833     <span class="keywordflow">if</span> (!conn) {
<a name="l01834"></a>01834         printk(KERN_ALERT <span class="stringliteral">&quot;conn_update: cid %x not valid\n&quot;</span>, iscsi_cid);
<a name="l01835"></a>01835         <span class="keywordflow">return</span>;
<a name="l01836"></a>01836     }
<a name="l01837"></a>01837     <span class="keywordflow">if</span> (!conn-&gt;ep) {
<a name="l01838"></a>01838         printk(KERN_ALERT <span class="stringliteral">&quot;cid %x does not have ep bound\n&quot;</span>, iscsi_cid);
<a name="l01839"></a>01839         <span class="keywordflow">return</span>;
<a name="l01840"></a>01840     }
<a name="l01841"></a>01841 
<a name="l01842"></a>01842     <span class="keywordflow">if</span> (update_kcqe-&gt;completion_status) {
<a name="l01843"></a>01843         printk(KERN_ALERT <span class="stringliteral">&quot;request failed cid %x\n&quot;</span>, iscsi_cid);
<a name="l01844"></a>01844         conn-&gt;ep-&gt;state = EP_STATE_ULP_UPDATE_FAILED;
<a name="l01845"></a>01845     } <span class="keywordflow">else</span>
<a name="l01846"></a>01846         conn-&gt;ep-&gt;state = EP_STATE_ULP_UPDATE_COMPL;
<a name="l01847"></a>01847 
<a name="l01848"></a>01848     wake_up_interruptible(&amp;conn-&gt;ep-&gt;ofld_wait);
<a name="l01849"></a>01849 }
<a name="l01850"></a>01850 
<a name="l01851"></a>01851 
<a name="l01859"></a>01859 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_recovery_que_add_conn(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l01860"></a>01860                     <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn)
<a name="l01861"></a>01861 {
<a name="l01862"></a>01862     iscsi_conn_failure(bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l01863"></a>01863                ISCSI_ERR_CONN_FAILED);
<a name="l01864"></a>01864 }
<a name="l01865"></a>01865 
<a name="l01866"></a>01866 
<a name="l01875"></a>01875 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_tcp_error(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l01876"></a>01876                     <span class="keyword">struct</span> <a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *tcp_err)
<a name="l01877"></a>01877 {
<a name="l01878"></a>01878     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn;
<a name="l01879"></a>01879     u32 iscsi_cid;
<a name="l01880"></a>01880 
<a name="l01881"></a>01881     iscsi_cid = tcp_err-&gt;iscsi_conn_id;
<a name="l01882"></a>01882     bnx2i_conn = bnx2i_get_conn_from_id(hba, iscsi_cid);
<a name="l01883"></a>01883 
<a name="l01884"></a>01884     <span class="keywordflow">if</span> (!bnx2i_conn) {
<a name="l01885"></a>01885         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i - tcp err - cid 0x%x not valid\n&quot;</span>, iscsi_cid);
<a name="l01886"></a>01886         <span class="keywordflow">return</span>;
<a name="l01887"></a>01887     }
<a name="l01888"></a>01888 
<a name="l01889"></a>01889     printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i - cid 0x%x had TCP errors, error code 0x%x\n&quot;</span>,
<a name="l01890"></a>01890               iscsi_cid, tcp_err-&gt;completion_status);
<a name="l01891"></a>01891     bnx2i_recovery_que_add_conn(bnx2i_conn-&gt;hba, bnx2i_conn);
<a name="l01892"></a>01892 }
<a name="l01893"></a>01893 
<a name="l01894"></a>01894 
<a name="l01908"></a>01908 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_iscsi_error(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l01909"></a>01909                       <span class="keyword">struct</span> <a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *iscsi_err)
<a name="l01910"></a>01910 {
<a name="l01911"></a>01911     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn;
<a name="l01912"></a>01912     u32 iscsi_cid;
<a name="l01913"></a>01913     <span class="keywordtype">char</span> warn_notice[] = <span class="stringliteral">&quot;iscsi_warning&quot;</span>;
<a name="l01914"></a>01914     <span class="keywordtype">char</span> error_notice[] = <span class="stringliteral">&quot;iscsi_error&quot;</span>;
<a name="l01915"></a>01915     <span class="keywordtype">char</span> additional_notice[64];
<a name="l01916"></a>01916     <span class="keywordtype">char</span> *message;
<a name="l01917"></a>01917     <span class="keywordtype">int</span> need_recovery;
<a name="l01918"></a>01918     u64 err_mask64;
<a name="l01919"></a>01919 
<a name="l01920"></a>01920     iscsi_cid = iscsi_err-&gt;iscsi_conn_id;
<a name="l01921"></a>01921     bnx2i_conn = bnx2i_get_conn_from_id(hba, iscsi_cid);
<a name="l01922"></a>01922     <span class="keywordflow">if</span> (!bnx2i_conn) {
<a name="l01923"></a>01923         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i - conn err, cid 0x%x not valid\n&quot;</span>, iscsi_cid);
<a name="l01924"></a>01924         <span class="keywordflow">return</span>;
<a name="l01925"></a>01925     }
<a name="l01926"></a>01926 
<a name="l01927"></a>01927     err_mask64 = (0x1ULL &lt;&lt; iscsi_err-&gt;completion_status);
<a name="l01928"></a>01928 
<a name="l01929"></a>01929     <span class="keywordflow">if</span> (err_mask64 &amp; iscsi_error_mask) {
<a name="l01930"></a>01930         need_recovery = 0;
<a name="l01931"></a>01931         message = warn_notice;
<a name="l01932"></a>01932     } <span class="keywordflow">else</span> {
<a name="l01933"></a>01933         need_recovery = 1;
<a name="l01934"></a>01934         message = error_notice;
<a name="l01935"></a>01935     }
<a name="l01936"></a>01936 
<a name="l01937"></a>01937     <span class="keywordflow">switch</span> (iscsi_err-&gt;completion_status) {
<a name="l01938"></a>01938     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_HDR_DIG_ERR:
<a name="l01939"></a>01939         strcpy(additional_notice, <span class="stringliteral">&quot;hdr digest err&quot;</span>);
<a name="l01940"></a>01940         <span class="keywordflow">break</span>;
<a name="l01941"></a>01941     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_DATA_DIG_ERR:
<a name="l01942"></a>01942         strcpy(additional_notice, <span class="stringliteral">&quot;data digest err&quot;</span>);
<a name="l01943"></a>01943         <span class="keywordflow">break</span>;
<a name="l01944"></a>01944     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_OPCODE:
<a name="l01945"></a>01945         strcpy(additional_notice, <span class="stringliteral">&quot;wrong opcode rcvd&quot;</span>);
<a name="l01946"></a>01946         <span class="keywordflow">break</span>;
<a name="l01947"></a>01947     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_AHS_LEN:
<a name="l01948"></a>01948         strcpy(additional_notice, <span class="stringliteral">&quot;AHS len &gt; 0 rcvd&quot;</span>);
<a name="l01949"></a>01949         <span class="keywordflow">break</span>;
<a name="l01950"></a>01950     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_ITT:
<a name="l01951"></a>01951         strcpy(additional_notice, <span class="stringliteral">&quot;invalid ITT rcvd&quot;</span>);
<a name="l01952"></a>01952         <span class="keywordflow">break</span>;
<a name="l01953"></a>01953     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_STATSN:
<a name="l01954"></a>01954         strcpy(additional_notice, <span class="stringliteral">&quot;wrong StatSN rcvd&quot;</span>);
<a name="l01955"></a>01955         <span class="keywordflow">break</span>;
<a name="l01956"></a>01956     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_EXP_DATASN:
<a name="l01957"></a>01957         strcpy(additional_notice, <span class="stringliteral">&quot;wrong DataSN rcvd&quot;</span>);
<a name="l01958"></a>01958         <span class="keywordflow">break</span>;
<a name="l01959"></a>01959     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_PEND_R2T:
<a name="l01960"></a>01960         strcpy(additional_notice, <span class="stringliteral">&quot;pend R2T violation&quot;</span>);
<a name="l01961"></a>01961         <span class="keywordflow">break</span>;
<a name="l01962"></a>01962     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_0:
<a name="l01963"></a>01963         strcpy(additional_notice, <span class="stringliteral">&quot;ERL0, UO&quot;</span>);
<a name="l01964"></a>01964         <span class="keywordflow">break</span>;
<a name="l01965"></a>01965     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_1:
<a name="l01966"></a>01966         strcpy(additional_notice, <span class="stringliteral">&quot;ERL0, U1&quot;</span>);
<a name="l01967"></a>01967         <span class="keywordflow">break</span>;
<a name="l01968"></a>01968     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_2:
<a name="l01969"></a>01969         strcpy(additional_notice, <span class="stringliteral">&quot;ERL0, U2&quot;</span>);
<a name="l01970"></a>01970         <span class="keywordflow">break</span>;
<a name="l01971"></a>01971     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_3:
<a name="l01972"></a>01972         strcpy(additional_notice, <span class="stringliteral">&quot;ERL0, U3&quot;</span>);
<a name="l01973"></a>01973         <span class="keywordflow">break</span>;
<a name="l01974"></a>01974     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_4:
<a name="l01975"></a>01975         strcpy(additional_notice, <span class="stringliteral">&quot;ERL0, U4&quot;</span>);
<a name="l01976"></a>01976         <span class="keywordflow">break</span>;
<a name="l01977"></a>01977     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_5:
<a name="l01978"></a>01978         strcpy(additional_notice, <span class="stringliteral">&quot;ERL0, U5&quot;</span>);
<a name="l01979"></a>01979         <span class="keywordflow">break</span>;
<a name="l01980"></a>01980     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_6:
<a name="l01981"></a>01981         strcpy(additional_notice, <span class="stringliteral">&quot;ERL0, U6&quot;</span>);
<a name="l01982"></a>01982         <span class="keywordflow">break</span>;
<a name="l01983"></a>01983     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_REMAIN_RCV_LEN:
<a name="l01984"></a>01984         strcpy(additional_notice, <span class="stringliteral">&quot;invalid resi len&quot;</span>);
<a name="l01985"></a>01985         <span class="keywordflow">break</span>;
<a name="l01986"></a>01986     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_MAX_RCV_PDU_LEN:
<a name="l01987"></a>01987         strcpy(additional_notice, <span class="stringliteral">&quot;MRDSL violation&quot;</span>);
<a name="l01988"></a>01988         <span class="keywordflow">break</span>;
<a name="l01989"></a>01989     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_F_BIT_ZERO:
<a name="l01990"></a>01990         strcpy(additional_notice, <span class="stringliteral">&quot;F-bit not set&quot;</span>);
<a name="l01991"></a>01991         <span class="keywordflow">break</span>;
<a name="l01992"></a>01992     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_TTT_NOT_RSRV:
<a name="l01993"></a>01993         strcpy(additional_notice, <span class="stringliteral">&quot;invalid TTT&quot;</span>);
<a name="l01994"></a>01994         <span class="keywordflow">break</span>;
<a name="l01995"></a>01995     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DATASN:
<a name="l01996"></a>01996         strcpy(additional_notice, <span class="stringliteral">&quot;invalid DataSN&quot;</span>);
<a name="l01997"></a>01997         <span class="keywordflow">break</span>;
<a name="l01998"></a>01998     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_REMAIN_BURST_LEN:
<a name="l01999"></a>01999         strcpy(additional_notice, <span class="stringliteral">&quot;burst len violation&quot;</span>);
<a name="l02000"></a>02000         <span class="keywordflow">break</span>;
<a name="l02001"></a>02001     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_BUFFER_OFF:
<a name="l02002"></a>02002         strcpy(additional_notice, <span class="stringliteral">&quot;buf offset violation&quot;</span>);
<a name="l02003"></a>02003         <span class="keywordflow">break</span>;
<a name="l02004"></a>02004     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_LUN:
<a name="l02005"></a>02005         strcpy(additional_notice, <span class="stringliteral">&quot;invalid LUN field&quot;</span>);
<a name="l02006"></a>02006         <span class="keywordflow">break</span>;
<a name="l02007"></a>02007     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_R2TSN:
<a name="l02008"></a>02008         strcpy(additional_notice, <span class="stringliteral">&quot;invalid R2TSN field&quot;</span>);
<a name="l02009"></a>02009         <span class="keywordflow">break</span>;
<a name="l02010"></a>02010 <span class="preprocessor">#define BNX2I_ERR_DESIRED_DATA_TRNS_LEN_0   \</span>
<a name="l02011"></a>02011 <span class="preprocessor">    ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DESIRED_DATA_TRNS_LEN_0</span>
<a name="l02012"></a>02012 <span class="preprocessor"></span>    <span class="keywordflow">case</span> BNX2I_ERR_DESIRED_DATA_TRNS_LEN_0:
<a name="l02013"></a>02013         strcpy(additional_notice, <span class="stringliteral">&quot;invalid cmd len1&quot;</span>);
<a name="l02014"></a>02014         <span class="keywordflow">break</span>;
<a name="l02015"></a>02015 <span class="preprocessor">#define BNX2I_ERR_DESIRED_DATA_TRNS_LEN_1   \</span>
<a name="l02016"></a>02016 <span class="preprocessor">    ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DESIRED_DATA_TRNS_LEN_1</span>
<a name="l02017"></a>02017 <span class="preprocessor"></span>    <span class="keywordflow">case</span> BNX2I_ERR_DESIRED_DATA_TRNS_LEN_1:
<a name="l02018"></a>02018         strcpy(additional_notice, <span class="stringliteral">&quot;invalid cmd len2&quot;</span>);
<a name="l02019"></a>02019         <span class="keywordflow">break</span>;
<a name="l02020"></a>02020     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_PEND_R2T_EXCEED:
<a name="l02021"></a>02021         strcpy(additional_notice,
<a name="l02022"></a>02022                <span class="stringliteral">&quot;pend r2t exceeds MaxOutstandingR2T value&quot;</span>);
<a name="l02023"></a>02023         <span class="keywordflow">break</span>;
<a name="l02024"></a>02024     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_TTT_IS_RSRV:
<a name="l02025"></a>02025         strcpy(additional_notice, <span class="stringliteral">&quot;TTT is rsvd&quot;</span>);
<a name="l02026"></a>02026         <span class="keywordflow">break</span>;
<a name="l02027"></a>02027     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_MAX_BURST_LEN:
<a name="l02028"></a>02028         strcpy(additional_notice, <span class="stringliteral">&quot;MBL violation&quot;</span>);
<a name="l02029"></a>02029         <span class="keywordflow">break</span>;
<a name="l02030"></a>02030 <span class="preprocessor">#define BNX2I_ERR_DATA_SEG_LEN_NOT_ZERO     \</span>
<a name="l02031"></a>02031 <span class="preprocessor">    ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DATA_SEG_LEN_NOT_ZERO</span>
<a name="l02032"></a>02032 <span class="preprocessor"></span>    <span class="keywordflow">case</span> BNX2I_ERR_DATA_SEG_LEN_NOT_ZERO:
<a name="l02033"></a>02033         strcpy(additional_notice, <span class="stringliteral">&quot;data seg len != 0&quot;</span>);
<a name="l02034"></a>02034         <span class="keywordflow">break</span>;
<a name="l02035"></a>02035     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_REJECT_PDU_LEN:
<a name="l02036"></a>02036         strcpy(additional_notice, <span class="stringliteral">&quot;reject pdu len error&quot;</span>);
<a name="l02037"></a>02037         <span class="keywordflow">break</span>;
<a name="l02038"></a>02038     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_ASYNC_PDU_LEN:
<a name="l02039"></a>02039         strcpy(additional_notice, <span class="stringliteral">&quot;async pdu len error&quot;</span>);
<a name="l02040"></a>02040         <span class="keywordflow">break</span>;
<a name="l02041"></a>02041     <span class="keywordflow">case</span> ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_NOPIN_PDU_LEN:
<a name="l02042"></a>02042         strcpy(additional_notice, <span class="stringliteral">&quot;nopin pdu len error&quot;</span>);
<a name="l02043"></a>02043         <span class="keywordflow">break</span>;
<a name="l02044"></a>02044 <span class="preprocessor">#define BNX2_ERR_PEND_R2T_IN_CLEANUP            \</span>
<a name="l02045"></a>02045 <span class="preprocessor">    ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_PEND_R2T_IN_CLEANUP</span>
<a name="l02046"></a>02046 <span class="preprocessor"></span>    <span class="keywordflow">case</span> BNX2_ERR_PEND_R2T_IN_CLEANUP:
<a name="l02047"></a>02047         strcpy(additional_notice, <span class="stringliteral">&quot;pend r2t in cleanup&quot;</span>);
<a name="l02048"></a>02048         <span class="keywordflow">break</span>;
<a name="l02049"></a>02049 
<a name="l02050"></a>02050     <span class="keywordflow">case</span> ISCI_KCQE_COMPLETION_STATUS_TCP_ERROR_IP_FRAGMENT:
<a name="l02051"></a>02051         strcpy(additional_notice, <span class="stringliteral">&quot;IP fragments rcvd&quot;</span>);
<a name="l02052"></a>02052         <span class="keywordflow">break</span>;
<a name="l02053"></a>02053     <span class="keywordflow">case</span> ISCI_KCQE_COMPLETION_STATUS_TCP_ERROR_IP_OPTIONS:
<a name="l02054"></a>02054         strcpy(additional_notice, <span class="stringliteral">&quot;IP options error&quot;</span>);
<a name="l02055"></a>02055         <span class="keywordflow">break</span>;
<a name="l02056"></a>02056     <span class="keywordflow">case</span> ISCI_KCQE_COMPLETION_STATUS_TCP_ERROR_URGENT_FLAG:
<a name="l02057"></a>02057         strcpy(additional_notice, <span class="stringliteral">&quot;urgent flag error&quot;</span>);
<a name="l02058"></a>02058         <span class="keywordflow">break</span>;
<a name="l02059"></a>02059     <span class="keywordflow">default</span>:
<a name="l02060"></a>02060         printk(KERN_ALERT <span class="stringliteral">&quot;iscsi_err - unknown err %x\n&quot;</span>,
<a name="l02061"></a>02061                   iscsi_err-&gt;completion_status);
<a name="l02062"></a>02062     }
<a name="l02063"></a>02063 
<a name="l02064"></a>02064     <span class="keywordflow">if</span> (need_recovery) {
<a name="l02065"></a>02065         iscsi_conn_printk(KERN_ALERT,
<a name="l02066"></a>02066                   bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l02067"></a>02067                   <span class="stringliteral">&quot;bnx2i: %s - %s\n&quot;</span>,
<a name="l02068"></a>02068                   message, additional_notice);
<a name="l02069"></a>02069 
<a name="l02070"></a>02070         iscsi_conn_printk(KERN_ALERT,
<a name="l02071"></a>02071                   bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l02072"></a>02072                   <span class="stringliteral">&quot;conn_err - hostno %d conn %p, &quot;</span>
<a name="l02073"></a>02073                   <span class="stringliteral">&quot;iscsi_cid %x cid %x\n&quot;</span>,
<a name="l02074"></a>02074                   bnx2i_conn-&gt;hba-&gt;shost-&gt;host_no,
<a name="l02075"></a>02075                   bnx2i_conn, bnx2i_conn-&gt;ep-&gt;ep_iscsi_cid,
<a name="l02076"></a>02076                   bnx2i_conn-&gt;ep-&gt;ep_cid);
<a name="l02077"></a>02077         bnx2i_recovery_que_add_conn(bnx2i_conn-&gt;hba, bnx2i_conn);
<a name="l02078"></a>02078     } <span class="keywordflow">else</span>
<a name="l02079"></a>02079         <span class="keywordflow">if</span> (!test_and_set_bit(iscsi_err-&gt;completion_status,
<a name="l02080"></a>02080                       (<span class="keywordtype">void</span> *) &amp;bnx2i_conn-&gt;violation_notified))
<a name="l02081"></a>02081             iscsi_conn_printk(KERN_ALERT,
<a name="l02082"></a>02082                       bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l02083"></a>02083                       <span class="stringliteral">&quot;bnx2i: %s - %s\n&quot;</span>,
<a name="l02084"></a>02084                       message, additional_notice);
<a name="l02085"></a>02085 }
<a name="l02086"></a>02086 
<a name="l02087"></a>02087 
<a name="l02095"></a>02095 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_conn_destroy_cmpl(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l02096"></a>02096                         <span class="keyword">struct</span> <a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *conn_destroy)
<a name="l02097"></a>02097 {
<a name="l02098"></a>02098     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep;
<a name="l02099"></a>02099 
<a name="l02100"></a>02100     ep = bnx2i_find_ep_in_destroy_list(hba, conn_destroy-&gt;iscsi_conn_id);
<a name="l02101"></a>02101     <span class="keywordflow">if</span> (!ep) {
<a name="l02102"></a>02102         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i_conn_destroy_cmpl: no pending &quot;</span>
<a name="l02103"></a>02103                   <span class="stringliteral">&quot;offload request, unexpected complection\n&quot;</span>);
<a name="l02104"></a>02104         <span class="keywordflow">return</span>;
<a name="l02105"></a>02105     }
<a name="l02106"></a>02106 
<a name="l02107"></a>02107     <span class="keywordflow">if</span> (hba != ep-&gt;hba) {
<a name="l02108"></a>02108         printk(KERN_ALERT <span class="stringliteral">&quot;conn destroy- error hba mis-match\n&quot;</span>);
<a name="l02109"></a>02109         <span class="keywordflow">return</span>;
<a name="l02110"></a>02110     }
<a name="l02111"></a>02111 
<a name="l02112"></a>02112     <span class="keywordflow">if</span> (conn_destroy-&gt;completion_status) {
<a name="l02113"></a>02113         printk(KERN_ALERT <span class="stringliteral">&quot;conn_destroy_cmpl: op failed\n&quot;</span>);
<a name="l02114"></a>02114         ep-&gt;state = EP_STATE_CLEANUP_FAILED;
<a name="l02115"></a>02115     } <span class="keywordflow">else</span>
<a name="l02116"></a>02116         ep-&gt;state = EP_STATE_CLEANUP_CMPL;
<a name="l02117"></a>02117     wake_up_interruptible(&amp;ep-&gt;ofld_wait);
<a name="l02118"></a>02118 }
<a name="l02119"></a>02119 
<a name="l02120"></a>02120 
<a name="l02129"></a>02129 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_process_ofld_cmpl(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l02130"></a>02130                     <span class="keyword">struct</span> <a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *ofld_kcqe)
<a name="l02131"></a>02131 {
<a name="l02132"></a>02132     u32 cid_addr;
<a name="l02133"></a>02133     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep;
<a name="l02134"></a>02134     u32 cid_num;
<a name="l02135"></a>02135 
<a name="l02136"></a>02136     ep = bnx2i_find_ep_in_ofld_list(hba, ofld_kcqe-&gt;iscsi_conn_id);
<a name="l02137"></a>02137     <span class="keywordflow">if</span> (!ep) {
<a name="l02138"></a>02138         printk(KERN_ALERT <span class="stringliteral">&quot;ofld_cmpl: no pend offload request\n&quot;</span>);
<a name="l02139"></a>02139         <span class="keywordflow">return</span>;
<a name="l02140"></a>02140     }
<a name="l02141"></a>02141 
<a name="l02142"></a>02142     <span class="keywordflow">if</span> (hba != ep-&gt;hba) {
<a name="l02143"></a>02143         printk(KERN_ALERT <span class="stringliteral">&quot;ofld_cmpl: error hba mis-match\n&quot;</span>);
<a name="l02144"></a>02144         <span class="keywordflow">return</span>;
<a name="l02145"></a>02145     }
<a name="l02146"></a>02146 
<a name="l02147"></a>02147     <span class="keywordflow">if</span> (ofld_kcqe-&gt;completion_status) {
<a name="l02148"></a>02148         <span class="keywordflow">if</span> (ofld_kcqe-&gt;completion_status ==
<a name="l02149"></a>02149             ISCSI_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE)
<a name="l02150"></a>02150             printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unable to allocate&quot;</span>
<a name="l02151"></a>02151                       <span class="stringliteral">&quot; iSCSI context resources\n&quot;</span>);
<a name="l02152"></a>02152         ep-&gt;state = EP_STATE_OFLD_FAILED;
<a name="l02153"></a>02153     } <span class="keywordflow">else</span> {
<a name="l02154"></a>02154         ep-&gt;state = EP_STATE_OFLD_COMPL;
<a name="l02155"></a>02155         cid_addr = ofld_kcqe-&gt;iscsi_conn_context_id;
<a name="l02156"></a>02156         cid_num = bnx2i_get_cid_num(ep);
<a name="l02157"></a>02157         ep-&gt;ep_cid = cid_addr;
<a name="l02158"></a>02158         ep-&gt;qp.ctx_base = NULL;
<a name="l02159"></a>02159     }
<a name="l02160"></a>02160     wake_up_interruptible(&amp;ep-&gt;ofld_wait);
<a name="l02161"></a>02161 }
<a name="l02162"></a>02162 
<a name="l02170"></a>02170 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_indicate_kcqe(<span class="keywordtype">void</span> *context, <span class="keyword">struct</span> <a class="code" href="structkcqe.html">kcqe</a> *<a class="code" href="structkcqe.html">kcqe</a>[],
<a name="l02171"></a>02171                 u32 num_cqe)
<a name="l02172"></a>02172 {
<a name="l02173"></a>02173     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = context;
<a name="l02174"></a>02174     <span class="keywordtype">int</span> i = 0;
<a name="l02175"></a>02175     <span class="keyword">struct </span><a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *ikcqe = NULL;
<a name="l02176"></a>02176 
<a name="l02177"></a>02177     <span class="keywordflow">while</span> (i &lt; num_cqe) {
<a name="l02178"></a>02178         ikcqe = (<span class="keyword">struct </span><a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> *) kcqe[i++];
<a name="l02179"></a>02179 
<a name="l02180"></a>02180         <span class="keywordflow">if</span> (ikcqe-&gt;op_code ==
<a name="l02181"></a>02181             ISCSI_KCQE_OPCODE_CQ_EVENT_NOTIFICATION)
<a name="l02182"></a>02182             bnx2i_fastpath_notification(hba, ikcqe);
<a name="l02183"></a>02183         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ikcqe-&gt;op_code == ISCSI_KCQE_OPCODE_OFFLOAD_CONN)
<a name="l02184"></a>02184             bnx2i_process_ofld_cmpl(hba, ikcqe);
<a name="l02185"></a>02185         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ikcqe-&gt;op_code == ISCSI_KCQE_OPCODE_UPDATE_CONN)
<a name="l02186"></a>02186             bnx2i_process_update_conn_cmpl(hba, ikcqe);
<a name="l02187"></a>02187         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ikcqe-&gt;op_code == ISCSI_KCQE_OPCODE_INIT) {
<a name="l02188"></a>02188             <span class="keywordflow">if</span> (ikcqe-&gt;completion_status !=
<a name="l02189"></a>02189                 ISCSI_KCQE_COMPLETION_STATUS_SUCCESS)
<a name="l02190"></a>02190                 bnx2i_iscsi_license_error(hba, ikcqe-&gt;\
<a name="l02191"></a>02191                               completion_status);
<a name="l02192"></a>02192             <span class="keywordflow">else</span> {
<a name="l02193"></a>02193                 set_bit(ADAPTER_STATE_UP, &amp;hba-&gt;adapter_state);
<a name="l02194"></a>02194                 bnx2i_get_link_state(hba);
<a name="l02195"></a>02195                 printk(KERN_INFO <span class="stringliteral">&quot;bnx2i [%.2x:%.2x.%.2x]: &quot;</span>
<a name="l02196"></a>02196                          <span class="stringliteral">&quot;ISCSI_INIT passed\n&quot;</span>,
<a name="l02197"></a>02197                          (u8)hba-&gt;pcidev-&gt;bus-&gt;number,
<a name="l02198"></a>02198                          hba-&gt;pci_devno,
<a name="l02199"></a>02199                          (u8)hba-&gt;pci_func);
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 
<a name="l02202"></a>02202             }
<a name="l02203"></a>02203         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ikcqe-&gt;op_code == ISCSI_KCQE_OPCODE_DESTROY_CONN)
<a name="l02204"></a>02204             bnx2i_process_conn_destroy_cmpl(hba, ikcqe);
<a name="l02205"></a>02205         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ikcqe-&gt;op_code == ISCSI_KCQE_OPCODE_ISCSI_ERROR)
<a name="l02206"></a>02206             bnx2i_process_iscsi_error(hba, ikcqe);
<a name="l02207"></a>02207         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ikcqe-&gt;op_code == ISCSI_KCQE_OPCODE_TCP_ERROR)
<a name="l02208"></a>02208             bnx2i_process_tcp_error(hba, ikcqe);
<a name="l02209"></a>02209         <span class="keywordflow">else</span>
<a name="l02210"></a>02210             printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: unknown opcode 0x%x\n&quot;</span>,
<a name="l02211"></a>02211                       ikcqe-&gt;op_code);
<a name="l02212"></a>02212     }
<a name="l02213"></a>02213 }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215 
<a name="l02216"></a>02216 <span class="comment">/*</span>
<a name="l02217"></a>02217 <span class="comment"> * Generic netstack event handler</span>
<a name="l02218"></a>02218 <span class="comment"> */</span>
<a name="l02219"></a>02219 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_indicate_inetevent(<span class="keywordtype">void</span> *context, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event)
<a name="l02220"></a>02220 {
<a name="l02221"></a>02221     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = context;
<a name="l02222"></a>02222 
<a name="l02223"></a>02223     <span class="keywordflow">switch</span> (event) {
<a name="l02224"></a>02224     <span class="keywordflow">case</span> NETDEV_UP:
<a name="l02225"></a>02225         iscsi_host_for_each_session(hba-&gt;shost,
<a name="l02226"></a>02226                         bnx2i_drop_session);
<a name="l02227"></a>02227         <span class="keywordflow">break</span>;
<a name="l02228"></a>02228     <span class="keywordflow">case</span> NETDEV_CHANGE:
<a name="l02229"></a>02229         <span class="keywordflow">break</span>;
<a name="l02230"></a>02230     <span class="keywordflow">default</span>:
<a name="l02231"></a>02231         ;
<a name="l02232"></a>02232     }
<a name="l02233"></a>02233 }
<a name="l02234"></a>02234 
<a name="l02243"></a>02243 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_indicate_netevent(<span class="keywordtype">void</span> *context, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event)
<a name="l02244"></a>02244 {
<a name="l02245"></a>02245     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = context;
<a name="l02246"></a>02246 
<a name="l02247"></a>02247     <span class="keywordflow">switch</span> (event) {
<a name="l02248"></a>02248     <span class="keywordflow">case</span> NETDEV_UP:
<a name="l02249"></a>02249         <span class="keywordflow">if</span> (!test_bit(ADAPTER_STATE_UP, &amp;hba-&gt;adapter_state))
<a name="l02250"></a>02250             bnx2i_send_fw_iscsi_init_msg(hba);
<a name="l02251"></a>02251         <span class="keywordflow">break</span>;
<a name="l02252"></a>02252     <span class="keywordflow">case</span> NETDEV_DOWN:
<a name="l02253"></a>02253         clear_bit(ADAPTER_STATE_GOING_DOWN, &amp;hba-&gt;adapter_state);
<a name="l02254"></a>02254         clear_bit(ADAPTER_STATE_UP, &amp;hba-&gt;adapter_state);
<a name="l02255"></a>02255         <span class="keywordflow">break</span>;
<a name="l02256"></a>02256     <span class="keywordflow">case</span> NETDEV_GOING_DOWN:
<a name="l02257"></a>02257         set_bit(ADAPTER_STATE_GOING_DOWN, &amp;hba-&gt;adapter_state);
<a name="l02258"></a>02258         iscsi_host_for_each_session(hba-&gt;shost,
<a name="l02259"></a>02259                         bnx2i_drop_session);
<a name="l02260"></a>02260         <span class="keywordflow">break</span>;
<a name="l02261"></a>02261     <span class="keywordflow">case</span> NETDEV_CHANGE:
<a name="l02262"></a>02262         bnx2i_get_link_state(hba);
<a name="l02263"></a>02263         <span class="keywordflow">break</span>;
<a name="l02264"></a>02264     <span class="keywordflow">default</span>:
<a name="l02265"></a>02265         ;
<a name="l02266"></a>02266     }
<a name="l02267"></a>02267 }
<a name="l02268"></a>02268 
<a name="l02269"></a>02269 
<a name="l02277"></a>02277 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_cm_connect_cmpl(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *cm_sk)
<a name="l02278"></a>02278 {
<a name="l02279"></a>02279     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *) cm_sk-&gt;context;
<a name="l02280"></a>02280 
<a name="l02281"></a>02281     if (test_bit(ADAPTER_STATE_GOING_DOWN, &amp;ep-&gt;hba-&gt;adapter_state))
<a name="l02282"></a>02282         ep-&gt;state = EP_STATE_CONNECT_FAILED;
<a name="l02283"></a>02283     <span class="keywordflow">else</span> if (test_bit(SK_F_OFFLD_COMPLETE, &amp;cm_sk-&gt;flags))
<a name="l02284"></a>02284         ep-&gt;state = EP_STATE_CONNECT_COMPL;
<a name="l02285"></a>02285     <span class="keywordflow">else</span>
<a name="l02286"></a>02286         ep-&gt;state = EP_STATE_CONNECT_FAILED;
<a name="l02287"></a>02287 
<a name="l02288"></a>02288     wake_up_interruptible(&amp;ep-&gt;ofld_wait);
<a name="l02289"></a>02289 }
<a name="l02290"></a>02290 
<a name="l02291"></a>02291 
<a name="l02299"></a>02299 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_cm_close_cmpl(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *cm_sk)
<a name="l02300"></a>02300 {
<a name="l02301"></a>02301     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *) cm_sk-&gt;context;
<a name="l02302"></a>02302 
<a name="l02303"></a>02303     ep-&gt;state = EP_STATE_DISCONN_COMPL;
<a name="l02304"></a>02304     wake_up_interruptible(&amp;ep-&gt;ofld_wait);
<a name="l02305"></a>02305 }
<a name="l02306"></a>02306 
<a name="l02307"></a>02307 
<a name="l02315"></a>02315 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_cm_abort_cmpl(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *cm_sk)
<a name="l02316"></a>02316 {
<a name="l02317"></a>02317     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *) cm_sk-&gt;context;
<a name="l02318"></a>02318 
<a name="l02319"></a>02319     ep-&gt;state = EP_STATE_DISCONN_COMPL;
<a name="l02320"></a>02320     wake_up_interruptible(&amp;ep-&gt;ofld_wait);
<a name="l02321"></a>02321 }
<a name="l02322"></a>02322 
<a name="l02323"></a>02323 
<a name="l02332"></a>02332 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_cm_remote_close(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *cm_sk)
<a name="l02333"></a>02333 {
<a name="l02334"></a>02334     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *) cm_sk-&gt;context;
<a name="l02335"></a>02335 
<a name="l02336"></a>02336     ep-&gt;state = EP_STATE_TCP_FIN_RCVD;
<a name="l02337"></a>02337     if (ep-&gt;conn)
<a name="l02338"></a>02338         bnx2i_recovery_que_add_conn(ep-&gt;hba, ep-&gt;conn);
<a name="l02339"></a>02339 }
<a name="l02340"></a>02340 
<a name="l02349"></a>02349 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_cm_remote_abort(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *cm_sk)
<a name="l02350"></a>02350 {
<a name="l02351"></a>02351     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *) cm_sk-&gt;context;
<a name="l02352"></a>02352 
<a name="l02353"></a>02353     ep-&gt;state = EP_STATE_TCP_RST_RCVD;
<a name="l02354"></a>02354     if (ep-&gt;conn)
<a name="l02355"></a>02355         bnx2i_recovery_que_add_conn(ep-&gt;hba, ep-&gt;conn);
<a name="l02356"></a>02356 }
<a name="l02357"></a>02357 
<a name="l02358"></a>02358 
<a name="l02364"></a>02364 <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> bnx2i_cnic_cb = {
<a name="l02365"></a>02365     .cnic_init = bnx2i_ulp_init,
<a name="l02366"></a>02366     .cnic_exit = bnx2i_ulp_exit,
<a name="l02367"></a>02367     .cnic_start = bnx2i_start,
<a name="l02368"></a>02368     .cnic_stop = bnx2i_stop,
<a name="l02369"></a>02369     .indicate_kcqes = bnx2i_indicate_kcqe,
<a name="l02370"></a>02370     .indicate_netevent = bnx2i_indicate_netevent,
<a name="l02371"></a>02371     .indicate_inetevent = bnx2i_indicate_inetevent,
<a name="l02372"></a>02372     .cm_connect_complete = bnx2i_cm_connect_cmpl,
<a name="l02373"></a>02373     .cm_close_complete = bnx2i_cm_close_cmpl,
<a name="l02374"></a>02374     .cm_abort_complete = bnx2i_cm_abort_cmpl,
<a name="l02375"></a>02375     .cm_remote_close = bnx2i_cm_remote_close,
<a name="l02376"></a>02376     .cm_remote_abort = bnx2i_cm_remote_abort,
<a name="l02377"></a>02377     .owner = THIS_MODULE
<a name="l02378"></a>02378 };
<a name="l02379"></a>02379 
<a name="l02380"></a>02380 
<a name="l02389"></a>02389 <span class="keywordtype">int</span> bnx2i_map_ep_dbell_regs(<span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l02390"></a>02390 {
<a name="l02391"></a>02391     u32 cid_num;
<a name="l02392"></a>02392     u32 reg_off;
<a name="l02393"></a>02393     u32 first_l4l5;
<a name="l02394"></a>02394     u32 ctx_sz;
<a name="l02395"></a>02395     u32 config2;
<a name="l02396"></a>02396     resource_size_t reg_base;
<a name="l02397"></a>02397 
<a name="l02398"></a>02398     cid_num = bnx2i_get_cid_num(ep);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;ep-&gt;hba-&gt;cnic_dev_type)) {
<a name="l02401"></a>02401         reg_base = pci_resource_start(ep-&gt;hba-&gt;pcidev,
<a name="l02402"></a>02402                           BNX2X_DOORBELL_PCI_BAR);
<a name="l02403"></a>02403         reg_off = PAGE_SIZE * (cid_num &amp; 0x1FFFF) + DPM_TRIGER_TYPE;
<a name="l02404"></a>02404         ep-&gt;qp.ctx_base = ioremap_nocache(reg_base + reg_off, 4);
<a name="l02405"></a>02405         <span class="keywordflow">goto</span> arm_cq;
<a name="l02406"></a>02406     }
<a name="l02407"></a>02407 
<a name="l02408"></a>02408     reg_base = ep-&gt;hba-&gt;netdev-&gt;base_addr;
<a name="l02409"></a>02409     <span class="keywordflow">if</span> ((test_bit(BNX2I_NX2_DEV_5709, &amp;ep-&gt;hba-&gt;cnic_dev_type)) &amp;&amp;
<a name="l02410"></a>02410         (ep-&gt;hba-&gt;mail_queue_access == BNX2I_MQ_BIN_MODE)) {
<a name="l02411"></a>02411         config2 = REG_RD(ep-&gt;hba, BNX2_MQ_CONFIG2);
<a name="l02412"></a>02412         first_l4l5 = config2 &amp; BNX2_MQ_CONFIG2_FIRST_L4L5;
<a name="l02413"></a>02413         ctx_sz = (config2 &amp; BNX2_MQ_CONFIG2_CONT_SZ) &gt;&gt; 3;
<a name="l02414"></a>02414         <span class="keywordflow">if</span> (ctx_sz)
<a name="l02415"></a>02415             reg_off = CTX_OFFSET + MAX_CID_CNT * MB_KERNEL_CTX_SIZE
<a name="l02416"></a>02416                   + 4096 *
<a name="l02417"></a>02417                   (((cid_num - first_l4l5) / ctx_sz) + 256);
<a name="l02418"></a>02418         <span class="keywordflow">else</span>
<a name="l02419"></a>02419             reg_off = CTX_OFFSET + (MB_KERNEL_CTX_SIZE * cid_num);
<a name="l02420"></a>02420     } <span class="keywordflow">else</span> {
<a name="l02421"></a>02421         <span class="comment">/* 5709 device in normal node and 5706/5708 devices */</span>
<a name="l02422"></a>02422         reg_off = CTX_OFFSET + (MB_KERNEL_CTX_SIZE * cid_num);
<a name="l02423"></a>02423     }
<a name="l02424"></a>02424 
<a name="l02425"></a>02425     ep-&gt;qp.ctx_base = ioremap_nocache(reg_base + reg_off,
<a name="l02426"></a>02426                       MB_KERNEL_CTX_SIZE);
<a name="l02427"></a>02427     <span class="keywordflow">if</span> (!ep-&gt;qp.ctx_base)
<a name="l02428"></a>02428         <span class="keywordflow">return</span> -ENOMEM;
<a name="l02429"></a>02429 
<a name="l02430"></a>02430 arm_cq:
<a name="l02431"></a>02431     bnx2i_arm_cq_event_coalescing(ep, CNIC_ARM_CQE);
<a name="l02432"></a>02432     <span class="keywordflow">return</span> 0;
<a name="l02433"></a>02433 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:20 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
