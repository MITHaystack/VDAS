<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/e1000/e1000-8.0.30/src/e1000_82543.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_b064440f672cf1ec5d7b2cc914176ee8.html">e1000</a>      </li>
      <li class="navelem"><a class="el" href="dir_4859a2408a6c51d613c0d7311f4668c5.html">e1000-8.0.30</a>      </li>
      <li class="navelem"><a class="el" href="dir_b0d38ad6b7203b1acf95bbe85f205e61.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">e1000_82543.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Intel PRO/1000 Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">  Copyright(c) 1999 - 2010 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">  under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">  version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">  more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">  The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<a name="l00024"></a>00024 <span class="comment">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00025"></a>00025 <span class="comment">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">*******************************************************************************/</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">/*</span>
<a name="l00030"></a>00030 <span class="comment"> * 82543GC Gigabit Ethernet Controller (Fiber)</span>
<a name="l00031"></a>00031 <span class="comment"> * 82543GC Gigabit Ethernet Controller (Copper)</span>
<a name="l00032"></a>00032 <span class="comment"> * 82544EI Gigabit Ethernet Controller (Copper)</span>
<a name="l00033"></a>00033 <span class="comment"> * 82544EI Gigabit Ethernet Controller (Fiber)</span>
<a name="l00034"></a>00034 <span class="comment"> * 82544GC Gigabit Ethernet Controller (Copper)</span>
<a name="l00035"></a>00035 <span class="comment"> * 82544GC Gigabit Ethernet Controller (LOM)</span>
<a name="l00036"></a>00036 <span class="comment"> */</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;e1000_api.h&quot;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">static</span> s32  e1000_init_phy_params_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00041"></a>00041 <span class="keyword">static</span> s32  e1000_init_nvm_params_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00042"></a>00042 <span class="keyword">static</span> s32  e1000_init_mac_params_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00043"></a>00043 <span class="keyword">static</span> s32  e1000_read_phy_reg_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset,
<a name="l00044"></a>00044                                      u16 *data);
<a name="l00045"></a>00045 <span class="keyword">static</span> s32  e1000_write_phy_reg_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset,
<a name="l00046"></a>00046                                       u16 data);
<a name="l00047"></a>00047 <span class="keyword">static</span> s32  e1000_phy_force_speed_duplex_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00048"></a>00048 <span class="keyword">static</span> s32  e1000_phy_hw_reset_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00049"></a>00049 <span class="keyword">static</span> s32  e1000_reset_hw_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00050"></a>00050 <span class="keyword">static</span> s32  e1000_init_hw_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00051"></a>00051 <span class="keyword">static</span> s32  e1000_setup_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00052"></a>00052 <span class="keyword">static</span> s32  e1000_setup_copper_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00053"></a>00053 <span class="keyword">static</span> s32  e1000_setup_fiber_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00054"></a>00054 <span class="keyword">static</span> s32  e1000_check_for_copper_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00055"></a>00055 <span class="keyword">static</span> s32  e1000_check_for_fiber_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00056"></a>00056 <span class="keyword">static</span> s32  e1000_led_on_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00057"></a>00057 <span class="keyword">static</span> s32  e1000_led_off_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_write_vfta_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset,
<a name="l00059"></a>00059                                    u32 value);
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_clear_hw_cntrs_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00061"></a>00061 <span class="keyword">static</span> s32  e1000_config_mac_to_phy_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00062"></a>00062 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_init_phy_disabled_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_lower_mdi_clk_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 *ctrl);
<a name="l00064"></a>00064 <span class="keyword">static</span> s32  e1000_polarity_reversal_workaround_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00065"></a>00065 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_raise_mdi_clk_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 *ctrl);
<a name="l00066"></a>00066 <span class="keyword">static</span> u16  e1000_shift_in_mdi_bits_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_shift_out_mdi_bits_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 data,
<a name="l00068"></a>00068                                            u16 count);
<a name="l00069"></a>00069 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_tbi_compatibility_enabled_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00070"></a>00070 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_set_tbi_sbp_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> <a class="code" href="structstate.html">state</a>);
<a name="l00071"></a>00071 
<a name="l00076"></a>00076 <span class="keyword">static</span> s32 e1000_init_phy_params_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00077"></a>00077 {
<a name="l00078"></a>00078     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;hw-&gt;phy;
<a name="l00079"></a>00079     s32 ret_val = E1000_SUCCESS;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_phy_params_82543&quot;</span>);
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     <span class="keywordflow">if</span> (hw-&gt;phy.media_type != e1000_media_type_copper) {
<a name="l00084"></a>00084         phy-&gt;type               = e1000_phy_none;
<a name="l00085"></a>00085         <span class="keywordflow">goto</span> out;
<a name="l00086"></a>00086     } <span class="keywordflow">else</span> {
<a name="l00087"></a>00087         phy-&gt;ops.power_up       = e1000_power_up_phy_copper;
<a name="l00088"></a>00088         phy-&gt;ops.power_down     = e1000_power_down_phy_copper;
<a name="l00089"></a>00089     }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     phy-&gt;addr                       = 1;
<a name="l00092"></a>00092     phy-&gt;autoneg_mask               = AUTONEG_ADVERTISE_SPEED_DEFAULT;
<a name="l00093"></a>00093     phy-&gt;reset_delay_us             = 10000;
<a name="l00094"></a>00094     phy-&gt;type                       = e1000_phy_m88;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="comment">/* Function Pointers */</span>
<a name="l00097"></a>00097     phy-&gt;ops.check_polarity         = e1000_check_polarity_m88;
<a name="l00098"></a>00098     phy-&gt;ops.commit                 = e1000_phy_sw_reset_generic;
<a name="l00099"></a>00099     phy-&gt;ops.force_speed_duplex     = e1000_phy_force_speed_duplex_82543;
<a name="l00100"></a>00100     phy-&gt;ops.get_cable_length       = e1000_get_cable_length_m88;
<a name="l00101"></a>00101     phy-&gt;ops.get_cfg_done           = e1000_get_cfg_done_generic;
<a name="l00102"></a>00102     phy-&gt;ops.read_reg               = (hw-&gt;mac.type == e1000_82543)
<a name="l00103"></a>00103                                       ? e1000_read_phy_reg_82543
<a name="l00104"></a>00104                                       : e1000_read_phy_reg_m88;
<a name="l00105"></a>00105     phy-&gt;ops.reset                  = (hw-&gt;mac.type == e1000_82543)
<a name="l00106"></a>00106                                       ? e1000_phy_hw_reset_82543
<a name="l00107"></a>00107                                       : e1000_phy_hw_reset_generic;
<a name="l00108"></a>00108     phy-&gt;ops.write_reg              = (hw-&gt;mac.type == e1000_82543)
<a name="l00109"></a>00109                                       ? e1000_write_phy_reg_82543
<a name="l00110"></a>00110                                       : e1000_write_phy_reg_m88;
<a name="l00111"></a>00111     phy-&gt;ops.get_info               = e1000_get_phy_info_m88;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="comment">/*</span>
<a name="l00114"></a>00114 <span class="comment">     * The external PHY of the 82543 can be in a funky state.</span>
<a name="l00115"></a>00115 <span class="comment">     * Resetting helps us read the PHY registers for acquiring</span>
<a name="l00116"></a>00116 <span class="comment">     * the PHY ID.</span>
<a name="l00117"></a>00117 <span class="comment">     */</span>
<a name="l00118"></a>00118     <span class="keywordflow">if</span> (!e1000_init_phy_disabled_82543(hw)) {
<a name="l00119"></a>00119         ret_val = phy-&gt;ops.reset(hw);
<a name="l00120"></a>00120         <span class="keywordflow">if</span> (ret_val) {
<a name="l00121"></a>00121             DEBUGOUT(<span class="stringliteral">&quot;Resetting PHY during init failed.\n&quot;</span>);
<a name="l00122"></a>00122             <span class="keywordflow">goto</span> out;
<a name="l00123"></a>00123         }
<a name="l00124"></a>00124         msec_delay(20);
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     ret_val = e1000_get_phy_id(hw);
<a name="l00128"></a>00128     <span class="keywordflow">if</span> (ret_val)
<a name="l00129"></a>00129         <span class="keywordflow">goto</span> out;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="comment">/* Verify phy id */</span>
<a name="l00132"></a>00132     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00133"></a>00133     <span class="keywordflow">case</span> e1000_82543:
<a name="l00134"></a>00134         <span class="keywordflow">if</span> (phy-&gt;id != M88E1000_E_PHY_ID) {
<a name="l00135"></a>00135             ret_val = -E1000_ERR_PHY;
<a name="l00136"></a>00136             <span class="keywordflow">goto</span> out;
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138         <span class="keywordflow">break</span>;
<a name="l00139"></a>00139     <span class="keywordflow">case</span> e1000_82544:
<a name="l00140"></a>00140         <span class="keywordflow">if</span> (phy-&gt;id != M88E1000_I_PHY_ID) {
<a name="l00141"></a>00141             ret_val = -E1000_ERR_PHY;
<a name="l00142"></a>00142             <span class="keywordflow">goto</span> out;
<a name="l00143"></a>00143         }
<a name="l00144"></a>00144         <span class="keywordflow">break</span>;
<a name="l00145"></a>00145     <span class="keywordflow">default</span>:
<a name="l00146"></a>00146         ret_val = -E1000_ERR_PHY;
<a name="l00147"></a>00147         <span class="keywordflow">goto</span> out;
<a name="l00148"></a>00148         <span class="keywordflow">break</span>;
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 out:
<a name="l00152"></a>00152     <span class="keywordflow">return</span> ret_val;
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00159"></a>00159 <span class="keyword">static</span> s32 e1000_init_nvm_params_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161     <span class="keyword">struct </span><a class="code" href="structe1000__nvm__info.html">e1000_nvm_info</a> *nvm = &amp;hw-&gt;nvm;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_nvm_params_82543&quot;</span>);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     nvm-&gt;type               = e1000_nvm_eeprom_microwire;
<a name="l00166"></a>00166     nvm-&gt;word_size          = 64;
<a name="l00167"></a>00167     nvm-&gt;delay_usec         = 50;
<a name="l00168"></a>00168     nvm-&gt;address_bits       =  6;
<a name="l00169"></a>00169     nvm-&gt;opcode_bits        =  3;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="comment">/* Function Pointers */</span>
<a name="l00172"></a>00172     nvm-&gt;ops.read           = e1000_read_nvm_microwire;
<a name="l00173"></a>00173     nvm-&gt;ops.update         = e1000_update_nvm_checksum_generic;
<a name="l00174"></a>00174     nvm-&gt;ops.valid_led_default = e1000_valid_led_default_generic;
<a name="l00175"></a>00175     nvm-&gt;ops.validate       = e1000_validate_nvm_checksum_generic;
<a name="l00176"></a>00176     nvm-&gt;ops.write          = e1000_write_nvm_microwire;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00185"></a>00185 <span class="keyword">static</span> s32 e1000_init_mac_params_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_mac_params_82543&quot;</span>);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191     <span class="comment">/* Set media type */</span>
<a name="l00192"></a>00192     <span class="keywordflow">switch</span> (hw-&gt;device_id) {
<a name="l00193"></a>00193     <span class="keywordflow">case</span> E1000_DEV_ID_82543GC_FIBER:
<a name="l00194"></a>00194     <span class="keywordflow">case</span> E1000_DEV_ID_82544EI_FIBER:
<a name="l00195"></a>00195         hw-&gt;phy.media_type = e1000_media_type_fiber;
<a name="l00196"></a>00196         <span class="keywordflow">break</span>;
<a name="l00197"></a>00197     <span class="keywordflow">default</span>:
<a name="l00198"></a>00198         hw-&gt;phy.media_type = e1000_media_type_copper;
<a name="l00199"></a>00199         <span class="keywordflow">break</span>;
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     <span class="comment">/* Set mta register count */</span>
<a name="l00203"></a>00203     mac-&gt;mta_reg_count = 128;
<a name="l00204"></a>00204     <span class="comment">/* Set rar entry count */</span>
<a name="l00205"></a>00205     mac-&gt;rar_entry_count = E1000_RAR_ENTRIES;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <span class="comment">/* Function pointers */</span>
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="comment">/* bus type/speed/width */</span>
<a name="l00210"></a>00210     mac-&gt;ops.get_bus_info = e1000_get_bus_info_pci_generic;
<a name="l00211"></a>00211     <span class="comment">/* function id */</span>
<a name="l00212"></a>00212     mac-&gt;ops.set_lan_id = e1000_set_lan_id_multi_port_pci;
<a name="l00213"></a>00213     <span class="comment">/* reset */</span>
<a name="l00214"></a>00214     mac-&gt;ops.reset_hw = e1000_reset_hw_82543;
<a name="l00215"></a>00215     <span class="comment">/* hw initialization */</span>
<a name="l00216"></a>00216     mac-&gt;ops.init_hw = e1000_init_hw_82543;
<a name="l00217"></a>00217     <span class="comment">/* link setup */</span>
<a name="l00218"></a>00218     mac-&gt;ops.setup_link = e1000_setup_link_82543;
<a name="l00219"></a>00219     <span class="comment">/* physical interface setup */</span>
<a name="l00220"></a>00220     mac-&gt;ops.setup_physical_interface =
<a name="l00221"></a>00221             (hw-&gt;phy.media_type == e1000_media_type_copper)
<a name="l00222"></a>00222                     ? e1000_setup_copper_link_82543
<a name="l00223"></a>00223                     : e1000_setup_fiber_link_82543;
<a name="l00224"></a>00224     <span class="comment">/* check for link */</span>
<a name="l00225"></a>00225     mac-&gt;ops.check_for_link =
<a name="l00226"></a>00226             (hw-&gt;phy.media_type == e1000_media_type_copper)
<a name="l00227"></a>00227                     ? e1000_check_for_copper_link_82543
<a name="l00228"></a>00228                     : e1000_check_for_fiber_link_82543;
<a name="l00229"></a>00229     <span class="comment">/* link info */</span>
<a name="l00230"></a>00230     mac-&gt;ops.get_link_up_info =
<a name="l00231"></a>00231             (hw-&gt;phy.media_type == e1000_media_type_copper)
<a name="l00232"></a>00232                     ? e1000_get_speed_and_duplex_copper_generic
<a name="l00233"></a>00233                     : e1000_get_speed_and_duplex_fiber_serdes_generic;
<a name="l00234"></a>00234     <span class="comment">/* multicast address update */</span>
<a name="l00235"></a>00235     mac-&gt;ops.update_mc_addr_list = e1000_update_mc_addr_list_generic;
<a name="l00236"></a>00236     <span class="comment">/* writing VFTA */</span>
<a name="l00237"></a>00237     mac-&gt;ops.write_vfta = e1000_write_vfta_82543;
<a name="l00238"></a>00238     <span class="comment">/* clearing VFTA */</span>
<a name="l00239"></a>00239     mac-&gt;ops.clear_vfta = e1000_clear_vfta_generic;
<a name="l00240"></a>00240     <span class="comment">/* turn on/off LED */</span>
<a name="l00241"></a>00241     mac-&gt;ops.led_on = e1000_led_on_82543;
<a name="l00242"></a>00242     mac-&gt;ops.led_off = e1000_led_off_82543;
<a name="l00243"></a>00243     <span class="comment">/* clear hardware counters */</span>
<a name="l00244"></a>00244     mac-&gt;ops.clear_hw_cntrs = e1000_clear_hw_cntrs_82543;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="comment">/* Set tbi compatibility */</span>
<a name="l00247"></a>00247     <span class="keywordflow">if</span> ((hw-&gt;mac.type != e1000_82543) ||
<a name="l00248"></a>00248         (hw-&gt;phy.media_type == e1000_media_type_fiber))
<a name="l00249"></a>00249         e1000_set_tbi_compatibility_82543(hw, <span class="keyword">false</span>);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00260"></a>00260 <span class="keywordtype">void</span> e1000_init_function_pointers_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_function_pointers_82543&quot;</span>);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     hw-&gt;mac.ops.init_params = e1000_init_mac_params_82543;
<a name="l00265"></a>00265     hw-&gt;nvm.ops.init_params = e1000_init_nvm_params_82543;
<a name="l00266"></a>00266     hw-&gt;phy.ops.init_params = e1000_init_phy_params_82543;
<a name="l00267"></a>00267 }
<a name="l00268"></a>00268 
<a name="l00276"></a>00276 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_tbi_compatibility_enabled_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00277"></a>00277 {
<a name="l00278"></a>00278     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82543.html">e1000_dev_spec_82543</a> *dev_spec = &amp;hw-&gt;dev_spec._82543;
<a name="l00279"></a>00279     <span class="keywordtype">bool</span> <a class="code" href="structstate.html">state</a> = <span class="keyword">false</span>;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     DEBUGFUNC(<span class="stringliteral">&quot;e1000_tbi_compatibility_enabled_82543&quot;</span>);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82543) {
<a name="l00284"></a>00284         DEBUGOUT(<span class="stringliteral">&quot;TBI compatibility workaround for 82543 only.\n&quot;</span>);
<a name="l00285"></a>00285         <span class="keywordflow">goto</span> out;
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     state = (dev_spec-&gt;tbi_compatibility &amp; TBI_COMPAT_ENABLED)
<a name="l00289"></a>00289             ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 out:
<a name="l00292"></a>00292     <span class="keywordflow">return</span> state;
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00302"></a>00302 <span class="keywordtype">void</span> e1000_set_tbi_compatibility_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> state)
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82543.html">e1000_dev_spec_82543</a> *dev_spec = &amp;hw-&gt;dev_spec._82543;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     DEBUGFUNC(<span class="stringliteral">&quot;e1000_set_tbi_compatibility_82543&quot;</span>);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82543) {
<a name="l00309"></a>00309         DEBUGOUT(<span class="stringliteral">&quot;TBI compatibility workaround for 82543 only.\n&quot;</span>);
<a name="l00310"></a>00310         <span class="keywordflow">goto</span> out;
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="keywordflow">if</span> (state)
<a name="l00314"></a>00314         dev_spec-&gt;tbi_compatibility |= TBI_COMPAT_ENABLED;
<a name="l00315"></a>00315     <span class="keywordflow">else</span>
<a name="l00316"></a>00316         dev_spec-&gt;tbi_compatibility &amp;= ~TBI_COMPAT_ENABLED;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 out:
<a name="l00319"></a>00319     <span class="keywordflow">return</span>;
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00329"></a>00329 <span class="keywordtype">bool</span> e1000_tbi_sbp_enabled_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82543.html">e1000_dev_spec_82543</a> *dev_spec = &amp;hw-&gt;dev_spec._82543;
<a name="l00332"></a>00332     <span class="keywordtype">bool</span> state = <span class="keyword">false</span>;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     DEBUGFUNC(<span class="stringliteral">&quot;e1000_tbi_sbp_enabled_82543&quot;</span>);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82543) {
<a name="l00337"></a>00337         DEBUGOUT(<span class="stringliteral">&quot;TBI compatibility workaround for 82543 only.\n&quot;</span>);
<a name="l00338"></a>00338         <span class="keywordflow">goto</span> out;
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341     state = (dev_spec-&gt;tbi_compatibility &amp; TBI_SBP_ENABLED)
<a name="l00342"></a>00342             ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 out:
<a name="l00345"></a>00345     <span class="keywordflow">return</span> state;
<a name="l00346"></a>00346 }
<a name="l00347"></a>00347 
<a name="l00355"></a>00355 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_set_tbi_sbp_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> state)
<a name="l00356"></a>00356 {
<a name="l00357"></a>00357     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82543.html">e1000_dev_spec_82543</a> *dev_spec = &amp;hw-&gt;dev_spec._82543;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     DEBUGFUNC(<span class="stringliteral">&quot;e1000_set_tbi_sbp_82543&quot;</span>);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <span class="keywordflow">if</span> (state &amp;&amp; e1000_tbi_compatibility_enabled_82543(hw))
<a name="l00362"></a>00362         dev_spec-&gt;tbi_compatibility |= TBI_SBP_ENABLED;
<a name="l00363"></a>00363     <span class="keywordflow">else</span>
<a name="l00364"></a>00364         dev_spec-&gt;tbi_compatibility &amp;= ~TBI_SBP_ENABLED;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366     <span class="keywordflow">return</span>;
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00376"></a>00376 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_init_phy_disabled_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00377"></a>00377 {
<a name="l00378"></a>00378     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82543.html">e1000_dev_spec_82543</a> *dev_spec = &amp;hw-&gt;dev_spec._82543;
<a name="l00379"></a>00379     <span class="keywordtype">bool</span> ret_val;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_phy_disabled_82543&quot;</span>);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82543) {
<a name="l00384"></a>00384         ret_val = <span class="keyword">false</span>;
<a name="l00385"></a>00385         <span class="keywordflow">goto</span> out;
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     ret_val = dev_spec-&gt;init_phy_disabled;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 out:
<a name="l00391"></a>00391     <span class="keywordflow">return</span> ret_val;
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00404"></a>00404 <span class="keywordtype">void</span> e1000_tbi_adjust_stats_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00405"></a>00405                                   <span class="keyword">struct</span> <a class="code" href="structe1000__hw__stats.html">e1000_hw_stats</a> *stats, u32 frame_len,
<a name="l00406"></a>00406                                   u8 *mac_addr, u32 max_frame_size)
<a name="l00407"></a>00407 {
<a name="l00408"></a>00408     <span class="keywordflow">if</span> (!(e1000_tbi_sbp_enabled_82543(hw)))
<a name="l00409"></a>00409         <span class="keywordflow">goto</span> out;
<a name="l00410"></a>00410 
<a name="l00411"></a>00411     <span class="comment">/* First adjust the frame length. */</span>
<a name="l00412"></a>00412     frame_len--;
<a name="l00413"></a>00413     <span class="comment">/*</span>
<a name="l00414"></a>00414 <span class="comment">     * We need to adjust the statistics counters, since the hardware</span>
<a name="l00415"></a>00415 <span class="comment">     * counters overcount this packet as a CRC error and undercount</span>
<a name="l00416"></a>00416 <span class="comment">     * the packet as a good packet</span>
<a name="l00417"></a>00417 <span class="comment">     */</span>
<a name="l00418"></a>00418     <span class="comment">/* This packet should not be counted as a CRC error.    */</span>
<a name="l00419"></a>00419     stats-&gt;crcerrs--;
<a name="l00420"></a>00420     <span class="comment">/* This packet does count as a Good Packet Received.    */</span>
<a name="l00421"></a>00421     stats-&gt;gprc++;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">/* Adjust the Good Octets received counters             */</span>
<a name="l00424"></a>00424     stats-&gt;gorc += frame_len;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     <span class="comment">/*</span>
<a name="l00427"></a>00427 <span class="comment">     * Is this a broadcast or multicast?  Check broadcast first,</span>
<a name="l00428"></a>00428 <span class="comment">     * since the test for a multicast frame will test positive on</span>
<a name="l00429"></a>00429 <span class="comment">     * a broadcast frame.</span>
<a name="l00430"></a>00430 <span class="comment">     */</span>
<a name="l00431"></a>00431     <span class="keywordflow">if</span> ((mac_addr[0] == 0xff) &amp;&amp; (mac_addr[1] == 0xff))
<a name="l00432"></a>00432         <span class="comment">/* Broadcast packet */</span>
<a name="l00433"></a>00433         stats-&gt;bprc++;
<a name="l00434"></a>00434     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*mac_addr &amp; 0x01)
<a name="l00435"></a>00435         <span class="comment">/* Multicast packet */</span>
<a name="l00436"></a>00436         stats-&gt;mprc++;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     <span class="comment">/*</span>
<a name="l00439"></a>00439 <span class="comment">     * In this case, the hardware has overcounted the number of</span>
<a name="l00440"></a>00440 <span class="comment">     * oversize frames.</span>
<a name="l00441"></a>00441 <span class="comment">     */</span>
<a name="l00442"></a>00442     <span class="keywordflow">if</span> ((frame_len == max_frame_size) &amp;&amp; (stats-&gt;roc &gt; 0))
<a name="l00443"></a>00443         stats-&gt;roc--;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     <span class="comment">/*</span>
<a name="l00446"></a>00446 <span class="comment">     * Adjust the bin counters when the extra byte put the frame in the</span>
<a name="l00447"></a>00447 <span class="comment">     * wrong bin. Remember that the frame_len was adjusted above.</span>
<a name="l00448"></a>00448 <span class="comment">     */</span>
<a name="l00449"></a>00449     <span class="keywordflow">if</span> (frame_len == 64) {
<a name="l00450"></a>00450         stats-&gt;prc64++;
<a name="l00451"></a>00451         stats-&gt;prc127--;
<a name="l00452"></a>00452     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (frame_len == 127) {
<a name="l00453"></a>00453         stats-&gt;prc127++;
<a name="l00454"></a>00454         stats-&gt;prc255--;
<a name="l00455"></a>00455     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (frame_len == 255) {
<a name="l00456"></a>00456         stats-&gt;prc255++;
<a name="l00457"></a>00457         stats-&gt;prc511--;
<a name="l00458"></a>00458     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (frame_len == 511) {
<a name="l00459"></a>00459         stats-&gt;prc511++;
<a name="l00460"></a>00460         stats-&gt;prc1023--;
<a name="l00461"></a>00461     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (frame_len == 1023) {
<a name="l00462"></a>00462         stats-&gt;prc1023++;
<a name="l00463"></a>00463         stats-&gt;prc1522--;
<a name="l00464"></a>00464     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (frame_len == 1522) {
<a name="l00465"></a>00465         stats-&gt;prc1522++;
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 out:
<a name="l00469"></a>00469     <span class="keywordflow">return</span>;
<a name="l00470"></a>00470 }
<a name="l00471"></a>00471 
<a name="l00480"></a>00480 <span class="keyword">static</span> s32 e1000_read_phy_reg_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset, u16 *data)
<a name="l00481"></a>00481 {
<a name="l00482"></a>00482     u32 mdic;
<a name="l00483"></a>00483     s32 ret_val = E1000_SUCCESS;
<a name="l00484"></a>00484 
<a name="l00485"></a>00485     DEBUGFUNC(<span class="stringliteral">&quot;e1000_read_phy_reg_82543&quot;</span>);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487     <span class="keywordflow">if</span> (offset &gt; MAX_PHY_REG_ADDRESS) {
<a name="l00488"></a>00488         DEBUGOUT1(<span class="stringliteral">&quot;PHY Address %d is out of range\n&quot;</span>, offset);
<a name="l00489"></a>00489         ret_val = -E1000_ERR_PARAM;
<a name="l00490"></a>00490         <span class="keywordflow">goto</span> out;
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493     <span class="comment">/*</span>
<a name="l00494"></a>00494 <span class="comment">     * We must first send a preamble through the MDIO pin to signal the</span>
<a name="l00495"></a>00495 <span class="comment">     * beginning of an MII instruction.  This is done by sending 32</span>
<a name="l00496"></a>00496 <span class="comment">     * consecutive &quot;1&quot; bits.</span>
<a name="l00497"></a>00497 <span class="comment">     */</span>
<a name="l00498"></a>00498     e1000_shift_out_mdi_bits_82543(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     <span class="comment">/*</span>
<a name="l00501"></a>00501 <span class="comment">     * Now combine the next few fields that are required for a read</span>
<a name="l00502"></a>00502 <span class="comment">     * operation.  We use this method instead of calling the</span>
<a name="l00503"></a>00503 <span class="comment">     * e1000_shift_out_mdi_bits routine five different times.  The format</span>
<a name="l00504"></a>00504 <span class="comment">     * of an MII read instruction consists of a shift out of 14 bits and</span>
<a name="l00505"></a>00505 <span class="comment">     * is defined as follows:</span>
<a name="l00506"></a>00506 <span class="comment">     *  &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Offset&gt;</span>
<a name="l00507"></a>00507 <span class="comment">     * followed by a shift in of 18 bits.  This first two bits shifted in</span>
<a name="l00508"></a>00508 <span class="comment">     * are TurnAround bits used to avoid contention on the MDIO pin when a</span>
<a name="l00509"></a>00509 <span class="comment">     * READ operation is performed.  These two bits are thrown away</span>
<a name="l00510"></a>00510 <span class="comment">     * followed by a shift in of 16 bits which contains the desired data.</span>
<a name="l00511"></a>00511 <span class="comment">     */</span>
<a name="l00512"></a>00512     mdic = (offset | (hw-&gt;phy.addr &lt;&lt; 5) |
<a name="l00513"></a>00513         (PHY_OP_READ &lt;&lt; 10) | (PHY_SOF &lt;&lt; 12));
<a name="l00514"></a>00514 
<a name="l00515"></a>00515     e1000_shift_out_mdi_bits_82543(hw, mdic, 14);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517     <span class="comment">/*</span>
<a name="l00518"></a>00518 <span class="comment">     * Now that we&#39;ve shifted out the read command to the MII, we need to</span>
<a name="l00519"></a>00519 <span class="comment">     * &quot;shift in&quot; the 16-bit value (18 total bits) of the requested PHY</span>
<a name="l00520"></a>00520 <span class="comment">     * register address.</span>
<a name="l00521"></a>00521 <span class="comment">     */</span>
<a name="l00522"></a>00522     *data = e1000_shift_in_mdi_bits_82543(hw);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 out:
<a name="l00525"></a>00525     <span class="keywordflow">return</span> ret_val;
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00536"></a>00536 <span class="keyword">static</span> s32 e1000_write_phy_reg_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset, u16 data)
<a name="l00537"></a>00537 {
<a name="l00538"></a>00538     u32 mdic;
<a name="l00539"></a>00539     s32 ret_val = E1000_SUCCESS;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541     DEBUGFUNC(<span class="stringliteral">&quot;e1000_write_phy_reg_82543&quot;</span>);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="keywordflow">if</span> (offset &gt; MAX_PHY_REG_ADDRESS) {
<a name="l00544"></a>00544         DEBUGOUT1(<span class="stringliteral">&quot;PHY Address %d is out of range\n&quot;</span>, offset);
<a name="l00545"></a>00545         ret_val = -E1000_ERR_PARAM;
<a name="l00546"></a>00546         <span class="keywordflow">goto</span> out;
<a name="l00547"></a>00547     }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549     <span class="comment">/*</span>
<a name="l00550"></a>00550 <span class="comment">     * We&#39;ll need to use the SW defined pins to shift the write command</span>
<a name="l00551"></a>00551 <span class="comment">     * out to the PHY. We first send a preamble to the PHY to signal the</span>
<a name="l00552"></a>00552 <span class="comment">     * beginning of the MII instruction.  This is done by sending 32</span>
<a name="l00553"></a>00553 <span class="comment">     * consecutive &quot;1&quot; bits.</span>
<a name="l00554"></a>00554 <span class="comment">     */</span>
<a name="l00555"></a>00555     e1000_shift_out_mdi_bits_82543(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <span class="comment">/*</span>
<a name="l00558"></a>00558 <span class="comment">     * Now combine the remaining required fields that will indicate a</span>
<a name="l00559"></a>00559 <span class="comment">     * write operation. We use this method instead of calling the</span>
<a name="l00560"></a>00560 <span class="comment">     * e1000_shift_out_mdi_bits routine for each field in the command. The</span>
<a name="l00561"></a>00561 <span class="comment">     * format of a MII write instruction is as follows:</span>
<a name="l00562"></a>00562 <span class="comment">     * &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&lt;Turnaround&gt;&lt;Data&gt;.</span>
<a name="l00563"></a>00563 <span class="comment">     */</span>
<a name="l00564"></a>00564     mdic = ((PHY_TURNAROUND) | (offset &lt;&lt; 2) | (hw-&gt;phy.addr &lt;&lt; 7) |
<a name="l00565"></a>00565             (PHY_OP_WRITE &lt;&lt; 12) | (PHY_SOF &lt;&lt; 14));
<a name="l00566"></a>00566     mdic &lt;&lt;= 16;
<a name="l00567"></a>00567     mdic |= (u32) data;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     e1000_shift_out_mdi_bits_82543(hw, mdic, 32);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 out:
<a name="l00572"></a>00572     <span class="keywordflow">return</span> ret_val;
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00583"></a>00583 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_raise_mdi_clk_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 *ctrl)
<a name="l00584"></a>00584 {
<a name="l00585"></a>00585     <span class="comment">/*</span>
<a name="l00586"></a>00586 <span class="comment">     * Raise the clock input to the Management Data Clock (by setting the</span>
<a name="l00587"></a>00587 <span class="comment">     * MDC bit), and then delay a sufficient amount of time.</span>
<a name="l00588"></a>00588 <span class="comment">     */</span>
<a name="l00589"></a>00589     E1000_WRITE_REG(hw, E1000_CTRL, (*ctrl | E1000_CTRL_MDC));
<a name="l00590"></a>00590     E1000_WRITE_FLUSH(hw);
<a name="l00591"></a>00591     usec_delay(10);
<a name="l00592"></a>00592 }
<a name="l00593"></a>00593 
<a name="l00602"></a>00602 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_lower_mdi_clk_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 *ctrl)
<a name="l00603"></a>00603 {
<a name="l00604"></a>00604     <span class="comment">/*</span>
<a name="l00605"></a>00605 <span class="comment">     * Lower the clock input to the Management Data Clock (by clearing the</span>
<a name="l00606"></a>00606 <span class="comment">     * MDC bit), and then delay a sufficient amount of time.</span>
<a name="l00607"></a>00607 <span class="comment">     */</span>
<a name="l00608"></a>00608     E1000_WRITE_REG(hw, E1000_CTRL, (*ctrl &amp; ~E1000_CTRL_MDC));
<a name="l00609"></a>00609     E1000_WRITE_FLUSH(hw);
<a name="l00610"></a>00610     usec_delay(10);
<a name="l00611"></a>00611 }
<a name="l00612"></a>00612 
<a name="l00623"></a>00623 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_shift_out_mdi_bits_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 data,
<a name="l00624"></a>00624                                            u16 count)
<a name="l00625"></a>00625 {
<a name="l00626"></a>00626     u32 ctrl, mask;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     <span class="comment">/*</span>
<a name="l00629"></a>00629 <span class="comment">     * We need to shift &quot;count&quot; number of bits out to the PHY.  So, the</span>
<a name="l00630"></a>00630 <span class="comment">     * value in the &quot;data&quot; parameter will be shifted out to the PHY one</span>
<a name="l00631"></a>00631 <span class="comment">     * bit at a time.  In order to do this, &quot;data&quot; must be broken down</span>
<a name="l00632"></a>00632 <span class="comment">     * into bits.</span>
<a name="l00633"></a>00633 <span class="comment">     */</span>
<a name="l00634"></a>00634     mask = 0x01;
<a name="l00635"></a>00635     mask &lt;&lt;= (count -1);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <span class="comment">/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */</span>
<a name="l00640"></a>00640     ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
<a name="l00641"></a>00641 
<a name="l00642"></a>00642     <span class="keywordflow">while</span> (mask) {
<a name="l00643"></a>00643         <span class="comment">/*</span>
<a name="l00644"></a>00644 <span class="comment">         * A &quot;1&quot; is shifted out to the PHY by setting the MDIO bit to</span>
<a name="l00645"></a>00645 <span class="comment">         * &quot;1&quot; and then raising and lowering the Management Data Clock.</span>
<a name="l00646"></a>00646 <span class="comment">         * A &quot;0&quot; is shifted out to the PHY by setting the MDIO bit to</span>
<a name="l00647"></a>00647 <span class="comment">         * &quot;0&quot; and then raising and lowering the clock.</span>
<a name="l00648"></a>00648 <span class="comment">         */</span>
<a name="l00649"></a>00649         <span class="keywordflow">if</span> (data &amp; mask) ctrl |= E1000_CTRL_MDIO;
<a name="l00650"></a>00650         <span class="keywordflow">else</span> ctrl &amp;= ~E1000_CTRL_MDIO;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l00653"></a>00653         E1000_WRITE_FLUSH(hw);
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         usec_delay(10);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         e1000_raise_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00658"></a>00658         e1000_lower_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660         mask &gt;&gt;= 1;
<a name="l00661"></a>00661     }
<a name="l00662"></a>00662 }
<a name="l00663"></a>00663 
<a name="l00673"></a>00673 <span class="keyword">static</span> u16 e1000_shift_in_mdi_bits_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00674"></a>00674 {
<a name="l00675"></a>00675     u32 ctrl;
<a name="l00676"></a>00676     u16 data = 0;
<a name="l00677"></a>00677     u8 i;
<a name="l00678"></a>00678 
<a name="l00679"></a>00679     <span class="comment">/*</span>
<a name="l00680"></a>00680 <span class="comment">     * In order to read a register from the PHY, we need to shift in a</span>
<a name="l00681"></a>00681 <span class="comment">     * total of 18 bits from the PHY.  The first two bit (turnaround)</span>
<a name="l00682"></a>00682 <span class="comment">     * times are used to avoid contention on the MDIO pin when a read</span>
<a name="l00683"></a>00683 <span class="comment">     * operation is performed.  These two bits are ignored by us and</span>
<a name="l00684"></a>00684 <span class="comment">     * thrown away.  Bits are &quot;shifted in&quot; by raising the input to the</span>
<a name="l00685"></a>00685 <span class="comment">     * Management Data Clock (setting the MDC bit) and then reading the</span>
<a name="l00686"></a>00686 <span class="comment">     * value of the MDIO bit.</span>
<a name="l00687"></a>00687 <span class="comment">     */</span>
<a name="l00688"></a>00688     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690     <span class="comment">/*</span>
<a name="l00691"></a>00691 <span class="comment">     * Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as</span>
<a name="l00692"></a>00692 <span class="comment">     * input.</span>
<a name="l00693"></a>00693 <span class="comment">     */</span>
<a name="l00694"></a>00694     ctrl &amp;= ~E1000_CTRL_MDIO_DIR;
<a name="l00695"></a>00695     ctrl &amp;= ~E1000_CTRL_MDIO;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697     E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l00698"></a>00698     E1000_WRITE_FLUSH(hw);
<a name="l00699"></a>00699 
<a name="l00700"></a>00700     <span class="comment">/*</span>
<a name="l00701"></a>00701 <span class="comment">     * Raise and lower the clock before reading in the data.  This accounts</span>
<a name="l00702"></a>00702 <span class="comment">     * for the turnaround bits.  The first clock occurred when we clocked</span>
<a name="l00703"></a>00703 <span class="comment">     * out the last bit of the Register Address.</span>
<a name="l00704"></a>00704 <span class="comment">     */</span>
<a name="l00705"></a>00705     e1000_raise_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00706"></a>00706     e1000_lower_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="keywordflow">for</span> (data = 0, i = 0; i &lt; 16; i++) {
<a name="l00709"></a>00709         data &lt;&lt;= 1;
<a name="l00710"></a>00710         e1000_raise_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00711"></a>00711         ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l00712"></a>00712         <span class="comment">/* Check to see if we shifted in a &quot;1&quot;. */</span>
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (ctrl &amp; E1000_CTRL_MDIO)
<a name="l00714"></a>00714             data |= 1;
<a name="l00715"></a>00715         e1000_lower_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00716"></a>00716     }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     e1000_raise_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00719"></a>00719     e1000_lower_mdi_clk_82543(hw, &amp;ctrl);
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     <span class="keywordflow">return</span> data;
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00732"></a>00732 <span class="keyword">static</span> s32 e1000_phy_force_speed_duplex_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00733"></a>00733 {
<a name="l00734"></a>00734     s32 ret_val;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     DEBUGFUNC(<span class="stringliteral">&quot;e1000_phy_force_speed_duplex_82543&quot;</span>);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     ret_val = e1000_phy_force_speed_duplex_m88(hw);
<a name="l00739"></a>00739     <span class="keywordflow">if</span> (ret_val)
<a name="l00740"></a>00740         <span class="keywordflow">goto</span> out;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="keywordflow">if</span> (!hw-&gt;mac.autoneg &amp;&amp;
<a name="l00743"></a>00743         (hw-&gt;mac.forced_speed_duplex &amp; E1000_ALL_10_SPEED))
<a name="l00744"></a>00744         ret_val = e1000_polarity_reversal_workaround_82543(hw);
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 out:
<a name="l00747"></a>00747     <span class="keywordflow">return</span> ret_val;
<a name="l00748"></a>00748 }
<a name="l00749"></a>00749 
<a name="l00758"></a>00758 <span class="keyword">static</span> s32 e1000_polarity_reversal_workaround_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00759"></a>00759 {
<a name="l00760"></a>00760     s32 ret_val = E1000_SUCCESS;
<a name="l00761"></a>00761     u16 mii_status_reg;
<a name="l00762"></a>00762     u16 i;
<a name="l00763"></a>00763     <span class="keywordtype">bool</span> link;
<a name="l00764"></a>00764 
<a name="l00765"></a>00765     <span class="keywordflow">if</span> (!(hw-&gt;phy.ops.write_reg))
<a name="l00766"></a>00766         <span class="keywordflow">goto</span> out;
<a name="l00767"></a>00767 
<a name="l00768"></a>00768     <span class="comment">/* Polarity reversal workaround for forced 10F/10H links. */</span>
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     <span class="comment">/* Disable the transmitter on the PHY */</span>
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
<a name="l00773"></a>00773     <span class="keywordflow">if</span> (ret_val)
<a name="l00774"></a>00774         <span class="keywordflow">goto</span> out;
<a name="l00775"></a>00775     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFFF);
<a name="l00776"></a>00776     <span class="keywordflow">if</span> (ret_val)
<a name="l00777"></a>00777         <span class="keywordflow">goto</span> out;
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
<a name="l00780"></a>00780     <span class="keywordflow">if</span> (ret_val)
<a name="l00781"></a>00781         <span class="keywordflow">goto</span> out;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783     <span class="comment">/*</span>
<a name="l00784"></a>00784 <span class="comment">     * This loop will early-out if the NO link condition has been met.</span>
<a name="l00785"></a>00785 <span class="comment">     * In other words, DO NOT use e1000_phy_has_link_generic() here.</span>
<a name="l00786"></a>00786 <span class="comment">     */</span>
<a name="l00787"></a>00787     <span class="keywordflow">for</span> (i = PHY_FORCE_TIME; i &gt; 0; i--) {
<a name="l00788"></a>00788         <span class="comment">/*</span>
<a name="l00789"></a>00789 <span class="comment">         * Read the MII Status Register and wait for Link Status bit</span>
<a name="l00790"></a>00790 <span class="comment">         * to be clear.</span>
<a name="l00791"></a>00791 <span class="comment">         */</span>
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         ret_val = hw-&gt;phy.ops.read_reg(hw, PHY_STATUS, &amp;mii_status_reg);
<a name="l00794"></a>00794         <span class="keywordflow">if</span> (ret_val)
<a name="l00795"></a>00795             <span class="keywordflow">goto</span> out;
<a name="l00796"></a>00796 
<a name="l00797"></a>00797         ret_val = hw-&gt;phy.ops.read_reg(hw, PHY_STATUS, &amp;mii_status_reg);
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (ret_val)
<a name="l00799"></a>00799             <span class="keywordflow">goto</span> out;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         <span class="keywordflow">if</span> ((mii_status_reg &amp; ~MII_SR_LINK_STATUS) == 0)
<a name="l00802"></a>00802             <span class="keywordflow">break</span>;
<a name="l00803"></a>00803         msec_delay_irq(100);
<a name="l00804"></a>00804     }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806     <span class="comment">/* Recommended delay time after link has been lost */</span>
<a name="l00807"></a>00807     msec_delay_irq(1000);
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     <span class="comment">/* Now we will re-enable the transmitter on the PHY */</span>
<a name="l00810"></a>00810 
<a name="l00811"></a>00811     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0019);
<a name="l00812"></a>00812     <span class="keywordflow">if</span> (ret_val)
<a name="l00813"></a>00813         <span class="keywordflow">goto</span> out;
<a name="l00814"></a>00814     msec_delay_irq(50);
<a name="l00815"></a>00815     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFFF0);
<a name="l00816"></a>00816     <span class="keywordflow">if</span> (ret_val)
<a name="l00817"></a>00817         <span class="keywordflow">goto</span> out;
<a name="l00818"></a>00818     msec_delay_irq(50);
<a name="l00819"></a>00819     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_GEN_CONTROL, 0xFF00);
<a name="l00820"></a>00820     <span class="keywordflow">if</span> (ret_val)
<a name="l00821"></a>00821         <span class="keywordflow">goto</span> out;
<a name="l00822"></a>00822     msec_delay_irq(50);
<a name="l00823"></a>00823     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_GEN_CONTROL, 0x0000);
<a name="l00824"></a>00824     <span class="keywordflow">if</span> (ret_val)
<a name="l00825"></a>00825         <span class="keywordflow">goto</span> out;
<a name="l00826"></a>00826 
<a name="l00827"></a>00827     ret_val = hw-&gt;phy.ops.write_reg(hw, M88E1000_PHY_PAGE_SELECT, 0x0000);
<a name="l00828"></a>00828     <span class="keywordflow">if</span> (ret_val)
<a name="l00829"></a>00829         <span class="keywordflow">goto</span> out;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831     <span class="comment">/*</span>
<a name="l00832"></a>00832 <span class="comment">     * Read the MII Status Register and wait for Link Status bit</span>
<a name="l00833"></a>00833 <span class="comment">     * to be set.</span>
<a name="l00834"></a>00834 <span class="comment">     */</span>
<a name="l00835"></a>00835     ret_val = e1000_phy_has_link_generic(hw, PHY_FORCE_TIME, 100000, &amp;link);
<a name="l00836"></a>00836     <span class="keywordflow">if</span> (ret_val)
<a name="l00837"></a>00837         <span class="keywordflow">goto</span> out;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 out:
<a name="l00840"></a>00840     <span class="keywordflow">return</span> ret_val;
<a name="l00841"></a>00841 }
<a name="l00842"></a>00842 
<a name="l00852"></a>00852 <span class="keyword">static</span> s32 e1000_phy_hw_reset_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00853"></a>00853 {
<a name="l00854"></a>00854     u32 ctrl_ext;
<a name="l00855"></a>00855     s32 ret_val;
<a name="l00856"></a>00856 
<a name="l00857"></a>00857     DEBUGFUNC(<span class="stringliteral">&quot;e1000_phy_hw_reset_82543&quot;</span>);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     <span class="comment">/*</span>
<a name="l00860"></a>00860 <span class="comment">     * Read the Extended Device Control Register, assert the PHY_RESET_DIR</span>
<a name="l00861"></a>00861 <span class="comment">     * bit to put the PHY into reset...</span>
<a name="l00862"></a>00862 <span class="comment">     */</span>
<a name="l00863"></a>00863     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l00864"></a>00864     ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
<a name="l00865"></a>00865     ctrl_ext &amp;= ~E1000_CTRL_EXT_SDP4_DATA;
<a name="l00866"></a>00866     E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
<a name="l00867"></a>00867     E1000_WRITE_FLUSH(hw);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     msec_delay(10);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871     <span class="comment">/* ...then take it out of reset. */</span>
<a name="l00872"></a>00872     ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
<a name="l00873"></a>00873     E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
<a name="l00874"></a>00874     E1000_WRITE_FLUSH(hw);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     usec_delay(150);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     <span class="keywordflow">if</span> (!(hw-&gt;phy.ops.get_cfg_done))
<a name="l00879"></a>00879         <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l00880"></a>00880 
<a name="l00881"></a>00881     ret_val = hw-&gt;phy.ops.get_cfg_done(hw);
<a name="l00882"></a>00882 
<a name="l00883"></a>00883     <span class="keywordflow">return</span> ret_val;
<a name="l00884"></a>00884 }
<a name="l00885"></a>00885 
<a name="l00892"></a>00892 <span class="keyword">static</span> s32 e1000_reset_hw_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00893"></a>00893 {
<a name="l00894"></a>00894     u32 ctrl;
<a name="l00895"></a>00895     s32 ret_val = E1000_SUCCESS;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897     DEBUGFUNC(<span class="stringliteral">&quot;e1000_reset_hw_82543&quot;</span>);
<a name="l00898"></a>00898 
<a name="l00899"></a>00899     DEBUGOUT(<span class="stringliteral">&quot;Masking off all interrupts\n&quot;</span>);
<a name="l00900"></a>00900     E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     E1000_WRITE_REG(hw, E1000_RCTL, 0);
<a name="l00903"></a>00903     E1000_WRITE_REG(hw, E1000_TCTL, E1000_TCTL_PSP);
<a name="l00904"></a>00904     E1000_WRITE_FLUSH(hw);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     e1000_set_tbi_sbp_82543(hw, <span class="keyword">false</span>);
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     <span class="comment">/*</span>
<a name="l00909"></a>00909 <span class="comment">     * Delay to allow any outstanding PCI transactions to complete before</span>
<a name="l00910"></a>00910 <span class="comment">     * resetting the device</span>
<a name="l00911"></a>00911 <span class="comment">     */</span>
<a name="l00912"></a>00912     msec_delay(10);
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     DEBUGOUT(<span class="stringliteral">&quot;Issuing a global reset to 82543/82544 MAC\n&quot;</span>);
<a name="l00917"></a>00917     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82543) {
<a name="l00918"></a>00918         E1000_WRITE_REG(hw, E1000_CTRL, ctrl | E1000_CTRL_RST);
<a name="l00919"></a>00919     } <span class="keywordflow">else</span> {
<a name="l00920"></a>00920         <span class="comment">/*</span>
<a name="l00921"></a>00921 <span class="comment">         * The 82544 can&#39;t ACK the 64-bit write when issuing the</span>
<a name="l00922"></a>00922 <span class="comment">         * reset, so use IO-mapping as a workaround.</span>
<a name="l00923"></a>00923 <span class="comment">         */</span>
<a name="l00924"></a>00924         E1000_WRITE_REG_IO(hw, E1000_CTRL, ctrl | E1000_CTRL_RST);
<a name="l00925"></a>00925     }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927     <span class="comment">/*</span>
<a name="l00928"></a>00928 <span class="comment">     * After MAC reset, force reload of NVM to restore power-on</span>
<a name="l00929"></a>00929 <span class="comment">     * settings to device.</span>
<a name="l00930"></a>00930 <span class="comment">     */</span>
<a name="l00931"></a>00931     hw-&gt;nvm.ops.reload(hw);
<a name="l00932"></a>00932     msec_delay(2);
<a name="l00933"></a>00933 
<a name="l00934"></a>00934     <span class="comment">/* Masking off and clearing any pending interrupts */</span>
<a name="l00935"></a>00935     E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);
<a name="l00936"></a>00936     E1000_READ_REG(hw, E1000_ICR);
<a name="l00937"></a>00937 
<a name="l00938"></a>00938     <span class="keywordflow">return</span> ret_val;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00947"></a>00947 <span class="keyword">static</span> s32 e1000_init_hw_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00948"></a>00948 {
<a name="l00949"></a>00949     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l00950"></a>00950     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82543.html">e1000_dev_spec_82543</a> *dev_spec = &amp;hw-&gt;dev_spec._82543;
<a name="l00951"></a>00951     u32 ctrl;
<a name="l00952"></a>00952     s32 ret_val;
<a name="l00953"></a>00953     u16 i;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_hw_82543&quot;</span>);
<a name="l00956"></a>00956 
<a name="l00957"></a>00957     <span class="comment">/* Disabling VLAN filtering */</span>
<a name="l00958"></a>00958     E1000_WRITE_REG(hw, E1000_VET, 0);
<a name="l00959"></a>00959     mac-&gt;ops.clear_vfta(hw);
<a name="l00960"></a>00960 
<a name="l00961"></a>00961     <span class="comment">/* Setup the receive address. */</span>
<a name="l00962"></a>00962     e1000_init_rx_addrs_generic(hw, mac-&gt;rar_entry_count);
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     <span class="comment">/* Zero out the Multicast HASH table */</span>
<a name="l00965"></a>00965     DEBUGOUT(<span class="stringliteral">&quot;Zeroing the MTA\n&quot;</span>);
<a name="l00966"></a>00966     <span class="keywordflow">for</span> (i = 0; i &lt; mac-&gt;mta_reg_count; i++) {
<a name="l00967"></a>00967         E1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);
<a name="l00968"></a>00968         E1000_WRITE_FLUSH(hw);
<a name="l00969"></a>00969     }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971     <span class="comment">/*</span>
<a name="l00972"></a>00972 <span class="comment">     * Set the PCI priority bit correctly in the CTRL register.  This</span>
<a name="l00973"></a>00973 <span class="comment">     * determines if the adapter gives priority to receives, or if it</span>
<a name="l00974"></a>00974 <span class="comment">     * gives equal priority to transmits and receives.</span>
<a name="l00975"></a>00975 <span class="comment">     */</span>
<a name="l00976"></a>00976     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82543 &amp;&amp; dev_spec-&gt;dma_fairness) {
<a name="l00977"></a>00977         ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l00978"></a>00978         E1000_WRITE_REG(hw, E1000_CTRL, ctrl | E1000_CTRL_PRIOR);
<a name="l00979"></a>00979     }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981     e1000_pcix_mmrbc_workaround_generic(hw);
<a name="l00982"></a>00982 
<a name="l00983"></a>00983     <span class="comment">/* Setup link and flow control */</span>
<a name="l00984"></a>00984     ret_val = mac-&gt;ops.setup_link(hw);
<a name="l00985"></a>00985 
<a name="l00986"></a>00986     <span class="comment">/*</span>
<a name="l00987"></a>00987 <span class="comment">     * Clear all of the statistics registers (clear on read).  It is</span>
<a name="l00988"></a>00988 <span class="comment">     * important that we do this after we have tried to establish link</span>
<a name="l00989"></a>00989 <span class="comment">     * because the symbol error count will increment wildly if there</span>
<a name="l00990"></a>00990 <span class="comment">     * is no link.</span>
<a name="l00991"></a>00991 <span class="comment">     */</span>
<a name="l00992"></a>00992     e1000_clear_hw_cntrs_82543(hw);
<a name="l00993"></a>00993 
<a name="l00994"></a>00994     <span class="keywordflow">return</span> ret_val;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l01010"></a>01010 <span class="keyword">static</span> s32 e1000_setup_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012     u32 ctrl_ext;
<a name="l01013"></a>01013     s32  ret_val;
<a name="l01014"></a>01014     u16 data;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016     DEBUGFUNC(<span class="stringliteral">&quot;e1000_setup_link_82543&quot;</span>);
<a name="l01017"></a>01017 
<a name="l01018"></a>01018     <span class="comment">/*</span>
<a name="l01019"></a>01019 <span class="comment">     * Take the 4 bits from NVM word 0xF that determine the initial</span>
<a name="l01020"></a>01020 <span class="comment">     * polarity value for the SW controlled pins, and setup the</span>
<a name="l01021"></a>01021 <span class="comment">     * Extended Device Control reg with that info.</span>
<a name="l01022"></a>01022 <span class="comment">     * This is needed because one of the SW controlled pins is used for</span>
<a name="l01023"></a>01023 <span class="comment">     * signal detection.  So this should be done before phy setup.</span>
<a name="l01024"></a>01024 <span class="comment">     */</span>
<a name="l01025"></a>01025     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82543) {
<a name="l01026"></a>01026         ret_val = hw-&gt;nvm.ops.read(hw, NVM_INIT_CONTROL2_REG, 1, &amp;data);
<a name="l01027"></a>01027         <span class="keywordflow">if</span> (ret_val) {
<a name="l01028"></a>01028             DEBUGOUT(<span class="stringliteral">&quot;NVM Read Error\n&quot;</span>);
<a name="l01029"></a>01029             ret_val = -E1000_ERR_NVM;
<a name="l01030"></a>01030             <span class="keywordflow">goto</span> out;
<a name="l01031"></a>01031         }
<a name="l01032"></a>01032         ctrl_ext = ((data &amp; NVM_WORD0F_SWPDIO_EXT_MASK) &lt;&lt;
<a name="l01033"></a>01033                     NVM_SWDPIO_EXT_SHIFT);
<a name="l01034"></a>01034         E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
<a name="l01035"></a>01035     }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037     ret_val = e1000_setup_link_generic(hw);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 out:
<a name="l01040"></a>01040     <span class="keywordflow">return</span> ret_val;
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 
<a name="l01051"></a>01051 <span class="keyword">static</span> s32 e1000_setup_copper_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01052"></a>01052 {
<a name="l01053"></a>01053     u32 ctrl;
<a name="l01054"></a>01054     s32 ret_val;
<a name="l01055"></a>01055     <span class="keywordtype">bool</span> link;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057     DEBUGFUNC(<span class="stringliteral">&quot;e1000_setup_copper_link_82543&quot;</span>);
<a name="l01058"></a>01058 
<a name="l01059"></a>01059     ctrl = E1000_READ_REG(hw, E1000_CTRL) | E1000_CTRL_SLU;
<a name="l01060"></a>01060     <span class="comment">/*</span>
<a name="l01061"></a>01061 <span class="comment">     * With 82543, we need to force speed and duplex on the MAC</span>
<a name="l01062"></a>01062 <span class="comment">     * equal to what the PHY speed and duplex configuration is.</span>
<a name="l01063"></a>01063 <span class="comment">     * In addition, we need to perform a hardware reset on the</span>
<a name="l01064"></a>01064 <span class="comment">     * PHY to take it out of reset.</span>
<a name="l01065"></a>01065 <span class="comment">     */</span>
<a name="l01066"></a>01066     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82543) {
<a name="l01067"></a>01067         ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
<a name="l01068"></a>01068         E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01069"></a>01069         ret_val = hw-&gt;phy.ops.reset(hw);
<a name="l01070"></a>01070         <span class="keywordflow">if</span> (ret_val)
<a name="l01071"></a>01071             <span class="keywordflow">goto</span> out;
<a name="l01072"></a>01072         hw-&gt;phy.reset_disable = <span class="keyword">false</span>;
<a name="l01073"></a>01073     } <span class="keywordflow">else</span> {
<a name="l01074"></a>01074         ctrl &amp;= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
<a name="l01075"></a>01075         E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     <span class="comment">/* Set MDI/MDI-X, Polarity Reversal, and downshift settings */</span>
<a name="l01079"></a>01079     ret_val = e1000_copper_link_setup_m88(hw);
<a name="l01080"></a>01080     <span class="keywordflow">if</span> (ret_val)
<a name="l01081"></a>01081         <span class="keywordflow">goto</span> out;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083     <span class="keywordflow">if</span> (hw-&gt;mac.autoneg) {
<a name="l01084"></a>01084         <span class="comment">/*</span>
<a name="l01085"></a>01085 <span class="comment">         * Setup autoneg and flow control advertisement and perform</span>
<a name="l01086"></a>01086 <span class="comment">         * autonegotiation.</span>
<a name="l01087"></a>01087 <span class="comment">         */</span>
<a name="l01088"></a>01088         ret_val = e1000_copper_link_autoneg(hw);
<a name="l01089"></a>01089         <span class="keywordflow">if</span> (ret_val)
<a name="l01090"></a>01090             <span class="keywordflow">goto</span> out;
<a name="l01091"></a>01091     } <span class="keywordflow">else</span> {
<a name="l01092"></a>01092         <span class="comment">/*</span>
<a name="l01093"></a>01093 <span class="comment">         * PHY will be set to 10H, 10F, 100H or 100F</span>
<a name="l01094"></a>01094 <span class="comment">         * depending on user settings.</span>
<a name="l01095"></a>01095 <span class="comment">         */</span>
<a name="l01096"></a>01096         DEBUGOUT(<span class="stringliteral">&quot;Forcing Speed and Duplex\n&quot;</span>);
<a name="l01097"></a>01097         ret_val = e1000_phy_force_speed_duplex_82543(hw);
<a name="l01098"></a>01098         <span class="keywordflow">if</span> (ret_val) {
<a name="l01099"></a>01099             DEBUGOUT(<span class="stringliteral">&quot;Error Forcing Speed and Duplex\n&quot;</span>);
<a name="l01100"></a>01100             <span class="keywordflow">goto</span> out;
<a name="l01101"></a>01101         }
<a name="l01102"></a>01102     }
<a name="l01103"></a>01103 
<a name="l01104"></a>01104     <span class="comment">/*</span>
<a name="l01105"></a>01105 <span class="comment">     * Check link status. Wait up to 100 microseconds for link to become</span>
<a name="l01106"></a>01106 <span class="comment">     * valid.</span>
<a name="l01107"></a>01107 <span class="comment">     */</span>
<a name="l01108"></a>01108     ret_val = e1000_phy_has_link_generic(hw,
<a name="l01109"></a>01109                                          COPPER_LINK_UP_LIMIT,
<a name="l01110"></a>01110                                          10,
<a name="l01111"></a>01111                                          &amp;link);
<a name="l01112"></a>01112     <span class="keywordflow">if</span> (ret_val)
<a name="l01113"></a>01113         <span class="keywordflow">goto</span> out;
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="keywordflow">if</span> (link) {
<a name="l01117"></a>01117         DEBUGOUT(<span class="stringliteral">&quot;Valid link established!!!\n&quot;</span>);
<a name="l01118"></a>01118         <span class="comment">/* Config the MAC and PHY after link is up */</span>
<a name="l01119"></a>01119         <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82544) {
<a name="l01120"></a>01120             e1000_config_collision_dist_generic(hw);
<a name="l01121"></a>01121         } <span class="keywordflow">else</span> {
<a name="l01122"></a>01122             ret_val = e1000_config_mac_to_phy_82543(hw);
<a name="l01123"></a>01123             <span class="keywordflow">if</span> (ret_val)
<a name="l01124"></a>01124                 <span class="keywordflow">goto</span> out;
<a name="l01125"></a>01125         }
<a name="l01126"></a>01126         ret_val = e1000_config_fc_after_link_up_generic(hw);
<a name="l01127"></a>01127     } <span class="keywordflow">else</span> {
<a name="l01128"></a>01128         DEBUGOUT(<span class="stringliteral">&quot;Unable to establish link!!!\n&quot;</span>);
<a name="l01129"></a>01129     }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131 out:
<a name="l01132"></a>01132     <span class="keywordflow">return</span> ret_val;
<a name="l01133"></a>01133 }
<a name="l01134"></a>01134 
<a name="l01142"></a>01142 <span class="keyword">static</span> s32 e1000_setup_fiber_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01143"></a>01143 {
<a name="l01144"></a>01144     u32 ctrl;
<a name="l01145"></a>01145     s32 ret_val;
<a name="l01146"></a>01146 
<a name="l01147"></a>01147     DEBUGFUNC(<span class="stringliteral">&quot;e1000_setup_fiber_link_82543&quot;</span>);
<a name="l01148"></a>01148 
<a name="l01149"></a>01149     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     <span class="comment">/* Take the link out of reset */</span>
<a name="l01152"></a>01152     ctrl &amp;= ~E1000_CTRL_LRST;
<a name="l01153"></a>01153 
<a name="l01154"></a>01154     e1000_config_collision_dist_generic(hw);
<a name="l01155"></a>01155 
<a name="l01156"></a>01156     ret_val = e1000_commit_fc_settings_generic(hw);
<a name="l01157"></a>01157     <span class="keywordflow">if</span> (ret_val)
<a name="l01158"></a>01158         <span class="keywordflow">goto</span> out;
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     DEBUGOUT(<span class="stringliteral">&quot;Auto-negotiation enabled\n&quot;</span>);
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01163"></a>01163     E1000_WRITE_FLUSH(hw);
<a name="l01164"></a>01164     msec_delay(1);
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     <span class="comment">/*</span>
<a name="l01167"></a>01167 <span class="comment">     * For these adapters, the SW definable pin 1 is cleared when the</span>
<a name="l01168"></a>01168 <span class="comment">     * optics detect a signal.  If we have a signal, then poll for a</span>
<a name="l01169"></a>01169 <span class="comment">     * &quot;Link-Up&quot; indication.</span>
<a name="l01170"></a>01170 <span class="comment">     */</span>
<a name="l01171"></a>01171     <span class="keywordflow">if</span> (!(E1000_READ_REG(hw, E1000_CTRL) &amp; E1000_CTRL_SWDPIN1)) {
<a name="l01172"></a>01172         ret_val = e1000_poll_fiber_serdes_link_generic(hw);
<a name="l01173"></a>01173     } <span class="keywordflow">else</span> {
<a name="l01174"></a>01174         DEBUGOUT(<span class="stringliteral">&quot;No signal detected\n&quot;</span>);
<a name="l01175"></a>01175     }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177 out:
<a name="l01178"></a>01178     <span class="keywordflow">return</span> ret_val;
<a name="l01179"></a>01179 }
<a name="l01180"></a>01180 
<a name="l01192"></a>01192 <span class="keyword">static</span> s32 e1000_check_for_copper_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01193"></a>01193 {
<a name="l01194"></a>01194     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l01195"></a>01195     u32 icr, rctl;
<a name="l01196"></a>01196     s32 ret_val;
<a name="l01197"></a>01197     u16 speed, duplex;
<a name="l01198"></a>01198     <span class="keywordtype">bool</span> link;
<a name="l01199"></a>01199 
<a name="l01200"></a>01200     DEBUGFUNC(<span class="stringliteral">&quot;e1000_check_for_copper_link_82543&quot;</span>);
<a name="l01201"></a>01201 
<a name="l01202"></a>01202     <span class="keywordflow">if</span> (!mac-&gt;get_link_status) {
<a name="l01203"></a>01203         ret_val = E1000_SUCCESS;
<a name="l01204"></a>01204         <span class="keywordflow">goto</span> out;
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     ret_val = e1000_phy_has_link_generic(hw, 1, 0, &amp;link);
<a name="l01208"></a>01208     <span class="keywordflow">if</span> (ret_val)
<a name="l01209"></a>01209         <span class="keywordflow">goto</span> out;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211     <span class="keywordflow">if</span> (!link)
<a name="l01212"></a>01212         <span class="keywordflow">goto</span> out; <span class="comment">/* No link detected */</span>
<a name="l01213"></a>01213 
<a name="l01214"></a>01214     mac-&gt;get_link_status = <span class="keyword">false</span>;
<a name="l01215"></a>01215 
<a name="l01216"></a>01216     e1000_check_downshift_generic(hw);
<a name="l01217"></a>01217 
<a name="l01218"></a>01218     <span class="comment">/*</span>
<a name="l01219"></a>01219 <span class="comment">     * If we are forcing speed/duplex, then we can return since</span>
<a name="l01220"></a>01220 <span class="comment">     * we have already determined whether we have link or not.</span>
<a name="l01221"></a>01221 <span class="comment">     */</span>
<a name="l01222"></a>01222     <span class="keywordflow">if</span> (!mac-&gt;autoneg) {
<a name="l01223"></a>01223         <span class="comment">/*</span>
<a name="l01224"></a>01224 <span class="comment">         * If speed and duplex are forced to 10H or 10F, then we will</span>
<a name="l01225"></a>01225 <span class="comment">         * implement the polarity reversal workaround.  We disable</span>
<a name="l01226"></a>01226 <span class="comment">         * interrupts first, and upon returning, place the devices</span>
<a name="l01227"></a>01227 <span class="comment">         * interrupt state to its previous value except for the link</span>
<a name="l01228"></a>01228 <span class="comment">         * status change interrupt which will happened due to the</span>
<a name="l01229"></a>01229 <span class="comment">         * execution of this workaround.</span>
<a name="l01230"></a>01230 <span class="comment">         */</span>
<a name="l01231"></a>01231         <span class="keywordflow">if</span> (mac-&gt;forced_speed_duplex &amp; E1000_ALL_10_SPEED) {
<a name="l01232"></a>01232             E1000_WRITE_REG(hw, E1000_IMC, 0xFFFFFFFF);
<a name="l01233"></a>01233             ret_val = e1000_polarity_reversal_workaround_82543(hw);
<a name="l01234"></a>01234             icr = E1000_READ_REG(hw, E1000_ICR);
<a name="l01235"></a>01235             E1000_WRITE_REG(hw, E1000_ICS, (icr &amp; ~E1000_ICS_LSC));
<a name="l01236"></a>01236             E1000_WRITE_REG(hw, E1000_IMS, IMS_ENABLE_MASK);
<a name="l01237"></a>01237         }
<a name="l01238"></a>01238 
<a name="l01239"></a>01239         ret_val = -E1000_ERR_CONFIG;
<a name="l01240"></a>01240         <span class="keywordflow">goto</span> out;
<a name="l01241"></a>01241     }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243     <span class="comment">/*</span>
<a name="l01244"></a>01244 <span class="comment">     * We have a M88E1000 PHY and Auto-Neg is enabled.  If we</span>
<a name="l01245"></a>01245 <span class="comment">     * have Si on board that is 82544 or newer, Auto</span>
<a name="l01246"></a>01246 <span class="comment">     * Speed Detection takes care of MAC speed/duplex</span>
<a name="l01247"></a>01247 <span class="comment">     * configuration.  So we only need to configure Collision</span>
<a name="l01248"></a>01248 <span class="comment">     * Distance in the MAC.  Otherwise, we need to force</span>
<a name="l01249"></a>01249 <span class="comment">     * speed/duplex on the MAC to the current PHY speed/duplex</span>
<a name="l01250"></a>01250 <span class="comment">     * settings.</span>
<a name="l01251"></a>01251 <span class="comment">     */</span>
<a name="l01252"></a>01252     <span class="keywordflow">if</span> (mac-&gt;type == e1000_82544)
<a name="l01253"></a>01253         e1000_config_collision_dist_generic(hw);
<a name="l01254"></a>01254     <span class="keywordflow">else</span> {
<a name="l01255"></a>01255         ret_val = e1000_config_mac_to_phy_82543(hw);
<a name="l01256"></a>01256         <span class="keywordflow">if</span> (ret_val) {
<a name="l01257"></a>01257             DEBUGOUT(<span class="stringliteral">&quot;Error configuring MAC to PHY settings\n&quot;</span>);
<a name="l01258"></a>01258             <span class="keywordflow">goto</span> out;
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     <span class="comment">/*</span>
<a name="l01263"></a>01263 <span class="comment">     * Configure Flow Control now that Auto-Neg has completed.</span>
<a name="l01264"></a>01264 <span class="comment">     * First, we need to restore the desired flow control</span>
<a name="l01265"></a>01265 <span class="comment">     * settings because we may have had to re-autoneg with a</span>
<a name="l01266"></a>01266 <span class="comment">     * different link partner.</span>
<a name="l01267"></a>01267 <span class="comment">     */</span>
<a name="l01268"></a>01268     ret_val = e1000_config_fc_after_link_up_generic(hw);
<a name="l01269"></a>01269     <span class="keywordflow">if</span> (ret_val) {
<a name="l01270"></a>01270         DEBUGOUT(<span class="stringliteral">&quot;Error configuring flow control\n&quot;</span>);
<a name="l01271"></a>01271     }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     <span class="comment">/*</span>
<a name="l01274"></a>01274 <span class="comment">     * At this point we know that we are on copper and we have</span>
<a name="l01275"></a>01275 <span class="comment">     * auto-negotiated link.  These are conditions for checking the link</span>
<a name="l01276"></a>01276 <span class="comment">     * partner capability register.  We use the link speed to determine if</span>
<a name="l01277"></a>01277 <span class="comment">     * TBI compatibility needs to be turned on or off.  If the link is not</span>
<a name="l01278"></a>01278 <span class="comment">     * at gigabit speed, then TBI compatibility is not needed.  If we are</span>
<a name="l01279"></a>01279 <span class="comment">     * at gigabit speed, we turn on TBI compatibility.</span>
<a name="l01280"></a>01280 <span class="comment">     */</span>
<a name="l01281"></a>01281     <span class="keywordflow">if</span> (e1000_tbi_compatibility_enabled_82543(hw)) {
<a name="l01282"></a>01282         ret_val = mac-&gt;ops.get_link_up_info(hw, &amp;speed, &amp;duplex);
<a name="l01283"></a>01283         <span class="keywordflow">if</span> (ret_val) {
<a name="l01284"></a>01284             DEBUGOUT(<span class="stringliteral">&quot;Error getting link speed and duplex\n&quot;</span>);
<a name="l01285"></a>01285             <span class="keywordflow">return</span> ret_val;
<a name="l01286"></a>01286         }
<a name="l01287"></a>01287         <span class="keywordflow">if</span> (speed != SPEED_1000) {
<a name="l01288"></a>01288             <span class="comment">/*</span>
<a name="l01289"></a>01289 <span class="comment">             * If link speed is not set to gigabit speed,</span>
<a name="l01290"></a>01290 <span class="comment">             * we do not need to enable TBI compatibility.</span>
<a name="l01291"></a>01291 <span class="comment">             */</span>
<a name="l01292"></a>01292             <span class="keywordflow">if</span> (e1000_tbi_sbp_enabled_82543(hw)) {
<a name="l01293"></a>01293                 <span class="comment">/*</span>
<a name="l01294"></a>01294 <span class="comment">                 * If we previously were in the mode,</span>
<a name="l01295"></a>01295 <span class="comment">                 * turn it off.</span>
<a name="l01296"></a>01296 <span class="comment">                 */</span>
<a name="l01297"></a>01297                 e1000_set_tbi_sbp_82543(hw, <span class="keyword">false</span>);
<a name="l01298"></a>01298                 rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l01299"></a>01299                 rctl &amp;= ~E1000_RCTL_SBP;
<a name="l01300"></a>01300                 E1000_WRITE_REG(hw, E1000_RCTL, rctl);
<a name="l01301"></a>01301             }
<a name="l01302"></a>01302         } <span class="keywordflow">else</span> {
<a name="l01303"></a>01303             <span class="comment">/*</span>
<a name="l01304"></a>01304 <span class="comment">             * If TBI compatibility is was previously off,</span>
<a name="l01305"></a>01305 <span class="comment">             * turn it on. For compatibility with a TBI link</span>
<a name="l01306"></a>01306 <span class="comment">             * partner, we will store bad packets. Some</span>
<a name="l01307"></a>01307 <span class="comment">             * frames have an additional byte on the end and</span>
<a name="l01308"></a>01308 <span class="comment">             * will look like CRC errors to to the hardware.</span>
<a name="l01309"></a>01309 <span class="comment">             */</span>
<a name="l01310"></a>01310             <span class="keywordflow">if</span> (!e1000_tbi_sbp_enabled_82543(hw)) {
<a name="l01311"></a>01311                 e1000_set_tbi_sbp_82543(hw, <span class="keyword">true</span>);
<a name="l01312"></a>01312                 rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l01313"></a>01313                 rctl |= E1000_RCTL_SBP;
<a name="l01314"></a>01314                 E1000_WRITE_REG(hw, E1000_RCTL, rctl);
<a name="l01315"></a>01315             }
<a name="l01316"></a>01316         }
<a name="l01317"></a>01317     }
<a name="l01318"></a>01318 out:
<a name="l01319"></a>01319     <span class="keywordflow">return</span> ret_val;
<a name="l01320"></a>01320 }
<a name="l01321"></a>01321 
<a name="l01329"></a>01329 <span class="keyword">static</span> s32 e1000_check_for_fiber_link_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01330"></a>01330 {
<a name="l01331"></a>01331     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l01332"></a>01332     u32 rxcw, ctrl, status;
<a name="l01333"></a>01333     s32 ret_val = E1000_SUCCESS;
<a name="l01334"></a>01334 
<a name="l01335"></a>01335     DEBUGFUNC(<span class="stringliteral">&quot;e1000_check_for_fiber_link_82543&quot;</span>);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01338"></a>01338     status = E1000_READ_REG(hw, E1000_STATUS);
<a name="l01339"></a>01339     rxcw = E1000_READ_REG(hw, E1000_RXCW);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341     <span class="comment">/*</span>
<a name="l01342"></a>01342 <span class="comment">     * If we don&#39;t have link (auto-negotiation failed or link partner</span>
<a name="l01343"></a>01343 <span class="comment">     * cannot auto-negotiate), the cable is plugged in (we have signal),</span>
<a name="l01344"></a>01344 <span class="comment">     * and our link partner is not trying to auto-negotiate with us (we</span>
<a name="l01345"></a>01345 <span class="comment">     * are receiving idles or data), we need to force link up. We also</span>
<a name="l01346"></a>01346 <span class="comment">     * need to give auto-negotiation time to complete, in case the cable</span>
<a name="l01347"></a>01347 <span class="comment">     * was just plugged in. The autoneg_failed flag does this.</span>
<a name="l01348"></a>01348 <span class="comment">     */</span>
<a name="l01349"></a>01349     <span class="comment">/* (ctrl &amp; E1000_CTRL_SWDPIN1) == 0 == have signal */</span>
<a name="l01350"></a>01350     <span class="keywordflow">if</span> ((!(ctrl &amp; E1000_CTRL_SWDPIN1)) &amp;&amp;
<a name="l01351"></a>01351         (!(status &amp; E1000_STATUS_LU)) &amp;&amp;
<a name="l01352"></a>01352         (!(rxcw &amp; E1000_RXCW_C))) {
<a name="l01353"></a>01353         <span class="keywordflow">if</span> (mac-&gt;autoneg_failed == 0) {
<a name="l01354"></a>01354             mac-&gt;autoneg_failed = 1;
<a name="l01355"></a>01355             ret_val = 0;
<a name="l01356"></a>01356             <span class="keywordflow">goto</span> out;
<a name="l01357"></a>01357         }
<a name="l01358"></a>01358         DEBUGOUT(<span class="stringliteral">&quot;NOT RXing /C/, disable AutoNeg and force link.\n&quot;</span>);
<a name="l01359"></a>01359 
<a name="l01360"></a>01360         <span class="comment">/* Disable auto-negotiation in the TXCW register */</span>
<a name="l01361"></a>01361         E1000_WRITE_REG(hw, E1000_TXCW, (mac-&gt;txcw &amp; ~E1000_TXCW_ANE));
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         <span class="comment">/* Force link-up and also force full-duplex. */</span>
<a name="l01364"></a>01364         ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01365"></a>01365         ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
<a name="l01366"></a>01366         E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01367"></a>01367 
<a name="l01368"></a>01368         <span class="comment">/* Configure Flow Control after forcing link up. */</span>
<a name="l01369"></a>01369         ret_val = e1000_config_fc_after_link_up_generic(hw);
<a name="l01370"></a>01370         <span class="keywordflow">if</span> (ret_val) {
<a name="l01371"></a>01371             DEBUGOUT(<span class="stringliteral">&quot;Error configuring flow control\n&quot;</span>);
<a name="l01372"></a>01372             <span class="keywordflow">goto</span> out;
<a name="l01373"></a>01373         }
<a name="l01374"></a>01374     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ctrl &amp; E1000_CTRL_SLU) &amp;&amp; (rxcw &amp; E1000_RXCW_C)) {
<a name="l01375"></a>01375         <span class="comment">/*</span>
<a name="l01376"></a>01376 <span class="comment">         * If we are forcing link and we are receiving /C/ ordered</span>
<a name="l01377"></a>01377 <span class="comment">         * sets, re-enable auto-negotiation in the TXCW register</span>
<a name="l01378"></a>01378 <span class="comment">         * and disable forced link in the Device Control register</span>
<a name="l01379"></a>01379 <span class="comment">         * in an attempt to auto-negotiate with our link partner.</span>
<a name="l01380"></a>01380 <span class="comment">         */</span>
<a name="l01381"></a>01381         DEBUGOUT(<span class="stringliteral">&quot;RXing /C/, enable AutoNeg and stop forcing link.\n&quot;</span>);
<a name="l01382"></a>01382         E1000_WRITE_REG(hw, E1000_TXCW, mac-&gt;txcw);
<a name="l01383"></a>01383         E1000_WRITE_REG(hw, E1000_CTRL, (ctrl &amp; ~E1000_CTRL_SLU));
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         mac-&gt;serdes_has_link = <span class="keyword">true</span>;
<a name="l01386"></a>01386     }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388 out:
<a name="l01389"></a>01389     <span class="keywordflow">return</span> ret_val;
<a name="l01390"></a>01390 }
<a name="l01391"></a>01391 
<a name="l01399"></a>01399 <span class="keyword">static</span> s32 e1000_config_mac_to_phy_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01400"></a>01400 {
<a name="l01401"></a>01401     u32 ctrl;
<a name="l01402"></a>01402     s32 ret_val = E1000_SUCCESS;
<a name="l01403"></a>01403     u16 phy_data;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405     DEBUGFUNC(<span class="stringliteral">&quot;e1000_config_mac_to_phy_82543&quot;</span>);
<a name="l01406"></a>01406 
<a name="l01407"></a>01407     <span class="keywordflow">if</span> (!(hw-&gt;phy.ops.read_reg))
<a name="l01408"></a>01408         <span class="keywordflow">goto</span> out;
<a name="l01409"></a>01409 
<a name="l01410"></a>01410     <span class="comment">/* Set the bits to force speed and duplex */</span>
<a name="l01411"></a>01411     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01412"></a>01412     ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
<a name="l01413"></a>01413     ctrl &amp;= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);
<a name="l01414"></a>01414 
<a name="l01415"></a>01415     <span class="comment">/*</span>
<a name="l01416"></a>01416 <span class="comment">     * Set up duplex in the Device Control and Transmit Control</span>
<a name="l01417"></a>01417 <span class="comment">     * registers depending on negotiated values.</span>
<a name="l01418"></a>01418 <span class="comment">     */</span>
<a name="l01419"></a>01419     ret_val = hw-&gt;phy.ops.read_reg(hw, M88E1000_PHY_SPEC_STATUS, &amp;phy_data);
<a name="l01420"></a>01420     <span class="keywordflow">if</span> (ret_val)
<a name="l01421"></a>01421         <span class="keywordflow">goto</span> out;
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     ctrl &amp;= ~E1000_CTRL_FD;
<a name="l01424"></a>01424     <span class="keywordflow">if</span> (phy_data &amp; M88E1000_PSSR_DPLX)
<a name="l01425"></a>01425         ctrl |= E1000_CTRL_FD;
<a name="l01426"></a>01426 
<a name="l01427"></a>01427     e1000_config_collision_dist_generic(hw);
<a name="l01428"></a>01428 
<a name="l01429"></a>01429     <span class="comment">/*</span>
<a name="l01430"></a>01430 <span class="comment">     * Set up speed in the Device Control register depending on</span>
<a name="l01431"></a>01431 <span class="comment">     * negotiated values.</span>
<a name="l01432"></a>01432 <span class="comment">     */</span>
<a name="l01433"></a>01433     <span class="keywordflow">if</span> ((phy_data &amp; M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
<a name="l01434"></a>01434         ctrl |= E1000_CTRL_SPD_1000;
<a name="l01435"></a>01435     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((phy_data &amp; M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
<a name="l01436"></a>01436         ctrl |= E1000_CTRL_SPD_100;
<a name="l01437"></a>01437 
<a name="l01438"></a>01438     E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01439"></a>01439 
<a name="l01440"></a>01440 out:
<a name="l01441"></a>01441     <span class="keywordflow">return</span> ret_val;
<a name="l01442"></a>01442 }
<a name="l01443"></a>01443 
<a name="l01453"></a>01453 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_write_vfta_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset, u32 value)
<a name="l01454"></a>01454 {
<a name="l01455"></a>01455     u32 temp;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457     DEBUGFUNC(<span class="stringliteral">&quot;e1000_write_vfta_82543&quot;</span>);
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     <span class="keywordflow">if</span> ((hw-&gt;mac.type == e1000_82544) &amp;&amp; (offset &amp; 1)) {
<a name="l01460"></a>01460         temp = E1000_READ_REG_ARRAY(hw, E1000_VFTA, offset - 1);
<a name="l01461"></a>01461         E1000_WRITE_REG_ARRAY(hw, E1000_VFTA, offset, value);
<a name="l01462"></a>01462         E1000_WRITE_FLUSH(hw);
<a name="l01463"></a>01463         E1000_WRITE_REG_ARRAY(hw, E1000_VFTA, offset - 1, temp);
<a name="l01464"></a>01464         E1000_WRITE_FLUSH(hw);
<a name="l01465"></a>01465     } <span class="keywordflow">else</span> {
<a name="l01466"></a>01466         e1000_write_vfta_generic(hw, offset, value);
<a name="l01467"></a>01467     }
<a name="l01468"></a>01468 }
<a name="l01469"></a>01469 
<a name="l01476"></a>01476 <span class="keyword">static</span> s32 e1000_led_on_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01477"></a>01477 {
<a name="l01478"></a>01478     u32 ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01479"></a>01479 
<a name="l01480"></a>01480     DEBUGFUNC(<span class="stringliteral">&quot;e1000_led_on_82543&quot;</span>);
<a name="l01481"></a>01481 
<a name="l01482"></a>01482     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82544 &amp;&amp;
<a name="l01483"></a>01483         hw-&gt;phy.media_type == e1000_media_type_copper) {
<a name="l01484"></a>01484         <span class="comment">/* Clear SW-definable Pin 0 to turn on the LED */</span>
<a name="l01485"></a>01485         ctrl &amp;= ~E1000_CTRL_SWDPIN0;
<a name="l01486"></a>01486         ctrl |= E1000_CTRL_SWDPIO0;
<a name="l01487"></a>01487     } <span class="keywordflow">else</span> {
<a name="l01488"></a>01488         <span class="comment">/* Fiber 82544 and all 82543 use this method */</span>
<a name="l01489"></a>01489         ctrl |= E1000_CTRL_SWDPIN0;
<a name="l01490"></a>01490         ctrl |= E1000_CTRL_SWDPIO0;
<a name="l01491"></a>01491     }
<a name="l01492"></a>01492     E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01493"></a>01493 
<a name="l01494"></a>01494     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l01495"></a>01495 }
<a name="l01496"></a>01496 
<a name="l01503"></a>01503 <span class="keyword">static</span> s32 e1000_led_off_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01504"></a>01504 {
<a name="l01505"></a>01505     u32 ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     DEBUGFUNC(<span class="stringliteral">&quot;e1000_led_off_82543&quot;</span>);
<a name="l01508"></a>01508 
<a name="l01509"></a>01509     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82544 &amp;&amp;
<a name="l01510"></a>01510         hw-&gt;phy.media_type == e1000_media_type_copper) {
<a name="l01511"></a>01511         <span class="comment">/* Set SW-definable Pin 0 to turn off the LED */</span>
<a name="l01512"></a>01512         ctrl |= E1000_CTRL_SWDPIN0;
<a name="l01513"></a>01513         ctrl |= E1000_CTRL_SWDPIO0;
<a name="l01514"></a>01514     } <span class="keywordflow">else</span> {
<a name="l01515"></a>01515         ctrl &amp;= ~E1000_CTRL_SWDPIN0;
<a name="l01516"></a>01516         ctrl |= E1000_CTRL_SWDPIO0;
<a name="l01517"></a>01517     }
<a name="l01518"></a>01518     E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01519"></a>01519 
<a name="l01520"></a>01520     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l01521"></a>01521 }
<a name="l01522"></a>01522 
<a name="l01529"></a>01529 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_clear_hw_cntrs_82543(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01530"></a>01530 {
<a name="l01531"></a>01531     DEBUGFUNC(<span class="stringliteral">&quot;e1000_clear_hw_cntrs_82543&quot;</span>);
<a name="l01532"></a>01532 
<a name="l01533"></a>01533     e1000_clear_hw_cntrs_base_generic(hw);
<a name="l01534"></a>01534 
<a name="l01535"></a>01535     E1000_READ_REG(hw, E1000_PRC64);
<a name="l01536"></a>01536     E1000_READ_REG(hw, E1000_PRC127);
<a name="l01537"></a>01537     E1000_READ_REG(hw, E1000_PRC255);
<a name="l01538"></a>01538     E1000_READ_REG(hw, E1000_PRC511);
<a name="l01539"></a>01539     E1000_READ_REG(hw, E1000_PRC1023);
<a name="l01540"></a>01540     E1000_READ_REG(hw, E1000_PRC1522);
<a name="l01541"></a>01541     E1000_READ_REG(hw, E1000_PTC64);
<a name="l01542"></a>01542     E1000_READ_REG(hw, E1000_PTC127);
<a name="l01543"></a>01543     E1000_READ_REG(hw, E1000_PTC255);
<a name="l01544"></a>01544     E1000_READ_REG(hw, E1000_PTC511);
<a name="l01545"></a>01545     E1000_READ_REG(hw, E1000_PTC1023);
<a name="l01546"></a>01546     E1000_READ_REG(hw, E1000_PTC1522);
<a name="l01547"></a>01547 
<a name="l01548"></a>01548     E1000_READ_REG(hw, E1000_ALGNERRC);
<a name="l01549"></a>01549     E1000_READ_REG(hw, E1000_RXERRC);
<a name="l01550"></a>01550     E1000_READ_REG(hw, E1000_TNCRS);
<a name="l01551"></a>01551     E1000_READ_REG(hw, E1000_CEXTERR);
<a name="l01552"></a>01552     E1000_READ_REG(hw, E1000_TSCTC);
<a name="l01553"></a>01553     E1000_READ_REG(hw, E1000_TSCTFC);
<a name="l01554"></a>01554 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:25 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
