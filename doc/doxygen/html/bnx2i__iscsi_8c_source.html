<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/broadcom/netxtreme2-5.2.50/bnx2i_sles11-2.0.1e-05/driver/bnx2i_iscsi.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_2eb02fd92a965ecd821875a0a052753b.html">broadcom</a>      </li>
      <li class="navelem"><a class="el" href="dir_0a4992c25a025ec51f35cbf57fa02bf7.html">netxtreme2-5.2.50</a>      </li>
      <li class="navelem"><a class="el" href="dir_9068ea9a8110d47a584a325eea2f8003.html">bnx2i_sles11-2.0.1e-05</a>      </li>
      <li class="navelem"><a class="el" href="dir_053aa95974aa42da3692c44002ab0932.html">driver</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">bnx2i_iscsi.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * bnx2i_iscsi.c: Broadcom NetXtreme II iSCSI driver.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (c) 2006 - 2008 Broadcom Corporation</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright (c) 2007, 2008 Mike Christie</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00010"></a>00010 <span class="comment"> * the Free Software Foundation.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * Written by: Anil Veerabhadrappa (anilgv@broadcom.com)</span>
<a name="l00013"></a>00013 <span class="comment"> * Maintain by: Eddie Wai (eddie.wai@broadcom.com)</span>
<a name="l00014"></a>00014 <span class="comment"> */</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;scsi/scsi_tcq.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;scsi/libiscsi.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;bnx2i.h&quot;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">struct </span>scsi_transport_template *bnx2i_scsi_xport_template;
<a name="l00021"></a>00021 <span class="keyword">struct </span>iscsi_transport bnx2i_iscsi_transport;
<a name="l00022"></a>00022 <span class="keyword">static</span> <span class="keyword">struct </span>scsi_host_template bnx2i_host_template;
<a name="l00023"></a>00023 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> en_tcp_dack;
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#ifdef _BNX2I_IOCTL_</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="keyword">extern</span> u16 bnx2i_alloc_tcp_port(<span class="keywordtype">void</span>);
<a name="l00027"></a>00027 <span class="keyword">extern</span> <span class="keywordtype">void</span> bnx2i_free_tcp_port(u16 port);
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="comment">/*</span>
<a name="l00031"></a>00031 <span class="comment"> * Global endpoint resource info</span>
<a name="l00032"></a>00032 <span class="comment"> */</span>
<a name="l00033"></a>00033 <span class="keyword">static</span> DEFINE_SPINLOCK(bnx2i_resc_lock); <span class="comment">/* protects global resources */</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_adapter_ready(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038     <span class="keywordtype">int</span> retval = 0;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040     <span class="keywordflow">if</span> (!hba || !test_bit(ADAPTER_STATE_UP, &amp;hba-&gt;adapter_state) ||
<a name="l00041"></a>00041         test_bit(ADAPTER_STATE_GOING_DOWN, &amp;hba-&gt;adapter_state) ||
<a name="l00042"></a>00042         test_bit(ADAPTER_STATE_LINK_DOWN, &amp;hba-&gt;adapter_state))
<a name="l00043"></a>00043         retval = -EPERM;
<a name="l00044"></a>00044     <span class="keywordflow">return</span> retval;
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_get_write_cmd_bd_idx(<span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd, u32 buf_off,
<a name="l00059"></a>00059                        u32 *start_bd_off, u32 *start_bd_idx)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061     <span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *bd_tbl = cmd-&gt;io_tbl.bd_tbl;
<a name="l00062"></a>00062     u32 cur_offset = 0;
<a name="l00063"></a>00063     u32 cur_bd_idx = 0;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     <span class="keywordflow">if</span> (buf_off) {
<a name="l00066"></a>00066         <span class="keywordflow">while</span> (buf_off &gt;= (cur_offset + bd_tbl-&gt;buffer_length)) {
<a name="l00067"></a>00067             cur_offset += bd_tbl-&gt;buffer_length;
<a name="l00068"></a>00068             cur_bd_idx++;
<a name="l00069"></a>00069             bd_tbl++;
<a name="l00070"></a>00070         }
<a name="l00071"></a>00071     }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     *start_bd_off = buf_off - cur_offset;
<a name="l00074"></a>00074     *start_bd_idx = cur_bd_idx;
<a name="l00075"></a>00075 }
<a name="l00076"></a>00076 
<a name="l00086"></a>00086 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_setup_write_cmd_bd_info(<span class="keyword">struct</span> iscsi_task *task)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088     <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd = task-&gt;dd_data;
<a name="l00089"></a>00089     u32 start_bd_offset;
<a name="l00090"></a>00090     u32 start_bd_idx;
<a name="l00091"></a>00091     u32 buffer_offset = 0;
<a name="l00092"></a>00092     u32 cmd_len = cmd-&gt;req.total_data_transfer_length;
<a name="l00093"></a>00093     u32 unsol_count = task-&gt;unsol_count;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095     <span class="comment">/* if ImmediateData is turned off &amp; IntialR2T is turned on,</span>
<a name="l00096"></a>00096 <span class="comment">     * there will be no immediate or unsolicited data, just return.</span>
<a name="l00097"></a>00097 <span class="comment">     */</span>
<a name="l00098"></a>00098 <span class="comment">/* TODO - check if this is correct, Anil</span>
<a name="l00099"></a>00099 <span class="comment">*/</span>
<a name="l00100"></a>00100     <span class="keywordflow">if</span> (!unsol_count &amp;&amp; !task-&gt;imm_count)
<a name="l00101"></a>00101         <span class="keywordflow">return</span>;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="comment">/* Immediate data */</span>
<a name="l00104"></a>00104     buffer_offset += task-&gt;imm_count;
<a name="l00105"></a>00105     <span class="keywordflow">if</span> (task-&gt;imm_count == cmd_len)
<a name="l00106"></a>00106         <span class="keywordflow">return</span>;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <span class="keywordflow">if</span> (unsol_count<span class="comment">/*iscsi_task_has_unsol_data(task)*/</span>) {
<a name="l00109"></a>00109         bnx2i_get_write_cmd_bd_idx(cmd, buffer_offset,
<a name="l00110"></a>00110                        &amp;start_bd_offset, &amp;start_bd_idx);
<a name="l00111"></a>00111         cmd-&gt;req.ud_buffer_offset = start_bd_offset;
<a name="l00112"></a>00112         cmd-&gt;req.ud_start_bd_index = start_bd_idx;
<a name="l00113"></a>00113         buffer_offset += task-&gt;unsol_count;
<a name="l00114"></a>00114     }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <span class="keywordflow">if</span> (buffer_offset != cmd_len) {
<a name="l00117"></a>00117         bnx2i_get_write_cmd_bd_idx(cmd, buffer_offset,
<a name="l00118"></a>00118                        &amp;start_bd_offset, &amp;start_bd_idx);
<a name="l00119"></a>00119         <span class="keywordflow">if</span> ((start_bd_offset &gt; task-&gt;conn-&gt;session-&gt;first_burst) ||
<a name="l00120"></a>00120             (start_bd_idx &gt; scsi_sg_count(cmd-&gt;scsi_cmd))) {
<a name="l00121"></a>00121             <span class="keywordtype">int</span> i = 0;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123             iscsi_conn_printk(KERN_ALERT, task-&gt;conn,
<a name="l00124"></a>00124                       <span class="stringliteral">&quot;bnx2i- error, buf offset 0x%x &quot;</span>
<a name="l00125"></a>00125                       <span class="stringliteral">&quot;bd_valid %d use_sg %d\n&quot;</span>,
<a name="l00126"></a>00126                       buffer_offset, cmd-&gt;io_tbl.bd_valid,
<a name="l00127"></a>00127                       scsi_sg_count(cmd-&gt;scsi_cmd));
<a name="l00128"></a>00128             <span class="keywordflow">for</span> (i = 0; i &lt; cmd-&gt;io_tbl.bd_valid; i++)
<a name="l00129"></a>00129                 iscsi_conn_printk(KERN_ALERT, task-&gt;conn,
<a name="l00130"></a>00130                           <span class="stringliteral">&quot;bnx2i err, bd[%d]: len %x\n&quot;</span>,
<a name="l00131"></a>00131                           i, cmd-&gt;io_tbl.bd_tbl[i].\
<a name="l00132"></a>00132                           buffer_length);
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134         cmd-&gt;req.sd_buffer_offset = start_bd_offset;
<a name="l00135"></a>00135         cmd-&gt;req.sd_start_bd_index = start_bd_idx;
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137 }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_map_scsi_sg(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, <span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd)
<a name="l00149"></a>00149 {
<a name="l00150"></a>00150     <span class="keyword">struct </span>scsi_cmnd *sc = cmd-&gt;scsi_cmd;
<a name="l00151"></a>00151     <span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *bd = cmd-&gt;io_tbl.bd_tbl;
<a name="l00152"></a>00152     <span class="keyword">struct </span>scatterlist *sg;
<a name="l00153"></a>00153     <span class="keywordtype">int</span> byte_count = 0;
<a name="l00154"></a>00154     <span class="keywordtype">int</span> bd_count = 0;
<a name="l00155"></a>00155     <span class="keywordtype">int</span> sg_count;
<a name="l00156"></a>00156     <span class="keywordtype">int</span> sg_len;
<a name="l00157"></a>00157     u64 addr;
<a name="l00158"></a>00158     <span class="keywordtype">int</span> i;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     BUG_ON(scsi_sg_count(sc) &gt; ISCSI_MAX_BDS_PER_CMD);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     sg_count = scsi_dma_map(sc);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     scsi_for_each_sg(sc, sg, sg_count, i) {
<a name="l00165"></a>00165         sg_len = sg_dma_len(sg);
<a name="l00166"></a>00166         addr = (u64) sg_dma_address(sg);
<a name="l00167"></a>00167         bd[bd_count].buffer_addr_lo = addr &amp; 0xffffffff;
<a name="l00168"></a>00168         bd[bd_count].buffer_addr_hi = addr &gt;&gt; 32;
<a name="l00169"></a>00169         bd[bd_count].buffer_length = sg_len;
<a name="l00170"></a>00170         bd[bd_count].flags = 0;
<a name="l00171"></a>00171         <span class="keywordflow">if</span> (bd_count == 0)
<a name="l00172"></a>00172             bd[bd_count].flags = ISCSI_BD_FIRST_IN_BD_CHAIN;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         byte_count += sg_len;
<a name="l00175"></a>00175         bd_count++;
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="keywordflow">if</span> (bd_count)
<a name="l00179"></a>00179         bd[bd_count - 1].flags |= ISCSI_BD_LAST_IN_BD_CHAIN;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     BUG_ON(byte_count != scsi_bufflen(sc));
<a name="l00182"></a>00182     <span class="keywordflow">return</span> bd_count;
<a name="l00183"></a>00183 }
<a name="l00184"></a>00184 
<a name="l00191"></a>00191 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_iscsi_map_sg_list(<span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd)
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193     <span class="keywordtype">int</span> bd_count;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     bd_count  = bnx2i_map_scsi_sg(cmd-&gt;conn-&gt;hba, cmd);
<a name="l00196"></a>00196     <span class="keywordflow">if</span> (!bd_count) {
<a name="l00197"></a>00197         <span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *bd = cmd-&gt;io_tbl.bd_tbl;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199         bd[0].buffer_addr_lo = bd[0].buffer_addr_hi = 0;
<a name="l00200"></a>00200         bd[0].buffer_length = bd[0].flags = 0;
<a name="l00201"></a>00201     }
<a name="l00202"></a>00202     cmd-&gt;io_tbl.bd_valid = bd_count;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 
<a name="l00212"></a>00212 <span class="keywordtype">void</span> bnx2i_iscsi_unmap_sg_list(<span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd)
<a name="l00213"></a>00213 {
<a name="l00214"></a>00214     <span class="keyword">struct </span>scsi_cmnd *sc = cmd-&gt;scsi_cmd;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="keywordflow">if</span> (cmd-&gt;io_tbl.bd_valid &amp;&amp; sc) {
<a name="l00217"></a>00217         scsi_dma_unmap(sc);
<a name="l00218"></a>00218         cmd-&gt;io_tbl.bd_valid = 0;
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220 }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_setup_cmd_wqe_template(<span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd)
<a name="l00223"></a>00223 {
<a name="l00224"></a>00224     memset(&amp;cmd-&gt;req, 0x00, <span class="keyword">sizeof</span>(cmd-&gt;req));
<a name="l00225"></a>00225     cmd-&gt;req.op_code = 0xFF;
<a name="l00226"></a>00226     cmd-&gt;req.bd_list_addr_lo = (u32) cmd-&gt;io_tbl.bd_tbl_dma;
<a name="l00227"></a>00227     cmd-&gt;req.bd_list_addr_hi =
<a name="l00228"></a>00228         (u32) ((u64) cmd-&gt;io_tbl.bd_tbl_dma &gt;&gt; 32);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_bind_conn_to_iscsi_cid(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00244"></a>00244                     <span class="keyword">struct</span> <a class="code" href="structbnx2i__conn.html">bnx2i_conn</a> *<a class="code" href="structbnx2i__conn.html">bnx2i_conn</a>,
<a name="l00245"></a>00245                     u32 iscsi_cid)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247     <span class="keywordflow">if</span> (hba &amp;&amp; hba-&gt;cid_que.conn_cid_tbl[iscsi_cid]) {
<a name="l00248"></a>00248         iscsi_conn_printk(KERN_ALERT, bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l00249"></a>00249                  <span class="stringliteral">&quot;conn bind - entry #%d not free\n&quot;</span>, iscsi_cid);
<a name="l00250"></a>00250         <span class="keywordflow">return</span> -EBUSY;
<a name="l00251"></a>00251     }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     hba-&gt;cid_que.conn_cid_tbl[iscsi_cid] = bnx2i_conn;
<a name="l00254"></a>00254     <span class="keywordflow">return</span> 0;
<a name="l00255"></a>00255 }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 
<a name="l00263"></a>00263 <span class="keyword">struct </span>bnx2i_conn *bnx2i_get_conn_from_id(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00264"></a>00264                       u16 iscsi_cid)
<a name="l00265"></a>00265 {
<a name="l00266"></a>00266     <span class="keywordflow">if</span> (!hba-&gt;cid_que.conn_cid_tbl) {
<a name="l00267"></a>00267         printk(KERN_ERR <span class="stringliteral">&quot;bnx2i: ERROR - missing conn&lt;-&gt;cid table\n&quot;</span>);
<a name="l00268"></a>00268         <span class="keywordflow">return</span> NULL;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iscsi_cid &gt;= hba-&gt;max_active_conns) {
<a name="l00271"></a>00271         printk(KERN_ERR <span class="stringliteral">&quot;bnx2i: hba=0x%p, wrong cid #%d, Max %d\n&quot;</span>, hba, iscsi_cid, hba-&gt;max_active_conns);
<a name="l00272"></a>00272         <span class="keywordflow">return</span> NULL;
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274     <span class="keywordflow">return</span> hba-&gt;cid_que.conn_cid_tbl[iscsi_cid];
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00282"></a>00282 <span class="keyword">static</span> u32 bnx2i_alloc_iscsi_cid(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00283"></a>00283 {
<a name="l00284"></a>00284     <span class="keywordtype">int</span> idx;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="keywordflow">if</span> (!hba-&gt;cid_que.cid_free_cnt)
<a name="l00287"></a>00287         <span class="keywordflow">return</span> -1;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     idx = hba-&gt;cid_que.cid_q_cons_idx;
<a name="l00290"></a>00290     hba-&gt;cid_que.cid_q_cons_idx++;
<a name="l00291"></a>00291     <span class="keywordflow">if</span> (hba-&gt;cid_que.cid_q_cons_idx == hba-&gt;cid_que.cid_q_max_idx)
<a name="l00292"></a>00292         hba-&gt;cid_que.cid_q_cons_idx = 0;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294     hba-&gt;cid_que.cid_free_cnt--;
<a name="l00295"></a>00295     <span class="keywordflow">return</span> hba-&gt;cid_que.cid_que[idx];
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 
<a name="l00304"></a>00304 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_free_iscsi_cid(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, u16 iscsi_cid)
<a name="l00305"></a>00305 {
<a name="l00306"></a>00306     <span class="keywordtype">int</span> idx;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="keywordflow">if</span> (iscsi_cid == (u16) -1)
<a name="l00309"></a>00309         <span class="keywordflow">return</span>;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     hba-&gt;cid_que.cid_free_cnt++;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     idx = hba-&gt;cid_que.cid_q_prod_idx;
<a name="l00314"></a>00314     hba-&gt;cid_que.cid_que[idx] = iscsi_cid;
<a name="l00315"></a>00315     hba-&gt;cid_que.conn_cid_tbl[iscsi_cid] = NULL;
<a name="l00316"></a>00316     hba-&gt;cid_que.cid_q_prod_idx++;
<a name="l00317"></a>00317     <span class="keywordflow">if</span> (hba-&gt;cid_que.cid_q_prod_idx == hba-&gt;cid_que.cid_q_max_idx)
<a name="l00318"></a>00318         hba-&gt;cid_que.cid_q_prod_idx = 0;
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 
<a name="l00329"></a>00329 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_setup_free_cid_que(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331     <span class="keywordtype">int</span> mem_size;
<a name="l00332"></a>00332     <span class="keywordtype">int</span> i;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     mem_size = hba-&gt;max_active_conns * <span class="keyword">sizeof</span>(u32);
<a name="l00335"></a>00335     mem_size = (mem_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337     hba-&gt;cid_que.cid_que_base = kmalloc(mem_size, GFP_KERNEL);
<a name="l00338"></a>00338     <span class="keywordflow">if</span> (!hba-&gt;cid_que.cid_que_base)
<a name="l00339"></a>00339         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341     mem_size = hba-&gt;max_active_conns * <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bnx2i_conn *);
<a name="l00342"></a>00342     mem_size = (mem_size + (PAGE_SIZE - 1)) &amp; PAGE_MASK;
<a name="l00343"></a>00343     hba-&gt;cid_que.conn_cid_tbl = kmalloc(mem_size, GFP_KERNEL);
<a name="l00344"></a>00344     <span class="keywordflow">if</span> (!hba-&gt;cid_que.conn_cid_tbl) {
<a name="l00345"></a>00345         kfree(hba-&gt;cid_que.cid_que_base);
<a name="l00346"></a>00346         hba-&gt;cid_que.cid_que_base = NULL;
<a name="l00347"></a>00347         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     hba-&gt;cid_que.cid_que = (u32 *)hba-&gt;cid_que.cid_que_base;
<a name="l00351"></a>00351     hba-&gt;cid_que.cid_q_prod_idx = 0;
<a name="l00352"></a>00352     hba-&gt;cid_que.cid_q_cons_idx = 0;
<a name="l00353"></a>00353     hba-&gt;cid_que.cid_q_max_idx = hba-&gt;max_active_conns;
<a name="l00354"></a>00354     hba-&gt;cid_que.cid_free_cnt = hba-&gt;max_active_conns;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     for (i = 0; i &lt; hba-&gt;max_active_conns; i++) {
<a name="l00357"></a>00357         hba-&gt;cid_que.cid_que[i] = i;
<a name="l00358"></a>00358         hba-&gt;cid_que.conn_cid_tbl[i] = NULL;
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360     <span class="keywordflow">return</span> 0;
<a name="l00361"></a>00361 }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 
<a name="l00368"></a>00368 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_release_free_cid_que(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370     kfree(hba-&gt;cid_que.cid_que_base);
<a name="l00371"></a>00371     hba-&gt;cid_que.cid_que_base = NULL;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373     kfree(hba-&gt;cid_que.conn_cid_tbl);
<a name="l00374"></a>00374     hba-&gt;cid_que.conn_cid_tbl = NULL;
<a name="l00375"></a>00375 }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 
<a name="l00386"></a>00386 <span class="keyword">static</span> <span class="keyword">struct </span>iscsi_endpoint *bnx2i_alloc_ep(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00387"></a>00387 {
<a name="l00388"></a>00388     <span class="keyword">struct </span>iscsi_endpoint *ep;
<a name="l00389"></a>00389     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep;
<a name="l00390"></a>00390 <span class="preprocessor">#ifdef _BNX2I_IOCTL_</span>
<a name="l00391"></a>00391 <span class="preprocessor"></span>    u16 tcp_port;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393     tcp_port = bnx2i_alloc_tcp_port();
<a name="l00394"></a>00394     <span class="keywordflow">if</span> (!tcp_port) {
<a name="l00395"></a>00395         printk(KERN_ERR <span class="stringliteral">&quot;bnx2i: unable to allocate tcp ports, &quot;</span>
<a name="l00396"></a>00396                 <span class="stringliteral">&quot;make sure &#39;bnx2id&#39; is running\n&quot;</span>);
<a name="l00397"></a>00397         <span class="keywordflow">return</span> NULL;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399 <span class="preprocessor">#endif</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     ep = iscsi_create_endpoint(<span class="keyword">sizeof</span>(*bnx2i_ep));
<a name="l00403"></a>00403     <span class="keywordflow">if</span> (!ep) {
<a name="l00404"></a>00404         printk(KERN_ERR <span class="stringliteral">&quot;bnx2i: Could not allocate ep\n&quot;</span>);
<a name="l00405"></a>00405         <span class="keywordflow">return</span> NULL;
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     bnx2i_ep = ep-&gt;dd_data;
<a name="l00409"></a>00409     INIT_LIST_HEAD(&amp;bnx2i_ep-&gt;link);
<a name="l00410"></a>00410     bnx2i_ep-&gt;state = EP_STATE_IDLE;
<a name="l00411"></a>00411     bnx2i_ep-&gt;ep_iscsi_cid = (u16) -1;
<a name="l00412"></a>00412     bnx2i_ep-&gt;hba = hba;
<a name="l00413"></a>00413     bnx2i_ep-&gt;hba_age = hba-&gt;age;
<a name="l00414"></a>00414 <span class="preprocessor">#ifdef _BNX2I_IOCTL_</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>    bnx2i_ep-&gt;tcp_port = tcp_port;
<a name="l00416"></a>00416 <span class="preprocessor">#else</span>
<a name="l00417"></a>00417 <span class="preprocessor"></span>    bnx2i_ep-&gt;tcp_port = 0;
<a name="l00418"></a>00418 <span class="preprocessor">#endif</span>
<a name="l00419"></a>00419 <span class="preprocessor"></span>    hba-&gt;ofld_conns_active++;
<a name="l00420"></a>00420     init_waitqueue_head(&amp;bnx2i_ep-&gt;ofld_wait);
<a name="l00421"></a>00421     <span class="keywordflow">return</span> ep;
<a name="l00422"></a>00422 }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 
<a name="l00429"></a>00429 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_free_ep(<span class="keyword">struct</span> iscsi_endpoint *ep)
<a name="l00430"></a>00430 {
<a name="l00431"></a>00431     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep = ep-&gt;dd_data;
<a name="l00432"></a>00432     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     spin_lock_irqsave(&amp;bnx2i_resc_lock, flags);
<a name="l00435"></a>00435     bnx2i_ep-&gt;state = EP_STATE_IDLE;
<a name="l00436"></a>00436     bnx2i_ep-&gt;hba-&gt;ofld_conns_active--;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     bnx2i_free_iscsi_cid(bnx2i_ep-&gt;hba, bnx2i_ep-&gt;ep_iscsi_cid);
<a name="l00439"></a>00439     <span class="keywordflow">if</span> (bnx2i_ep-&gt;conn) {
<a name="l00440"></a>00440         bnx2i_ep-&gt;conn-&gt;ep = NULL;
<a name="l00441"></a>00441         bnx2i_ep-&gt;conn = NULL;
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="preprocessor">#ifdef _BNX2I_IOCTL_</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (bnx2i_ep-&gt;tcp_port)
<a name="l00446"></a>00446         bnx2i_free_tcp_port(bnx2i_ep-&gt;tcp_port);
<a name="l00447"></a>00447 <span class="preprocessor">#endif</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00449"></a>00449     bnx2i_ep-&gt;hba = NULL;
<a name="l00450"></a>00450     spin_unlock_irqrestore(&amp;bnx2i_resc_lock, flags);
<a name="l00451"></a>00451     iscsi_destroy_endpoint(ep);
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 
<a name="l00461"></a>00461 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_alloc_bdt(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, <span class="keyword">struct</span> iscsi_session *session,
<a name="l00462"></a>00462                <span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464     <span class="keyword">struct </span><a class="code" href="structio__bdt.html">io_bdt</a> *io = &amp;cmd-&gt;io_tbl;
<a name="l00465"></a>00465     <span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *bd;
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     io-&gt;bd_tbl = dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev,
<a name="l00468"></a>00468                     ISCSI_MAX_BDS_PER_CMD * <span class="keyword">sizeof</span>(*bd),
<a name="l00469"></a>00469                     &amp;io-&gt;bd_tbl_dma, GFP_KERNEL);
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (!io-&gt;bd_tbl) {
<a name="l00471"></a>00471         iscsi_session_printk(KERN_ERR, session, <span class="stringliteral">&quot;Could not &quot;</span>
<a name="l00472"></a>00472                      <span class="stringliteral">&quot;allocate bdt.\n&quot;</span>);
<a name="l00473"></a>00473         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475     io-&gt;bd_valid = 0;
<a name="l00476"></a>00476     <span class="keywordflow">return</span> 0;
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00485"></a>00485 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_destroy_cmd_pool(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00486"></a>00486                    <span class="keyword">struct</span> iscsi_session *session)
<a name="l00487"></a>00487 {
<a name="l00488"></a>00488     <span class="keywordtype">int</span> i;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="keywordflow">for</span> (i = 0; i &lt; session-&gt;cmds_max; i++) {
<a name="l00491"></a>00491         <span class="keyword">struct </span>iscsi_task *task = session-&gt;cmds[i];
<a name="l00492"></a>00492         <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd = task-&gt;dd_data;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         <span class="keywordflow">if</span> (cmd-&gt;io_tbl.bd_tbl)
<a name="l00495"></a>00495             dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev,
<a name="l00496"></a>00496                       ISCSI_MAX_BDS_PER_CMD *
<a name="l00497"></a>00497                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structiscsi__bd.html">iscsi_bd</a>),
<a name="l00498"></a>00498                       cmd-&gt;io_tbl.bd_tbl,
<a name="l00499"></a>00499                       cmd-&gt;io_tbl.bd_tbl_dma);
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 
<a name="l00510"></a>00510 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_setup_cmd_pool(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00511"></a>00511                 <span class="keyword">struct</span> iscsi_session *session)
<a name="l00512"></a>00512 {
<a name="l00513"></a>00513     <span class="keywordtype">int</span> i;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515     <span class="keywordflow">for</span> (i = 0; i &lt; session-&gt;cmds_max; i++) {
<a name="l00516"></a>00516         <span class="keyword">struct </span>iscsi_task *task = session-&gt;cmds[i];
<a name="l00517"></a>00517         <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd = task-&gt;dd_data;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="comment">/* Anil */</span>
<a name="l00520"></a>00520         task-&gt;hdr = (<span class="keyword">struct </span>iscsi_cmd *)&amp;cmd-&gt;hdr;
<a name="l00521"></a>00521         task-&gt;hdr_max = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iscsi_hdr);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="keywordflow">if</span> (bnx2i_alloc_bdt(hba, session, cmd))
<a name="l00524"></a>00524             <span class="keywordflow">goto</span> free_bdts;
<a name="l00525"></a>00525     }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527     <span class="keywordflow">return</span> 0;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 free_bdts:
<a name="l00530"></a>00530     bnx2i_destroy_cmd_pool(hba, session);
<a name="l00531"></a>00531     <span class="keywordflow">return</span> -ENOMEM;
<a name="l00532"></a>00532 }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 
<a name="l00542"></a>00542 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_setup_mp_bdt(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00543"></a>00543 {
<a name="l00544"></a>00544     <span class="keywordtype">int</span> rc = 0;
<a name="l00545"></a>00545     <span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *mp_bdt;
<a name="l00546"></a>00546     u64 addr;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     hba-&gt;mp_bd_tbl = dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00549"></a>00549                         &amp;hba-&gt;mp_bd_dma, GFP_KERNEL);
<a name="l00550"></a>00550     <span class="keywordflow">if</span> (!hba-&gt;mp_bd_tbl) {
<a name="l00551"></a>00551         printk(KERN_ERR <span class="stringliteral">&quot;unable to allocate Middle Path BDT\n&quot;</span>);
<a name="l00552"></a>00552         rc = -1;
<a name="l00553"></a>00553         <span class="keywordflow">goto</span> out;
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     hba-&gt;dummy_buffer = dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00557"></a>00557                            &amp;hba-&gt;dummy_buf_dma, GFP_KERNEL);
<a name="l00558"></a>00558     <span class="keywordflow">if</span> (!hba-&gt;dummy_buffer) {
<a name="l00559"></a>00559         printk(KERN_ERR <span class="stringliteral">&quot;unable to alloc Middle Path Dummy Buffer\n&quot;</span>);
<a name="l00560"></a>00560         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00561"></a>00561                   hba-&gt;mp_bd_tbl, hba-&gt;mp_bd_dma);
<a name="l00562"></a>00562         hba-&gt;mp_bd_tbl = NULL;
<a name="l00563"></a>00563         rc = -1;
<a name="l00564"></a>00564         <span class="keywordflow">goto</span> out;
<a name="l00565"></a>00565     }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567     mp_bdt = (<span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *) hba-&gt;mp_bd_tbl;
<a name="l00568"></a>00568     addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) hba-&gt;dummy_buf_dma;
<a name="l00569"></a>00569     mp_bdt-&gt;buffer_addr_lo = addr &amp; 0xffffffff;
<a name="l00570"></a>00570     mp_bdt-&gt;buffer_addr_hi = addr &gt;&gt; 32;
<a name="l00571"></a>00571     mp_bdt-&gt;buffer_length = PAGE_SIZE;
<a name="l00572"></a>00572     mp_bdt-&gt;flags = ISCSI_BD_LAST_IN_BD_CHAIN |
<a name="l00573"></a>00573             ISCSI_BD_FIRST_IN_BD_CHAIN;
<a name="l00574"></a>00574 out:
<a name="l00575"></a>00575     <span class="keywordflow">return</span> rc;
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 
<a name="l00585"></a>00585 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_free_mp_bdt(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00586"></a>00586 {
<a name="l00587"></a>00587     <span class="keywordflow">if</span> (hba-&gt;mp_bd_tbl) {
<a name="l00588"></a>00588         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00589"></a>00589                   hba-&gt;mp_bd_tbl, hba-&gt;mp_bd_dma);
<a name="l00590"></a>00590         hba-&gt;mp_bd_tbl = NULL;
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592     <span class="keywordflow">if</span> (hba-&gt;dummy_buffer) {
<a name="l00593"></a>00593         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00594"></a>00594                   hba-&gt;dummy_buffer, hba-&gt;dummy_buf_dma);
<a name="l00595"></a>00595         hba-&gt;dummy_buffer = NULL;
<a name="l00596"></a>00596     }
<a name="l00597"></a>00597         <span class="keywordflow">return</span>;
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00611"></a>00611 <span class="keywordtype">void</span> bnx2i_drop_session(<span class="keyword">struct</span> iscsi_cls_session *cls_session)
<a name="l00612"></a>00612 {
<a name="l00613"></a>00613     iscsi_session_failure(cls_session, ISCSI_ERR_CONN_FAILED);
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00623"></a>00623 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_ep_destroy_list_add(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00624"></a>00624                      <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00625"></a>00625 {
<a name="l00626"></a>00626     write_lock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00627"></a>00627     list_add_tail(&amp;ep-&gt;link, &amp;hba-&gt;ep_destroy_list);
<a name="l00628"></a>00628     write_unlock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00629"></a>00629     <span class="keywordflow">return</span> 0;
<a name="l00630"></a>00630 }
<a name="l00631"></a>00631 
<a name="l00640"></a>00640 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_ep_destroy_list_del(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00641"></a>00641                      <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00642"></a>00642 {
<a name="l00643"></a>00643     write_lock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00644"></a>00644     list_del_init(&amp;ep-&gt;link);
<a name="l00645"></a>00645     write_unlock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00646"></a>00646 
<a name="l00647"></a>00647     <span class="keywordflow">return</span> 0;
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00657"></a>00657 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_ep_ofld_list_add(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00658"></a>00658                   <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660     write_lock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00661"></a>00661     list_add_tail(&amp;ep-&gt;link, &amp;hba-&gt;ep_ofld_list);
<a name="l00662"></a>00662     write_unlock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00663"></a>00663     <span class="keywordflow">return</span> 0;
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00673"></a>00673 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_ep_ofld_list_del(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00674"></a>00674                   <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l00675"></a>00675 {
<a name="l00676"></a>00676     write_lock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00677"></a>00677     list_del_init(&amp;ep-&gt;link);
<a name="l00678"></a>00678     write_unlock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00679"></a>00679     <span class="keywordflow">return</span> 0;
<a name="l00680"></a>00680 }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 
<a name="l00690"></a>00690 <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *
<a name="l00691"></a>00691 bnx2i_find_ep_in_ofld_list(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, u32 iscsi_cid)
<a name="l00692"></a>00692 {
<a name="l00693"></a>00693     <span class="keyword">struct </span>list_head *list;
<a name="l00694"></a>00694     <span class="keyword">struct </span>list_head *tmp;
<a name="l00695"></a>00695     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697     read_lock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00698"></a>00698     list_for_each_safe(list, tmp, &amp;hba-&gt;ep_ofld_list) {
<a name="l00699"></a>00699         ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *)list;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         <span class="keywordflow">if</span> (ep-&gt;ep_iscsi_cid == iscsi_cid)
<a name="l00702"></a>00702             <span class="keywordflow">break</span>;
<a name="l00703"></a>00703         ep = NULL;
<a name="l00704"></a>00704     }
<a name="l00705"></a>00705     read_unlock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     <span class="keywordflow">if</span> (!ep)
<a name="l00708"></a>00708         printk(KERN_ERR <span class="stringliteral">&quot;l5 cid %d not found\n&quot;</span>, iscsi_cid);
<a name="l00709"></a>00709     <span class="keywordflow">return</span> ep;
<a name="l00710"></a>00710 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 
<a name="l00719"></a>00719 <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *
<a name="l00720"></a>00720 bnx2i_find_ep_in_destroy_list(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba, u32 iscsi_cid)
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722     <span class="keyword">struct </span>list_head *list;
<a name="l00723"></a>00723     <span class="keyword">struct </span>list_head *tmp;
<a name="l00724"></a>00724     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     read_lock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00727"></a>00727     list_for_each_safe(list, tmp, &amp;hba-&gt;ep_destroy_list) {
<a name="l00728"></a>00728         ep = (<span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *)list;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="keywordflow">if</span> (ep-&gt;ep_iscsi_cid == iscsi_cid)
<a name="l00731"></a>00731             <span class="keywordflow">break</span>;
<a name="l00732"></a>00732         ep = NULL;
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734     read_unlock_bh(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="keywordflow">if</span> (!ep)
<a name="l00737"></a>00737         printk(KERN_ERR <span class="stringliteral">&quot;l5 cid %d not found\n&quot;</span>, iscsi_cid);
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     <span class="keywordflow">return</span> ep;
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 
<a name="l00751"></a>00751 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_setup_host_queue_size(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00752"></a>00752                     <span class="keyword">struct</span> Scsi_Host *shost)
<a name="l00753"></a>00753 {
<a name="l00754"></a>00754     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_5708, &amp;hba-&gt;cnic_dev_type))
<a name="l00755"></a>00755         shost-&gt;can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;
<a name="l00756"></a>00756     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_5709, &amp;hba-&gt;cnic_dev_type))
<a name="l00757"></a>00757         shost-&gt;can_queue = ISCSI_MAX_CMDS_PER_HBA_5709;
<a name="l00758"></a>00758     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;hba-&gt;cnic_dev_type))
<a name="l00759"></a>00759         shost-&gt;can_queue = ISCSI_MAX_CMDS_PER_HBA_57710;
<a name="l00760"></a>00760     <span class="keywordflow">else</span>
<a name="l00761"></a>00761         shost-&gt;can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;
<a name="l00762"></a>00762 }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764 
<a name="l00772"></a>00772 <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *bnx2i_alloc_hba(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *cnic)
<a name="l00773"></a>00773 {
<a name="l00774"></a>00774     <span class="keyword">struct </span>Scsi_Host *shost;
<a name="l00775"></a>00775     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba;
<a name="l00776"></a>00776 
<a name="l00777"></a>00777     shost = iscsi_host_alloc(&amp;bnx2i_host_template, <span class="keyword">sizeof</span>(*hba), 0);
<a name="l00778"></a>00778     <span class="keywordflow">if</span> (!shost)
<a name="l00779"></a>00779         <span class="keywordflow">return</span> NULL;
<a name="l00780"></a>00780     shost-&gt;dma_boundary = cnic-&gt;pcidev-&gt;dma_mask;
<a name="l00781"></a>00781     shost-&gt;transportt = bnx2i_scsi_xport_template;
<a name="l00782"></a>00782     shost-&gt;max_id = ISCSI_MAX_CONNS_PER_HBA;
<a name="l00783"></a>00783     shost-&gt;max_channel = 0;
<a name="l00784"></a>00784     shost-&gt;max_lun = 512;
<a name="l00785"></a>00785     shost-&gt;max_cmd_len = 16;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     hba = iscsi_host_priv(shost);
<a name="l00788"></a>00788     hba-&gt;shost = shost;
<a name="l00789"></a>00789     hba-&gt;netdev = cnic-&gt;netdev;
<a name="l00790"></a>00790     <span class="comment">/* Get PCI related information and update hba struct members */</span>
<a name="l00791"></a>00791     hba-&gt;pcidev = cnic-&gt;pcidev;
<a name="l00792"></a>00792     pci_dev_get(hba-&gt;pcidev);
<a name="l00793"></a>00793     hba-&gt;pci_did = hba-&gt;pcidev-&gt;device;
<a name="l00794"></a>00794     hba-&gt;pci_vid = hba-&gt;pcidev-&gt;vendor;
<a name="l00795"></a>00795     hba-&gt;pci_sdid = hba-&gt;pcidev-&gt;subsystem_device;
<a name="l00796"></a>00796     hba-&gt;pci_svid = hba-&gt;pcidev-&gt;subsystem_vendor;
<a name="l00797"></a>00797     hba-&gt;pci_func = PCI_FUNC(hba-&gt;pcidev-&gt;devfn);
<a name="l00798"></a>00798     hba-&gt;pci_devno = PCI_SLOT(hba-&gt;pcidev-&gt;devfn);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800     bnx2i_identify_device(hba);
<a name="l00801"></a>00801     bnx2i_setup_host_queue_size(hba, shost);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_5709, &amp;hba-&gt;cnic_dev_type)) {
<a name="l00804"></a>00804         hba-&gt;regview = ioremap_nocache(hba-&gt;netdev-&gt;base_addr,
<a name="l00805"></a>00805                            BNX2_MQ_CONFIG2);
<a name="l00806"></a>00806         <span class="keywordflow">if</span> (!hba-&gt;regview)
<a name="l00807"></a>00807             <span class="keywordflow">goto</span> ioreg_map_err;
<a name="l00808"></a>00808     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;hba-&gt;cnic_dev_type)) {
<a name="l00809"></a>00809         hba-&gt;regview = ioremap_nocache(hba-&gt;netdev-&gt;base_addr, 4096);
<a name="l00810"></a>00810         <span class="keywordflow">if</span> (!hba-&gt;regview)
<a name="l00811"></a>00811             <span class="keywordflow">goto</span> ioreg_map_err;
<a name="l00812"></a>00812     }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814     <span class="keywordflow">if</span> (bnx2i_setup_mp_bdt(hba))
<a name="l00815"></a>00815         <span class="keywordflow">goto</span> mp_bdt_mem_err;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817     INIT_LIST_HEAD(&amp;hba-&gt;ep_ofld_list);
<a name="l00818"></a>00818     INIT_LIST_HEAD(&amp;hba-&gt;ep_destroy_list);
<a name="l00819"></a>00819     rwlock_init(&amp;hba-&gt;ep_rdwr_lock);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821     hba-&gt;mtu_supported = BNX2I_MAX_MTU_SUPPORTED;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823     <span class="comment">/* different values for 5708/5709/57710 */</span>
<a name="l00824"></a>00824     hba-&gt;max_active_conns = ISCSI_MAX_CONNS_PER_HBA;
<a name="l00825"></a>00825 
<a name="l00826"></a>00826     <span class="keywordflow">if</span> (bnx2i_setup_free_cid_que(hba))
<a name="l00827"></a>00827         <span class="keywordflow">goto</span> cid_que_err;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     <span class="comment">/* SQ/RQ/CQ size can be changed via sysfx interface */</span>
<a name="l00830"></a>00830     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;hba-&gt;cnic_dev_type)) {
<a name="l00831"></a>00831         <span class="keywordflow">if</span> (sq_size &amp;&amp; sq_size &lt;= BNX2I_5770X_SQ_WQES_MAX)
<a name="l00832"></a>00832             hba-&gt;max_sqes = sq_size;
<a name="l00833"></a>00833         <span class="keywordflow">else</span>
<a name="l00834"></a>00834             hba-&gt;max_sqes = BNX2I_5770X_SQ_WQES_DEFAULT;
<a name="l00835"></a>00835     } <span class="keywordflow">else</span> {    <span class="comment">/* 5706/5708/5709 */</span>
<a name="l00836"></a>00836         <span class="keywordflow">if</span> (sq_size &amp;&amp; sq_size &lt;= BNX2I_570X_SQ_WQES_MAX)
<a name="l00837"></a>00837             hba-&gt;max_sqes = sq_size;
<a name="l00838"></a>00838         <span class="keywordflow">else</span>
<a name="l00839"></a>00839             hba-&gt;max_sqes = BNX2I_570X_SQ_WQES_DEFAULT;
<a name="l00840"></a>00840     }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     hba-&gt;max_rqes = rq_size;
<a name="l00843"></a>00843     hba-&gt;max_cqes = hba-&gt;max_sqes + rq_size;
<a name="l00844"></a>00844     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;hba-&gt;cnic_dev_type)) {
<a name="l00845"></a>00845         <span class="keywordflow">if</span> (hba-&gt;max_cqes &gt; BNX2I_5770X_CQ_WQES_MAX)
<a name="l00846"></a>00846             hba-&gt;max_cqes = BNX2I_5770X_CQ_WQES_MAX;
<a name="l00847"></a>00847     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hba-&gt;max_cqes &gt; BNX2I_570X_CQ_WQES_MAX)
<a name="l00848"></a>00848         hba-&gt;max_cqes = BNX2I_570X_CQ_WQES_MAX;
<a name="l00849"></a>00849 
<a name="l00850"></a>00850     hba-&gt;num_ccell = hba-&gt;max_sqes / 2;
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     spin_lock_init(&amp;hba-&gt;lock);
<a name="l00853"></a>00853     mutex_init(&amp;hba-&gt;net_dev_lock);
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     <span class="keywordflow">if</span> (iscsi_host_add(shost, &amp;hba-&gt;pcidev-&gt;dev))
<a name="l00856"></a>00856         <span class="keywordflow">goto</span> free_dump_mem;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     <span class="keywordflow">return</span> hba;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 free_dump_mem:
<a name="l00861"></a>00861     bnx2i_release_free_cid_que(hba);
<a name="l00862"></a>00862 cid_que_err:
<a name="l00863"></a>00863     bnx2i_free_mp_bdt(hba);
<a name="l00864"></a>00864 mp_bdt_mem_err:
<a name="l00865"></a>00865     <span class="keywordflow">if</span> (hba-&gt;regview) {
<a name="l00866"></a>00866         iounmap(hba-&gt;regview);
<a name="l00867"></a>00867         hba-&gt;regview = NULL;
<a name="l00868"></a>00868     }
<a name="l00869"></a>00869 ioreg_map_err:
<a name="l00870"></a>00870     pci_dev_put(hba-&gt;pcidev);
<a name="l00871"></a>00871     scsi_host_put(shost);
<a name="l00872"></a>00872     <span class="keywordflow">return</span> NULL;
<a name="l00873"></a>00873 }
<a name="l00874"></a>00874 
<a name="l00881"></a>00881 <span class="keywordtype">void</span> bnx2i_free_hba(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba)
<a name="l00882"></a>00882 {
<a name="l00883"></a>00883     <span class="keyword">struct </span>Scsi_Host *shost = hba-&gt;shost;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885     iscsi_host_remove(shost);
<a name="l00886"></a>00886     INIT_LIST_HEAD(&amp;hba-&gt;ep_ofld_list);
<a name="l00887"></a>00887     INIT_LIST_HEAD(&amp;hba-&gt;ep_destroy_list);
<a name="l00888"></a>00888     pci_dev_put(hba-&gt;pcidev);
<a name="l00889"></a>00889 
<a name="l00890"></a>00890     <span class="keywordflow">if</span> (hba-&gt;regview) {
<a name="l00891"></a>00891         iounmap(hba-&gt;regview);
<a name="l00892"></a>00892         hba-&gt;regview = NULL;
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894     bnx2i_free_mp_bdt(hba);
<a name="l00895"></a>00895     bnx2i_release_free_cid_que(hba);
<a name="l00896"></a>00896     iscsi_host_free(shost);
<a name="l00897"></a>00897 }
<a name="l00898"></a>00898 
<a name="l00906"></a>00906 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_conn_free_login_resources(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00907"></a>00907                         <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn)
<a name="l00908"></a>00908 {
<a name="l00909"></a>00909     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.resp_bd_tbl) {
<a name="l00910"></a>00910         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00911"></a>00911                   bnx2i_conn-&gt;gen_pdu.resp_bd_tbl,
<a name="l00912"></a>00912                   bnx2i_conn-&gt;gen_pdu.resp_bd_dma);
<a name="l00913"></a>00913         bnx2i_conn-&gt;gen_pdu.resp_bd_tbl = NULL;
<a name="l00914"></a>00914     }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.req_bd_tbl) {
<a name="l00917"></a>00917         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00918"></a>00918                   bnx2i_conn-&gt;gen_pdu.req_bd_tbl,
<a name="l00919"></a>00919                   bnx2i_conn-&gt;gen_pdu.req_bd_dma);
<a name="l00920"></a>00920         bnx2i_conn-&gt;gen_pdu.req_bd_tbl = NULL;
<a name="l00921"></a>00921     }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.resp_buf) {
<a name="l00924"></a>00924         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev,
<a name="l00925"></a>00925                   ISCSI_DEF_MAX_RECV_SEG_LEN,
<a name="l00926"></a>00926                   bnx2i_conn-&gt;gen_pdu.resp_buf,
<a name="l00927"></a>00927                   bnx2i_conn-&gt;gen_pdu.resp_dma_addr);
<a name="l00928"></a>00928         bnx2i_conn-&gt;gen_pdu.resp_buf = NULL;
<a name="l00929"></a>00929     }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.req_buf) {
<a name="l00932"></a>00932         dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev,
<a name="l00933"></a>00933                   ISCSI_DEF_MAX_RECV_SEG_LEN,
<a name="l00934"></a>00934                   bnx2i_conn-&gt;gen_pdu.req_buf,
<a name="l00935"></a>00935                   bnx2i_conn-&gt;gen_pdu.req_dma_addr);
<a name="l00936"></a>00936         bnx2i_conn-&gt;gen_pdu.req_buf = NULL;
<a name="l00937"></a>00937     }
<a name="l00938"></a>00938 }
<a name="l00939"></a>00939 
<a name="l00947"></a>00947 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_conn_alloc_login_resources(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l00948"></a>00948                         <span class="keyword">struct</span> bnx2i_conn *bnx2i_conn)
<a name="l00949"></a>00949 {
<a name="l00950"></a>00950     <span class="comment">/* Allocate memory for login request/response buffers */</span>
<a name="l00951"></a>00951     bnx2i_conn-&gt;gen_pdu.req_buf =
<a name="l00952"></a>00952         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev,
<a name="l00953"></a>00953                    ISCSI_DEF_MAX_RECV_SEG_LEN,
<a name="l00954"></a>00954                    &amp;bnx2i_conn-&gt;gen_pdu.req_dma_addr,
<a name="l00955"></a>00955                    GFP_KERNEL);
<a name="l00956"></a>00956     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.req_buf == NULL)
<a name="l00957"></a>00957         <span class="keywordflow">goto</span> login_req_buf_failure;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959     bnx2i_conn-&gt;gen_pdu.req_buf_size = 0;
<a name="l00960"></a>00960     bnx2i_conn-&gt;gen_pdu.req_wr_ptr = bnx2i_conn-&gt;gen_pdu.req_buf;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962     bnx2i_conn-&gt;gen_pdu.resp_buf =
<a name="l00963"></a>00963         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev,
<a name="l00964"></a>00964                    ISCSI_DEF_MAX_RECV_SEG_LEN,
<a name="l00965"></a>00965                    &amp;bnx2i_conn-&gt;gen_pdu.resp_dma_addr,
<a name="l00966"></a>00966                    GFP_KERNEL);
<a name="l00967"></a>00967     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.resp_buf == NULL)
<a name="l00968"></a>00968         <span class="keywordflow">goto</span> login_resp_buf_failure;
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     bnx2i_conn-&gt;gen_pdu.resp_buf_size = ISCSI_DEF_MAX_RECV_SEG_LEN;
<a name="l00971"></a>00971     bnx2i_conn-&gt;gen_pdu.resp_wr_ptr = bnx2i_conn-&gt;gen_pdu.resp_buf;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     bnx2i_conn-&gt;gen_pdu.req_bd_tbl =
<a name="l00974"></a>00974         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00975"></a>00975                    &amp;bnx2i_conn-&gt;gen_pdu.req_bd_dma, GFP_KERNEL);
<a name="l00976"></a>00976     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.req_bd_tbl == NULL)
<a name="l00977"></a>00977         <span class="keywordflow">goto</span> login_req_bd_tbl_failure;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979     bnx2i_conn-&gt;gen_pdu.resp_bd_tbl =
<a name="l00980"></a>00980         dma_alloc_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00981"></a>00981                    &amp;bnx2i_conn-&gt;gen_pdu.resp_bd_dma,
<a name="l00982"></a>00982                    GFP_KERNEL);
<a name="l00983"></a>00983     <span class="keywordflow">if</span> (bnx2i_conn-&gt;gen_pdu.resp_bd_tbl == NULL)
<a name="l00984"></a>00984         <span class="keywordflow">goto</span> login_resp_bd_tbl_failure;
<a name="l00985"></a>00985 
<a name="l00986"></a>00986     <span class="keywordflow">return</span> 0;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 login_resp_bd_tbl_failure:
<a name="l00989"></a>00989     dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, PAGE_SIZE,
<a name="l00990"></a>00990               bnx2i_conn-&gt;gen_pdu.req_bd_tbl,
<a name="l00991"></a>00991               bnx2i_conn-&gt;gen_pdu.req_bd_dma);
<a name="l00992"></a>00992     bnx2i_conn-&gt;gen_pdu.req_bd_tbl = NULL;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 login_req_bd_tbl_failure:
<a name="l00995"></a>00995     dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ISCSI_DEF_MAX_RECV_SEG_LEN,
<a name="l00996"></a>00996               bnx2i_conn-&gt;gen_pdu.resp_buf,
<a name="l00997"></a>00997               bnx2i_conn-&gt;gen_pdu.resp_dma_addr);
<a name="l00998"></a>00998     bnx2i_conn-&gt;gen_pdu.resp_buf = NULL;
<a name="l00999"></a>00999 login_resp_buf_failure:
<a name="l01000"></a>01000     dma_free_coherent(&amp;hba-&gt;pcidev-&gt;dev, ISCSI_DEF_MAX_RECV_SEG_LEN,
<a name="l01001"></a>01001               bnx2i_conn-&gt;gen_pdu.req_buf,
<a name="l01002"></a>01002               bnx2i_conn-&gt;gen_pdu.req_dma_addr);
<a name="l01003"></a>01003     bnx2i_conn-&gt;gen_pdu.req_buf = NULL;
<a name="l01004"></a>01004 login_req_buf_failure:
<a name="l01005"></a>01005     iscsi_conn_printk(KERN_ERR, bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l01006"></a>01006               <span class="stringliteral">&quot;login resource alloc failed!!\n&quot;</span>);
<a name="l01007"></a>01007     <span class="keywordflow">return</span> -ENOMEM;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 
<a name="l01019"></a>01019 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_iscsi_prep_generic_pdu_bd(<span class="keyword">struct</span> bnx2i_conn *bnx2i_conn)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021     <span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *bd_tbl;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     bd_tbl = (<span class="keyword">struct </span><a class="code" href="structiscsi__bd.html">iscsi_bd</a> *) bnx2i_conn-&gt;gen_pdu.req_bd_tbl;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     bd_tbl-&gt;buffer_addr_hi =
<a name="l01026"></a>01026         (u32) ((u64) bnx2i_conn-&gt;gen_pdu.req_dma_addr &gt;&gt; 32);
<a name="l01027"></a>01027     bd_tbl-&gt;buffer_addr_lo = (u32) bnx2i_conn-&gt;gen_pdu.req_dma_addr;
<a name="l01028"></a>01028     bd_tbl-&gt;buffer_length = bnx2i_conn-&gt;gen_pdu.req_wr_ptr -
<a name="l01029"></a>01029                 bnx2i_conn-&gt;gen_pdu.req_buf;
<a name="l01030"></a>01030     bd_tbl-&gt;reserved0 = 0;
<a name="l01031"></a>01031     bd_tbl-&gt;flags = ISCSI_BD_LAST_IN_BD_CHAIN |
<a name="l01032"></a>01032             ISCSI_BD_FIRST_IN_BD_CHAIN;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034     bd_tbl = (<span class="keyword">struct</span> <a class="code" href="structiscsi__bd.html">iscsi_bd</a>  *) bnx2i_conn-&gt;gen_pdu.resp_bd_tbl;
<a name="l01035"></a>01035     bd_tbl-&gt;buffer_addr_hi = (u64) bnx2i_conn-&gt;gen_pdu.resp_dma_addr &gt;&gt; 32;
<a name="l01036"></a>01036     bd_tbl-&gt;buffer_addr_lo = (u32) bnx2i_conn-&gt;gen_pdu.resp_dma_addr;
<a name="l01037"></a>01037     bd_tbl-&gt;buffer_length = ISCSI_DEF_MAX_RECV_SEG_LEN;
<a name="l01038"></a>01038     bd_tbl-&gt;reserved0 = 0;
<a name="l01039"></a>01039     bd_tbl-&gt;flags = ISCSI_BD_LAST_IN_BD_CHAIN |
<a name="l01040"></a>01040             ISCSI_BD_FIRST_IN_BD_CHAIN;
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 
<a name="l01051"></a>01051 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_iscsi_send_generic_request(<span class="keyword">struct</span> iscsi_task *task)
<a name="l01052"></a>01052 {
<a name="l01053"></a>01053     <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd = task-&gt;dd_data;
<a name="l01054"></a>01054     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = cmd-&gt;conn;
<a name="l01055"></a>01055     <span class="keywordtype">int</span> rc = 0;
<a name="l01056"></a>01056     <span class="keywordtype">char</span> *buf;
<a name="l01057"></a>01057     <span class="keywordtype">int</span> data_len;
<a name="l01058"></a>01058 
<a name="l01059"></a>01059     bnx2i_iscsi_prep_generic_pdu_bd(bnx2i_conn);
<a name="l01060"></a>01060     <span class="keywordflow">switch</span> (task-&gt;hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) {
<a name="l01061"></a>01061     <span class="keywordflow">case</span> ISCSI_OP_LOGIN:
<a name="l01062"></a>01062         bnx2i_send_iscsi_login(bnx2i_conn, task);
<a name="l01063"></a>01063         <span class="keywordflow">break</span>;
<a name="l01064"></a>01064     <span class="keywordflow">case</span> ISCSI_OP_NOOP_OUT:
<a name="l01065"></a>01065         data_len = bnx2i_conn-&gt;gen_pdu.req_buf_size;
<a name="l01066"></a>01066         buf = bnx2i_conn-&gt;gen_pdu.req_buf;
<a name="l01067"></a>01067         <span class="keywordflow">if</span> (data_len)
<a name="l01068"></a>01068             rc = bnx2i_send_iscsi_nopout(bnx2i_conn, task,
<a name="l01069"></a>01069                              RESERVED_ITT,
<a name="l01070"></a>01070                              buf, data_len, 1);
<a name="l01071"></a>01071         <span class="keywordflow">else</span>
<a name="l01072"></a>01072             rc = bnx2i_send_iscsi_nopout(bnx2i_conn, task,
<a name="l01073"></a>01073                              RESERVED_ITT,
<a name="l01074"></a>01074                              NULL, 0, 1);
<a name="l01075"></a>01075         <span class="keywordflow">break</span>;
<a name="l01076"></a>01076     <span class="keywordflow">case</span> ISCSI_OP_LOGOUT:
<a name="l01077"></a>01077         rc = bnx2i_send_iscsi_logout(bnx2i_conn, task);
<a name="l01078"></a>01078         <span class="keywordflow">break</span>;
<a name="l01079"></a>01079     <span class="keywordflow">case</span> ISCSI_OP_SCSI_TMFUNC:
<a name="l01080"></a>01080         rc = bnx2i_send_iscsi_tmf(bnx2i_conn, task);
<a name="l01081"></a>01081         <span class="keywordflow">break</span>;
<a name="l01082"></a>01082     <span class="keywordflow">default</span>:
<a name="l01083"></a>01083         iscsi_conn_printk(KERN_ALERT, bnx2i_conn-&gt;cls_conn-&gt;dd_data,
<a name="l01084"></a>01084                   <span class="stringliteral">&quot;send_gen: unsupported op 0x%x\n&quot;</span>,
<a name="l01085"></a>01085                   task-&gt;hdr-&gt;opcode);
<a name="l01086"></a>01086     }
<a name="l01087"></a>01087     <span class="keywordflow">return</span> rc;
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 <span class="comment">/**********************************************************************</span>
<a name="l01092"></a>01092 <span class="comment"> *      SCSI-ML Interface</span>
<a name="l01093"></a>01093 <span class="comment"> **********************************************************************/</span>
<a name="l01094"></a>01094 
<a name="l01100"></a>01100 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_cpy_scsi_cdb(<span class="keyword">struct</span> scsi_cmnd *sc, <span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd)
<a name="l01101"></a>01101 {
<a name="l01102"></a>01102     u32 dword;
<a name="l01103"></a>01103     <span class="keywordtype">int</span> lpcnt;
<a name="l01104"></a>01104     u8 *srcp;
<a name="l01105"></a>01105     u32 *dstp;
<a name="l01106"></a>01106     u32 scsi_lun[2];
<a name="l01107"></a>01107 
<a name="l01108"></a>01108     int_to_scsilun(sc-&gt;device-&gt;lun, (<span class="keyword">struct</span> scsi_lun *) scsi_lun);
<a name="l01109"></a>01109     cmd-&gt;req.lun[0] = be32_to_cpu(scsi_lun[0]);
<a name="l01110"></a>01110     cmd-&gt;req.lun[1] = be32_to_cpu(scsi_lun[1]);
<a name="l01111"></a>01111 
<a name="l01112"></a>01112     lpcnt = cmd-&gt;scsi_cmd-&gt;cmd_len / <span class="keyword">sizeof</span>(dword);
<a name="l01113"></a>01113     srcp = (u8 *) sc-&gt;cmnd;
<a name="l01114"></a>01114     dstp = (u32 *) cmd-&gt;req.cdb;
<a name="l01115"></a>01115     <span class="keywordflow">while</span> (lpcnt--) {
<a name="l01116"></a>01116         memcpy(&amp;dword, (<span class="keyword">const</span> <span class="keywordtype">void</span> *) srcp, 4);
<a name="l01117"></a>01117         *dstp = cpu_to_be32(dword);
<a name="l01118"></a>01118         srcp += 4;
<a name="l01119"></a>01119         dstp++;
<a name="l01120"></a>01120     }
<a name="l01121"></a>01121     <span class="keywordflow">if</span> (sc-&gt;cmd_len &amp; 0x3) {
<a name="l01122"></a>01122         dword = (u32) srcp[0] | ((u32) srcp[1] &lt;&lt; 8);
<a name="l01123"></a>01123         *dstp = cpu_to_be32(dword);
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_cleanup_task(<span class="keyword">struct</span> iscsi_conn *conn,
<a name="l01128"></a>01128                    <span class="keyword">struct</span> iscsi_task *task)
<a name="l01129"></a>01129 {
<a name="l01130"></a>01130     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l01131"></a>01131     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = bnx2i_conn-&gt;hba;
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     <span class="comment">/*</span>
<a name="l01134"></a>01134 <span class="comment">     * mgmt task or cmd was never sent to us to transmit.</span>
<a name="l01135"></a>01135 <span class="comment">     */</span>
<a name="l01136"></a>01136     <span class="keywordflow">if</span> (!task-&gt;sc || task-&gt;state == ISCSI_TASK_PENDING)
<a name="l01137"></a>01137         <span class="keywordflow">return</span>;
<a name="l01138"></a>01138     <span class="comment">/*</span>
<a name="l01139"></a>01139 <span class="comment">     * need to clean-up task context to claim dma buffers</span>
<a name="l01140"></a>01140 <span class="comment">     */</span>
<a name="l01141"></a>01141     <span class="keywordflow">if</span> (conn-&gt;tmf_state == TMF_SUCCESS) {
<a name="l01142"></a>01142         bnx2i_send_cmd_cleanup_req(hba, task-&gt;dd_data);
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         spin_unlock(&amp;conn-&gt;session-&gt;lock);
<a name="l01145"></a>01145         <span class="comment">/* This was made to be an interruptible wait as the</span>
<a name="l01146"></a>01146 <span class="comment">                 * cmd_cleanup_cmpl struct is updated in the int context */</span>
<a name="l01147"></a>01147                 wait_for_completion_interruptible_timeout(
<a name="l01148"></a>01148                                 &amp;bnx2i_conn-&gt;cmd_cleanup_cmpl,
<a name="l01149"></a>01149                 msecs_to_jiffies(ISCSI_CMD_CLEANUP_TIMEOUT));
<a name="l01150"></a>01150         spin_lock(&amp;conn-&gt;session-&gt;lock);
<a name="l01151"></a>01151     }
<a name="l01152"></a>01152     <span class="comment">/*</span>
<a name="l01153"></a>01153 <span class="comment">     * check task again incase the command completed while we were</span>
<a name="l01154"></a>01154 <span class="comment">     * cleaning it up and session lock was dropped.</span>
<a name="l01155"></a>01155 <span class="comment">     */</span>
<a name="l01156"></a>01156     <span class="keywordflow">if</span> (!task-&gt;sc)
<a name="l01157"></a>01157         bnx2i_iscsi_unmap_sg_list(task-&gt;dd_data);
<a name="l01158"></a>01158 }
<a name="l01159"></a>01159 
<a name="l01165"></a>01165 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01166"></a>01166 bnx2i_mtask_xmit(<span class="keyword">struct</span> iscsi_conn *conn, <span class="keyword">struct</span> iscsi_task *task)
<a name="l01167"></a>01167 {
<a name="l01168"></a>01168     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l01169"></a>01169     <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd = task-&gt;dd_data;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171     memset(bnx2i_conn-&gt;gen_pdu.req_buf, 0, ISCSI_DEF_MAX_RECV_SEG_LEN);
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     bnx2i_setup_cmd_wqe_template(cmd);
<a name="l01174"></a>01174     bnx2i_conn-&gt;gen_pdu.req_buf_size = task-&gt;data_count;
<a name="l01175"></a>01175     <span class="keywordflow">if</span> (task-&gt;data_count) {
<a name="l01176"></a>01176         memcpy(bnx2i_conn-&gt;gen_pdu.req_buf, task-&gt;data,
<a name="l01177"></a>01177                task-&gt;data_count);
<a name="l01178"></a>01178         bnx2i_conn-&gt;gen_pdu.req_wr_ptr =
<a name="l01179"></a>01179             bnx2i_conn-&gt;gen_pdu.req_buf + task-&gt;data_count;
<a name="l01180"></a>01180     }
<a name="l01181"></a>01181     cmd-&gt;conn = conn-&gt;dd_data;
<a name="l01182"></a>01182     cmd-&gt;scsi_cmd = NULL;
<a name="l01183"></a>01183     <span class="keywordflow">return</span> bnx2i_iscsi_send_generic_request(task);
<a name="l01184"></a>01184 }
<a name="l01185"></a>01185 
<a name="l01192"></a>01192 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_task_xmit(<span class="keyword">struct</span> iscsi_task *task)
<a name="l01193"></a>01193 {
<a name="l01194"></a>01194     <span class="keyword">struct </span>iscsi_conn *conn = task-&gt;conn;
<a name="l01195"></a>01195     <span class="keyword">struct </span>iscsi_session *session = conn-&gt;session;
<a name="l01196"></a>01196     <span class="keyword">struct </span>Scsi_Host *shost = iscsi_session_to_shost(session-&gt;cls_session);
<a name="l01197"></a>01197     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = iscsi_host_priv(shost);
<a name="l01198"></a>01198     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l01199"></a>01199     <span class="keyword">struct </span>scsi_cmnd *sc = task-&gt;sc;
<a name="l01200"></a>01200     <span class="keyword">struct </span><a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a> *cmd = task-&gt;dd_data;
<a name="l01201"></a>01201     <span class="keyword">struct </span>iscsi_cmd *hdr = (<span class="keyword">struct </span>iscsi_cmd *) task-&gt;hdr;
<a name="l01202"></a>01202 
<a name="l01203"></a>01203 
<a name="l01204"></a>01204     if (!bnx2i_conn-&gt;is_bound)
<a name="l01205"></a>01205         <span class="keywordflow">return</span> -ENOTCONN;
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     <span class="comment">/*</span>
<a name="l01208"></a>01208 <span class="comment">     * If there is no scsi_cmnd this must be a mgmt task</span>
<a name="l01209"></a>01209 <span class="comment">     */</span>
<a name="l01210"></a>01210     <span class="keywordflow">if</span> (!sc)
<a name="l01211"></a>01211         <span class="keywordflow">return</span> bnx2i_mtask_xmit(conn, task);
<a name="l01212"></a>01212 
<a name="l01213"></a>01213     bnx2i_setup_cmd_wqe_template(cmd);
<a name="l01214"></a>01214     cmd-&gt;req.op_code = ISCSI_OP_SCSI_CMD;
<a name="l01215"></a>01215     cmd-&gt;conn = bnx2i_conn;
<a name="l01216"></a>01216     cmd-&gt;scsi_cmd = sc;
<a name="l01217"></a>01217     cmd-&gt;req.total_data_transfer_length = scsi_bufflen(sc);
<a name="l01218"></a>01218     cmd-&gt;req.cmd_sn = be32_to_cpu(hdr-&gt;cmdsn);
<a name="l01219"></a>01219 
<a name="l01220"></a>01220     bnx2i_iscsi_map_sg_list(cmd);
<a name="l01221"></a>01221     bnx2i_cpy_scsi_cdb(sc, cmd);
<a name="l01222"></a>01222 
<a name="l01223"></a>01223     cmd-&gt;req.op_attr = ISCSI_ATTR_SIMPLE;
<a name="l01224"></a>01224     <span class="keywordflow">if</span> (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
<a name="l01225"></a>01225         cmd-&gt;req.op_attr |= ISCSI_CMD_REQUEST_WRITE;
<a name="l01226"></a>01226         cmd-&gt;req.itt = task-&gt;itt |
<a name="l01227"></a>01227             (ISCSI_TASK_TYPE_WRITE &lt;&lt; ISCSI_CMD_REQUEST_TYPE_SHIFT);
<a name="l01228"></a>01228         bnx2i_setup_write_cmd_bd_info(task);
<a name="l01229"></a>01229     } <span class="keywordflow">else</span> {
<a name="l01230"></a>01230         <span class="keywordflow">if</span> (scsi_bufflen(sc))
<a name="l01231"></a>01231             cmd-&gt;req.op_attr |= ISCSI_CMD_REQUEST_READ;
<a name="l01232"></a>01232         cmd-&gt;req.itt = task-&gt;itt |
<a name="l01233"></a>01233             (ISCSI_TASK_TYPE_READ &lt;&lt; ISCSI_CMD_REQUEST_TYPE_SHIFT);
<a name="l01234"></a>01234     }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236     cmd-&gt;req.num_bds = cmd-&gt;io_tbl.bd_valid;
<a name="l01237"></a>01237     <span class="keywordflow">if</span> (!cmd-&gt;io_tbl.bd_valid) {
<a name="l01238"></a>01238         cmd-&gt;req.bd_list_addr_lo = (u32) hba-&gt;mp_bd_dma;
<a name="l01239"></a>01239         cmd-&gt;req.bd_list_addr_hi = (u32) ((u64) hba-&gt;mp_bd_dma &gt;&gt; 32);
<a name="l01240"></a>01240         cmd-&gt;req.num_bds = 1;
<a name="l01241"></a>01241     }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243     bnx2i_send_iscsi_scsicmd(bnx2i_conn, cmd);
<a name="l01244"></a>01244     <span class="keywordflow">return</span> 0;
<a name="l01245"></a>01245 }
<a name="l01246"></a>01246 
<a name="l01255"></a>01255 <span class="keyword">static</span> <span class="keyword">struct </span>iscsi_cls_session *
<a name="l01256"></a>01256 bnx2i_session_create(<span class="keyword">struct</span> iscsi_endpoint *ep,
<a name="l01257"></a>01257              uint16_t cmds_max, uint16_t qdepth,
<a name="l01258"></a>01258              uint32_t initial_cmdsn, uint32_t *host_no)
<a name="l01259"></a>01259 {
<a name="l01260"></a>01260     <span class="keyword">struct </span>Scsi_Host *shost;
<a name="l01261"></a>01261     <span class="keyword">struct </span>iscsi_cls_session *cls_session;
<a name="l01262"></a>01262     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba;
<a name="l01263"></a>01263     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep;
<a name="l01264"></a>01264     <span class="keywordflow">if</span> (!ep) {
<a name="l01265"></a>01265         printk(KERN_ERR <span class="stringliteral">&quot;bnx2i: missing ep.\n&quot;</span>);
<a name="l01266"></a>01266         <span class="keywordflow">return</span> NULL;
<a name="l01267"></a>01267     }
<a name="l01268"></a>01268 
<a name="l01269"></a>01269     bnx2i_ep = ep-&gt;dd_data;
<a name="l01270"></a>01270     shost = bnx2i_ep-&gt;hba-&gt;shost;
<a name="l01271"></a>01271     hba = iscsi_host_priv(shost);
<a name="l01272"></a>01272     <span class="keywordflow">if</span> (bnx2i_adapter_ready(hba))
<a name="l01273"></a>01273         <span class="keywordflow">return</span> NULL;
<a name="l01274"></a>01274 
<a name="l01275"></a>01275     <span class="comment">/*</span>
<a name="l01276"></a>01276 <span class="comment">     * user can override hw limit as long as it is within</span>
<a name="l01277"></a>01277 <span class="comment">     * the min/max.</span>
<a name="l01278"></a>01278 <span class="comment">     */</span>
<a name="l01279"></a>01279     <span class="keywordflow">if</span> (cmds_max &gt; hba-&gt;max_sqes)
<a name="l01280"></a>01280         cmds_max = hba-&gt;max_sqes;
<a name="l01281"></a>01281     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmds_max &lt; BNX2I_SQ_WQES_MIN)
<a name="l01282"></a>01282         cmds_max = BNX2I_SQ_WQES_MIN;
<a name="l01283"></a>01283 
<a name="l01284"></a>01284     cls_session = iscsi_session_setup(&amp;bnx2i_iscsi_transport, shost,
<a name="l01285"></a>01285                       cmds_max, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbnx2i__cmd.html">bnx2i_cmd</a>),
<a name="l01286"></a>01286                       initial_cmdsn, ISCSI_MAX_TARGET);
<a name="l01287"></a>01287     <span class="keywordflow">if</span> (!cls_session)
<a name="l01288"></a>01288         <span class="keywordflow">return</span> NULL;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290     <span class="keywordflow">if</span> (bnx2i_setup_cmd_pool(hba, cls_session-&gt;dd_data))
<a name="l01291"></a>01291         <span class="keywordflow">goto</span> session_teardown;
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     *host_no = shost-&gt;host_no;
<a name="l01294"></a>01294 
<a name="l01295"></a>01295     <span class="keywordflow">return</span> cls_session;
<a name="l01296"></a>01296 
<a name="l01297"></a>01297 session_teardown:
<a name="l01298"></a>01298     iscsi_session_teardown(cls_session);
<a name="l01299"></a>01299     <span class="keywordflow">return</span> NULL;
<a name="l01300"></a>01300 }
<a name="l01301"></a>01301 
<a name="l01302"></a>01302 
<a name="l01310"></a>01310 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_session_destroy(<span class="keyword">struct</span> iscsi_cls_session *cls_session)
<a name="l01311"></a>01311 {
<a name="l01312"></a>01312     <span class="keyword">struct </span>iscsi_session *session = cls_session-&gt;dd_data;
<a name="l01313"></a>01313     <span class="keyword">struct </span>Scsi_Host *shost = iscsi_session_to_shost(cls_session);
<a name="l01314"></a>01314     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = iscsi_host_priv(shost);
<a name="l01315"></a>01315 
<a name="l01316"></a>01316     bnx2i_destroy_cmd_pool(hba, session);
<a name="l01317"></a>01317     iscsi_session_teardown(cls_session);
<a name="l01318"></a>01318 }
<a name="l01319"></a>01319 
<a name="l01320"></a>01320 
<a name="l01328"></a>01328 <span class="keyword">static</span> <span class="keyword">struct </span>iscsi_cls_conn *
<a name="l01329"></a>01329 bnx2i_conn_create(<span class="keyword">struct</span> iscsi_cls_session *cls_session, uint32_t cid)
<a name="l01330"></a>01330 {
<a name="l01331"></a>01331     <span class="keyword">struct </span>Scsi_Host *shost = iscsi_session_to_shost(cls_session);
<a name="l01332"></a>01332     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = iscsi_host_priv(shost);
<a name="l01333"></a>01333     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn;
<a name="l01334"></a>01334     <span class="keyword">struct </span>iscsi_cls_conn *cls_conn;
<a name="l01335"></a>01335     <span class="keyword">struct </span>iscsi_conn *conn;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     cls_conn = iscsi_conn_setup(cls_session, <span class="keyword">sizeof</span>(*bnx2i_conn),
<a name="l01338"></a>01338                     cid);
<a name="l01339"></a>01339     <span class="keywordflow">if</span> (!cls_conn)
<a name="l01340"></a>01340         <span class="keywordflow">return</span> NULL;
<a name="l01341"></a>01341     conn = cls_conn-&gt;dd_data;
<a name="l01342"></a>01342 
<a name="l01343"></a>01343     bnx2i_conn = conn-&gt;dd_data;
<a name="l01344"></a>01344     bnx2i_conn-&gt;cls_conn = cls_conn;
<a name="l01345"></a>01345     bnx2i_conn-&gt;hba = hba;
<a name="l01346"></a>01346     <span class="comment">/* &#39;ep&#39; ptr will be assigned in bind() call */</span>
<a name="l01347"></a>01347     bnx2i_conn-&gt;ep = NULL;
<a name="l01348"></a>01348     init_completion(&amp;bnx2i_conn-&gt;cmd_cleanup_cmpl);
<a name="l01349"></a>01349 
<a name="l01350"></a>01350     <span class="keywordflow">if</span> (bnx2i_conn_alloc_login_resources(hba, bnx2i_conn)) {
<a name="l01351"></a>01351         iscsi_conn_printk(KERN_ALERT, conn,
<a name="l01352"></a>01352                   <span class="stringliteral">&quot;conn_new: login resc alloc failed!!\n&quot;</span>);
<a name="l01353"></a>01353         <span class="keywordflow">goto</span> free_conn;
<a name="l01354"></a>01354     }
<a name="l01355"></a>01355 
<a name="l01356"></a>01356     <span class="keywordflow">return</span> cls_conn;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 free_conn:
<a name="l01359"></a>01359     iscsi_conn_teardown(cls_conn);
<a name="l01360"></a>01360     <span class="keywordflow">return</span> NULL;
<a name="l01361"></a>01361 }
<a name="l01362"></a>01362 
<a name="l01375"></a>01375 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_conn_bind(<span class="keyword">struct</span> iscsi_cls_session *cls_session,
<a name="l01376"></a>01376                <span class="keyword">struct</span> iscsi_cls_conn *cls_conn,
<a name="l01377"></a>01377                uint64_t transport_fd, <span class="keywordtype">int</span> is_leading)
<a name="l01378"></a>01378 {
<a name="l01379"></a>01379     <span class="keyword">struct </span>iscsi_conn *conn = cls_conn-&gt;dd_data;
<a name="l01380"></a>01380     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l01381"></a>01381     <span class="keyword">struct </span>Scsi_Host *shost = iscsi_session_to_shost(cls_session);
<a name="l01382"></a>01382     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = iscsi_host_priv(shost);
<a name="l01383"></a>01383     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep;
<a name="l01384"></a>01384     <span class="keyword">struct </span>iscsi_endpoint *ep;
<a name="l01385"></a>01385     <span class="keywordtype">int</span> ret_code;
<a name="l01386"></a>01386 
<a name="l01387"></a>01387     ep = iscsi_lookup_endpoint(transport_fd);
<a name="l01388"></a>01388     <span class="keywordflow">if</span> (!ep)
<a name="l01389"></a>01389         <span class="keywordflow">return</span> -EINVAL;
<a name="l01390"></a>01390 
<a name="l01391"></a>01391     bnx2i_ep = ep-&gt;dd_data;
<a name="l01392"></a>01392     <span class="keywordflow">if</span> ((bnx2i_ep-&gt;state == EP_STATE_TCP_FIN_RCVD) ||
<a name="l01393"></a>01393         (bnx2i_ep-&gt;state == EP_STATE_TCP_RST_RCVD))
<a name="l01394"></a>01394         <span class="comment">/* Peer disconnect via&#39; FIN or RST */</span>
<a name="l01395"></a>01395         <span class="keywordflow">return</span> -EINVAL;
<a name="l01396"></a>01396 
<a name="l01397"></a>01397     <span class="keywordflow">if</span> (iscsi_conn_bind(cls_session, cls_conn, is_leading))
<a name="l01398"></a>01398         <span class="keywordflow">return</span> -EINVAL;
<a name="l01399"></a>01399 
<a name="l01400"></a>01400     <span class="keywordflow">if</span> (bnx2i_ep-&gt;hba != hba) {
<a name="l01401"></a>01401         <span class="comment">/* Error - TCP connection does not belong to this device</span>
<a name="l01402"></a>01402 <span class="comment">         */</span>
<a name="l01403"></a>01403         iscsi_conn_printk(KERN_ALERT, cls_conn-&gt;dd_data,
<a name="l01404"></a>01404                   <span class="stringliteral">&quot;conn bind, ep=0x%p (%s) does not&quot;</span>,
<a name="l01405"></a>01405                   bnx2i_ep, bnx2i_ep-&gt;hba-&gt;netdev-&gt;name);
<a name="l01406"></a>01406         iscsi_conn_printk(KERN_ALERT, cls_conn-&gt;dd_data,
<a name="l01407"></a>01407                   <span class="stringliteral">&quot;belong to hba (%s)\n&quot;</span>,
<a name="l01408"></a>01408                   hba-&gt;netdev-&gt;name);
<a name="l01409"></a>01409         <span class="keywordflow">return</span> -EEXIST;
<a name="l01410"></a>01410     }
<a name="l01411"></a>01411 
<a name="l01412"></a>01412     bnx2i_ep-&gt;conn = bnx2i_conn;
<a name="l01413"></a>01413     bnx2i_conn-&gt;ep = bnx2i_ep;
<a name="l01414"></a>01414     bnx2i_conn-&gt;iscsi_conn_cid = bnx2i_ep-&gt;ep_iscsi_cid;
<a name="l01415"></a>01415     bnx2i_conn-&gt;fw_cid = bnx2i_ep-&gt;ep_cid;
<a name="l01416"></a>01416     bnx2i_conn-&gt;is_bound = 1;
<a name="l01417"></a>01417 
<a name="l01418"></a>01418     ret_code = bnx2i_bind_conn_to_iscsi_cid(hba, bnx2i_conn,
<a name="l01419"></a>01419                         bnx2i_ep-&gt;ep_iscsi_cid);
<a name="l01420"></a>01420 
<a name="l01421"></a>01421     <span class="comment">/* 5706/5708/5709 FW takes RQ as full when initiated, but for 57710</span>
<a name="l01422"></a>01422 <span class="comment">     * driver needs to explicitly replenish RQ index during setup.</span>
<a name="l01423"></a>01423 <span class="comment">     */</span>
<a name="l01424"></a>01424     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;bnx2i_ep-&gt;hba-&gt;cnic_dev_type))
<a name="l01425"></a>01425         bnx2i_put_rq_buf(bnx2i_conn, 0);
<a name="l01426"></a>01426 
<a name="l01427"></a>01427     bnx2i_arm_cq_event_coalescing(bnx2i_conn-&gt;ep, CNIC_ARM_CQE);
<a name="l01428"></a>01428     <span class="keywordflow">return</span> ret_code;
<a name="l01429"></a>01429 }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 
<a name="l01439"></a>01439 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_conn_destroy(<span class="keyword">struct</span> iscsi_cls_conn *cls_conn)
<a name="l01440"></a>01440 {
<a name="l01441"></a>01441     <span class="keyword">struct </span>iscsi_conn *conn = cls_conn-&gt;dd_data;
<a name="l01442"></a>01442     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l01443"></a>01443     <span class="keyword">struct </span>Scsi_Host *shost;
<a name="l01444"></a>01444     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba;
<a name="l01445"></a>01445 
<a name="l01446"></a>01446     shost = iscsi_session_to_shost(iscsi_conn_to_session(cls_conn));
<a name="l01447"></a>01447     hba = iscsi_host_priv(shost);
<a name="l01448"></a>01448 
<a name="l01449"></a>01449     bnx2i_conn_free_login_resources(hba, bnx2i_conn);
<a name="l01450"></a>01450     iscsi_conn_teardown(cls_conn);
<a name="l01451"></a>01451 }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453 
<a name="l01462"></a>01462 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_conn_get_param(<span class="keyword">struct</span> iscsi_cls_conn *cls_conn,
<a name="l01463"></a>01463                 <span class="keyword">enum</span> iscsi_param param, <span class="keywordtype">char</span> *buf)
<a name="l01464"></a>01464 {
<a name="l01465"></a>01465     <span class="keyword">struct </span>iscsi_conn *conn = cls_conn-&gt;dd_data;
<a name="l01466"></a>01466     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l01467"></a>01467     <span class="keywordtype">int</span> len = 0;
<a name="l01468"></a>01468 
<a name="l01469"></a>01469     <span class="keywordflow">switch</span> (param) {
<a name="l01470"></a>01470     <span class="keywordflow">case</span> ISCSI_PARAM_CONN_PORT:
<a name="l01471"></a>01471         <span class="keywordflow">if</span> (bnx2i_conn-&gt;ep)
<a name="l01472"></a>01472             len = sprintf(buf, <span class="stringliteral">&quot;%hu\n&quot;</span>,
<a name="l01473"></a>01473                       bnx2i_conn-&gt;ep-&gt;cm_sk-&gt;dst_port);
<a name="l01474"></a>01474         <span class="keywordflow">break</span>;
<a name="l01475"></a>01475     <span class="keywordflow">case</span> ISCSI_PARAM_CONN_ADDRESS:
<a name="l01476"></a>01476         <span class="keywordflow">if</span> (bnx2i_conn-&gt;ep)
<a name="l01477"></a>01477             len = sprintf(buf, NIPQUAD_FMT <span class="stringliteral">&quot;\n&quot;</span>,
<a name="l01478"></a>01478                       NIPQUAD(bnx2i_conn-&gt;ep-&gt;cm_sk-&gt;dst_ip));
<a name="l01479"></a>01479         <span class="keywordflow">break</span>;
<a name="l01480"></a>01480     <span class="keywordflow">default</span>:
<a name="l01481"></a>01481         <span class="keywordflow">return</span> iscsi_conn_get_param(cls_conn, param, buf);
<a name="l01482"></a>01482     }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484     <span class="keywordflow">return</span> len;
<a name="l01485"></a>01485 }
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="keyword">static</span> ssize_t format_addr(<span class="keywordtype">char</span> *buf, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *addr, <span class="keywordtype">int</span> len)
<a name="l01488"></a>01488 {
<a name="l01489"></a>01489     <span class="keywordtype">int</span> i;
<a name="l01490"></a>01490     <span class="keywordtype">char</span> *cp = buf;
<a name="l01491"></a>01491 
<a name="l01492"></a>01492     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
<a name="l01493"></a>01493         cp += sprintf(cp, <span class="stringliteral">&quot;%02x%c&quot;</span>, addr[i],
<a name="l01494"></a>01494                   i == (len - 1) ? <span class="charliteral">&#39;\n&#39;</span> : <span class="charliteral">&#39;:&#39;</span>);
<a name="l01495"></a>01495     <span class="keywordflow">return</span> cp - buf;
<a name="l01496"></a>01496 }
<a name="l01497"></a>01497 
<a name="l01504"></a>01504 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_host_get_param(<span class="keyword">struct</span> Scsi_Host *shost,
<a name="l01505"></a>01505                 <span class="keyword">enum</span> iscsi_host_param param, <span class="keywordtype">char</span> *buf)
<a name="l01506"></a>01506 {
<a name="l01507"></a>01507     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba = iscsi_host_priv(shost);
<a name="l01508"></a>01508     <span class="keywordtype">int</span> len = 0;
<a name="l01509"></a>01509 
<a name="l01510"></a>01510     <span class="keywordflow">switch</span> (param) {
<a name="l01511"></a>01511     <span class="keywordflow">case</span> ISCSI_HOST_PARAM_HWADDRESS:
<a name="l01512"></a>01512         len = format_addr(buf, hba-&gt;netdev-&gt;dev_addr, 6);
<a name="l01513"></a>01513         <span class="keywordflow">break</span>;
<a name="l01514"></a>01514     <span class="keywordflow">case</span> ISCSI_HOST_PARAM_NETDEV_NAME:
<a name="l01515"></a>01515         len = sprintf(buf, <span class="stringliteral">&quot;%s\n&quot;</span>, hba-&gt;netdev-&gt;name);
<a name="l01516"></a>01516         <span class="keywordflow">break</span>;
<a name="l01517"></a>01517     <span class="keywordflow">default</span>:
<a name="l01518"></a>01518         <span class="keywordflow">return</span> iscsi_host_get_param(shost, param, buf);
<a name="l01519"></a>01519     }
<a name="l01520"></a>01520     <span class="keywordflow">return</span> len;
<a name="l01521"></a>01521 }
<a name="l01522"></a>01522 
<a name="l01529"></a>01529 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_conn_start(<span class="keyword">struct</span> iscsi_cls_conn *cls_conn)
<a name="l01530"></a>01530 {
<a name="l01531"></a>01531     <span class="keyword">struct </span>iscsi_conn *conn = cls_conn-&gt;dd_data;
<a name="l01532"></a>01532     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = conn-&gt;dd_data;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     bnx2i_conn-&gt;ep-&gt;state = EP_STATE_ULP_UPDATE_START;
<a name="l01535"></a>01535     bnx2i_update_iscsi_conn(conn);
<a name="l01536"></a>01536 
<a name="l01537"></a>01537     <span class="comment">/*</span>
<a name="l01538"></a>01538 <span class="comment">     * this should normally not sleep for a long time so it should</span>
<a name="l01539"></a>01539 <span class="comment">     * not disrupt the caller.</span>
<a name="l01540"></a>01540 <span class="comment">     */</span>
<a name="l01541"></a>01541     bnx2i_conn-&gt;ep-&gt;ofld_timer.expires = 1 * HZ + jiffies;
<a name="l01542"></a>01542     bnx2i_conn-&gt;ep-&gt;ofld_timer.function = bnx2i_ep_ofld_timer;
<a name="l01543"></a>01543     bnx2i_conn-&gt;ep-&gt;ofld_timer.data = (<span class="keywordtype">unsigned</span> long) bnx2i_conn-&gt;ep;
<a name="l01544"></a>01544     add_timer(&amp;bnx2i_conn-&gt;ep-&gt;ofld_timer);
<a name="l01545"></a>01545     <span class="comment">/* update iSCSI context for this conn, wait for CNIC to complete */</span>
<a name="l01546"></a>01546     wait_event_interruptible(bnx2i_conn-&gt;ep-&gt;ofld_wait,
<a name="l01547"></a>01547             bnx2i_conn-&gt;ep-&gt;state != EP_STATE_ULP_UPDATE_START);
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     <span class="keywordflow">if</span> (signal_pending(current))
<a name="l01550"></a>01550         flush_signals(current);
<a name="l01551"></a>01551     del_timer_sync(&amp;bnx2i_conn-&gt;ep-&gt;ofld_timer);
<a name="l01552"></a>01552 
<a name="l01553"></a>01553     iscsi_conn_start(cls_conn);
<a name="l01554"></a>01554     <span class="keywordflow">return</span> 0;
<a name="l01555"></a>01555 }
<a name="l01556"></a>01556 
<a name="l01557"></a>01557 
<a name="l01563"></a>01563 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_conn_get_stats(<span class="keyword">struct</span> iscsi_cls_conn *cls_conn,
<a name="l01564"></a>01564                  <span class="keyword">struct</span> iscsi_stats *stats)
<a name="l01565"></a>01565 {
<a name="l01566"></a>01566     <span class="keyword">struct </span>iscsi_conn *conn = cls_conn-&gt;dd_data;
<a name="l01567"></a>01567 
<a name="l01568"></a>01568     stats-&gt;txdata_octets = conn-&gt;txdata_octets;
<a name="l01569"></a>01569     stats-&gt;rxdata_octets = conn-&gt;rxdata_octets;
<a name="l01570"></a>01570     stats-&gt;scsicmd_pdus = conn-&gt;scsicmd_pdus_cnt;
<a name="l01571"></a>01571     stats-&gt;dataout_pdus = conn-&gt;dataout_pdus_cnt;
<a name="l01572"></a>01572     stats-&gt;scsirsp_pdus = conn-&gt;scsirsp_pdus_cnt;
<a name="l01573"></a>01573     stats-&gt;datain_pdus = conn-&gt;datain_pdus_cnt;
<a name="l01574"></a>01574     stats-&gt;r2t_pdus = conn-&gt;r2t_pdus_cnt;
<a name="l01575"></a>01575     stats-&gt;tmfcmd_pdus = conn-&gt;tmfcmd_pdus_cnt;
<a name="l01576"></a>01576     stats-&gt;tmfrsp_pdus = conn-&gt;tmfrsp_pdus_cnt;
<a name="l01577"></a>01577     stats-&gt;custom_length = 3;
<a name="l01578"></a>01578     strcpy(stats-&gt;custom[2].desc, <span class="stringliteral">&quot;eh_abort_cnt&quot;</span>);
<a name="l01579"></a>01579     stats-&gt;custom[2].value = conn-&gt;eh_abort_cnt;
<a name="l01580"></a>01580     stats-&gt;digest_err = 0;
<a name="l01581"></a>01581     stats-&gt;timeout_err = 0;
<a name="l01582"></a>01582     stats-&gt;custom_length = 0;
<a name="l01583"></a>01583 }
<a name="l01584"></a>01584 
<a name="l01585"></a>01585 
<a name="l01592"></a>01592 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *bnx2i_check_route(<span class="keyword">struct</span> sockaddr *dst_addr)
<a name="l01593"></a>01593 {
<a name="l01594"></a>01594     <span class="keyword">struct </span>sockaddr_in *desti = (<span class="keyword">struct </span>sockaddr_in *) dst_addr;
<a name="l01595"></a>01595     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba;
<a name="l01596"></a>01596     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cnic = NULL;
<a name="l01597"></a>01597 
<a name="l01598"></a>01598     bnx2i_reg_dev_all();
<a name="l01599"></a>01599 
<a name="l01600"></a>01600     hba = get_adapter_list_head();
<a name="l01601"></a>01601     <span class="keywordflow">if</span> (hba &amp;&amp; hba-&gt;cnic)
<a name="l01602"></a>01602         cnic = hba-&gt;cnic-&gt;cm_select_dev(desti, CNIC_ULP_ISCSI);
<a name="l01603"></a>01603     <span class="keywordflow">if</span> (!cnic) {
<a name="l01604"></a>01604         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: no route,&quot;</span>
<a name="l01605"></a>01605                <span class="stringliteral">&quot;can&#39;t connect using cnic\n&quot;</span>);
<a name="l01606"></a>01606         <span class="keywordflow">goto</span> no_nx2_route;
<a name="l01607"></a>01607     }
<a name="l01608"></a>01608     hba = bnx2i_find_hba_for_cnic(cnic);
<a name="l01609"></a>01609     <span class="keywordflow">if</span> (!hba)
<a name="l01610"></a>01610         <span class="keywordflow">goto</span> no_nx2_route;
<a name="l01611"></a>01611 
<a name="l01612"></a>01612     <span class="keywordflow">if</span> (bnx2i_adapter_ready(hba)) {
<a name="l01613"></a>01613         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: check route, hba not found\n&quot;</span>);
<a name="l01614"></a>01614         <span class="keywordflow">goto</span> no_nx2_route;
<a name="l01615"></a>01615     }
<a name="l01616"></a>01616     <span class="keywordflow">if</span> (hba-&gt;netdev-&gt;mtu &gt; hba-&gt;mtu_supported) {
<a name="l01617"></a>01617         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: %s network i/f mtu is set to %d\n&quot;</span>,
<a name="l01618"></a>01618                   hba-&gt;netdev-&gt;name, hba-&gt;netdev-&gt;mtu);
<a name="l01619"></a>01619         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: iSCSI HBA can support mtu of %d\n&quot;</span>,
<a name="l01620"></a>01620                   hba-&gt;mtu_supported);
<a name="l01621"></a>01621         <span class="keywordflow">goto</span> no_nx2_route;
<a name="l01622"></a>01622     }
<a name="l01623"></a>01623     <span class="keywordflow">return</span> hba;
<a name="l01624"></a>01624 no_nx2_route:
<a name="l01625"></a>01625     <span class="keywordflow">return</span> NULL;
<a name="l01626"></a>01626 }
<a name="l01627"></a>01627 
<a name="l01628"></a>01628 
<a name="l01636"></a>01636 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_tear_down_conn(<span class="keyword">struct</span> <a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba,
<a name="l01637"></a>01637                  <span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *ep)
<a name="l01638"></a>01638 {
<a name="l01639"></a>01639     <span class="keywordflow">if</span> (test_bit(BNX2I_CNIC_REGISTERED, &amp;hba-&gt;reg_with_cnic))
<a name="l01640"></a>01640         hba-&gt;cnic-&gt;cm_destroy(ep-&gt;cm_sk);
<a name="l01641"></a>01641 
<a name="l01642"></a>01642     <span class="keywordflow">if</span> (test_bit(ADAPTER_STATE_GOING_DOWN, &amp;ep-&gt;hba-&gt;adapter_state))
<a name="l01643"></a>01643         ep-&gt;state = EP_STATE_DISCONN_COMPL;
<a name="l01644"></a>01644 
<a name="l01645"></a>01645     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;hba-&gt;cnic_dev_type) &amp;&amp;
<a name="l01646"></a>01646         ep-&gt;state == EP_STATE_DISCONN_TIMEDOUT) {
<a name="l01647"></a>01647         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i - ERROR - please submit GRC Dump,&quot;</span>
<a name="l01648"></a>01648                   <span class="stringliteral">&quot; NW/PCIe trace, driver msgs to developers&quot;</span>
<a name="l01649"></a>01649                   <span class="stringliteral">&quot; for analysis\n&quot;</span>);
<a name="l01650"></a>01650         <span class="keywordflow">return</span> 1;
<a name="l01651"></a>01651     }
<a name="l01652"></a>01652 
<a name="l01653"></a>01653     ep-&gt;state = EP_STATE_CLEANUP_START;
<a name="l01654"></a>01654     init_timer(&amp;ep-&gt;ofld_timer);
<a name="l01655"></a>01655     ep-&gt;ofld_timer.expires = 10*HZ + jiffies;
<a name="l01656"></a>01656     ep-&gt;ofld_timer.function = bnx2i_ep_ofld_timer;
<a name="l01657"></a>01657     ep-&gt;ofld_timer.data = (<span class="keywordtype">unsigned</span> long) ep;
<a name="l01658"></a>01658     add_timer(&amp;ep-&gt;ofld_timer);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660     bnx2i_ep_destroy_list_add(hba, ep);
<a name="l01661"></a>01661 
<a name="l01662"></a>01662     <span class="comment">/* destroy iSCSI context, wait for it to complete */</span>
<a name="l01663"></a>01663     bnx2i_send_conn_destroy(hba, ep);
<a name="l01664"></a>01664     wait_event_interruptible(ep-&gt;ofld_wait,
<a name="l01665"></a>01665                  (ep-&gt;state != EP_STATE_CLEANUP_START));
<a name="l01666"></a>01666 
<a name="l01667"></a>01667     <span class="keywordflow">if</span> (signal_pending(current))
<a name="l01668"></a>01668         flush_signals(current);
<a name="l01669"></a>01669     del_timer_sync(&amp;ep-&gt;ofld_timer);
<a name="l01670"></a>01670 
<a name="l01671"></a>01671     bnx2i_ep_destroy_list_del(hba, ep);
<a name="l01672"></a>01672 
<a name="l01673"></a>01673     <span class="keywordflow">if</span> (ep-&gt;state != EP_STATE_CLEANUP_CMPL)
<a name="l01674"></a>01674         <span class="comment">/* should never happen */</span>
<a name="l01675"></a>01675         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i - conn destroy failed\n&quot;</span>);
<a name="l01676"></a>01676 
<a name="l01677"></a>01677     <span class="keywordflow">return</span> 0;
<a name="l01678"></a>01678 }
<a name="l01679"></a>01679 
<a name="l01680"></a>01680 
<a name="l01693"></a>01693 <span class="keyword">static</span> <span class="keyword">struct </span>iscsi_endpoint *bnx2i_ep_connect(<span class="keyword">struct</span> sockaddr *dst_addr,
<a name="l01694"></a>01694                            <span class="keywordtype">int</span> non_blocking)
<a name="l01695"></a>01695 {
<a name="l01696"></a>01696     u32 iscsi_cid = BNX2I_CID_RESERVED;
<a name="l01697"></a>01697     <span class="keyword">struct </span>sockaddr_in *desti = (<span class="keyword">struct </span>sockaddr_in *) dst_addr;
<a name="l01698"></a>01698     <span class="keyword">struct </span>sockaddr_in6 *desti6;
<a name="l01699"></a>01699     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep;
<a name="l01700"></a>01700     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba;
<a name="l01701"></a>01701     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cnic;
<a name="l01702"></a>01702     <span class="keyword">struct </span><a class="code" href="structcnic__sockaddr.html">cnic_sockaddr</a> saddr;
<a name="l01703"></a>01703     <span class="keyword">struct </span>iscsi_endpoint *ep;
<a name="l01704"></a>01704     <span class="keywordtype">int</span> rc = 0;
<a name="l01705"></a>01705 
<a name="l01706"></a>01706     <span class="comment">/*</span>
<a name="l01707"></a>01707 <span class="comment">     * check if the given destination can be reached through</span>
<a name="l01708"></a>01708 <span class="comment">     * a iscsi capable NetXtreme2 device</span>
<a name="l01709"></a>01709 <span class="comment">     */</span>
<a name="l01710"></a>01710     hba = bnx2i_check_route(dst_addr);
<a name="l01711"></a>01711 
<a name="l01712"></a>01712     <span class="keywordflow">if</span> (!hba) {
<a name="l01713"></a>01713         rc = -ENOMEM;
<a name="l01714"></a>01714         <span class="keywordflow">goto</span> check_busy;
<a name="l01715"></a>01715     }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717     cnic = hba-&gt;cnic;
<a name="l01718"></a>01718     ep = bnx2i_alloc_ep(hba);
<a name="l01719"></a>01719     <span class="keywordflow">if</span> (!ep) {
<a name="l01720"></a>01720         rc = -ENOMEM;
<a name="l01721"></a>01721         <span class="keywordflow">goto</span> check_busy;
<a name="l01722"></a>01722     }
<a name="l01723"></a>01723     bnx2i_ep = ep-&gt;dd_data;
<a name="l01724"></a>01724 
<a name="l01725"></a>01725     mutex_lock(&amp;hba-&gt;net_dev_lock);
<a name="l01726"></a>01726     <span class="keywordflow">if</span> (bnx2i_adapter_ready(hba)) {
<a name="l01727"></a>01727         rc = -EPERM;
<a name="l01728"></a>01728         <span class="keywordflow">goto</span> net_if_down;
<a name="l01729"></a>01729     }
<a name="l01730"></a>01730 
<a name="l01731"></a>01731     bnx2i_ep-&gt;num_active_cmds = 0;
<a name="l01732"></a>01732     iscsi_cid = bnx2i_alloc_iscsi_cid(hba);
<a name="l01733"></a>01733     <span class="keywordflow">if</span> (iscsi_cid == -1) {
<a name="l01734"></a>01734         printk(KERN_ALERT <span class="stringliteral">&quot;alloc_ep: unable to allocate iscsi cid\n&quot;</span>);
<a name="l01735"></a>01735         rc = -ENOMEM;
<a name="l01736"></a>01736         <span class="keywordflow">goto</span> iscsi_cid_err;
<a name="l01737"></a>01737     }
<a name="l01738"></a>01738     bnx2i_ep-&gt;hba_age = hba-&gt;age;
<a name="l01739"></a>01739 
<a name="l01740"></a>01740     rc = bnx2i_alloc_qp_resc(hba, bnx2i_ep);
<a name="l01741"></a>01741     <span class="keywordflow">if</span> (rc != 0) {
<a name="l01742"></a>01742         printk(KERN_ALERT <span class="stringliteral">&quot;bnx2i: ep_conn, alloc QP resc error\n&quot;</span>);
<a name="l01743"></a>01743         rc = -ENOMEM;
<a name="l01744"></a>01744         <span class="keywordflow">goto</span> qp_resc_err;
<a name="l01745"></a>01745     }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     bnx2i_ep-&gt;ep_iscsi_cid = (u16)iscsi_cid;
<a name="l01748"></a>01748     bnx2i_ep-&gt;state = EP_STATE_OFLD_START;
<a name="l01749"></a>01749     bnx2i_ep_ofld_list_add(hba, bnx2i_ep);
<a name="l01750"></a>01750 
<a name="l01751"></a>01751     init_timer(&amp;bnx2i_ep-&gt;ofld_timer);
<a name="l01752"></a>01752     bnx2i_ep-&gt;ofld_timer.expires = 2 * HZ + jiffies;
<a name="l01753"></a>01753     bnx2i_ep-&gt;ofld_timer.function = bnx2i_ep_ofld_timer;
<a name="l01754"></a>01754     bnx2i_ep-&gt;ofld_timer.data = (<span class="keywordtype">unsigned</span> long) bnx2i_ep;
<a name="l01755"></a>01755     add_timer(&amp;bnx2i_ep-&gt;ofld_timer);
<a name="l01756"></a>01756 
<a name="l01757"></a>01757     bnx2i_send_conn_ofld_req(hba, bnx2i_ep);
<a name="l01758"></a>01758 
<a name="l01759"></a>01759     <span class="comment">/* Wait for CNIC hardware to setup conn context and return &#39;cid&#39; */</span>
<a name="l01760"></a>01760     wait_event_interruptible(bnx2i_ep-&gt;ofld_wait,
<a name="l01761"></a>01761                  bnx2i_ep-&gt;state != EP_STATE_OFLD_START);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     <span class="keywordflow">if</span> (signal_pending(current))
<a name="l01764"></a>01764         flush_signals(current);
<a name="l01765"></a>01765     del_timer_sync(&amp;bnx2i_ep-&gt;ofld_timer);
<a name="l01766"></a>01766 
<a name="l01767"></a>01767     bnx2i_ep_ofld_list_del(hba, bnx2i_ep);
<a name="l01768"></a>01768 
<a name="l01769"></a>01769     <span class="keywordflow">if</span> (bnx2i_ep-&gt;state != EP_STATE_OFLD_COMPL) {
<a name="l01770"></a>01770         rc = -ENOSPC;
<a name="l01771"></a>01771         <span class="keywordflow">goto</span> conn_failed;
<a name="l01772"></a>01772     }
<a name="l01773"></a>01773 
<a name="l01774"></a>01774     rc = cnic-&gt;cm_create(cnic, CNIC_ULP_ISCSI, bnx2i_ep-&gt;ep_cid,
<a name="l01775"></a>01775                  iscsi_cid, &amp;bnx2i_ep-&gt;cm_sk, bnx2i_ep);
<a name="l01776"></a>01776     <span class="keywordflow">if</span> (rc) {
<a name="l01777"></a>01777         rc = -EINVAL;
<a name="l01778"></a>01778         <span class="keywordflow">goto</span> conn_failed;
<a name="l01779"></a>01779     }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781     bnx2i_ep-&gt;cm_sk-&gt;rcv_buf = 256 * 1024;
<a name="l01782"></a>01782     bnx2i_ep-&gt;cm_sk-&gt;snd_buf = 256 * 1024;
<a name="l01783"></a>01783     <span class="keywordflow">if</span> (!en_tcp_dack)
<a name="l01784"></a>01784         bnx2i_ep-&gt;cm_sk-&gt;tcp_flags |= SK_TCP_NO_DELAY_ACK;
<a name="l01785"></a>01785     bnx2i_ep-&gt;cm_sk-&gt;tcp_flags |= SK_TCP_TIMESTAMP;
<a name="l01786"></a>01786 
<a name="l01787"></a>01787     memset(&amp;saddr, 0, <span class="keyword">sizeof</span>(saddr));
<a name="l01788"></a>01788     <span class="keywordflow">if</span> (dst_addr-&gt;sa_family == AF_INET) {
<a name="l01789"></a>01789         desti = (<span class="keyword">struct </span>sockaddr_in *) dst_addr;
<a name="l01790"></a>01790 <span class="preprocessor">#ifdef _BNX2I_IOCTL_</span>
<a name="l01791"></a>01791 <span class="preprocessor"></span>        saddr.local.v4.sin_port = htons(bnx2i_ep-&gt;tcp_port);
<a name="l01792"></a>01792 <span class="preprocessor">#endif</span>
<a name="l01793"></a>01793 <span class="preprocessor"></span>        saddr.remote.v4 = *desti;
<a name="l01794"></a>01794         saddr.local.v4.sin_family = desti-&gt;sin_family;
<a name="l01795"></a>01795     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dst_addr-&gt;sa_family == AF_INET6) {
<a name="l01796"></a>01796         desti6 = (<span class="keyword">struct </span>sockaddr_in6 *) dst_addr;
<a name="l01797"></a>01797 <span class="preprocessor">#ifdef _BNX2I_IOCTL_</span>
<a name="l01798"></a>01798 <span class="preprocessor"></span>        saddr.local.v6.sin6_port = htons(bnx2i_ep-&gt;tcp_port);
<a name="l01799"></a>01799 <span class="preprocessor">#endif</span>
<a name="l01800"></a>01800 <span class="preprocessor"></span>        saddr.remote.v6 = *desti6;
<a name="l01801"></a>01801         saddr.local.v6.sin6_family = desti6-&gt;sin6_family;
<a name="l01802"></a>01802     }
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     bnx2i_ep-&gt;timestamp = jiffies;
<a name="l01805"></a>01805     bnx2i_ep-&gt;state = EP_STATE_CONNECT_START;
<a name="l01806"></a>01806     <span class="keywordflow">if</span> (!test_bit(BNX2I_CNIC_REGISTERED, &amp;hba-&gt;reg_with_cnic)) {
<a name="l01807"></a>01807         rc = -EINVAL;
<a name="l01808"></a>01808         <span class="keywordflow">goto</span> conn_failed;
<a name="l01809"></a>01809     } <span class="keywordflow">else</span>
<a name="l01810"></a>01810         rc = cnic-&gt;cm_connect(bnx2i_ep-&gt;cm_sk, &amp;saddr);
<a name="l01811"></a>01811 
<a name="l01812"></a>01812     <span class="keywordflow">if</span> (rc)
<a name="l01813"></a>01813         <span class="keywordflow">goto</span> release_ep;
<a name="l01814"></a>01814 
<a name="l01815"></a>01815     <span class="keywordflow">if</span> (bnx2i_map_ep_dbell_regs(bnx2i_ep))
<a name="l01816"></a>01816         <span class="keywordflow">goto</span> release_ep;
<a name="l01817"></a>01817     mutex_unlock(&amp;hba-&gt;net_dev_lock);
<a name="l01818"></a>01818     <span class="keywordflow">return</span> ep;
<a name="l01819"></a>01819 
<a name="l01820"></a>01820 release_ep:
<a name="l01821"></a>01821     <span class="keywordflow">if</span> (bnx2i_tear_down_conn(hba, bnx2i_ep)) {
<a name="l01822"></a>01822         mutex_unlock(&amp;hba-&gt;net_dev_lock);
<a name="l01823"></a>01823         <span class="keywordflow">return</span> ERR_PTR(rc);
<a name="l01824"></a>01824     }
<a name="l01825"></a>01825 conn_failed:
<a name="l01826"></a>01826 net_if_down:
<a name="l01827"></a>01827 iscsi_cid_err:
<a name="l01828"></a>01828     bnx2i_free_qp_resc(hba, bnx2i_ep);
<a name="l01829"></a>01829 qp_resc_err:
<a name="l01830"></a>01830     bnx2i_free_ep(ep);
<a name="l01831"></a>01831     mutex_unlock(&amp;hba-&gt;net_dev_lock);
<a name="l01832"></a>01832 check_busy:
<a name="l01833"></a>01833     bnx2i_unreg_dev_all();
<a name="l01834"></a>01834     <span class="keywordflow">return</span> ERR_PTR(rc);
<a name="l01835"></a>01835 }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 
<a name="l01845"></a>01845 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_ep_poll(<span class="keyword">struct</span> iscsi_endpoint *ep, <span class="keywordtype">int</span> timeout_ms)
<a name="l01846"></a>01846 {
<a name="l01847"></a>01847     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep;
<a name="l01848"></a>01848     <span class="keywordtype">int</span> rc = 0;
<a name="l01849"></a>01849 
<a name="l01850"></a>01850     bnx2i_ep = ep-&gt;dd_data;
<a name="l01851"></a>01851     <span class="keywordflow">if</span> ((bnx2i_ep-&gt;state == EP_STATE_IDLE) ||
<a name="l01852"></a>01852         (bnx2i_ep-&gt;state == EP_STATE_CONNECT_FAILED) ||
<a name="l01853"></a>01853         (bnx2i_ep-&gt;state == EP_STATE_OFLD_FAILED))
<a name="l01854"></a>01854         <span class="keywordflow">return</span> -1;
<a name="l01855"></a>01855     <span class="keywordflow">if</span> (bnx2i_ep-&gt;state == EP_STATE_CONNECT_COMPL)
<a name="l01856"></a>01856         <span class="keywordflow">return</span> 1;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858     rc = wait_event_interruptible_timeout(bnx2i_ep-&gt;ofld_wait,
<a name="l01859"></a>01859                           ((bnx2i_ep-&gt;state ==
<a name="l01860"></a>01860                         EP_STATE_OFLD_FAILED) ||
<a name="l01861"></a>01861                            (bnx2i_ep-&gt;state ==
<a name="l01862"></a>01862                         EP_STATE_CONNECT_FAILED) ||
<a name="l01863"></a>01863                            (bnx2i_ep-&gt;state ==
<a name="l01864"></a>01864                         EP_STATE_CONNECT_COMPL)),
<a name="l01865"></a>01865                           msecs_to_jiffies(timeout_ms));
<a name="l01866"></a>01866     <span class="keywordflow">if</span> (!rc || (bnx2i_ep-&gt;state == EP_STATE_OFLD_FAILED))
<a name="l01867"></a>01867         rc = -1;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869     <span class="keywordflow">if</span> (rc &gt; 0)
<a name="l01870"></a>01870         <span class="keywordflow">return</span> 1;
<a name="l01871"></a>01871     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!rc)
<a name="l01872"></a>01872         <span class="keywordflow">return</span> 0;   <span class="comment">/* timeout */</span>
<a name="l01873"></a>01873     <span class="keywordflow">else</span>
<a name="l01874"></a>01874         <span class="keywordflow">return</span> rc;
<a name="l01875"></a>01875 }
<a name="l01876"></a>01876 
<a name="l01877"></a>01877 
<a name="l01884"></a>01884 <span class="keyword">static</span> <span class="keywordtype">int</span> bnx2i_ep_tcp_conn_active(<span class="keyword">struct</span> <a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep)
<a name="l01885"></a>01885 {
<a name="l01886"></a>01886     <span class="keywordtype">int</span> ret;
<a name="l01887"></a>01887     <span class="keywordtype">int</span> cnic_dev_10g = 0;
<a name="l01888"></a>01888 
<a name="l01889"></a>01889     <span class="keywordflow">if</span> (test_bit(BNX2I_NX2_DEV_57710, &amp;bnx2i_ep-&gt;hba-&gt;cnic_dev_type))
<a name="l01890"></a>01890         cnic_dev_10g = 1;
<a name="l01891"></a>01891 
<a name="l01892"></a>01892     <span class="keywordflow">switch</span> (bnx2i_ep-&gt;state) {
<a name="l01893"></a>01893     <span class="keywordflow">case</span> EP_STATE_CONNECT_START:
<a name="l01894"></a>01894     <span class="keywordflow">case</span> EP_STATE_CLEANUP_FAILED:
<a name="l01895"></a>01895     <span class="keywordflow">case</span> EP_STATE_OFLD_FAILED:
<a name="l01896"></a>01896     <span class="keywordflow">case</span> EP_STATE_DISCONN_TIMEDOUT:
<a name="l01897"></a>01897         ret = 0;
<a name="l01898"></a>01898         <span class="keywordflow">break</span>;
<a name="l01899"></a>01899     <span class="keywordflow">case</span> EP_STATE_CONNECT_COMPL:
<a name="l01900"></a>01900     <span class="keywordflow">case</span> EP_STATE_ULP_UPDATE_START:
<a name="l01901"></a>01901     <span class="keywordflow">case</span> EP_STATE_ULP_UPDATE_COMPL:
<a name="l01902"></a>01902     <span class="keywordflow">case</span> EP_STATE_TCP_FIN_RCVD:
<a name="l01903"></a>01903     <span class="keywordflow">case</span> EP_STATE_ULP_UPDATE_FAILED:
<a name="l01904"></a>01904         ret = 1;
<a name="l01905"></a>01905         <span class="keywordflow">break</span>;
<a name="l01906"></a>01906     <span class="keywordflow">case</span> EP_STATE_TCP_RST_RCVD:
<a name="l01907"></a>01907         ret = 0;
<a name="l01908"></a>01908         <span class="keywordflow">break</span>;
<a name="l01909"></a>01909     <span class="keywordflow">case</span> EP_STATE_CONNECT_FAILED:
<a name="l01910"></a>01910         <span class="keywordflow">if</span> (cnic_dev_10g)
<a name="l01911"></a>01911             ret = 1;
<a name="l01912"></a>01912         <span class="keywordflow">else</span>
<a name="l01913"></a>01913             ret = 0;
<a name="l01914"></a>01914         <span class="keywordflow">break</span>;
<a name="l01915"></a>01915     <span class="keywordflow">default</span>:
<a name="l01916"></a>01916         ret = 0;
<a name="l01917"></a>01917     }
<a name="l01918"></a>01918 
<a name="l01919"></a>01919     <span class="keywordflow">return</span> ret;
<a name="l01920"></a>01920 }
<a name="l01921"></a>01921 
<a name="l01922"></a>01922 
<a name="l01929"></a>01929 <span class="keyword">static</span> <span class="keywordtype">void</span> bnx2i_ep_disconnect(<span class="keyword">struct</span> iscsi_endpoint *ep)
<a name="l01930"></a>01930 {
<a name="l01931"></a>01931     <span class="keyword">struct </span><a class="code" href="structbnx2i__endpoint.html">bnx2i_endpoint</a> *bnx2i_ep;
<a name="l01932"></a>01932     <span class="keyword">struct </span>bnx2i_conn *bnx2i_conn = NULL;
<a name="l01933"></a>01933     <span class="keyword">struct </span>iscsi_session *session = NULL;
<a name="l01934"></a>01934     <span class="keyword">struct </span>iscsi_conn *conn;
<a name="l01935"></a>01935     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cnic;
<a name="l01936"></a>01936     <span class="keyword">struct </span><a class="code" href="structbnx2i__hba.html">bnx2i_hba</a> *hba;
<a name="l01937"></a>01937 
<a name="l01938"></a>01938     bnx2i_ep = ep-&gt;dd_data;
<a name="l01939"></a>01939 
<a name="l01940"></a>01940     <span class="comment">/* driver should not attempt connection cleanup untill TCP_CONNECT</span>
<a name="l01941"></a>01941 <span class="comment">     * completes either successfully or fails. Timeout is 9-secs, so</span>
<a name="l01942"></a>01942 <span class="comment">     * wait for it to complete</span>
<a name="l01943"></a>01943 <span class="comment">     */</span>
<a name="l01944"></a>01944     <span class="keywordflow">while</span> ((bnx2i_ep-&gt;state == EP_STATE_CONNECT_START) &amp;&amp;
<a name="l01945"></a>01945         !time_after(jiffies, bnx2i_ep-&gt;timestamp + (12 * HZ)))
<a name="l01946"></a>01946         msleep(250);
<a name="l01947"></a>01947 
<a name="l01948"></a>01948     <span class="keywordflow">if</span> (bnx2i_ep-&gt;conn) {
<a name="l01949"></a>01949         bnx2i_conn = bnx2i_ep-&gt;conn;
<a name="l01950"></a>01950         conn = bnx2i_conn-&gt;cls_conn-&gt;dd_data;
<a name="l01951"></a>01951         session = conn-&gt;session;
<a name="l01952"></a>01952 
<a name="l01953"></a>01953         spin_lock_bh(&amp;session-&gt;lock);
<a name="l01954"></a>01954         bnx2i_conn-&gt;is_bound = 0;
<a name="l01955"></a>01955         spin_unlock_bh(&amp;session-&gt;lock);
<a name="l01956"></a>01956     }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958     hba = bnx2i_ep-&gt;hba;
<a name="l01959"></a>01959     <span class="keywordflow">if</span> (bnx2i_ep-&gt;state == EP_STATE_IDLE)
<a name="l01960"></a>01960         <span class="keywordflow">goto</span> return_bnx2i_ep;
<a name="l01961"></a>01961     cnic = hba-&gt;cnic;
<a name="l01962"></a>01962 
<a name="l01963"></a>01963     mutex_lock(&amp;hba-&gt;net_dev_lock);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965     <span class="keywordflow">if</span> (!test_bit(ADAPTER_STATE_UP, &amp;hba-&gt;adapter_state))
<a name="l01966"></a>01966         <span class="keywordflow">goto</span> free_resc;
<a name="l01967"></a>01967     <span class="keywordflow">if</span> (bnx2i_ep-&gt;hba_age != hba-&gt;age)
<a name="l01968"></a>01968         <span class="keywordflow">goto</span> free_resc;
<a name="l01969"></a>01969 
<a name="l01970"></a>01970     <span class="keywordflow">if</span> (!bnx2i_ep_tcp_conn_active(bnx2i_ep))
<a name="l01971"></a>01971         <span class="keywordflow">goto</span> destory_conn;
<a name="l01972"></a>01972 
<a name="l01973"></a>01973     bnx2i_ep-&gt;state = EP_STATE_DISCONN_START;
<a name="l01974"></a>01974 
<a name="l01975"></a>01975     init_timer(&amp;bnx2i_ep-&gt;ofld_timer);
<a name="l01976"></a>01976     bnx2i_ep-&gt;ofld_timer.expires = 10*HZ + jiffies;
<a name="l01977"></a>01977     bnx2i_ep-&gt;ofld_timer.function = bnx2i_ep_ofld_timer;
<a name="l01978"></a>01978     bnx2i_ep-&gt;ofld_timer.data = (<span class="keywordtype">unsigned</span> long) bnx2i_ep;
<a name="l01979"></a>01979     add_timer(&amp;bnx2i_ep-&gt;ofld_timer);
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     <span class="keywordflow">if</span> (test_bit(BNX2I_CNIC_REGISTERED, &amp;hba-&gt;reg_with_cnic)) {
<a name="l01982"></a>01982         <span class="keywordtype">int</span> close = 0;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984         <span class="keywordflow">if</span> (session) {
<a name="l01985"></a>01985             spin_lock_bh(&amp;session-&gt;lock);
<a name="l01986"></a>01986             <span class="keywordflow">if</span> (session-&gt;state == ISCSI_STATE_LOGGING_OUT)
<a name="l01987"></a>01987                 close = 1;
<a name="l01988"></a>01988             spin_unlock_bh(&amp;session-&gt;lock);
<a name="l01989"></a>01989         }
<a name="l01990"></a>01990         <span class="keywordflow">if</span> (close)
<a name="l01991"></a>01991             cnic-&gt;cm_close(bnx2i_ep-&gt;cm_sk);
<a name="l01992"></a>01992         <span class="keywordflow">else</span>
<a name="l01993"></a>01993             cnic-&gt;cm_abort(bnx2i_ep-&gt;cm_sk);
<a name="l01994"></a>01994     } <span class="keywordflow">else</span>
<a name="l01995"></a>01995         <span class="keywordflow">goto</span> free_resc;
<a name="l01996"></a>01996 
<a name="l01997"></a>01997     <span class="comment">/* wait for option-2 conn teardown */</span>
<a name="l01998"></a>01998     wait_event_interruptible(bnx2i_ep-&gt;ofld_wait,
<a name="l01999"></a>01999                  bnx2i_ep-&gt;state != EP_STATE_DISCONN_START);
<a name="l02000"></a>02000 
<a name="l02001"></a>02001     <span class="keywordflow">if</span> (signal_pending(current))
<a name="l02002"></a>02002         flush_signals(current);
<a name="l02003"></a>02003     del_timer_sync(&amp;bnx2i_ep-&gt;ofld_timer);
<a name="l02004"></a>02004 
<a name="l02005"></a>02005 destory_conn:
<a name="l02006"></a>02006     <span class="keywordflow">if</span> (bnx2i_tear_down_conn(hba, bnx2i_ep)) {
<a name="l02007"></a>02007         mutex_unlock(&amp;hba-&gt;net_dev_lock);
<a name="l02008"></a>02008         <span class="keywordflow">return</span>;
<a name="l02009"></a>02009     }
<a name="l02010"></a>02010 free_resc:
<a name="l02011"></a>02011     mutex_unlock(&amp;hba-&gt;net_dev_lock);
<a name="l02012"></a>02012     bnx2i_free_qp_resc(hba, bnx2i_ep);
<a name="l02013"></a>02013 return_bnx2i_ep:
<a name="l02014"></a>02014     <span class="keywordflow">if</span> (bnx2i_conn)
<a name="l02015"></a>02015         bnx2i_conn-&gt;ep = NULL;
<a name="l02016"></a>02016 
<a name="l02017"></a>02017     bnx2i_free_ep(ep);
<a name="l02018"></a>02018 
<a name="l02019"></a>02019     <span class="keywordflow">if</span> (!hba-&gt;ofld_conns_active)
<a name="l02020"></a>02020         bnx2i_unreg_dev_all();
<a name="l02021"></a>02021 }
<a name="l02022"></a>02022 
<a name="l02023"></a>02023 <span class="comment">/*</span>
<a name="l02024"></a>02024 <span class="comment"> * &#39;Scsi_Host_Template&#39; structure and &#39;iscsi_tranport&#39; structure template</span>
<a name="l02025"></a>02025 <span class="comment"> * used while registering with the scsi host and iSCSI transport module.</span>
<a name="l02026"></a>02026 <span class="comment"> */</span>
<a name="l02027"></a>02027 <span class="keyword">static</span> <span class="keyword">struct </span>scsi_host_template bnx2i_host_template = {
<a name="l02028"></a>02028     .module         = THIS_MODULE,
<a name="l02029"></a>02029     .name           = <span class="stringliteral">&quot;Broadcom Offload iSCSI Initiator&quot;</span>,
<a name="l02030"></a>02030     .proc_name      = <span class="stringliteral">&quot;bnx2i&quot;</span>,
<a name="l02031"></a>02031     .queuecommand       = iscsi_queuecommand,
<a name="l02032"></a>02032     .eh_abort_handler   = iscsi_eh_abort,
<a name="l02033"></a>02033     .eh_device_reset_handler = iscsi_eh_device_reset,
<a name="l02034"></a>02034 <span class="preprocessor">#if 0   </span><span class="comment">/* TODO - investigate */</span>
<a name="l02035"></a>02035     .eh_target_reset_handler = iscsi_eh_target_reset,
<a name="l02036"></a>02036 <span class="preprocessor">#endif</span>
<a name="l02037"></a>02037 <span class="preprocessor"></span>    .can_queue      = 1024,
<a name="l02038"></a>02038     .max_sectors        = 127,
<a name="l02039"></a>02039     .cmd_per_lun        = 32,
<a name="l02040"></a>02040     .this_id        = -1,
<a name="l02041"></a>02041     .use_clustering     = ENABLE_CLUSTERING,
<a name="l02042"></a>02042     .sg_tablesize       = ISCSI_MAX_BDS_PER_CMD,
<a name="l02043"></a>02043     .shost_attrs        = bnx2i_dev_attributes,
<a name="l02044"></a>02044 };
<a name="l02045"></a>02045 
<a name="l02046"></a>02046 <span class="keyword">struct </span>iscsi_transport bnx2i_iscsi_transport = {
<a name="l02047"></a>02047     .owner          = THIS_MODULE,
<a name="l02048"></a>02048     .name           = <span class="stringliteral">&quot;bnx2i&quot;</span>,
<a name="l02049"></a>02049     .caps           = CAP_RECOVERY_L0 | CAP_HDRDGST |
<a name="l02050"></a>02050                   CAP_MULTI_R2T | CAP_DATADGST |
<a name="l02051"></a>02051                   CAP_DATA_PATH_OFFLOAD,
<a name="l02052"></a>02052     .param_mask     = ISCSI_MAX_RECV_DLENGTH |
<a name="l02053"></a>02053                   ISCSI_MAX_XMIT_DLENGTH |
<a name="l02054"></a>02054                   ISCSI_HDRDGST_EN |
<a name="l02055"></a>02055                   ISCSI_DATADGST_EN |
<a name="l02056"></a>02056                   ISCSI_INITIAL_R2T_EN |
<a name="l02057"></a>02057                   ISCSI_MAX_R2T |
<a name="l02058"></a>02058                   ISCSI_IMM_DATA_EN |
<a name="l02059"></a>02059                   ISCSI_FIRST_BURST |
<a name="l02060"></a>02060                   ISCSI_MAX_BURST |
<a name="l02061"></a>02061                   ISCSI_PDU_INORDER_EN |
<a name="l02062"></a>02062                   ISCSI_DATASEQ_INORDER_EN |
<a name="l02063"></a>02063                   ISCSI_ERL |
<a name="l02064"></a>02064                   ISCSI_CONN_PORT |
<a name="l02065"></a>02065                   ISCSI_CONN_ADDRESS |
<a name="l02066"></a>02066                   ISCSI_EXP_STATSN |
<a name="l02067"></a>02067                   ISCSI_PERSISTENT_PORT |
<a name="l02068"></a>02068                   ISCSI_PERSISTENT_ADDRESS |
<a name="l02069"></a>02069                   ISCSI_TARGET_NAME | ISCSI_TPGT |
<a name="l02070"></a>02070                   ISCSI_USERNAME | ISCSI_PASSWORD |
<a name="l02071"></a>02071                   ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN |
<a name="l02072"></a>02072                   ISCSI_FAST_ABORT | ISCSI_ABORT_TMO |
<a name="l02073"></a>02073                   ISCSI_LU_RESET_TMO |
<a name="l02074"></a>02074                   ISCSI_PING_TMO | ISCSI_RECV_TMO |
<a name="l02075"></a>02075                   ISCSI_IFACE_NAME | ISCSI_INITIATOR_NAME,
<a name="l02076"></a>02076     .host_param_mask    = ISCSI_HOST_HWADDRESS | ISCSI_HOST_NETDEV_NAME,
<a name="l02077"></a>02077     .create_session     = bnx2i_session_create,
<a name="l02078"></a>02078     .destroy_session    = bnx2i_session_destroy,
<a name="l02079"></a>02079     .create_conn        = bnx2i_conn_create,
<a name="l02080"></a>02080     .bind_conn      = bnx2i_conn_bind,
<a name="l02081"></a>02081     .destroy_conn       = bnx2i_conn_destroy,
<a name="l02082"></a>02082     .set_param      = iscsi_set_param,
<a name="l02083"></a>02083     .get_conn_param     = bnx2i_conn_get_param,
<a name="l02084"></a>02084     .get_session_param  = iscsi_session_get_param,
<a name="l02085"></a>02085     .get_host_param     = bnx2i_host_get_param,
<a name="l02086"></a>02086     .start_conn     = bnx2i_conn_start,
<a name="l02087"></a>02087     .stop_conn      = iscsi_conn_stop,
<a name="l02088"></a>02088     .send_pdu       = iscsi_conn_send_pdu,
<a name="l02089"></a>02089     .xmit_task      = bnx2i_task_xmit,
<a name="l02090"></a>02090     .get_stats      = bnx2i_conn_get_stats,
<a name="l02091"></a>02091     <span class="comment">/* TCP connect - disconnect - option-2 interface calls */</span>
<a name="l02092"></a>02092     .ep_connect     = bnx2i_ep_connect,
<a name="l02093"></a>02093     .ep_poll        = bnx2i_ep_poll,
<a name="l02094"></a>02094     .ep_disconnect      = bnx2i_ep_disconnect,
<a name="l02095"></a>02095     <span class="comment">/* Error recovery timeout call */</span>
<a name="l02096"></a>02096     .session_recovery_timedout = iscsi_session_recovery_timedout,
<a name="l02097"></a>02097     .cleanup_task       = bnx2i_cleanup_task,
<a name="l02098"></a>02098 };
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:20 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
