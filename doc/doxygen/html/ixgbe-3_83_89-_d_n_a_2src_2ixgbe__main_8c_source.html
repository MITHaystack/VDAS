<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/ixgbe/ixgbe-3.3.9-DNA/src/ixgbe_main.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_aa6459e1e92664bab04094557f6624be.html">ixgbe</a>      </li>
      <li class="navelem"><a class="el" href="dir_3b56ec236485f9dee0c084116c4cc016.html">ixgbe-3.3.9-DNA</a>      </li>
      <li class="navelem"><a class="el" href="dir_ecb77d0badc0ebf1a0c30c7262560bf3.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ixgbe_main.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Intel 10 Gigabit PCI Express Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">   Copyright(c) 1999 - 2010 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">   under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">   version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">   This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">   more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">   this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">   51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">   The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">   Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">   e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00024"></a>00024 <span class="comment">   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment"> *******************************************************************************/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029  <span class="comment">/******************************************************************************</span>
<a name="l00030"></a>00030 <span class="comment">  Copyright (c)2006 - 2007 Myricom, Inc. for some LRO specific code</span>
<a name="l00031"></a>00031 <span class="comment"> ******************************************************************************/</span>
<a name="l00032"></a>00032 <span class="preprocessor"> #include &lt;linux/types.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor"> #include &lt;linux/module.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor"> #include &lt;linux/pci.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor"> #include &lt;linux/netdevice.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor"> #include &lt;linux/vmalloc.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor"> #include &lt;linux/string.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor"> #include &lt;linux/in.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor"> #include &lt;linux/ip.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor"> #include &lt;linux/tcp.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor"> #ifdef HAVE_SCTP</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor"> #include &lt;linux/sctp.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor"> #endif</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor"> #include &lt;linux/pkt_sched.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor"> #include &lt;linux/ipv6.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor"> #ifdef NETIF_F_TSO</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor"> #include &lt;net/checksum.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor"> #ifdef NETIF_F_TSO6</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor"> #include &lt;net/ip6_checksum.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor"> #endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor"> #endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor"> #ifdef SIOCETHTOOL</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor"> #include &lt;linux/ethtool.h&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor"> #endif</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>
<a name="l00056"></a>00056 <span class="preprocessor"> #include &quot;ixgbe.h&quot;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="preprocessor"> #include &quot;ixgbe_sriov.h&quot;</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060  <span class="keywordtype">char</span> ixgbe_driver_name[] = <span class="stringliteral">&quot;ixgbe&quot;</span>;
<a name="l00061"></a>00061  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> ixgbe_driver_string[] =
<a name="l00062"></a>00062                    <span class="stringliteral">&quot;Intel(R) 10 Gigabit PCI Express Network Driver&quot;</span>;
<a name="l00063"></a>00063 <span class="preprocessor"> #define DRV_HW_PERF</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>
<a name="l00065"></a>00065 <span class="preprocessor"> #ifndef CONFIG_IXGBE_NAPI</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor"> #define DRIVERNAPI</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor"> #else</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor"> #define DRIVERNAPI &quot;-NAPI&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor"> #endif</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>
<a name="l00071"></a>00071 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#undef DRIVERNAPI</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define DRIVERNAPI &quot;-DNA&quot;</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>
<a name="l00076"></a>00076 <span class="preprocessor"> #define FPGA</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor"> #define VMDQ_TAG</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080 <span class="preprocessor"> #define MAJ 3</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor"> #define MIN 3</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor"> #define BUILD 9</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor"> #define DRV_VERSION __stringify(MAJ) &quot;.&quot; __stringify(MIN) &quot;.&quot; __stringify(BUILD) DRIVERNAPI DRV_HW_PERF FPGA VMDQ_TAG</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span> <span class="keyword">const</span> <span class="keywordtype">char</span> ixgbe_driver_version[] = DRV_VERSION;
<a name="l00085"></a>00085  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> ixgbe_copyright[] =
<a name="l00086"></a>00086                  <span class="stringliteral">&quot;Copyright (c) 1999-2011 Intel Corporation.&quot;</span>;
<a name="l00087"></a>00087  <span class="comment">/* ixgbe_pci_tbl - PCI Device ID Table</span>
<a name="l00088"></a>00088 <span class="comment">  *</span>
<a name="l00089"></a>00089 <span class="comment">  * Wildcard entries (PCI_ANY_ID) should come last</span>
<a name="l00090"></a>00090 <span class="comment">  * Last entry must be all 0s</span>
<a name="l00091"></a>00091 <span class="comment">  *</span>
<a name="l00092"></a>00092 <span class="comment">  * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,</span>
<a name="l00093"></a>00093 <span class="comment">  *   Class, Class Mask, private data (not used) }</span>
<a name="l00094"></a>00094 <span class="comment">  */</span>
<a name="l00095"></a>00095  <span class="keyword">static</span> <span class="keyword">struct </span>pci_device_id ixgbe_pci_tbl[] = {
<a name="l00096"></a>00096      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598)},
<a name="l00097"></a>00097      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_BX)},
<a name="l00098"></a>00098      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AF_DUAL_PORT)},
<a name="l00099"></a>00099      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AF_SINGLE_PORT)},
<a name="l00100"></a>00100      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AT)},
<a name="l00101"></a>00101      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AT2)},
<a name="l00102"></a>00102      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598EB_CX4)},
<a name="l00103"></a>00103      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_CX4_DUAL_PORT)},
<a name="l00104"></a>00104      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_DA_DUAL_PORT)},
<a name="l00105"></a>00105      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM)},
<a name="l00106"></a>00106      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598EB_XF_LR)},
<a name="l00107"></a>00107      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598EB_SFP_LOM)},
<a name="l00108"></a>00108      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_KX4)},
<a name="l00109"></a>00109      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_XAUI_LOM)},
<a name="l00110"></a>00110      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_KR)},
<a name="l00111"></a>00111      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_SFP)},
<a name="l00112"></a>00112      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_SFP_EM)},
<a name="l00113"></a>00113      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_KX4_MEZZ)},
<a name="l00114"></a>00114      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_T3_LOM)},
<a name="l00115"></a>00115      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_CX4)},
<a name="l00116"></a>00116      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_BACKPLANE_FCOE)},
<a name="l00117"></a>00117      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_SFP_FCOE)},
<a name="l00118"></a>00118      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_COMBO_BACKPLANE)},
<a name="l00119"></a>00119      {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_X540T)},
<a name="l00120"></a>00120      <span class="comment">/* required last entry */</span>
<a name="l00121"></a>00121      {0, }
<a name="l00122"></a>00122  };
<a name="l00123"></a>00123  MODULE_DEVICE_TABLE(pci, ixgbe_pci_tbl);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="preprocessor"> #if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span> <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_notify_dca(<span class="keyword">struct</span> notifier_block *, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l00127"></a>00127                  <span class="keywordtype">void</span> *p);
<a name="l00128"></a>00128  <span class="keyword">static</span> <span class="keyword">struct </span>notifier_block dca_notifier = {
<a name="l00129"></a>00129      .notifier_call = ixgbe_notify_dca,
<a name="l00130"></a>00130      .next          = NULL,
<a name="l00131"></a>00131      .priority      = 0
<a name="l00132"></a>00132  };
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="preprocessor"> #endif</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span> MODULE_AUTHOR(<span class="stringliteral">&quot;Intel Corporation, &lt;linux.nics@intel.com&gt;&quot;</span>);
<a name="l00136"></a>00136  MODULE_DESCRIPTION(<span class="stringliteral">&quot;Intel(R) 10 Gigabit PCI Express Network Driver&quot;</span>);
<a name="l00137"></a>00137  MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);
<a name="l00138"></a>00138  MODULE_VERSION(DRV_VERSION);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="preprocessor"> #define DEFAULT_DEBUG_LEVEL_SHIFT 3</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>
<a name="l00142"></a>00142 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span><span class="preprocessor">#include &quot;ixgbe_dna.c&quot;</span>
<a name="l00144"></a>00144 <span class="preprocessor">#endif</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_disable_sriov(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00148"></a>00148  {
<a name="l00149"></a>00149      <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00150"></a>00150      u32 gcr;
<a name="l00151"></a>00151      u32 gpie;
<a name="l00152"></a>00152      u32 vmdctl;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="preprocessor"> #ifdef CONFIG_PCI_IOV</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span>     <span class="comment">/* disable iov and allow time for transactions to clear */</span>
<a name="l00156"></a>00156      pci_disable_sriov(adapter-&gt;pdev);
<a name="l00157"></a>00157 <span class="preprocessor"> #endif</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>
<a name="l00159"></a>00159      <span class="comment">/* turn off device IOV mode */</span>
<a name="l00160"></a>00160      gcr = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);
<a name="l00161"></a>00161      gcr &amp;= ~(IXGBE_GCR_EXT_SRIOV);
<a name="l00162"></a>00162      IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr);
<a name="l00163"></a>00163      gpie = IXGBE_READ_REG(hw, IXGBE_GPIE);
<a name="l00164"></a>00164      gpie &amp;= ~IXGBE_GPIE_VTMODE_MASK;
<a name="l00165"></a>00165      IXGBE_WRITE_REG(hw, IXGBE_GPIE, gpie);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167      <span class="comment">/* set default pool back to 0 */</span>
<a name="l00168"></a>00168      vmdctl = IXGBE_READ_REG(hw, IXGBE_VT_CTL);
<a name="l00169"></a>00169      vmdctl &amp;= ~IXGBE_VT_CTL_POOL_MASK;
<a name="l00170"></a>00170      IXGBE_WRITE_REG(hw, IXGBE_VT_CTL, vmdctl);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172      <span class="comment">/* take a breather then clean up driver data */</span>
<a name="l00173"></a>00173      msleep(100);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175      kfree(adapter-&gt;vfinfo);
<a name="l00176"></a>00176      adapter-&gt;vfinfo = NULL;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178      adapter-&gt;num_vfs = 0;
<a name="l00179"></a>00179      adapter-&gt;flags &amp;= ~IXGBE_FLAG_SRIOV_ENABLED;
<a name="l00180"></a>00180  }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_event_schedule(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00183"></a>00183  {
<a name="l00184"></a>00184      <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) &amp;&amp;
<a name="l00185"></a>00185          !test_and_set_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state))
<a name="l00186"></a>00186          schedule_work(&amp;adapter-&gt;service_task);
<a name="l00187"></a>00187  }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_event_complete(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00190"></a>00190  {
<a name="l00191"></a>00191      BUG_ON(!test_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state));
<a name="l00192"></a>00192 
<a name="l00193"></a>00193      <span class="comment">/* flush memory to make sure state is correct before next watchog */</span>
<a name="l00194"></a>00194      smp_mb__before_clear_bit();
<a name="l00195"></a>00195      clear_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state);
<a name="l00196"></a>00196  }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_release_hw_control(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00199"></a>00199  {
<a name="l00200"></a>00200      u32 ctrl_ext;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202      <span class="comment">/* Let firmware take over control of h/w */</span>
<a name="l00203"></a>00203      ctrl_ext = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT);
<a name="l00204"></a>00204      IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT,
<a name="l00205"></a>00205              ctrl_ext &amp; ~IXGBE_CTRL_EXT_DRV_LOAD);
<a name="l00206"></a>00206  }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_hw_control(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00209"></a>00209  {
<a name="l00210"></a>00210      u32 ctrl_ext;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212      <span class="comment">/* Let firmware know the driver has taken over */</span>
<a name="l00213"></a>00213      ctrl_ext = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT);
<a name="l00214"></a>00214      IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT,
<a name="l00215"></a>00215              ctrl_ext | IXGBE_CTRL_EXT_DRV_LOAD);
<a name="l00216"></a>00216  }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218  <span class="comment">/*</span>
<a name="l00219"></a>00219 <span class="comment">  * ixgbe_set_ivar - set the IVAR registers, mapping interrupt causes to vectors</span>
<a name="l00220"></a>00220 <span class="comment">  * @adapter: pointer to adapter struct</span>
<a name="l00221"></a>00221 <span class="comment">  * @direction: 0 for Rx, 1 for Tx, -1 for other causes</span>
<a name="l00222"></a>00222 <span class="comment">  * @queue: queue to map the corresponding interrupt to</span>
<a name="l00223"></a>00223 <span class="comment">  * @msix_vector: the vector to map to the corresponding queue</span>
<a name="l00224"></a>00224 <span class="comment">  *</span>
<a name="l00225"></a>00225 <span class="comment">  */</span>
<a name="l00226"></a>00226  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_ivar(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, s8 direction,
<a name="l00227"></a>00227                 u8 queue, u8 msix_vector)
<a name="l00228"></a>00228  {
<a name="l00229"></a>00229      u32 ivar, index;
<a name="l00230"></a>00230      <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00231"></a>00231      <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00232"></a>00232      <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00233"></a>00233          msix_vector |= IXGBE_IVAR_ALLOC_VAL;
<a name="l00234"></a>00234          <span class="keywordflow">if</span> (direction == -1)
<a name="l00235"></a>00235              direction = 0;
<a name="l00236"></a>00236          index = (((direction * 64) + queue) &gt;&gt; 2) &amp; 0x1F;
<a name="l00237"></a>00237          ivar = IXGBE_READ_REG(hw, IXGBE_IVAR(index));
<a name="l00238"></a>00238          ivar &amp;= ~(0xFF &lt;&lt; (8 * (queue &amp; 0x3)));
<a name="l00239"></a>00239          ivar |= (msix_vector &lt;&lt; (8 * (queue &amp; 0x3)));
<a name="l00240"></a>00240          IXGBE_WRITE_REG(hw, IXGBE_IVAR(index), ivar);
<a name="l00241"></a>00241          <span class="keywordflow">break</span>;
<a name="l00242"></a>00242      <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00243"></a>00243      <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00244"></a>00244          <span class="keywordflow">if</span> (direction == -1) {
<a name="l00245"></a>00245              <span class="comment">/* other causes */</span>
<a name="l00246"></a>00246              msix_vector |= IXGBE_IVAR_ALLOC_VAL;
<a name="l00247"></a>00247              index = ((queue &amp; 1) * 8);
<a name="l00248"></a>00248              ivar = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_IVAR_MISC);
<a name="l00249"></a>00249              ivar &amp;= ~(0xFF &lt;&lt; index);
<a name="l00250"></a>00250              ivar |= (msix_vector &lt;&lt; index);
<a name="l00251"></a>00251              IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IVAR_MISC, ivar);
<a name="l00252"></a>00252              <span class="keywordflow">break</span>;
<a name="l00253"></a>00253          } <span class="keywordflow">else</span> {
<a name="l00254"></a>00254              <span class="comment">/* tx or rx causes */</span>
<a name="l00255"></a>00255              msix_vector |= IXGBE_IVAR_ALLOC_VAL;
<a name="l00256"></a>00256              index = ((16 * (queue &amp; 1)) + (8 * direction));
<a name="l00257"></a>00257              ivar = IXGBE_READ_REG(hw, IXGBE_IVAR(queue &gt;&gt; 1));
<a name="l00258"></a>00258              ivar &amp;= ~(0xFF &lt;&lt; index);
<a name="l00259"></a>00259              ivar |= (msix_vector &lt;&lt; index);
<a name="l00260"></a>00260              IXGBE_WRITE_REG(hw, IXGBE_IVAR(queue &gt;&gt; 1), ivar);
<a name="l00261"></a>00261              <span class="keywordflow">break</span>;
<a name="l00262"></a>00262          }
<a name="l00263"></a>00263      <span class="keywordflow">default</span>:
<a name="l00264"></a>00264          <span class="keywordflow">break</span>;
<a name="l00265"></a>00265      }
<a name="l00266"></a>00266  }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_irq_rearm_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l00269"></a>00269                        u64 qmask)
<a name="l00270"></a>00270  {
<a name="l00271"></a>00271      u32 mask;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273      <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l00274"></a>00274      <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00275"></a>00275          mask = (IXGBE_EIMS_RTX_QUEUE &amp; qmask);
<a name="l00276"></a>00276          IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS, mask);
<a name="l00277"></a>00277          <span class="keywordflow">break</span>;
<a name="l00278"></a>00278      <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00279"></a>00279      <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00280"></a>00280          mask = (qmask &amp; 0xFFFFFFFF);
<a name="l00281"></a>00281          IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS_EX(0), mask);
<a name="l00282"></a>00282          mask = (qmask &gt;&gt; 32);
<a name="l00283"></a>00283          IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS_EX(1), mask);
<a name="l00284"></a>00284          <span class="keywordflow">break</span>;
<a name="l00285"></a>00285      <span class="keywordflow">default</span>:
<a name="l00286"></a>00286          <span class="keywordflow">break</span>;
<a name="l00287"></a>00287      }
<a name="l00288"></a>00288  }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_unmap_tx_resource(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring,
<a name="l00291"></a>00291                         <span class="keyword">struct</span> <a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer)
<a name="l00292"></a>00292  {
<a name="l00293"></a>00293 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>   <span class="comment">// printk(&quot;[DNA] ixgbe_unmap_tx_resource()\n&quot;);</span>
<a name="l00295"></a>00295    <span class="keywordflow">return</span>;
<a name="l00296"></a>00296 <span class="preprocessor">#endif</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>     <span class="keywordflow">if</span> (tx_buffer-&gt;dma) {
<a name="l00298"></a>00298          <span class="keywordflow">if</span> (tx_buffer-&gt;tx_flags &amp; IXGBE_TX_FLAGS_MAPPED_AS_PAGE)
<a name="l00299"></a>00299              dma_unmap_page(ring-&gt;dev,
<a name="l00300"></a>00300                     tx_buffer-&gt;dma,
<a name="l00301"></a>00301                     tx_buffer-&gt;length,
<a name="l00302"></a>00302                     DMA_TO_DEVICE);
<a name="l00303"></a>00303          <span class="keywordflow">else</span>
<a name="l00304"></a>00304              dma_unmap_single(ring-&gt;dev,
<a name="l00305"></a>00305                       tx_buffer-&gt;dma,
<a name="l00306"></a>00306                       tx_buffer-&gt;length,
<a name="l00307"></a>00307                       DMA_TO_DEVICE);
<a name="l00308"></a>00308      }
<a name="l00309"></a>00309      tx_buffer-&gt;dma = 0;
<a name="l00310"></a>00310  }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312  <span class="keywordtype">void</span> ixgbe_unmap_and_free_tx_resource(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l00313"></a>00313                        <span class="keyword">struct</span> <a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info)
<a name="l00314"></a>00314  {
<a name="l00315"></a>00315 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>   <span class="comment">// printk(&quot;[DNA] ixgbe_unmap_and_free_tx_resource()\n&quot;);</span>
<a name="l00317"></a>00317    <span class="keywordflow">return</span>;
<a name="l00318"></a>00318 <span class="preprocessor">#endif</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span>
<a name="l00320"></a>00320      ixgbe_unmap_tx_resource(tx_ring, tx_buffer_info);
<a name="l00321"></a>00321      <span class="keywordflow">if</span> (tx_buffer_info-&gt;skb)
<a name="l00322"></a>00322          dev_kfree_skb_any(tx_buffer_info-&gt;skb);
<a name="l00323"></a>00323      tx_buffer_info-&gt;skb = NULL;
<a name="l00324"></a>00324      <span class="comment">/* tx_buffer_info must be completely set up in the transmit path */</span>
<a name="l00325"></a>00325  }
<a name="l00326"></a>00326 
<a name="l00337"></a>00337  u8 ixgbe_dcb_txq_to_tc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u8 reg_idx)
<a name="l00338"></a>00338  {
<a name="l00339"></a>00339      <span class="keywordtype">int</span> tc = -1;
<a name="l00340"></a>00340      <span class="keywordtype">int</span> dcb_i = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342      <span class="comment">/* if DCB is not enabled the queues have no TC */</span>
<a name="l00343"></a>00343      <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l00344"></a>00344          <span class="keywordflow">return</span> tc;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346      <span class="comment">/* check valid range */</span>
<a name="l00347"></a>00347      <span class="keywordflow">if</span> (reg_idx &gt;= adapter-&gt;hw.mac.max_tx_queues)
<a name="l00348"></a>00348          <span class="keywordflow">return</span> tc;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350      <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l00351"></a>00351      <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00352"></a>00352          tc = reg_idx &gt;&gt; 2;
<a name="l00353"></a>00353          <span class="keywordflow">break</span>;
<a name="l00354"></a>00354      <span class="keywordflow">default</span>:
<a name="l00355"></a>00355          <span class="keywordflow">if</span> (dcb_i != 4 &amp;&amp; dcb_i != 8)
<a name="l00356"></a>00356              <span class="keywordflow">break</span>;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358          <span class="comment">/* if VMDq is enabled the lowest order bits determine TC */</span>
<a name="l00359"></a>00359          <span class="keywordflow">if</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_SRIOV_ENABLED |
<a name="l00360"></a>00360                        IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l00361"></a>00361              tc = reg_idx &amp; (dcb_i - 1);
<a name="l00362"></a>00362              <span class="keywordflow">break</span>;
<a name="l00363"></a>00363          }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365          <span class="comment">/*</span>
<a name="l00366"></a>00366 <span class="comment">          * Convert the reg_idx into the correct TC. This bitmask</span>
<a name="l00367"></a>00367 <span class="comment">          * targets the last full 32 ring traffic class and assigns</span>
<a name="l00368"></a>00368 <span class="comment">          * it a value of 1. From there the rest of the rings are</span>
<a name="l00369"></a>00369 <span class="comment">          * based on shifting the mask further up to include the</span>
<a name="l00370"></a>00370 <span class="comment">          * reg_idx / 16 and then reg_idx / 8. It assumes dcB_i</span>
<a name="l00371"></a>00371 <span class="comment">          * will only ever be 8 or 4 and that reg_idx will never</span>
<a name="l00372"></a>00372 <span class="comment">          * be greater then 128. The code without the power of 2</span>
<a name="l00373"></a>00373 <span class="comment">          * optimizations would be:</span>
<a name="l00374"></a>00374 <span class="comment">          * (((reg_idx % 32) + 32) * dcb_i) &gt;&gt; (9 - reg_idx / 32)</span>
<a name="l00375"></a>00375 <span class="comment">          */</span>
<a name="l00376"></a>00376          tc = ((reg_idx &amp; 0X1F) + 0x20) * dcb_i;
<a name="l00377"></a>00377          tc &gt;&gt;= 9 - (reg_idx &gt;&gt; 5);
<a name="l00378"></a>00378      }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380      <span class="keywordflow">return</span> tc;
<a name="l00381"></a>00381  }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_xoff_received(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00384"></a>00384  {
<a name="l00385"></a>00385      <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00386"></a>00386      <span class="keyword">struct </span><a class="code" href="structixgbe__hw__stats.html">ixgbe_hw_stats</a> *hwstats = &amp;adapter-&gt;stats;
<a name="l00387"></a>00387      u32 data = 0;
<a name="l00388"></a>00388      u32 xoff[8] = {0};
<a name="l00389"></a>00389      <span class="keywordtype">int</span> i;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391      <span class="keywordflow">if</span> ((hw-&gt;fc.current_mode == ixgbe_fc_full) ||
<a name="l00392"></a>00392          (hw-&gt;fc.current_mode == ixgbe_fc_rx_pause)) {
<a name="l00393"></a>00393          <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00394"></a>00394          <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00395"></a>00395              data = IXGBE_READ_REG(hw, IXGBE_LXOFFRXC);
<a name="l00396"></a>00396              <span class="keywordflow">break</span>;
<a name="l00397"></a>00397          <span class="keywordflow">default</span>:
<a name="l00398"></a>00398              data = IXGBE_READ_REG(hw, IXGBE_LXOFFRXCNT);
<a name="l00399"></a>00399          }
<a name="l00400"></a>00400          hwstats-&gt;lxoffrxc += data;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402          <span class="comment">/* refill credits (no tx hang) if we received xoff */</span>
<a name="l00403"></a>00403          <span class="keywordflow">if</span> (!data)
<a name="l00404"></a>00404              <span class="keywordflow">return</span>;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406          <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l00407"></a>00407              clear_bit(__IXGBE_HANG_CHECK_ARMED,
<a name="l00408"></a>00408                    &amp;adapter-&gt;tx_ring[i]-&gt;state);
<a name="l00409"></a>00409          <span class="keywordflow">return</span>;
<a name="l00410"></a>00410      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(adapter-&gt;dcb_cfg.pfc_mode_enable)) {
<a name="l00411"></a>00411         <span class="keywordflow">return</span>;
<a name="l00412"></a>00412      }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414      <span class="comment">/* update stats for each tc, only valid with PFC enabled */</span>
<a name="l00415"></a>00415      <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TX_PACKET_BUFFERS; i++) {
<a name="l00416"></a>00416          <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00417"></a>00417          <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00418"></a>00418              xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));
<a name="l00419"></a>00419              <span class="keywordflow">break</span>;
<a name="l00420"></a>00420          <span class="keywordflow">default</span>:
<a name="l00421"></a>00421              xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(i));
<a name="l00422"></a>00422          }
<a name="l00423"></a>00423          hwstats-&gt;pxoffrxc[i] += xoff[i];
<a name="l00424"></a>00424      }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426      <span class="comment">/* disarm tx queues that have received xoff frames */</span>
<a name="l00427"></a>00427      <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l00428"></a>00428          <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l00429"></a>00429          u8 tc = ixgbe_dcb_txq_to_tc(adapter, tx_ring-&gt;reg_idx);
<a name="l00430"></a>00430          <span class="keywordflow">if</span> ((tc &lt;= 7) &amp;&amp; (xoff[tc]))
<a name="l00431"></a>00431              clear_bit(__IXGBE_HANG_CHECK_ARMED, &amp;tx_ring-&gt;state);
<a name="l00432"></a>00432      }
<a name="l00433"></a>00433  }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435  <span class="keyword">static</span> u64 ixgbe_get_tx_completed(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l00436"></a>00436  {
<a name="l00437"></a>00437      <span class="keywordflow">return</span> ring-&gt;tx_stats.completed;
<a name="l00438"></a>00438  }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440  <span class="keyword">static</span> u64 ixgbe_get_tx_pending(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l00441"></a>00441  {
<a name="l00442"></a>00442      <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = ring-&gt;q_vector-&gt;adapter;
<a name="l00443"></a>00443      <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445      u32 head = IXGBE_READ_REG(hw, IXGBE_TDH(ring-&gt;reg_idx));
<a name="l00446"></a>00446      u32 tail = IXGBE_READ_REG(hw, IXGBE_TDT(ring-&gt;reg_idx));
<a name="l00447"></a>00447 
<a name="l00448"></a>00448      <span class="keywordflow">if</span> (head != tail)
<a name="l00449"></a>00449          <span class="keywordflow">return</span> (head &lt; tail) ? tail - head : (tail + ring-&gt;count - head);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451      <span class="keywordflow">return</span> 0;
<a name="l00452"></a>00452  }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454  <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_check_tx_hang(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l00455"></a>00455  {
<a name="l00456"></a>00456      u32 tx_done = ixgbe_get_tx_completed(tx_ring);
<a name="l00457"></a>00457      u32 tx_done_old = tx_ring-&gt;tx_stats.tx_done_old;
<a name="l00458"></a>00458      u32 tx_pending = ixgbe_get_tx_pending(tx_ring);
<a name="l00459"></a>00459      <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461      clear_check_for_tx_hang(tx_ring);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463      <span class="comment">/*</span>
<a name="l00464"></a>00464 <span class="comment">      * Check for a hung queue, but be thorough. This verifies</span>
<a name="l00465"></a>00465 <span class="comment">      * that a transmit has been completed since the previous</span>
<a name="l00466"></a>00466 <span class="comment">      * check AND there is at least one packet pending. The</span>
<a name="l00467"></a>00467 <span class="comment">      * ARMED bit is set to indicate a potential hang. The</span>
<a name="l00468"></a>00468 <span class="comment">      * bit is cleared if a pause frame is received to remove</span>
<a name="l00469"></a>00469 <span class="comment">      * false hang detection due to PFC or 802.3x frames. By</span>
<a name="l00470"></a>00470 <span class="comment">      * requiring this to fail twice we avoid races with</span>
<a name="l00471"></a>00471 <span class="comment">      * PFC clearing the ARMED bit and conditions where we</span>
<a name="l00472"></a>00472 <span class="comment">      * run the check_tx_hang logic with a transmit completion</span>
<a name="l00473"></a>00473 <span class="comment">      * pending but without time to complete it yet.</span>
<a name="l00474"></a>00474 <span class="comment">      */</span>
<a name="l00475"></a>00475      <span class="keywordflow">if</span> ((tx_done_old == tx_done) &amp;&amp; tx_pending) {
<a name="l00476"></a>00476          <span class="comment">/* make sure it is true for two checks in a row */</span>
<a name="l00477"></a>00477          ret = test_and_set_bit(__IXGBE_HANG_CHECK_ARMED,
<a name="l00478"></a>00478                     &amp;tx_ring-&gt;state);
<a name="l00479"></a>00479      } <span class="keywordflow">else</span> {
<a name="l00480"></a>00480          <span class="comment">/* update completed stats and continue */</span>
<a name="l00481"></a>00481          tx_ring-&gt;tx_stats.tx_done_old = tx_done;
<a name="l00482"></a>00482          <span class="comment">/* reset the countdown */</span>
<a name="l00483"></a>00483          clear_bit(__IXGBE_HANG_CHECK_ARMED, &amp;tx_ring-&gt;state);
<a name="l00484"></a>00484      }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486      <span class="keywordflow">return</span> ret;
<a name="l00487"></a>00487  }
<a name="l00488"></a>00488 
<a name="l00493"></a>00493  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_tx_timeout_reset(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00494"></a>00494  {
<a name="l00495"></a>00495 
<a name="l00496"></a>00496      <span class="comment">/* Do the reset outside of interrupt context */</span>
<a name="l00497"></a>00497      <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l00498"></a>00498          adapter-&gt;flags2 |= IXGBE_FLAG2_RESET_REQUESTED;
<a name="l00499"></a>00499          ixgbe_service_event_schedule(adapter);
<a name="l00500"></a>00500      }
<a name="l00501"></a>00501  }
<a name="l00502"></a>00502 
<a name="l00507"></a>00507  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_tx_timeout(<span class="keyword">struct</span> net_device *netdev)
<a name="l00508"></a>00508  {
<a name="l00509"></a>00509  <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00510"></a>00510      <span class="keywordtype">bool</span> real_tx_hang = <span class="keyword">false</span>;
<a name="l00511"></a>00511      <span class="keywordtype">int</span> i;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="preprocessor"> #define TX_TIMEO_LIMIT 16000</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span>     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l00515"></a>00515          <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l00516"></a>00516      <span class="keywordflow">if</span> (check_for_tx_hang(tx_ring) &amp;&amp; ixgbe_check_tx_hang(tx_ring))
<a name="l00517"></a>00517          real_tx_hang = <span class="keyword">true</span>;
<a name="l00518"></a>00518      }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520      <span class="keywordflow">if</span> (real_tx_hang){
<a name="l00521"></a>00521          ixgbe_tx_timeout_reset(adapter);
<a name="l00522"></a>00522      } <span class="keywordflow">else</span> {
<a name="l00523"></a>00523          e_info(drv, <span class="stringliteral">&quot;Fake Tx hang detected with timeout of %d &quot;</span>
<a name="l00524"></a>00524              <span class="stringliteral">&quot;seconds\n&quot;</span>, netdev-&gt;watchdog_timeo/HZ);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526          <span class="comment">/* fake Tx hang - increase the kernel timeout */</span>
<a name="l00527"></a>00527          <span class="keywordflow">if</span> (netdev-&gt;watchdog_timeo &lt; TX_TIMEO_LIMIT)
<a name="l00528"></a>00528              netdev-&gt;watchdog_timeo *= 2;
<a name="l00529"></a>00529      }
<a name="l00530"></a>00530  }
<a name="l00531"></a>00531 
<a name="l00537"></a>00537  <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_clean_tx_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l00538"></a>00538                    <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l00539"></a>00539                    <span class="keywordtype">int</span> budget)
<a name="l00540"></a>00540  {
<a name="l00541"></a>00541      <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer;
<a name="l00542"></a>00542      <span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a> *tx_desc;
<a name="l00543"></a>00543      <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>  *adapter = q_vector-&gt;adapter;
<a name="l00544"></a>00544      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_bytes = 0, total_packets = 0;
<a name="l00545"></a>00545      u16 i = tx_ring-&gt;next_to_clean;
<a name="l00546"></a>00546 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span>     <span class="comment">// printk(&quot;[DNA] ixgbe_unmap_tx_resource()\n&quot;);</span>
<a name="l00548"></a>00548      <span class="keywordflow">return</span>(budget);
<a name="l00549"></a>00549 <span class="preprocessor">#endif</span>
<a name="l00550"></a>00550 <span class="preprocessor"></span>
<a name="l00551"></a>00551      <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l00552"></a>00552          <span class="keywordflow">return</span> budget;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554      tx_buffer = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l00555"></a>00555      tx_desc = IXGBE_TX_DESC_ADV(tx_ring, i);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557      <span class="keywordflow">for</span> (; budget; budget--) {
<a name="l00558"></a>00558          <span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a> *eop_desc = tx_buffer-&gt;next_to_watch;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560          eop_desc = tx_buffer-&gt;next_to_watch = tx_desc;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562          <span class="comment">/* if next_to_watch is not set then there is no work pending */</span>
<a name="l00563"></a>00563          <span class="keywordflow">if</span> (!eop_desc)
<a name="l00564"></a>00564              <span class="keywordflow">break</span>;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566          <span class="comment">/* if DD is not set pending work has not been completed */</span>
<a name="l00567"></a>00567          <span class="keywordflow">if</span> (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(IXGBE_TXD_STAT_DD)))
<a name="l00568"></a>00568              <span class="keywordflow">break</span>;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570          <span class="comment">/* count the packet as being completed */</span>
<a name="l00571"></a>00571          tx_ring-&gt;tx_stats.completed++;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573          <span class="comment">/* clear next_to_watch to prevent false hangs */</span>
<a name="l00574"></a>00574          tx_buffer-&gt;next_to_watch = NULL;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576          <span class="comment">/* prevent any other reads prior to eop_desc being verified */</span>
<a name="l00577"></a>00577          rmb();
<a name="l00578"></a>00578 
<a name="l00579"></a>00579          <span class="keywordflow">do</span> {
<a name="l00580"></a>00580              ixgbe_unmap_tx_resource(tx_ring, tx_buffer);
<a name="l00581"></a>00581              tx_desc-&gt;wb.status = 0;
<a name="l00582"></a>00582 
<a name="l00583"></a>00583              <span class="keywordflow">if</span> (likely(tx_desc == eop_desc)) {
<a name="l00584"></a>00584                  eop_desc = NULL;
<a name="l00585"></a>00585                  dev_kfree_skb_any(tx_buffer-&gt;skb);
<a name="l00586"></a>00586                  tx_buffer-&gt;skb = NULL;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588                  total_bytes += tx_buffer-&gt;bytecount;
<a name="l00589"></a>00589                  total_packets += tx_buffer-&gt;gso_segs;
<a name="l00590"></a>00590              }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592              tx_buffer++;
<a name="l00593"></a>00593              tx_desc++;
<a name="l00594"></a>00594              i++;
<a name="l00595"></a>00595              <span class="keywordflow">if</span> (unlikely(i == tx_ring-&gt;count)) {
<a name="l00596"></a>00596                  i = 0;
<a name="l00597"></a>00597                  tx_buffer = tx_ring-&gt;tx_buffer_info;
<a name="l00598"></a>00598                  tx_desc = IXGBE_TX_DESC_ADV(tx_ring, 0);
<a name="l00599"></a>00599              }
<a name="l00600"></a>00600          } <span class="keywordflow">while</span> (eop_desc);
<a name="l00601"></a>00601      }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603      tx_ring-&gt;next_to_clean = i;
<a name="l00604"></a>00604      tx_ring-&gt;stats.bytes += total_bytes;
<a name="l00605"></a>00605      tx_ring-&gt;stats.packets += total_packets;
<a name="l00606"></a>00606      q_vector-&gt;tx.total_bytes += total_bytes;
<a name="l00607"></a>00607      q_vector-&gt;tx.total_packets += total_packets;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609      <span class="keywordflow">if</span> (check_for_tx_hang(tx_ring) &amp;&amp; ixgbe_check_tx_hang(tx_ring)) {
<a name="l00610"></a>00610          <span class="comment">/* schedule immediate reset if we believe we hung */</span>
<a name="l00611"></a>00611          <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00612"></a>00612          u32 head = IXGBE_READ_REG(hw, IXGBE_TDH(tx_ring-&gt;reg_idx));
<a name="l00613"></a>00613          u32 tail = IXGBE_READ_REG(hw, IXGBE_TDT(tx_ring-&gt;reg_idx));
<a name="l00614"></a>00614          u16 i = tx_ring-&gt;next_to_clean;
<a name="l00615"></a>00615          e_err(drv, <span class="stringliteral">&quot;Detected Tx Unit Hang\n&quot;</span>
<a name="l00616"></a>00616              <span class="stringliteral">&quot;  Tx Queue             &lt;%d&gt;\n&quot;</span>
<a name="l00617"></a>00617              <span class="stringliteral">&quot;  TDH, TDT             &lt;%x&gt;, &lt;%x&gt;\n&quot;</span>
<a name="l00618"></a>00618              <span class="stringliteral">&quot;  next_to_use          &lt;%x&gt;\n&quot;</span>
<a name="l00619"></a>00619              <span class="stringliteral">&quot;  next_to_clean        &lt;%x&gt;\n&quot;</span>,
<a name="l00620"></a>00620              tx_ring-&gt;queue_index, head, tail,
<a name="l00621"></a>00621              tx_ring-&gt;next_to_use, i);
<a name="l00622"></a>00622          e_err(drv, <span class="stringliteral">&quot;tx_buffer_info[next_to_clean]\n&quot;</span>
<a name="l00623"></a>00623              <span class="stringliteral">&quot;  time_stamp           &lt;%lx&gt;\n&quot;</span>
<a name="l00624"></a>00624              <span class="stringliteral">&quot;  jiffies              &lt;%lx&gt;\n&quot;</span>,
<a name="l00625"></a>00625              tx_ring-&gt;tx_buffer_info[i].time_stamp, jiffies);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627          netif_stop_subqueue(netdev_ring(tx_ring), ring_queue_index(tx_ring));
<a name="l00628"></a>00628 
<a name="l00629"></a>00629          e_info(probe,
<a name="l00630"></a>00630             <span class="stringliteral">&quot;tx hang %d detected on queue %d, resetting adapter\n&quot;</span>,
<a name="l00631"></a>00631             adapter-&gt;tx_timeout_count + 1, tx_ring-&gt;queue_index);
<a name="l00632"></a>00632 
<a name="l00633"></a>00633          ixgbe_tx_timeout_reset(adapter);
<a name="l00634"></a>00634 
<a name="l00635"></a>00635          <span class="comment">/* the adapter is about to reset, no point in enabling stuff */</span>
<a name="l00636"></a>00636          <span class="keywordflow">return</span> budget;
<a name="l00637"></a>00637      }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 <span class="preprocessor"> #define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span>     <span class="keywordflow">if</span> (unlikely(total_packets &amp;&amp; netif_carrier_ok(netdev_ring(tx_ring)) &amp;&amp;
<a name="l00641"></a>00641               (ixgbe_desc_unused(tx_ring) &gt;= TX_WAKE_THRESHOLD))) {
<a name="l00642"></a>00642          <span class="comment">/* Make sure that anybody stopping the queue after this</span>
<a name="l00643"></a>00643 <span class="comment">          * sees the new next_to_clean.</span>
<a name="l00644"></a>00644 <span class="comment">          */</span>
<a name="l00645"></a>00645          smp_mb();
<a name="l00646"></a>00646 <span class="preprocessor"> #ifdef HAVE_TX_MQ</span>
<a name="l00647"></a>00647 <span class="preprocessor"></span>         <span class="keywordflow">if</span> (__netif_subqueue_stopped(netdev_ring(tx_ring), ring_queue_index(tx_ring))
<a name="l00648"></a>00648              &amp;&amp; !test_bit(__IXGBE_DOWN, &amp;q_vector-&gt;adapter-&gt;state)) {
<a name="l00649"></a>00649              netif_wake_subqueue(netdev_ring(tx_ring), ring_queue_index(tx_ring));
<a name="l00650"></a>00650              ++tx_ring-&gt;tx_stats.restart_queue;
<a name="l00651"></a>00651          }
<a name="l00652"></a>00652 <span class="preprocessor"> #else</span>
<a name="l00653"></a>00653 <span class="preprocessor"></span>         <span class="keywordflow">if</span> (netif_queue_stopped(netdev_ring(tx_ring)) &amp;&amp;
<a name="l00654"></a>00654              !test_bit(__IXGBE_DOWN, &amp;q_vector-&gt;adapter-&gt;state)) {
<a name="l00655"></a>00655              netif_wake_queue(netdev_ring(tx_ring));
<a name="l00656"></a>00656              ++tx_ring-&gt;tx_stats.restart_queue;
<a name="l00657"></a>00657          }
<a name="l00658"></a>00658 <span class="preprocessor"> #endif</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span>     }
<a name="l00660"></a>00660      <span class="keywordflow">return</span> budget;
<a name="l00661"></a>00661  }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_rx_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l00664"></a>00664                  <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l00665"></a>00665                  <span class="keywordtype">int</span> cpu)
<a name="l00666"></a>00666  {
<a name="l00667"></a>00667      <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00668"></a>00668      u32 rxctrl;
<a name="l00669"></a>00669      u8 reg_idx = rx_ring-&gt;reg_idx;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671      rxctrl = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(reg_idx));
<a name="l00672"></a>00672      <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00673"></a>00673      <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00674"></a>00674          rxctrl &amp;= ~IXGBE_DCA_RXCTRL_CPUID_MASK;
<a name="l00675"></a>00675          rxctrl |= dca3_get_tag(rx_ring-&gt;dev, cpu);
<a name="l00676"></a>00676          <span class="keywordflow">break</span>;
<a name="l00677"></a>00677      <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00678"></a>00678      <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00679"></a>00679          rxctrl &amp;= ~IXGBE_DCA_RXCTRL_CPUID_MASK_82599;
<a name="l00680"></a>00680          rxctrl |= (dca3_get_tag(rx_ring-&gt;dev, cpu) &lt;&lt;
<a name="l00681"></a>00681                 IXGBE_DCA_RXCTRL_CPUID_SHIFT_82599);
<a name="l00682"></a>00682          <span class="keywordflow">break</span>;
<a name="l00683"></a>00683      <span class="keywordflow">default</span>:
<a name="l00684"></a>00684          <span class="keywordflow">break</span>;
<a name="l00685"></a>00685      }
<a name="l00686"></a>00686      rxctrl |= IXGBE_DCA_RXCTRL_DESC_DCA_EN;
<a name="l00687"></a>00687      rxctrl |= IXGBE_DCA_RXCTRL_HEAD_DCA_EN;
<a name="l00688"></a>00688      <span class="comment">/* just do the header data when in Packet Split mode */</span>
<a name="l00689"></a>00689      <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED_DATA) ||
<a name="l00690"></a>00690          ring_is_ps_enabled(rx_ring))
<a name="l00691"></a>00691          rxctrl &amp;= ~IXGBE_DCA_RXCTRL_DATA_DCA_EN;
<a name="l00692"></a>00692      <span class="keywordflow">else</span>
<a name="l00693"></a>00693          rxctrl |= IXGBE_DCA_RXCTRL_DATA_DCA_EN;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695      rxctrl &amp;= ~(IXGBE_DCA_RXCTRL_DESC_RRO_EN);
<a name="l00696"></a>00696      rxctrl &amp;= ~(IXGBE_DCA_RXCTRL_DESC_WRO_EN |
<a name="l00697"></a>00697              IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
<a name="l00698"></a>00698      IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(reg_idx), rxctrl);
<a name="l00699"></a>00699  }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701  <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_tx_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l00702"></a>00702                  <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l00703"></a>00703                  <span class="keywordtype">int</span> cpu)
<a name="l00704"></a>00704  {
<a name="l00705"></a>00705      <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00706"></a>00706      u32 txctrl;
<a name="l00707"></a>00707      u8 reg_idx = tx_ring-&gt;reg_idx;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709      <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00710"></a>00710      <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00711"></a>00711          txctrl = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(reg_idx));
<a name="l00712"></a>00712          txctrl &amp;= ~IXGBE_DCA_TXCTRL_CPUID_MASK;
<a name="l00713"></a>00713          txctrl |= dca3_get_tag(tx_ring-&gt;dev, cpu);
<a name="l00714"></a>00714          txctrl |= IXGBE_DCA_TXCTRL_DESC_DCA_EN;
<a name="l00715"></a>00715          txctrl &amp;= ~IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
<a name="l00716"></a>00716          IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL(reg_idx), txctrl);
<a name="l00717"></a>00717          <span class="keywordflow">break</span>;
<a name="l00718"></a>00718      <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00719"></a>00719      <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00720"></a>00720          txctrl = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(reg_idx));
<a name="l00721"></a>00721          txctrl &amp;= ~IXGBE_DCA_TXCTRL_CPUID_MASK_82599;
<a name="l00722"></a>00722                 txctrl |= (dca3_get_tag(tx_ring-&gt;dev, cpu) &lt;&lt;
<a name="l00723"></a>00723                IXGBE_DCA_TXCTRL_CPUID_SHIFT_82599);
<a name="l00724"></a>00724         txctrl |= IXGBE_DCA_TXCTRL_DESC_DCA_EN;
<a name="l00725"></a>00725         txctrl &amp;= ~IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
<a name="l00726"></a>00726         IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(reg_idx), txctrl);
<a name="l00727"></a>00727         <span class="keywordflow">break</span>;
<a name="l00728"></a>00728     <span class="keywordflow">default</span>:
<a name="l00729"></a>00729         <span class="keywordflow">break</span>;
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731 }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l00734"></a>00734 {
<a name="l00735"></a>00735     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l00736"></a>00736     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring;
<a name="l00737"></a>00737     <span class="keywordtype">int</span> cpu = get_cpu();
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     <span class="keywordflow">if</span> (q_vector-&gt;cpu == cpu)
<a name="l00740"></a>00740         <span class="keywordflow">goto</span> out_no_update;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="keywordflow">for</span> (ring = q_vector-&gt;tx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l00743"></a>00743         ixgbe_update_tx_dca(adapter, ring, cpu);
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     <span class="keywordflow">for</span> (ring = q_vector-&gt;rx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l00746"></a>00746         ixgbe_update_rx_dca(adapter, ring, cpu);
<a name="l00747"></a>00747 
<a name="l00748"></a>00748     q_vector-&gt;cpu = cpu;
<a name="l00749"></a>00749 out_no_update:
<a name="l00750"></a>00750     put_cpu();
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00754"></a>00754 {
<a name="l00755"></a>00755     <span class="keywordtype">int</span> num_q_vectors;
<a name="l00756"></a>00756     <span class="keywordtype">int</span> i;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED))
<a name="l00759"></a>00759         <span class="keywordflow">return</span>;
<a name="l00760"></a>00760 
<a name="l00761"></a>00761     <span class="comment">/* always use CB2 mode, difference is masked in the CB driver */</span>
<a name="l00762"></a>00762     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DCA_CTRL, 2);
<a name="l00763"></a>00763 
<a name="l00764"></a>00764     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l00765"></a>00765         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l00766"></a>00766     <span class="keywordflow">else</span>
<a name="l00767"></a>00767         num_q_vectors = 1;
<a name="l00768"></a>00768 
<a name="l00769"></a>00769     <span class="keywordflow">for</span> (i = 0; i &lt; num_q_vectors; i++) {
<a name="l00770"></a>00770         adapter-&gt;q_vector[i]-&gt;cpu = -1;
<a name="l00771"></a>00771         ixgbe_update_dca(adapter-&gt;q_vector[i]);
<a name="l00772"></a>00772     }
<a name="l00773"></a>00773 }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l00776"></a>00776 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> __ixgbe_notify_dca(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev, <span class="keywordtype">void</span> *data)
<a name="l00777"></a>00777 {
<a name="l00778"></a>00778     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = dev_get_drvdata(dev);
<a name="l00779"></a>00779     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keyword">event</span> = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)data;
<a name="l00780"></a>00780 
<a name="l00781"></a>00781     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED))
<a name="l00782"></a>00782         <span class="keywordflow">return</span> 0;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     <span class="keywordflow">switch</span> (event) {
<a name="l00785"></a>00785     <span class="keywordflow">case</span> DCA_PROVIDER_ADD:
<a name="l00786"></a>00786         <span class="comment">/* if we&#39;re already enabled, don&#39;t do it again */</span>
<a name="l00787"></a>00787         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
<a name="l00788"></a>00788             <span class="keywordflow">break</span>;
<a name="l00789"></a>00789         <span class="keywordflow">if</span> (dca_add_requester(dev) == 0) {
<a name="l00790"></a>00790             adapter-&gt;flags |= IXGBE_FLAG_DCA_ENABLED;
<a name="l00791"></a>00791             ixgbe_setup_dca(adapter);
<a name="l00792"></a>00792             <span class="keywordflow">break</span>;
<a name="l00793"></a>00793         }
<a name="l00794"></a>00794         <span class="comment">/* Fall Through since DCA is disabled. */</span>
<a name="l00795"></a>00795     <span class="keywordflow">case</span> DCA_PROVIDER_REMOVE:
<a name="l00796"></a>00796         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED) {
<a name="l00797"></a>00797             dca_remove_requester(dev);
<a name="l00798"></a>00798             adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCA_ENABLED;
<a name="l00799"></a>00799             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DCA_CTRL, 1);
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801         <span class="keywordflow">break</span>;
<a name="l00802"></a>00802     }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804     <span class="keywordflow">return</span> 0;
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_DCA or CONFIG_DCA_MODULE */</span>
<a name="l00808"></a>00808 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_release_rx_desc(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring, u32 val)
<a name="l00809"></a>00809 {
<a name="l00810"></a>00810     rx_ring-&gt;next_to_use = val;
<a name="l00811"></a>00811     <span class="comment">/*</span>
<a name="l00812"></a>00812 <span class="comment">     * Force memory writes to complete before letting h/w</span>
<a name="l00813"></a>00813 <span class="comment">     * know there are new descriptors to fetch.  (Only</span>
<a name="l00814"></a>00814 <span class="comment">     * applicable for weak-ordered memory model archs,</span>
<a name="l00815"></a>00815 <span class="comment">     * such as IA-64).</span>
<a name="l00816"></a>00816 <span class="comment">     */</span>
<a name="l00817"></a>00817     wmb();
<a name="l00818"></a>00818     writel(val, rx_ring-&gt;tail);
<a name="l00819"></a>00819 }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_alloc_mapped_skb(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l00822"></a>00822                    <span class="keyword">struct</span> <a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *bi)
<a name="l00823"></a>00823 {
<a name="l00824"></a>00824     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = rx_ring-&gt;dev;
<a name="l00825"></a>00825     <span class="keyword">struct </span>sk_buff *skb = bi-&gt;skb;
<a name="l00826"></a>00826     dma_addr_t dma = bi-&gt;dma;
<a name="l00827"></a>00827     u16 rx_buf_len = rx_ring-&gt;rx_buf_len;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     <span class="keywordflow">if</span> (dma)
<a name="l00830"></a>00830         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="keywordflow">if</span> (likely(!skb)) {
<a name="l00833"></a>00833         skb = netdev_alloc_skb_ip_align(netdev_ring(rx_ring), rx_buf_len);
<a name="l00834"></a>00834         bi-&gt;skb = skb;
<a name="l00835"></a>00835         <span class="keywordflow">if</span> (!skb) {
<a name="l00836"></a>00836             rx_ring-&gt;rx_stats.alloc_rx_buff_failed++;
<a name="l00837"></a>00837             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00838"></a>00838         }
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841     <span class="comment">/* initialize skb for ring */</span>
<a name="l00842"></a>00842     skb_record_rx_queue(skb, ring_queue_index(rx_ring));
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     dma = dma_map_single(dev, skb-&gt;data, rx_buf_len, DMA_FROM_DEVICE);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846     <span class="keywordflow">if</span> (dma_mapping_error(dev, dma)) {
<a name="l00847"></a>00847         rx_ring-&gt;rx_stats.alloc_rx_buff_failed++;
<a name="l00848"></a>00848         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     bi-&gt;dma = dma;
<a name="l00852"></a>00852     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00853"></a>00853 }
<a name="l00854"></a>00854 
<a name="l00855"></a>00855 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_alloc_mapped_page(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l00856"></a>00856                     <span class="keyword">struct</span> <a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *bi)
<a name="l00857"></a>00857 {
<a name="l00858"></a>00858     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = rx_ring-&gt;dev;
<a name="l00859"></a>00859     <span class="keyword">struct </span>page *page = bi-&gt;page;
<a name="l00860"></a>00860     dma_addr_t page_dma = bi-&gt;page_dma;
<a name="l00861"></a>00861     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> page_offset = bi-&gt;page_offset ^ (PAGE_SIZE / 2);
<a name="l00862"></a>00862 
<a name="l00863"></a>00863     <span class="keywordflow">if</span> (page_dma)
<a name="l00864"></a>00864         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866     <span class="keywordflow">if</span> (!page) {
<a name="l00867"></a>00867         page = netdev_alloc_page(netdev_ring(rx_ring));
<a name="l00868"></a>00868         bi-&gt;page = page;
<a name="l00869"></a>00869         <span class="keywordflow">if</span> (unlikely(!page)) {
<a name="l00870"></a>00870             rx_ring-&gt;rx_stats.alloc_rx_page_failed++;
<a name="l00871"></a>00871             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00872"></a>00872         }
<a name="l00873"></a>00873     }
<a name="l00874"></a>00874 
<a name="l00875"></a>00875     page_dma = dma_map_page(dev, page,
<a name="l00876"></a>00876                 page_offset, PAGE_SIZE / 2,
<a name="l00877"></a>00877                 DMA_FROM_DEVICE);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     <span class="keywordflow">if</span> (dma_mapping_error(dev, page_dma)) {
<a name="l00880"></a>00880         rx_ring-&gt;rx_stats.alloc_rx_page_failed++;
<a name="l00881"></a>00881         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00882"></a>00882     }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     bi-&gt;page_dma = page_dma;
<a name="l00885"></a>00885     bi-&gt;page_offset = page_offset;
<a name="l00886"></a>00886     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00894"></a>00894 <span class="keywordtype">void</span> ixgbe_alloc_rx_buffers(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring, u16 cleaned_count)
<a name="l00895"></a>00895 {
<a name="l00896"></a>00896     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc;
<a name="l00897"></a>00897     <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *bi;
<a name="l00898"></a>00898     u16 i = rx_ring-&gt;next_to_use;
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l00901"></a>00901 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!rx_ring-&gt;netdev) <span class="keywordflow">return</span>;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903     <span class="keywordflow">if</span>(rx_ring-&gt;dna.rx_tx.rx.packet_memory == 0)
<a name="l00904"></a>00904       dna_ixgbe_alloc_rx_buffers(rx_ring);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     <span class="keywordflow">return</span>;
<a name="l00907"></a>00907 <span class="preprocessor">#endif</span>
<a name="l00908"></a>00908 <span class="preprocessor"></span>
<a name="l00909"></a>00909     <span class="comment">/* nothing to do or no valid netdev defined */</span>
<a name="l00910"></a>00910     <span class="keywordflow">if</span> (!cleaned_count || !netdev_ring(rx_ring))
<a name="l00911"></a>00911         <span class="keywordflow">return</span>;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913     rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
<a name="l00914"></a>00914     bi = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l00915"></a>00915     i -= rx_ring-&gt;count;
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     <span class="keywordflow">while</span> (cleaned_count--) {
<a name="l00918"></a>00918       <span class="keywordflow">if</span> (!ixgbe_alloc_mapped_skb(rx_ring, bi))
<a name="l00919"></a>00919         <span class="keywordflow">break</span>;
<a name="l00920"></a>00920 
<a name="l00921"></a>00921       <span class="keywordflow">if</span> (!ring_is_ps_enabled(rx_ring)) {
<a name="l00922"></a>00922         <span class="comment">/* Refresh the desc even if buffer_addrs didn&#39;t change</span>
<a name="l00923"></a>00923 <span class="comment">         * because each write-back erases this info. */</span>
<a name="l00924"></a>00924         rx_desc-&gt;read.pkt_addr = cpu_to_le64(bi-&gt;dma);
<a name="l00925"></a>00925       } <span class="keywordflow">else</span> {
<a name="l00926"></a>00926         rx_desc-&gt;read.hdr_addr = cpu_to_le64(bi-&gt;dma);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928         <span class="keywordflow">if</span> (!ixgbe_alloc_mapped_page(rx_ring, bi))
<a name="l00929"></a>00929           <span class="keywordflow">break</span>;
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         rx_desc-&gt;read.pkt_addr = cpu_to_le64(bi-&gt;page_dma);
<a name="l00932"></a>00932       }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934       rx_desc++;
<a name="l00935"></a>00935       bi++;
<a name="l00936"></a>00936       i++;
<a name="l00937"></a>00937       <span class="keywordflow">if</span> (unlikely(!i)) {
<a name="l00938"></a>00938         rx_desc = IXGBE_RX_DESC_ADV(rx_ring, 0);
<a name="l00939"></a>00939         bi = rx_ring-&gt;rx_buffer_info;
<a name="l00940"></a>00940         i -= rx_ring-&gt;count;
<a name="l00941"></a>00941       }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943       <span class="comment">/* clear the hdr_addr for the next_to_use descriptor */</span>
<a name="l00944"></a>00944       rx_desc-&gt;read.hdr_addr = 0;
<a name="l00945"></a>00945     }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947     i += rx_ring-&gt;count;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     <span class="keywordflow">if</span> (rx_ring-&gt;next_to_use != i)
<a name="l00950"></a>00950         ixgbe_release_rx_desc(rx_ring, i);
<a name="l00951"></a>00951 }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 <span class="keyword">static</span> <span class="keyword">inline</span> u16 ixgbe_get_hlen(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l00954"></a>00954                  <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc)
<a name="l00955"></a>00955 {
<a name="l00956"></a>00956     __le16 hdr_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.hdr_info;
<a name="l00957"></a>00957     u16 hlen = le16_to_cpu(hdr_info) &amp; IXGBE_RXDADV_HDRBUFLEN_MASK;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959     <span class="comment">/* if we are not packet split we just need to return upper length */</span>
<a name="l00960"></a>00960     <span class="keywordflow">if</span> (!ring_is_ps_enabled(rx_ring))
<a name="l00961"></a>00961         <span class="keywordflow">return</span> le16_to_cpu(rx_desc-&gt;wb.upper.length);
<a name="l00962"></a>00962 
<a name="l00963"></a>00963     <span class="comment">/*</span>
<a name="l00964"></a>00964 <span class="comment">     * HW will not DMA in data larger than the given buffer, even if it</span>
<a name="l00965"></a>00965 <span class="comment">     * parses the (NFS, of course) header to be larger.  In that case, it</span>
<a name="l00966"></a>00966 <span class="comment">     * fills the header buffer and spills the rest into the page.</span>
<a name="l00967"></a>00967 <span class="comment">     */</span>
<a name="l00968"></a>00968     <span class="keywordflow">if</span> (hlen &gt; (IXGBE_RX_HDR_SIZE &lt;&lt; IXGBE_RXDADV_HDRBUFLEN_SHIFT))
<a name="l00969"></a>00969         hlen = IXGBE_RX_HDR_SIZE;
<a name="l00970"></a>00970     <span class="keywordflow">else</span>
<a name="l00971"></a>00971         hlen &gt;&gt;= IXGBE_RXDADV_HDRBUFLEN_SHIFT;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     <span class="keywordflow">return</span> hlen;
<a name="l00974"></a>00974 }
<a name="l00975"></a>00975 
<a name="l00984"></a>00984 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>sk_buff *ixgbe_merge_active_tail(<span class="keyword">struct</span> sk_buff *tail)
<a name="l00985"></a>00985 {
<a name="l00986"></a>00986     <span class="keyword">struct </span>sk_buff *head = IXGBE_RSC_CB(tail)-&gt;head;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988     <span class="keywordflow">if</span> (!head)
<a name="l00989"></a>00989         <span class="keywordflow">return</span> tail;
<a name="l00990"></a>00990 
<a name="l00991"></a>00991     IXGBE_RSC_CB(tail)-&gt;head = NULL;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     <span class="keywordflow">if</span> (head-&gt;prev)
<a name="l00994"></a>00994         head-&gt;prev-&gt;next = tail;
<a name="l00995"></a>00995     <span class="keywordflow">else</span>
<a name="l00996"></a>00996         skb_shinfo(head)-&gt;frag_list = tail;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998     head-&gt;len += tail-&gt;len;
<a name="l00999"></a>00999     head-&gt;data_len += tail-&gt;len;
<a name="l01000"></a>01000     head-&gt;truesize += tail-&gt;len;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     head-&gt;prev = tail;
<a name="l01003"></a>01003     IXGBE_RSC_CB(head)-&gt;append_cnt++;
<a name="l01004"></a>01004 
<a name="l01005"></a>01005     <span class="keywordflow">return</span> head;
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01015"></a>01015 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_close_active_frag_list(<span class="keyword">struct</span> sk_buff *head)
<a name="l01016"></a>01016 {
<a name="l01017"></a>01017     <span class="keywordflow">if</span> (head-&gt;prev) {
<a name="l01018"></a>01018         head-&gt;prev = NULL;
<a name="l01019"></a>01019         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01020"></a>01020     }
<a name="l01021"></a>01021     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span>
<a name="l01032"></a>01032 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_rx_is_fcoe(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l01033"></a>01033                     <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc)
<a name="l01034"></a>01034 {
<a name="l01035"></a>01035     __le16 pkt_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.pkt_info;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037     <span class="keywordflow">return</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) &amp;&amp;
<a name="l01038"></a>01038            (pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_ETQF_MASK)) &amp;&amp;
<a name="l01039"></a>01039            ((pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_ETQF_MASK)) ==
<a name="l01040"></a>01040         (cpu_to_le16(IXGBE_ETQF_FILTER_FCOE &lt;&lt;
<a name="l01041"></a>01041                  IXGBE_RXDADV_PKTTYPE_ETQF_SHIFT)));
<a name="l01042"></a>01042 }
<a name="l01043"></a>01043 
<a name="l01044"></a>01044 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l01045"></a>01045 
<a name="l01051"></a>01051 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_receive_skb(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01052"></a>01052                   <span class="keyword">struct</span> sk_buff *skb, u16 <a class="code" href="structvlan__tag.html">vlan_tag</a>,
<a name="l01053"></a>01053                   <span class="keyword">struct</span> vlan_group *vlgrp)
<a name="l01054"></a>01054 {
<a name="l01055"></a>01055     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l01058"></a>01058 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_IN_NETPOLL)) {
<a name="l01059"></a>01059 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (vlan_tag &amp; VLAN_VID_MASK) {
<a name="l01061"></a>01061                 <span class="keywordflow">if</span> (vlgrp)
<a name="l01062"></a>01062                     vlan_gro_receive(&amp;q_vector-&gt;napi,
<a name="l01063"></a>01063                              vlgrp, vlan_tag, skb);
<a name="l01064"></a>01064                 <span class="keywordflow">else</span>
<a name="l01065"></a>01065                     dev_kfree_skb_any(skb);
<a name="l01066"></a>01066             } <span class="keywordflow">else</span> {
<a name="l01067"></a>01067                 napi_gro_receive(&amp;q_vector-&gt;napi, skb);
<a name="l01068"></a>01068             }
<a name="l01069"></a>01069 <span class="preprocessor">#else</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span>            napi_gro_receive(&amp;q_vector-&gt;napi, skb);
<a name="l01071"></a>01071 <span class="preprocessor">#endif</span>
<a name="l01072"></a>01072 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l01073"></a>01073 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l01074"></a>01074             <span class="keywordtype">int</span> ret = NET_RX_SUCCESS;
<a name="l01075"></a>01075 
<a name="l01076"></a>01076             <span class="comment">/* bypass unused variable warnings */</span>
<a name="l01077"></a>01077             ret = ret;
<a name="l01078"></a>01078 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l01079"></a>01079 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (vlan_tag &amp; VLAN_VID_MASK) {
<a name="l01080"></a>01080                 <span class="keywordflow">if</span> (vlgrp)
<a name="l01081"></a>01081                     ret = vlan_hwaccel_rx(skb, vlgrp,
<a name="l01082"></a>01082                                           vlan_tag);
<a name="l01083"></a>01083                 <span class="keywordflow">else</span>
<a name="l01084"></a>01084                     dev_kfree_skb_any(skb);
<a name="l01085"></a>01085             } <span class="keywordflow">else</span> {
<a name="l01086"></a>01086                 ret = netif_rx(skb);
<a name="l01087"></a>01087             }
<a name="l01088"></a>01088 <span class="preprocessor">#else</span>
<a name="l01089"></a>01089 <span class="preprocessor"></span>            ret = netif_rx(skb);
<a name="l01090"></a>01090 <span class="preprocessor">#endif</span>
<a name="l01091"></a>01091 <span class="preprocessor"></span><span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l01092"></a>01092 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (ret == NET_RX_DROP)
<a name="l01093"></a>01093                 adapter-&gt;rx_dropped_backlog++;
<a name="l01094"></a>01094 <span class="preprocessor">#endif</span>
<a name="l01095"></a>01095 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l01096"></a>01096 <span class="preprocessor"></span>        }
<a name="l01097"></a>01097 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l01098"></a>01098 }
<a name="l01099"></a>01099 
<a name="l01107"></a>01107 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_rx_checksum(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l01108"></a>01108                                      <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc,
<a name="l01109"></a>01109                                      <span class="keyword">struct</span> sk_buff *skb,
<a name="l01110"></a>01110                      u32 status_err)
<a name="l01111"></a>01111 {
<a name="l01112"></a>01112     skb-&gt;ip_summed = CHECKSUM_NONE;
<a name="l01113"></a>01113 
<a name="l01114"></a>01114     <span class="comment">/* Rx csum disabled */</span>
<a name="l01115"></a>01115     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_RX_CSUM_ENABLED))
<a name="l01116"></a>01116         <span class="keywordflow">return</span>;
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     <span class="comment">/* if IP and error */</span>
<a name="l01119"></a>01119     <span class="keywordflow">if</span> ((status_err &amp; IXGBE_RXD_STAT_IPCS) &amp;&amp;
<a name="l01120"></a>01120         (status_err &amp; IXGBE_RXDADV_ERR_IPE)) {
<a name="l01121"></a>01121         adapter-&gt;hw_csum_rx_error++;
<a name="l01122"></a>01122         <span class="keywordflow">return</span>;
<a name="l01123"></a>01123     }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125     <span class="keywordflow">if</span> (!(status_err &amp; IXGBE_RXD_STAT_L4CS))
<a name="l01126"></a>01126         <span class="keywordflow">return</span>;
<a name="l01127"></a>01127 
<a name="l01128"></a>01128     <span class="keywordflow">if</span> (status_err &amp; IXGBE_RXDADV_ERR_TCPE) {
<a name="l01129"></a>01129         __le16 pkt_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.pkt_info;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         <span class="comment">/*</span>
<a name="l01132"></a>01132 <span class="comment">         * 82599 errata, UDP frames with a 0 checksum can be marked as</span>
<a name="l01133"></a>01133 <span class="comment">         * checksum errors.</span>
<a name="l01134"></a>01134 <span class="comment">         */</span>
<a name="l01135"></a>01135         <span class="keywordflow">if</span> ((pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_UDP)) &amp;&amp;
<a name="l01136"></a>01136             (adapter-&gt;hw.mac.type == ixgbe_mac_82599EB))
<a name="l01137"></a>01137             <span class="keywordflow">return</span>;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         adapter-&gt;hw_csum_rx_error++;
<a name="l01140"></a>01140         <span class="keywordflow">return</span>;
<a name="l01141"></a>01141     }
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     <span class="comment">/* It must be a TCP or UDP packet with a valid checksum */</span>
<a name="l01144"></a>01144     skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<a name="l01145"></a>01145 }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span>
<a name="l01155"></a>01155 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_can_lro(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01156"></a>01156                  <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc,
<a name="l01157"></a>01157                  <span class="keyword">struct</span> sk_buff *skb)
<a name="l01158"></a>01158 {
<a name="l01159"></a>01159     __le16 pkt_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.pkt_info;
<a name="l01160"></a>01160 
<a name="l01161"></a>01161     <span class="keywordflow">return</span> (ring_is_lro_enabled(rx_ring) &amp;&amp;
<a name="l01162"></a>01162         (skb-&gt;protocol == __constant_htons(ETH_P_IP)) &amp;&amp;
<a name="l01163"></a>01163         !(netdev_ring(rx_ring)-&gt;flags &amp; IFF_PROMISC) &amp;&amp;
<a name="l01164"></a>01164         (pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPV4)) &amp;&amp;
<a name="l01165"></a>01165         (pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_TCP)));
<a name="l01166"></a>01166 }
<a name="l01167"></a>01167 
<a name="l01174"></a>01174 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_flush(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01175"></a>01175                                  <span class="keyword">struct</span> <a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod)
<a name="l01176"></a>01176 {
<a name="l01177"></a>01177     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist = q_vector-&gt;lrolist;
<a name="l01178"></a>01178     <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph;
<a name="l01179"></a>01179     <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *th;
<a name="l01180"></a>01180     <span class="keyword">struct </span>sk_buff *skb;
<a name="l01181"></a>01181     __be32 *ts_ptr;
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01184"></a>01184     lrolist-&gt;active_cnt--;
<a name="l01185"></a>01185 
<a name="l01186"></a>01186     skb = lrod-&gt;skb;
<a name="l01187"></a>01187     lrod-&gt;skb = NULL;
<a name="l01188"></a>01188 
<a name="l01189"></a>01189     <span class="keywordflow">if</span> (lrod-&gt;append_cnt) {
<a name="l01190"></a>01190         <span class="comment">/* merge last skb in chain and adjust pointers */</span>
<a name="l01191"></a>01191         skb = ixgbe_merge_active_tail(skb);
<a name="l01192"></a>01192         ixgbe_close_active_frag_list(skb);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         <span class="comment">/* incorporate ip header and re-calculate checksum */</span>
<a name="l01195"></a>01195         iph = (<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *)skb-&gt;data;
<a name="l01196"></a>01196         iph-&gt;tot_len = htons(skb-&gt;len);
<a name="l01197"></a>01197         iph-&gt;check = 0;
<a name="l01198"></a>01198         iph-&gt;check = ip_fast_csum((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)iph, iph-&gt;ihl);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200         <span class="comment">/* incorporate the push flag into the tcp header */</span>
<a name="l01201"></a>01201         th = (<span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *) ((<span class="keywordtype">char</span> *)skb-&gt;data + <span class="keyword">sizeof</span>(*iph));
<a name="l01202"></a>01202         th-&gt;psh = lrod-&gt;psh;
<a name="l01203"></a>01203         th-&gt;check = 0;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205         <span class="comment">/* incorporate latest timestamp into the tcp header */</span>
<a name="l01206"></a>01206         <span class="keywordflow">if</span> (lrod-&gt;opt_bytes) {
<a name="l01207"></a>01207             ts_ptr = (__be32 *)(th + 1);
<a name="l01208"></a>01208             ts_ptr[1] = htonl(lrod-&gt;tsval);
<a name="l01209"></a>01209             ts_ptr[2] = lrod-&gt;tsecr;
<a name="l01210"></a>01210         }
<a name="l01211"></a>01211     }
<a name="l01212"></a>01212 
<a name="l01213"></a>01213 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l01214"></a>01214 <span class="preprocessor"></span>    skb_shinfo(skb)-&gt;gso_size = lrod-&gt;mss;
<a name="l01215"></a>01215 <span class="preprocessor">#endif</span>
<a name="l01216"></a>01216 <span class="preprocessor"></span>    ixgbe_receive_skb(q_vector, skb, lrod-&gt;vlan_tag, lrod-&gt;vlgrp);
<a name="l01217"></a>01217     lrolist-&gt;stats.flushed++;
<a name="l01218"></a>01218 
<a name="l01219"></a>01219     hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;free);
<a name="l01220"></a>01220 }
<a name="l01221"></a>01221 
<a name="l01222"></a>01222 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_flush_all(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l01223"></a>01223 {
<a name="l01224"></a>01224     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01225"></a>01225     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l01226"></a>01226     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist = q_vector-&gt;lrolist;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;active, lro_node)
<a name="l01229"></a>01229         ixgbe_lro_flush(q_vector, lrod);
<a name="l01230"></a>01230 }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 <span class="comment">/*</span>
<a name="l01233"></a>01233 <span class="comment"> * ixgbe_lro_header_ok - Main LRO function.</span>
<a name="l01234"></a>01234 <span class="comment"> **/</span>
<a name="l01235"></a>01235 static u16 ixgbe_lro_header_ok(struct sk_buff *new_skb, struct <a class="code" href="structiphdr.html">iphdr</a> *iph,
<a name="l01236"></a>01236                                struct <a class="code" href="structtcphdr.html">tcphdr</a> *th)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238     <span class="keywordtype">int</span> opt_bytes, tcp_data_len;
<a name="l01239"></a>01239     __be32 *ts_ptr = NULL;
<a name="l01240"></a>01240 
<a name="l01241"></a>01241     <span class="comment">/* If we see CE codepoint in IP header, packet is not mergeable */</span>
<a name="l01242"></a>01242     <span class="keywordflow">if</span> (INET_ECN_is_ce(ipv4_get_dsfield(iph)))
<a name="l01243"></a>01243         <span class="keywordflow">return</span> -1;
<a name="l01244"></a>01244 
<a name="l01245"></a>01245     <span class="comment">/* ensure there are no options */</span>
<a name="l01246"></a>01246     <span class="keywordflow">if</span> ((iph-&gt;ihl &lt;&lt; 2) != <span class="keyword">sizeof</span>(*iph))
<a name="l01247"></a>01247         <span class="keywordflow">return</span> -1;
<a name="l01248"></a>01248 
<a name="l01249"></a>01249     <span class="comment">/* verify protocol is TCP */</span>
<a name="l01250"></a>01250     <span class="keywordflow">if</span> (iph-&gt;protocol != IPPROTO_TCP)
<a name="l01251"></a>01251         <span class="keywordflow">return</span> -1;
<a name="l01252"></a>01252 
<a name="l01253"></a>01253     <span class="comment">/* .. and the packet is not fragmented */</span>
<a name="l01254"></a>01254     <span class="keywordflow">if</span> (iph-&gt;frag_off &amp; __constant_htons(IP_MF|IP_OFFSET))
<a name="l01255"></a>01255         <span class="keywordflow">return</span> -1;
<a name="l01256"></a>01256 
<a name="l01257"></a>01257     <span class="comment">/* ensure no bits set besides ack or psh */</span>
<a name="l01258"></a>01258     <span class="keywordflow">if</span> (th-&gt;fin || th-&gt;syn || th-&gt;rst ||
<a name="l01259"></a>01259         th-&gt;urg || th-&gt;ece || th-&gt;cwr || !th-&gt;ack)
<a name="l01260"></a>01260         <span class="keywordflow">return</span> -1;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     <span class="comment">/* ensure that the checksum is valid */</span>
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (new_skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
<a name="l01264"></a>01264         <span class="keywordflow">return</span> -1;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <span class="comment">/*</span>
<a name="l01267"></a>01267 <span class="comment">     * check for timestamps. Since the only option we handle are timestamps,</span>
<a name="l01268"></a>01268 <span class="comment">     * we only have to handle the simple case of aligned timestamps</span>
<a name="l01269"></a>01269 <span class="comment">     */</span>
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     opt_bytes = (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*th);
<a name="l01272"></a>01272     <span class="keywordflow">if</span> (opt_bytes != 0) {
<a name="l01273"></a>01273         ts_ptr = (__be32 *)(th + 1);
<a name="l01274"></a>01274         <span class="keywordflow">if</span> ((opt_bytes != TCPOLEN_TSTAMP_ALIGNED) ||
<a name="l01275"></a>01275             (*ts_ptr != htonl((TCPOPT_NOP &lt;&lt; 24) |
<a name="l01276"></a>01276             (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) |
<a name="l01277"></a>01277             TCPOLEN_TIMESTAMP))) {
<a name="l01278"></a>01278             <span class="keywordflow">return</span> -1;
<a name="l01279"></a>01279         }
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     tcp_data_len = ntohs(iph-&gt;tot_len) - (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*iph);
<a name="l01283"></a>01283 
<a name="l01284"></a>01284     <span class="keywordflow">return</span> tcp_data_len;
<a name="l01285"></a>01285 }
<a name="l01286"></a>01286 
<a name="l01297"></a>01297 <span class="keyword">static</span> <span class="keyword">struct </span>sk_buff *ixgbe_lro_queue(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01298"></a>01298                                        <span class="keyword">struct</span> sk_buff *new_skb,
<a name="l01299"></a>01299                        u16 tag, <span class="keyword">struct</span> vlan_group *vlgrp)
<a name="l01300"></a>01300 {
<a name="l01301"></a>01301     <span class="keyword">struct </span>sk_buff *lro_skb;
<a name="l01302"></a>01302     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01303"></a>01303     <span class="keyword">struct </span>hlist_node *node;
<a name="l01304"></a>01304     <span class="keyword">struct </span>skb_shared_info *new_skb_info = skb_shinfo(new_skb);
<a name="l01305"></a>01305     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist = q_vector-&gt;lrolist;
<a name="l01306"></a>01306     <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = (<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *)new_skb-&gt;data;
<a name="l01307"></a>01307     <span class="keyword">struct</span> <a class="code" href="structtcphdr.html">tcphdr</a> *th = (<span class="keyword">struct</span> <a class="code" href="structtcphdr.html">tcphdr</a> *)(iph + 1);
<a name="l01308"></a>01308     <span class="keywordtype">int</span> tcp_data_len = ixgbe_lro_header_ok(new_skb, iph, th);
<a name="l01309"></a>01309     u16  opt_bytes = (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*th);
<a name="l01310"></a>01310     __be32 *ts_ptr = (opt_bytes ? (__be32 *)(th + 1) : NULL);
<a name="l01311"></a>01311     u32 seq = ntohl(th-&gt;seq);
<a name="l01312"></a>01312 
<a name="l01313"></a>01313     <span class="comment">/*</span>
<a name="l01314"></a>01314 <span class="comment">     * we have a packet that might be eligible for LRO,</span>
<a name="l01315"></a>01315 <span class="comment">     * so see if it matches anything we might expect</span>
<a name="l01316"></a>01316 <span class="comment">     */</span>
<a name="l01317"></a>01317     hlist_for_each_entry(lrod, node, &amp;lrolist-&gt;active, lro_node) {
<a name="l01318"></a>01318         <span class="keywordflow">if</span> (lrod-&gt;source_port != th-&gt;source ||
<a name="l01319"></a>01319             lrod-&gt;dest_port != th-&gt;dest ||
<a name="l01320"></a>01320             lrod-&gt;source_ip != iph-&gt;saddr ||
<a name="l01321"></a>01321             lrod-&gt;dest_ip != iph-&gt;daddr ||
<a name="l01322"></a>01322             lrod-&gt;vlan_tag != tag)
<a name="l01323"></a>01323             <span class="keywordflow">continue</span>;
<a name="l01324"></a>01324 
<a name="l01325"></a>01325         <span class="comment">/*</span>
<a name="l01326"></a>01326 <span class="comment">         * malformed header, no tcp data, resultant packet would</span>
<a name="l01327"></a>01327 <span class="comment">         * be too large, ack sequence numbers do not match, window</span>
<a name="l01328"></a>01328 <span class="comment">         * size has changed, or new skb is larger than our current mss.</span>
<a name="l01329"></a>01329 <span class="comment">         * If any of the above we should flush the lro descriptor and</span>
<a name="l01330"></a>01330 <span class="comment">         * start over if possible</span>
<a name="l01331"></a>01331 <span class="comment">         */</span>
<a name="l01332"></a>01332         <span class="keywordflow">if</span> (tcp_data_len &lt;= 0 || (tcp_data_len + lrod-&gt;len) &gt; 65521 ||
<a name="l01333"></a>01333             lrod-&gt;ack_seq != th-&gt;ack_seq ||
<a name="l01334"></a>01334             lrod-&gt;window != th-&gt;window ||
<a name="l01335"></a>01335             lrod-&gt;mss &lt; tcp_data_len) {
<a name="l01336"></a>01336             ixgbe_lro_flush(q_vector, lrod);
<a name="l01337"></a>01337             <span class="keywordflow">break</span>;
<a name="l01338"></a>01338         }
<a name="l01339"></a>01339 
<a name="l01340"></a>01340         <span class="comment">/* out of order packet */</span>
<a name="l01341"></a>01341         <span class="keywordflow">if</span> (seq != lrod-&gt;next_seq) {
<a name="l01342"></a>01342             ixgbe_lro_flush(q_vector, lrod);
<a name="l01343"></a>01343             tcp_data_len = -1;
<a name="l01344"></a>01344             <span class="keywordflow">break</span>;
<a name="l01345"></a>01345         }
<a name="l01346"></a>01346 
<a name="l01347"></a>01347         <span class="comment">/* packet without timestamp, or timestamp suddenly added to flow */</span>
<a name="l01348"></a>01348         <span class="keywordflow">if</span> (lrod-&gt;opt_bytes != opt_bytes) {
<a name="l01349"></a>01349             ixgbe_lro_flush(q_vector, lrod);
<a name="l01350"></a>01350             <span class="keywordflow">break</span>;
<a name="l01351"></a>01351         }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353         <span class="keywordflow">if</span> (opt_bytes) {
<a name="l01354"></a>01354             u32 tsval = ntohl(*(ts_ptr + 1));
<a name="l01355"></a>01355             <span class="comment">/* make sure timestamp values are increasing */</span>
<a name="l01356"></a>01356             <span class="keywordflow">if</span> (opt_bytes != lrod-&gt;opt_bytes ||
<a name="l01357"></a>01357                 lrod-&gt;tsval &gt; tsval || *(ts_ptr + 2) == 0) {
<a name="l01358"></a>01358                 ixgbe_lro_flush(q_vector, lrod);
<a name="l01359"></a>01359                 tcp_data_len = -1;
<a name="l01360"></a>01360                 <span class="keywordflow">break</span>;
<a name="l01361"></a>01361             }
<a name="l01362"></a>01362 
<a name="l01363"></a>01363             lrod-&gt;tsval = tsval;
<a name="l01364"></a>01364             lrod-&gt;tsecr = *(ts_ptr + 2);
<a name="l01365"></a>01365         }
<a name="l01366"></a>01366 
<a name="l01367"></a>01367         <span class="comment">/* remove any padding from the end of the skb */</span>
<a name="l01368"></a>01368         __pskb_trim(new_skb, ntohs(iph-&gt;tot_len));
<a name="l01369"></a>01369         <span class="comment">/* Remove IP and TCP header*/</span>
<a name="l01370"></a>01370         skb_pull(new_skb, ntohs(iph-&gt;tot_len) - tcp_data_len);
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         lrod-&gt;next_seq += tcp_data_len;
<a name="l01373"></a>01373         lrod-&gt;len += tcp_data_len;
<a name="l01374"></a>01374         lrod-&gt;psh |= th-&gt;psh;
<a name="l01375"></a>01375         lrod-&gt;append_cnt++;
<a name="l01376"></a>01376         lrolist-&gt;stats.coal++;
<a name="l01377"></a>01377         lro_skb = lrod-&gt;skb;
<a name="l01378"></a>01378 
<a name="l01379"></a>01379         <span class="comment">/* if header is empty pull pages into current skb */</span>
<a name="l01380"></a>01380         <span class="keywordflow">if</span> (!skb_headlen(new_skb) &amp;&amp;
<a name="l01381"></a>01381             ((skb_shinfo(lro_skb)-&gt;nr_frags +
<a name="l01382"></a>01382               skb_shinfo(new_skb)-&gt;nr_frags) &lt;= MAX_SKB_FRAGS )) {
<a name="l01383"></a>01383             <span class="keyword">struct </span>skb_shared_info *lro_skb_info = skb_shinfo(lro_skb);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385             <span class="comment">/* copy frags into the last skb */</span>
<a name="l01386"></a>01386             memcpy(lro_skb_info-&gt;frags + lro_skb_info-&gt;nr_frags,
<a name="l01387"></a>01387                    new_skb_info-&gt;frags,
<a name="l01388"></a>01388                    new_skb_info-&gt;nr_frags * <span class="keyword">sizeof</span>(skb_frag_t));
<a name="l01389"></a>01389 
<a name="l01390"></a>01390             lro_skb_info-&gt;nr_frags += new_skb_info-&gt;nr_frags;
<a name="l01391"></a>01391             lro_skb-&gt;len += tcp_data_len;
<a name="l01392"></a>01392             lro_skb-&gt;data_len += tcp_data_len;
<a name="l01393"></a>01393             lro_skb-&gt;truesize += tcp_data_len;
<a name="l01394"></a>01394 
<a name="l01395"></a>01395             new_skb_info-&gt;nr_frags = 0;
<a name="l01396"></a>01396             new_skb-&gt;truesize -= tcp_data_len;
<a name="l01397"></a>01397             new_skb-&gt;len = new_skb-&gt;data_len = 0;
<a name="l01398"></a>01398             new_skb-&gt;data = skb_mac_header(new_skb);
<a name="l01399"></a>01399             __pskb_trim(new_skb, 0);
<a name="l01400"></a>01400             new_skb-&gt;protocol = 0;
<a name="l01401"></a>01401             lrolist-&gt;stats.recycled++;
<a name="l01402"></a>01402         } <span class="keywordflow">else</span> {
<a name="l01403"></a>01403             lro_skb = ixgbe_merge_active_tail(lro_skb);
<a name="l01404"></a>01404             IXGBE_RSC_CB(new_skb)-&gt;head = lro_skb;
<a name="l01405"></a>01405             lrod-&gt;skb = new_skb;
<a name="l01406"></a>01406             new_skb = NULL;
<a name="l01407"></a>01407         }
<a name="l01408"></a>01408 
<a name="l01409"></a>01409         <span class="keywordflow">if</span> (lrod-&gt;psh || (tcp_data_len &lt; lrod-&gt;mss))
<a name="l01410"></a>01410             ixgbe_lro_flush(q_vector, lrod);
<a name="l01411"></a>01411 
<a name="l01412"></a>01412         <span class="keywordflow">return</span> new_skb;
<a name="l01413"></a>01413     }
<a name="l01414"></a>01414 
<a name="l01415"></a>01415     <span class="comment">/* start a new packet */</span>
<a name="l01416"></a>01416     <span class="keywordflow">if</span> (tcp_data_len &gt; 0 &amp;&amp; !hlist_empty(&amp;lrolist-&gt;free) &amp;&amp; !th-&gt;psh) {
<a name="l01417"></a>01417         lrod = hlist_entry(lrolist-&gt;free.first, <span class="keyword">struct</span> <a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a>,
<a name="l01418"></a>01418                            lro_node);
<a name="l01419"></a>01419 
<a name="l01420"></a>01420         lrod-&gt;skb = new_skb;
<a name="l01421"></a>01421         lrod-&gt;source_ip = iph-&gt;saddr;
<a name="l01422"></a>01422         lrod-&gt;dest_ip = iph-&gt;daddr;
<a name="l01423"></a>01423         lrod-&gt;source_port = th-&gt;source;
<a name="l01424"></a>01424         lrod-&gt;dest_port = th-&gt;dest;
<a name="l01425"></a>01425         lrod-&gt;vlan_tag = tag;
<a name="l01426"></a>01426         lrod-&gt;vlgrp = vlgrp;
<a name="l01427"></a>01427         lrod-&gt;len = new_skb-&gt;len;
<a name="l01428"></a>01428         lrod-&gt;next_seq = seq + tcp_data_len;
<a name="l01429"></a>01429         lrod-&gt;ack_seq = th-&gt;ack_seq;
<a name="l01430"></a>01430         lrod-&gt;window = th-&gt;window;
<a name="l01431"></a>01431         lrod-&gt;mss = tcp_data_len;
<a name="l01432"></a>01432         lrod-&gt;opt_bytes = opt_bytes;
<a name="l01433"></a>01433         lrod-&gt;psh = 0;
<a name="l01434"></a>01434         lrod-&gt;append_cnt = 0;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436         <span class="comment">/* record timestamp if it is present */</span>
<a name="l01437"></a>01437         <span class="keywordflow">if</span> (opt_bytes) {
<a name="l01438"></a>01438             lrod-&gt;tsval = ntohl(*(ts_ptr + 1));
<a name="l01439"></a>01439             lrod-&gt;tsecr = *(ts_ptr + 2);
<a name="l01440"></a>01440         }
<a name="l01441"></a>01441         <span class="comment">/* remove first packet from freelist.. */</span>
<a name="l01442"></a>01442         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01443"></a>01443         <span class="comment">/* .. and insert at the front of the active list */</span>
<a name="l01444"></a>01444         hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;active);
<a name="l01445"></a>01445         lrolist-&gt;active_cnt++;
<a name="l01446"></a>01446         lrolist-&gt;stats.coal++;
<a name="l01447"></a>01447         <span class="keywordflow">return</span> NULL;
<a name="l01448"></a>01448     }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450     <span class="comment">/* packet not handled by any of the above, pass it to the stack */</span>
<a name="l01451"></a>01451     ixgbe_receive_skb(q_vector, new_skb, tag, vlgrp);
<a name="l01452"></a>01452     <span class="keywordflow">return</span> NULL;
<a name="l01453"></a>01453 }
<a name="l01454"></a>01454 
<a name="l01455"></a>01455 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_ring_exit(<span class="keyword">struct</span> <a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist)
<a name="l01456"></a>01456 {
<a name="l01457"></a>01457     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l01458"></a>01458     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01459"></a>01459 
<a name="l01460"></a>01460     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;active,
<a name="l01461"></a>01461                               lro_node) {
<a name="l01462"></a>01462         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01463"></a>01463         kfree(lrod);
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465 
<a name="l01466"></a>01466     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;free,
<a name="l01467"></a>01467                               lro_node) {
<a name="l01468"></a>01468         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01469"></a>01469         kfree(lrod);
<a name="l01470"></a>01470     }
<a name="l01471"></a>01471 }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_ring_init(<span class="keyword">struct</span> <a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist)
<a name="l01474"></a>01474 {
<a name="l01475"></a>01475     <span class="keywordtype">int</span> j, bytes;
<a name="l01476"></a>01476     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01477"></a>01477 
<a name="l01478"></a>01478     bytes = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a>);
<a name="l01479"></a>01479 
<a name="l01480"></a>01480     INIT_HLIST_HEAD(&amp;lrolist-&gt;free);
<a name="l01481"></a>01481     INIT_HLIST_HEAD(&amp;lrolist-&gt;active);
<a name="l01482"></a>01482 
<a name="l01483"></a>01483     <span class="keywordflow">for</span> (j = 0; j &lt; IXGBE_LRO_MAX; j++) {
<a name="l01484"></a>01484         lrod = kzalloc(bytes, GFP_KERNEL);
<a name="l01485"></a>01485         <span class="keywordflow">if</span> (lrod != NULL) {
<a name="l01486"></a>01486             INIT_HLIST_NODE(&amp;lrod-&gt;lro_node);
<a name="l01487"></a>01487             hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;free);
<a name="l01488"></a>01488         }
<a name="l01489"></a>01489     }
<a name="l01490"></a>01490 }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l01493"></a>01493 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_get_rsc_state(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01494"></a>01494                        <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc)
<a name="l01495"></a>01495 {
<a name="l01496"></a>01496     <span class="keywordflow">return</span> ring_is_rsc_enabled(rx_ring) &amp;&amp;
<a name="l01497"></a>01497            (rx_desc-&gt;wb.lower.lo_dword.data &amp;
<a name="l01498"></a>01498         cpu_to_le32(IXGBE_RXDADV_RSCCNT_MASK));
<a name="l01499"></a>01499 }
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_rx_status_indication(u32 staterr,
<a name="l01502"></a>01502                                        <span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01503"></a>01503 {
<a name="l01504"></a>01504     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01505"></a>01505     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01506"></a>01506     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01507"></a>01507         <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_FLM)
<a name="l01508"></a>01508             adapter-&gt;flm++;
<a name="l01509"></a>01509 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l01510"></a>01510 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_DYNINT)
<a name="l01511"></a>01511             adapter-&gt;lli_int++;
<a name="l01512"></a>01512 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LLI */</span>
<a name="l01513"></a>01513         <span class="keywordflow">break</span>;
<a name="l01514"></a>01514     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01515"></a>01515 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l01516"></a>01516 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_DYNINT)
<a name="l01517"></a>01517             adapter-&gt;lli_int++;
<a name="l01518"></a>01518 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LLI */</span>
<a name="l01519"></a>01519         <span class="keywordflow">break</span>;
<a name="l01520"></a>01520     <span class="keywordflow">default</span>:
<a name="l01521"></a>01521         <span class="keywordflow">break</span>;
<a name="l01522"></a>01522     }
<a name="l01523"></a>01523 }
<a name="l01524"></a>01524 
<a name="l01525"></a>01525 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l01526"></a>01526 <span class="preprocessor"></span>
<a name="l01539"></a>01539 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_cleanup_loopback_headers(<span class="keyword">struct</span> sk_buff *skb)
<a name="l01540"></a>01540 {
<a name="l01541"></a>01541     <span class="keywordtype">int</span> pull_len = (skb-&gt;len &lt; 60) ? skb-&gt;len : ETH_HLEN;
<a name="l01542"></a>01542     <span class="keywordtype">int</span> pad_len = 60 - min_t(<span class="keywordtype">int</span>, skb-&gt;len, 60);
<a name="l01543"></a>01543 
<a name="l01544"></a>01544     <span class="comment">/* pull at least Ethernet header length into data */</span>
<a name="l01545"></a>01545     <span class="keywordflow">if</span> (!pskb_may_pull(skb, pull_len)) {
<a name="l01546"></a>01546         dev_kfree_skb_any(skb);
<a name="l01547"></a>01547         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01548"></a>01548     }
<a name="l01549"></a>01549 
<a name="l01550"></a>01550     <span class="comment">/* if skb_pad returns an error the skb was freed */</span>
<a name="l01551"></a>01551     <span class="keywordflow">if</span> (pad_len) {
<a name="l01552"></a>01552         <span class="keywordflow">if</span> (skb_pad(skb, pad_len))
<a name="l01553"></a>01553             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01554"></a>01554         __skb_put(skb, pad_len);
<a name="l01555"></a>01555     }
<a name="l01556"></a>01556 
<a name="l01557"></a>01557     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01558"></a>01558 }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PCI_IOV */</span>
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_clean_rx_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01563"></a>01563                   <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01564"></a>01564                   <span class="keywordtype">int</span> budget)
<a name="l01565"></a>01565 {
<a name="l01566"></a>01566     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l01567"></a>01567     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc;
<a name="l01568"></a>01568     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_rx_bytes = 0, total_rx_packets = 0;
<a name="l01569"></a>01569     <span class="keyword">const</span> <span class="keywordtype">int</span> current_node = numa_node_id();
<a name="l01570"></a>01570 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l01571"></a>01571 <span class="preprocessor"></span>    <span class="keywordtype">int</span> ddp_bytes = 0;
<a name="l01572"></a>01572 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l01573"></a>01573     u32 staterr;
<a name="l01574"></a>01574     u16 i = rx_ring-&gt;next_to_clean;
<a name="l01575"></a>01575     u16 cleaned_count = ixgbe_desc_unused(rx_ring);
<a name="l01576"></a>01576     <span class="keyword">struct </span>vlan_group *vlgrp = adapter-&gt;vlgrp;
<a name="l01577"></a>01577 
<a name="l01578"></a>01578 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l01579"></a>01579 <span class="preprocessor"></span>    <span class="keywordflow">return</span>(dna_ixgbe_clean_rx_irq(q_vector, rx_ring, budget));
<a name="l01580"></a>01580 <span class="preprocessor">#endif</span>
<a name="l01581"></a>01581 <span class="preprocessor"></span>    rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
<a name="l01582"></a>01582     staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l01583"></a>01583 
<a name="l01584"></a>01584     <span class="keywordflow">while</span> (staterr &amp; IXGBE_RXD_STAT_DD) {
<a name="l01585"></a>01585         <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *next_rxd;
<a name="l01586"></a>01586         <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *rx_buffer_info;
<a name="l01587"></a>01587         <span class="keyword">struct </span>sk_buff *skb;
<a name="l01588"></a>01588         u16 vlan_tag;
<a name="l01589"></a>01589         <span class="keywordtype">bool</span> pkt_is_rsc;
<a name="l01590"></a>01590 
<a name="l01591"></a>01591         rx_buffer_info = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l01592"></a>01592         skb = rx_buffer_info-&gt;skb;
<a name="l01593"></a>01593         rx_buffer_info-&gt;skb = NULL;
<a name="l01594"></a>01594 
<a name="l01595"></a>01595         prefetch(skb-&gt;data);
<a name="l01596"></a>01596 
<a name="l01597"></a>01597         <span class="comment">/*</span>
<a name="l01598"></a>01598 <span class="comment">         * This memory barrier is needed to keep us from reading</span>
<a name="l01599"></a>01599 <span class="comment">         * any other fields out of the rx_desc until we know the</span>
<a name="l01600"></a>01600 <span class="comment">         * RXD_STAT_DD bit is set</span>
<a name="l01601"></a>01601 <span class="comment">         */</span>
<a name="l01602"></a>01602         rmb();
<a name="l01603"></a>01603 
<a name="l01604"></a>01604         pkt_is_rsc = ixgbe_get_rsc_state(rx_ring, rx_desc);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606         <span class="comment">/* pull the header of the skb in if no data is already present */</span>
<a name="l01607"></a>01607         <span class="keywordflow">if</span> (!skb_is_nonlinear(skb)) {
<a name="l01608"></a>01608             __skb_put(skb, ixgbe_get_hlen(rx_ring, rx_desc));
<a name="l01609"></a>01609             <span class="comment">/*</span>
<a name="l01610"></a>01610 <span class="comment">             * When HWRSC is enabled, delay unmapping of the first</span>
<a name="l01611"></a>01611 <span class="comment">             * packet. It carries the header information, HW may</span>
<a name="l01612"></a>01612 <span class="comment">             * still access the header after the writeback.  Only</span>
<a name="l01613"></a>01613 <span class="comment">             * unmap it when EOP is reached</span>
<a name="l01614"></a>01614 <span class="comment">             */</span>
<a name="l01615"></a>01615             <span class="keywordflow">if</span> (!(staterr &amp; IXGBE_RXD_STAT_EOP) &amp;&amp; pkt_is_rsc &amp;&amp;
<a name="l01616"></a>01616                 !IXGBE_RSC_CB(skb)-&gt;head) {
<a name="l01617"></a>01617                 IXGBE_RSC_CB(skb)-&gt;delay_unmap = <span class="keyword">true</span>;
<a name="l01618"></a>01618                 IXGBE_RSC_CB(skb)-&gt;dma = rx_buffer_info-&gt;dma;
<a name="l01619"></a>01619             } <span class="keywordflow">else</span> {
<a name="l01620"></a>01620                 skb = ixgbe_merge_active_tail(skb);
<a name="l01621"></a>01621                 dma_unmap_single(rx_ring-&gt;dev,
<a name="l01622"></a>01622                          rx_buffer_info-&gt;dma,
<a name="l01623"></a>01623                          rx_ring-&gt;rx_buf_len,
<a name="l01624"></a>01624                          DMA_FROM_DEVICE);
<a name="l01625"></a>01625             }
<a name="l01626"></a>01626             rx_buffer_info-&gt;dma = 0;
<a name="l01627"></a>01627         }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629         <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring) &amp;&amp; rx_desc-&gt;wb.upper.length) {
<a name="l01630"></a>01630             u16 upper_len = le16_to_cpu(rx_desc-&gt;wb.upper.length);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632             skb_fill_page_desc(skb, skb_shinfo(skb)-&gt;nr_frags,
<a name="l01633"></a>01633                        rx_buffer_info-&gt;page,
<a name="l01634"></a>01634                        rx_buffer_info-&gt;page_offset,
<a name="l01635"></a>01635                        upper_len);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637             skb-&gt;len += upper_len;
<a name="l01638"></a>01638             skb-&gt;data_len += upper_len;
<a name="l01639"></a>01639             skb-&gt;truesize += upper_len;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641             <span class="keywordflow">if</span> ((page_count(rx_buffer_info-&gt;page) == 1) &amp;&amp;
<a name="l01642"></a>01642                 (page_to_nid(rx_buffer_info-&gt;page) == current_node))
<a name="l01643"></a>01643                 get_page(rx_buffer_info-&gt;page);
<a name="l01644"></a>01644             <span class="keywordflow">else</span>
<a name="l01645"></a>01645                 rx_buffer_info-&gt;page = NULL;
<a name="l01646"></a>01646 
<a name="l01647"></a>01647             dma_unmap_page(rx_ring-&gt;dev,
<a name="l01648"></a>01648                        rx_buffer_info-&gt;page_dma,
<a name="l01649"></a>01649                            PAGE_SIZE / 2,
<a name="l01650"></a>01650                            DMA_FROM_DEVICE);
<a name="l01651"></a>01651             rx_buffer_info-&gt;page_dma = 0;
<a name="l01652"></a>01652         }
<a name="l01653"></a>01653 
<a name="l01654"></a>01654         i++;
<a name="l01655"></a>01655         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l01656"></a>01656             i = 0;
<a name="l01657"></a>01657 
<a name="l01658"></a>01658         next_rxd = IXGBE_RX_DESC_ADV(rx_ring, i);
<a name="l01659"></a>01659         prefetch(next_rxd);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661         <span class="keywordflow">if</span> (unlikely(!(staterr &amp; IXGBE_RXD_STAT_EOP))) {
<a name="l01662"></a>01662             <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *next_buffer;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664             <span class="keywordflow">if</span> (pkt_is_rsc) {
<a name="l01665"></a>01665                 u32 nextp = staterr &amp; IXGBE_RXDADV_NEXTP_MASK;
<a name="l01666"></a>01666                 nextp &gt;&gt;= IXGBE_RXDADV_NEXTP_SHIFT;
<a name="l01667"></a>01667                 next_buffer = &amp;rx_ring-&gt;rx_buffer_info[nextp];
<a name="l01668"></a>01668             } <span class="keywordflow">else</span> {
<a name="l01669"></a>01669                 next_buffer = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l01670"></a>01670             }
<a name="l01671"></a>01671 
<a name="l01672"></a>01672             <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring)) {
<a name="l01673"></a>01673                 rx_buffer_info-&gt;skb = next_buffer-&gt;skb;
<a name="l01674"></a>01674                 rx_buffer_info-&gt;dma = next_buffer-&gt;dma;
<a name="l01675"></a>01675                 next_buffer-&gt;skb = skb;
<a name="l01676"></a>01676                 next_buffer-&gt;dma = 0;
<a name="l01677"></a>01677             } <span class="keywordflow">else</span> {
<a name="l01678"></a>01678                 IXGBE_RSC_CB(next_buffer-&gt;skb)-&gt;head = skb;
<a name="l01679"></a>01679             }
<a name="l01680"></a>01680             rx_ring-&gt;rx_stats.non_eop_descs++;
<a name="l01681"></a>01681             <span class="keywordflow">goto</span> next_desc;
<a name="l01682"></a>01682         }
<a name="l01683"></a>01683 
<a name="l01684"></a>01684         <span class="keywordflow">if</span> (ixgbe_close_active_frag_list(skb) &amp;&amp; !pkt_is_rsc) {
<a name="l01685"></a>01685             <span class="comment">/* if we got here without RSC the packet is invalid */</span>
<a name="l01686"></a>01686             dev_kfree_skb_any(skb);
<a name="l01687"></a>01687             <span class="keywordflow">goto</span> next_desc;
<a name="l01688"></a>01688         }
<a name="l01689"></a>01689 
<a name="l01690"></a>01690         <span class="keywordflow">if</span> (pkt_is_rsc) {
<a name="l01691"></a>01691             <span class="keywordflow">if</span> (IXGBE_RSC_CB(skb)-&gt;delay_unmap) {
<a name="l01692"></a>01692                 dma_unmap_single(rx_ring-&gt;dev,
<a name="l01693"></a>01693                                  IXGBE_RSC_CB(skb)-&gt;dma,
<a name="l01694"></a>01694                          rx_ring-&gt;rx_buf_len,
<a name="l01695"></a>01695                                  DMA_FROM_DEVICE);
<a name="l01696"></a>01696                 IXGBE_RSC_CB(skb)-&gt;dma = 0;
<a name="l01697"></a>01697                 IXGBE_RSC_CB(skb)-&gt;delay_unmap = <span class="keyword">false</span>;
<a name="l01698"></a>01698             }
<a name="l01699"></a>01699 
<a name="l01700"></a>01700             <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring))
<a name="l01701"></a>01701                 rx_ring-&gt;rx_stats.rsc_count +=
<a name="l01702"></a>01702                     skb_shinfo(skb)-&gt;nr_frags;
<a name="l01703"></a>01703             <span class="keywordflow">else</span>
<a name="l01704"></a>01704                 rx_ring-&gt;rx_stats.rsc_count +=
<a name="l01705"></a>01705                     IXGBE_RSC_CB(skb)-&gt;append_cnt + 1;
<a name="l01706"></a>01706             rx_ring-&gt;rx_stats.rsc_flush++;
<a name="l01707"></a>01707 
<a name="l01708"></a>01708             IXGBE_RSC_CB(skb)-&gt;append_cnt = 0;
<a name="l01709"></a>01709         }
<a name="l01710"></a>01710 
<a name="l01711"></a>01711         <span class="comment">/* ERR_MASK will only have valid bits if EOP set */</span>
<a name="l01712"></a>01712         <span class="keywordflow">if</span> (unlikely(staterr &amp; IXGBE_RXDADV_ERR_FRAME_ERR_MASK)) {
<a name="l01713"></a>01713             dev_kfree_skb_any(skb);
<a name="l01714"></a>01714             <span class="keywordflow">goto</span> next_desc;
<a name="l01715"></a>01715         }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l01718"></a>01718 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_LB) {
<a name="l01719"></a>01719             <span class="keywordflow">if</span> (ixgbe_cleanup_loopback_headers(skb))
<a name="l01720"></a>01720                 <span class="keywordflow">goto</span> next_desc;
<a name="l01721"></a>01721         }
<a name="l01722"></a>01722 
<a name="l01723"></a>01723 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PCI_IOV */</span>
<a name="l01724"></a>01724         ixgbe_rx_status_indication(staterr, adapter);
<a name="l01725"></a>01725         ixgbe_rx_checksum(adapter, rx_desc, skb, staterr);
<a name="l01726"></a>01726 
<a name="l01727"></a>01727         <span class="comment">/* probably a little skewed due to removing CRC */</span>
<a name="l01728"></a>01728         total_rx_bytes += skb-&gt;len;
<a name="l01729"></a>01729         total_rx_packets++;
<a name="l01730"></a>01730 
<a name="l01731"></a>01731         skb-&gt;protocol = eth_type_trans(skb, netdev_ring(rx_ring));
<a name="l01732"></a>01732         vlan_tag = ((staterr &amp; IXGBE_RXD_STAT_VP) ?
<a name="l01733"></a>01733                     le16_to_cpu(rx_desc-&gt;wb.upper.vlan) : 0);
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l01736"></a>01736 <span class="preprocessor"></span>        <span class="comment">/* if ddp, not passing to ULD unless for FCP_RSP or error */</span>
<a name="l01737"></a>01737         <span class="keywordflow">if</span> (ixgbe_rx_is_fcoe(adapter, rx_desc)) {
<a name="l01738"></a>01738             ddp_bytes = ixgbe_fcoe_ddp(adapter, rx_desc, skb,
<a name="l01739"></a>01739                            staterr);
<a name="l01740"></a>01740             <span class="keywordflow">if</span> (!ddp_bytes) {
<a name="l01741"></a>01741                 dev_kfree_skb_any(skb);
<a name="l01742"></a>01742 <span class="preprocessor">#ifndef NETIF_F_GRO</span>
<a name="l01743"></a>01743 <span class="preprocessor"></span>                netdev_ring(rx_ring)-&gt;last_rx = jiffies;
<a name="l01744"></a>01744 <span class="preprocessor">#endif</span>
<a name="l01745"></a>01745 <span class="preprocessor"></span>                <span class="keywordflow">goto</span> next_desc;
<a name="l01746"></a>01746             }
<a name="l01747"></a>01747         }
<a name="l01748"></a>01748 
<a name="l01749"></a>01749 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l01750"></a>01750 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l01751"></a>01751 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ixgbe_can_lro(rx_ring, rx_desc, skb))
<a name="l01752"></a>01752             rx_buffer_info-&gt;skb = ixgbe_lro_queue(q_vector, skb,
<a name="l01753"></a>01753                                   vlan_tag, vlgrp);
<a name="l01754"></a>01754         <span class="keywordflow">else</span>
<a name="l01755"></a>01755 <span class="preprocessor">#endif</span>
<a name="l01756"></a>01756 <span class="preprocessor"></span>            ixgbe_receive_skb(q_vector, skb, vlan_tag, vlgrp);
<a name="l01757"></a>01757 
<a name="l01758"></a>01758 <span class="preprocessor">#ifndef NETIF_F_GRO</span>
<a name="l01759"></a>01759 <span class="preprocessor"></span>        netdev_ring(rx_ring)-&gt;last_rx = jiffies;
<a name="l01760"></a>01760 <span class="preprocessor">#endif</span>
<a name="l01761"></a>01761 <span class="preprocessor"></span>        budget--;
<a name="l01762"></a>01762 next_desc:
<a name="l01763"></a>01763         <span class="keywordflow">if</span> (!budget)
<a name="l01764"></a>01764             <span class="keywordflow">break</span>;
<a name="l01765"></a>01765 
<a name="l01766"></a>01766         cleaned_count++;
<a name="l01767"></a>01767         <span class="comment">/* return some buffers to hardware, one at a time is too slow */</span>
<a name="l01768"></a>01768         <span class="keywordflow">if</span> (cleaned_count &gt;= IXGBE_RX_BUFFER_WRITE) {
<a name="l01769"></a>01769             ixgbe_alloc_rx_buffers(rx_ring, cleaned_count);
<a name="l01770"></a>01770             cleaned_count = 0;
<a name="l01771"></a>01771         }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773         <span class="comment">/* use prefetched values */</span>
<a name="l01774"></a>01774         rx_desc = next_rxd;
<a name="l01775"></a>01775         staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l01776"></a>01776     }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l01779"></a>01779 <span class="preprocessor"></span>    <span class="comment">/* include DDPed FCoE data */</span>
<a name="l01780"></a>01780     <span class="keywordflow">if</span> (ddp_bytes &gt; 0) {
<a name="l01781"></a>01781         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mss;
<a name="l01782"></a>01782 
<a name="l01783"></a>01783         mss = netdev_ring(rx_ring)-&gt;mtu - <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fcoe_hdr) -
<a name="l01784"></a>01784             sizeof(struct fc_frame_header) -
<a name="l01785"></a>01785             sizeof(struct fcoe_crc_eof);
<a name="l01786"></a>01786         <span class="keywordflow">if</span> (mss &gt; 512)
<a name="l01787"></a>01787             mss &amp;= ~511;
<a name="l01788"></a>01788         total_rx_bytes += ddp_bytes;
<a name="l01789"></a>01789         total_rx_packets += DIV_ROUND_UP(ddp_bytes, mss);
<a name="l01790"></a>01790     }
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l01793"></a>01793     rx_ring-&gt;next_to_clean = i;
<a name="l01794"></a>01794     rx_ring-&gt;stats.packets += total_rx_packets;
<a name="l01795"></a>01795     rx_ring-&gt;stats.bytes += total_rx_bytes;
<a name="l01796"></a>01796     q_vector-&gt;rx.total_packets += total_rx_packets;
<a name="l01797"></a>01797     q_vector-&gt;rx.total_bytes += total_rx_bytes;
<a name="l01798"></a>01798 
<a name="l01799"></a>01799     <span class="keywordflow">if</span> (cleaned_count)
<a name="l01800"></a>01800         ixgbe_alloc_rx_buffers(rx_ring, cleaned_count);
<a name="l01801"></a>01801 
<a name="l01802"></a>01802 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l01803"></a>01803 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ring_is_lro_enabled(rx_ring))
<a name="l01804"></a>01804         ixgbe_lro_flush_all(q_vector);
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l01807"></a>01807     <span class="keywordflow">return</span> budget;
<a name="l01808"></a>01808 }
<a name="l01809"></a>01809 
<a name="l01817"></a>01817 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_msix(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01818"></a>01818 {
<a name="l01819"></a>01819     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l01820"></a>01820     <span class="keywordtype">int</span> q_vectors, v_idx;
<a name="l01821"></a>01821     u32 mask;
<a name="l01822"></a>01822 
<a name="l01823"></a>01823     q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l01824"></a>01824 
<a name="l01825"></a>01825     <span class="comment">/*</span>
<a name="l01826"></a>01826 <span class="comment">     * Populate the IVAR table and set the ITR values to the</span>
<a name="l01827"></a>01827 <span class="comment">     * corresponding register.</span>
<a name="l01828"></a>01828 <span class="comment">     */</span>
<a name="l01829"></a>01829     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; q_vectors; v_idx++) {
<a name="l01830"></a>01830         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring;
<a name="l01831"></a>01831         q_vector = adapter-&gt;q_vector[v_idx];
<a name="l01832"></a>01832 
<a name="l01833"></a>01833         <span class="keywordflow">for</span> (ring = q_vector-&gt;rx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l01834"></a>01834             ixgbe_set_ivar(adapter, 0, ring-&gt;reg_idx, v_idx);
<a name="l01835"></a>01835 
<a name="l01836"></a>01836         <span class="keywordflow">for</span> (ring = q_vector-&gt;tx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l01837"></a>01837             ixgbe_set_ivar(adapter, 1, ring-&gt;reg_idx, v_idx);
<a name="l01838"></a>01838 
<a name="l01839"></a>01839         <span class="keywordflow">if</span> (q_vector-&gt;tx.ring &amp;&amp; !q_vector-&gt;rx.ring)
<a name="l01840"></a>01840             <span class="comment">/* tx only vector */</span>
<a name="l01841"></a>01841             q_vector-&gt;eitr = adapter-&gt;tx_eitr_param;
<a name="l01842"></a>01842         <span class="keywordflow">else</span>
<a name="l01843"></a>01843             <span class="comment">/* rx or rx/tx vector */</span>
<a name="l01844"></a>01844             q_vector-&gt;eitr = adapter-&gt;rx_eitr_param;
<a name="l01845"></a>01845 
<a name="l01846"></a>01846         ixgbe_write_eitr(q_vector);
<a name="l01847"></a>01847     }
<a name="l01848"></a>01848 
<a name="l01849"></a>01849     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01850"></a>01850     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01851"></a>01851         ixgbe_set_ivar(adapter, -1, IXGBE_IVAR_OTHER_CAUSES_INDEX,
<a name="l01852"></a>01852                    v_idx);
<a name="l01853"></a>01853         <span class="keywordflow">break</span>;
<a name="l01854"></a>01854     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01855"></a>01855         ixgbe_set_ivar(adapter, -1, 1, v_idx);
<a name="l01856"></a>01856         <span class="keywordflow">break</span>;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01859"></a>01859         ixgbe_set_ivar(adapter, -1, 1, v_idx);
<a name="l01860"></a>01860         <span class="keywordflow">break</span>;
<a name="l01861"></a>01861     <span class="keywordflow">default</span>:
<a name="l01862"></a>01862         <span class="keywordflow">break</span>;
<a name="l01863"></a>01863     }
<a name="l01864"></a>01864     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EITR(v_idx), 1950);
<a name="l01865"></a>01865 
<a name="l01866"></a>01866     <span class="comment">/* set up to autoclear timer, and the vectors */</span>
<a name="l01867"></a>01867     mask = IXGBE_EIMS_ENABLE_MASK;
<a name="l01868"></a>01868     mask &amp;= ~(IXGBE_EIMS_OTHER |
<a name="l01869"></a>01869           IXGBE_EIMS_MAILBOX |
<a name="l01870"></a>01870           IXGBE_EIMS_LSC);
<a name="l01871"></a>01871 
<a name="l01872"></a>01872     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIAC, mask);
<a name="l01873"></a>01873 }
<a name="l01874"></a>01874 
<a name="l01875"></a>01875 <span class="keyword">enum</span> latency_range {
<a name="l01876"></a>01876     lowest_latency = 0,
<a name="l01877"></a>01877     low_latency = 1,
<a name="l01878"></a>01878     bulk_latency = 2,
<a name="l01879"></a>01879     latency_invalid = 255
<a name="l01880"></a>01880 };
<a name="l01881"></a>01881 
<a name="l01897"></a>01897 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_itr(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01898"></a>01898                  <span class="keyword">struct</span> <a class="code" href="structixgbe__ring__container.html">ixgbe_ring_container</a> *ring_container)
<a name="l01899"></a>01899 {
<a name="l01900"></a>01900     <span class="keywordtype">int</span> bytes = ring_container-&gt;total_bytes;
<a name="l01901"></a>01901     <span class="keywordtype">int</span> packets = ring_container-&gt;total_packets;
<a name="l01902"></a>01902     u32 timepassed_us;
<a name="l01903"></a>01903     u64 bytes_perint;
<a name="l01904"></a>01904     u8 itr_setting = ring_container-&gt;itr;
<a name="l01905"></a>01905 
<a name="l01906"></a>01906     <span class="keywordflow">if</span> (packets == 0)
<a name="l01907"></a>01907         <span class="keywordflow">return</span>;
<a name="l01908"></a>01908 
<a name="l01909"></a>01909     <span class="comment">/* simple throttlerate management</span>
<a name="l01910"></a>01910 <span class="comment">     *   0-10MB/s   lowest (100000 ints/s)</span>
<a name="l01911"></a>01911 <span class="comment">     *  10-20MB/s   low    (20000 ints/s)</span>
<a name="l01912"></a>01912 <span class="comment">     *  20-1249MB/s bulk   (8000 ints/s)</span>
<a name="l01913"></a>01913 <span class="comment">     */</span>
<a name="l01914"></a>01914     <span class="comment">/* what was last interrupt timeslice? */</span>
<a name="l01915"></a>01915     timepassed_us = 1000000/q_vector-&gt;eitr;
<a name="l01916"></a>01916     bytes_perint = bytes / timepassed_us; <span class="comment">/* bytes/usec */</span>
<a name="l01917"></a>01917 
<a name="l01918"></a>01918     <span class="keywordflow">switch</span> (itr_setting) {
<a name="l01919"></a>01919     <span class="keywordflow">case</span> lowest_latency:
<a name="l01920"></a>01920         <span class="keywordflow">if</span> (bytes_perint &gt; 10) {
<a name="l01921"></a>01921             itr_setting = low_latency;
<a name="l01922"></a>01922         }
<a name="l01923"></a>01923         <span class="keywordflow">break</span>;
<a name="l01924"></a>01924     <span class="keywordflow">case</span> low_latency:
<a name="l01925"></a>01925         <span class="keywordflow">if</span> (bytes_perint &lt;= 10) {
<a name="l01926"></a>01926             itr_setting = lowest_latency;
<a name="l01927"></a>01927         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_perint &gt; 20) {
<a name="l01928"></a>01928             itr_setting = bulk_latency;
<a name="l01929"></a>01929         }
<a name="l01930"></a>01930         <span class="keywordflow">break</span>;
<a name="l01931"></a>01931     <span class="keywordflow">case</span> bulk_latency:
<a name="l01932"></a>01932         <span class="keywordflow">if</span> (bytes_perint &lt;= 20) {
<a name="l01933"></a>01933             itr_setting = low_latency;
<a name="l01934"></a>01934         }
<a name="l01935"></a>01935         <span class="keywordflow">break</span>;
<a name="l01936"></a>01936     }
<a name="l01937"></a>01937 
<a name="l01938"></a>01938     <span class="comment">/* clear work counters since we have the values we need */</span>
<a name="l01939"></a>01939     ring_container-&gt;total_bytes = 0;
<a name="l01940"></a>01940     ring_container-&gt;total_packets = 0;
<a name="l01941"></a>01941 
<a name="l01942"></a>01942     <span class="comment">/* write updated itr to ring container */</span>
<a name="l01943"></a>01943     ring_container-&gt;itr = itr_setting;
<a name="l01944"></a>01944 }
<a name="l01945"></a>01945 
<a name="l01954"></a>01954 <span class="keywordtype">void</span> ixgbe_write_eitr(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l01955"></a>01955 {
<a name="l01956"></a>01956     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l01957"></a>01957     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01958"></a>01958     <span class="keywordtype">int</span> v_idx = q_vector-&gt;v_idx;
<a name="l01959"></a>01959     u32 itr_reg = EITR_INTS_PER_SEC_TO_REG(q_vector-&gt;eitr);
<a name="l01960"></a>01960 
<a name="l01961"></a>01961     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01962"></a>01962     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01963"></a>01963         <span class="comment">/* must write high and low 16 bits to reset counter */</span>
<a name="l01964"></a>01964         itr_reg |= (itr_reg &lt;&lt; 16);
<a name="l01965"></a>01965         <span class="keywordflow">break</span>;
<a name="l01966"></a>01966     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01967"></a>01967     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01968"></a>01968         <span class="comment">/*</span>
<a name="l01969"></a>01969 <span class="comment">         * 82599 can support a value of zero, so allow it for</span>
<a name="l01970"></a>01970 <span class="comment">         * max interrupt rate, but there is an errata where it can</span>
<a name="l01971"></a>01971 <span class="comment">         * not be zero with RSC</span>
<a name="l01972"></a>01972 <span class="comment">         */</span>
<a name="l01973"></a>01973         <span class="keywordflow">if</span> (itr_reg == 8 &amp;&amp;
<a name="l01974"></a>01974             !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED))
<a name="l01975"></a>01975             itr_reg = 0;
<a name="l01976"></a>01976 
<a name="l01977"></a>01977         <span class="comment">/*</span>
<a name="l01978"></a>01978 <span class="comment">         * set the WDIS bit to not clear the timer bits and cause an</span>
<a name="l01979"></a>01979 <span class="comment">         * immediate assertion of the interrupt</span>
<a name="l01980"></a>01980 <span class="comment">         */</span>
<a name="l01981"></a>01981         itr_reg |= IXGBE_EITR_CNT_WDIS;
<a name="l01982"></a>01982         <span class="keywordflow">break</span>;
<a name="l01983"></a>01983     <span class="keywordflow">default</span>:
<a name="l01984"></a>01984         <span class="keywordflow">break</span>;
<a name="l01985"></a>01985     }
<a name="l01986"></a>01986     IXGBE_WRITE_REG(hw, IXGBE_EITR(v_idx), itr_reg);
<a name="l01987"></a>01987 }
<a name="l01988"></a>01988 
<a name="l01989"></a>01989 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_itr(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l01990"></a>01990 {
<a name="l01991"></a>01991     u32 new_itr = q_vector-&gt;eitr;
<a name="l01992"></a>01992     u8 current_itr;
<a name="l01993"></a>01993 
<a name="l01994"></a>01994     ixgbe_update_itr(q_vector, &amp;q_vector-&gt;tx);
<a name="l01995"></a>01995     ixgbe_update_itr(q_vector, &amp;q_vector-&gt;rx);
<a name="l01996"></a>01996 
<a name="l01997"></a>01997     current_itr = max(q_vector-&gt;rx.itr, q_vector-&gt;tx.itr);
<a name="l01998"></a>01998 
<a name="l01999"></a>01999     <span class="keywordflow">switch</span> (current_itr) {
<a name="l02000"></a>02000     <span class="comment">/* counts and packets in update_itr are dependent on these numbers */</span>
<a name="l02001"></a>02001     <span class="keywordflow">case</span> lowest_latency:
<a name="l02002"></a>02002         new_itr = 100000;
<a name="l02003"></a>02003         <span class="keywordflow">break</span>;
<a name="l02004"></a>02004     <span class="keywordflow">case</span> low_latency:
<a name="l02005"></a>02005         new_itr = 20000; <span class="comment">/* aka hwitr = ~200 */</span>
<a name="l02006"></a>02006         <span class="keywordflow">break</span>;
<a name="l02007"></a>02007     <span class="keywordflow">case</span> bulk_latency:
<a name="l02008"></a>02008         new_itr = 8000;
<a name="l02009"></a>02009         <span class="keywordflow">break</span>;
<a name="l02010"></a>02010     <span class="keywordflow">default</span>:
<a name="l02011"></a>02011         <span class="keywordflow">break</span>;
<a name="l02012"></a>02012     }
<a name="l02013"></a>02013 
<a name="l02014"></a>02014     <span class="keywordflow">if</span> (new_itr != q_vector-&gt;eitr) {
<a name="l02015"></a>02015         <span class="comment">/* do an exponential smoothing */</span>
<a name="l02016"></a>02016         new_itr = ((q_vector-&gt;eitr * 9) + new_itr)/10;
<a name="l02017"></a>02017 
<a name="l02018"></a>02018         <span class="comment">/* save the algorithm value here */</span>
<a name="l02019"></a>02019         q_vector-&gt;eitr = new_itr;
<a name="l02020"></a>02020 
<a name="l02021"></a>02021         ixgbe_write_eitr(q_vector);
<a name="l02022"></a>02022     }
<a name="l02023"></a>02023 }
<a name="l02024"></a>02024 
<a name="l02029"></a>02029 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_overtemp_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02030"></a>02030 {
<a name="l02031"></a>02031     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02032"></a>02032     u32 eicr = adapter-&gt;interrupt_event;
<a name="l02033"></a>02033 
<a name="l02034"></a>02034     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02035"></a>02035         <span class="keywordflow">return</span>;
<a name="l02036"></a>02036 
<a name="l02037"></a>02037     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &amp;&amp;
<a name="l02038"></a>02038         !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_EVENT))
<a name="l02039"></a>02039         <span class="keywordflow">return</span>;
<a name="l02040"></a>02040 
<a name="l02041"></a>02041     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_TEMP_SENSOR_EVENT;
<a name="l02042"></a>02042 
<a name="l02043"></a>02043     <span class="keywordflow">switch</span> (hw-&gt;device_id) {
<a name="l02044"></a>02044     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_T3_LOM:
<a name="l02045"></a>02045         <span class="comment">/*</span>
<a name="l02046"></a>02046 <span class="comment">         * Since the warning interrupt is for both ports</span>
<a name="l02047"></a>02047 <span class="comment">         * we don&#39;t have to check if:</span>
<a name="l02048"></a>02048 <span class="comment">         *  - This interrupt wasn&#39;t for our port.</span>
<a name="l02049"></a>02049 <span class="comment">         *  - We may have missed the interrupt so always have to</span>
<a name="l02050"></a>02050 <span class="comment">         *    check if we  got a LSC</span>
<a name="l02051"></a>02051 <span class="comment">         */</span>
<a name="l02052"></a>02052         <span class="keywordflow">if</span> (!(eicr &amp; IXGBE_EICR_GPI_SDP0) &amp;&amp;
<a name="l02053"></a>02053             !(eicr &amp; IXGBE_EICR_LSC))
<a name="l02054"></a>02054             <span class="keywordflow">return</span>;
<a name="l02055"></a>02055 
<a name="l02056"></a>02056         <span class="keywordflow">if</span> (!(eicr &amp; IXGBE_EICR_LSC) &amp;&amp; hw-&gt;mac.ops.check_link) {
<a name="l02057"></a>02057             u32 autoneg;
<a name="l02058"></a>02058             <span class="keywordtype">bool</span> link_up = <span class="keyword">false</span>;
<a name="l02059"></a>02059 
<a name="l02060"></a>02060             hw-&gt;mac.ops.check_link(hw, &amp;autoneg, &amp;link_up, <span class="keyword">false</span>);
<a name="l02061"></a>02061 
<a name="l02062"></a>02062             <span class="keywordflow">if</span> (link_up)
<a name="l02063"></a>02063                 <span class="keywordflow">return</span>;
<a name="l02064"></a>02064         }
<a name="l02065"></a>02065 
<a name="l02066"></a>02066         <span class="comment">/* Check if this is not due to overtemp */</span>
<a name="l02067"></a>02067         <span class="keywordflow">if</span> (hw-&gt;phy.ops.check_overtemp(hw) != IXGBE_ERR_OVERTEMP)
<a name="l02068"></a>02068             <span class="keywordflow">return</span>;
<a name="l02069"></a>02069 
<a name="l02070"></a>02070         <span class="keywordflow">break</span>;
<a name="l02071"></a>02071     <span class="keywordflow">default</span>:
<a name="l02072"></a>02072         <span class="keywordflow">if</span> (!(eicr &amp; IXGBE_EICR_GPI_SDP0))
<a name="l02073"></a>02073             <span class="keywordflow">return</span>;
<a name="l02074"></a>02074         <span class="keywordflow">break</span>;
<a name="l02075"></a>02075     }
<a name="l02076"></a>02076     e_crit(drv,
<a name="l02077"></a>02077            <span class="stringliteral">&quot;Network adapter has been stopped because it has over heated. &quot;</span>
<a name="l02078"></a>02078            <span class="stringliteral">&quot;Restart the computer. If the problem persists, &quot;</span>
<a name="l02079"></a>02079            <span class="stringliteral">&quot;power off the system and replace the adapter\n&quot;</span>);
<a name="l02080"></a>02080 
<a name="l02081"></a>02081     adapter-&gt;interrupt_event = 0;
<a name="l02082"></a>02082 }
<a name="l02083"></a>02083 
<a name="l02084"></a>02084 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_fan_failure(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u32 eicr)
<a name="l02085"></a>02085 {
<a name="l02086"></a>02086     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02087"></a>02087 
<a name="l02088"></a>02088     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE) &amp;&amp;
<a name="l02089"></a>02089         (eicr &amp; IXGBE_EICR_GPI_SDP1)) {
<a name="l02090"></a>02090         e_crit(probe, <span class="stringliteral">&quot;Fan has stopped, replace the adapter\n&quot;</span>);
<a name="l02091"></a>02091         <span class="comment">/* write to clear the interrupt */</span>
<a name="l02092"></a>02092         IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1);
<a name="l02093"></a>02093     }
<a name="l02094"></a>02094 }
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_sfp_event(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u32 eicr)
<a name="l02097"></a>02097 {
<a name="l02098"></a>02098     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02099"></a>02099 
<a name="l02100"></a>02100     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_GPI_SDP2) {
<a name="l02101"></a>02101         <span class="comment">/* Clear the interrupt */</span>
<a name="l02102"></a>02102         IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP2);
<a name="l02103"></a>02103         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02104"></a>02104             adapter-&gt;flags2 |= IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l02105"></a>02105             ixgbe_service_event_schedule(adapter);
<a name="l02106"></a>02106         }
<a name="l02107"></a>02107     }
<a name="l02108"></a>02108 
<a name="l02109"></a>02109     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_GPI_SDP1) {
<a name="l02110"></a>02110         <span class="comment">/* Clear the interrupt */</span>
<a name="l02111"></a>02111         IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1);
<a name="l02112"></a>02112         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02113"></a>02113             adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l02114"></a>02114             ixgbe_service_event_schedule(adapter);
<a name="l02115"></a>02115         }
<a name="l02116"></a>02116     }
<a name="l02117"></a>02117 }
<a name="l02118"></a>02118 
<a name="l02119"></a>02119 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_lsc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02120"></a>02120 {
<a name="l02121"></a>02121     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02122"></a>02122 
<a name="l02123"></a>02123     adapter-&gt;lsc_int++;
<a name="l02124"></a>02124     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l02125"></a>02125     adapter-&gt;link_check_timeout = jiffies;
<a name="l02126"></a>02126     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02127"></a>02127         IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_EIMC_LSC);
<a name="l02128"></a>02128         IXGBE_WRITE_FLUSH(hw);
<a name="l02129"></a>02129         ixgbe_service_event_schedule(adapter);
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131 }
<a name="l02132"></a>02132 
<a name="l02133"></a>02133 <span class="keyword">static</span> irqreturn_t ixgbe_msix_lsc(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02134"></a>02134 {
<a name="l02135"></a>02135     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = data;
<a name="l02136"></a>02136     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02137"></a>02137     u32 eicr;
<a name="l02138"></a>02138 
<a name="l02139"></a>02139     <span class="comment">/*</span>
<a name="l02140"></a>02140 <span class="comment">     * Workaround for Silicon errata #26 on 82598.  Use clear-by-write</span>
<a name="l02141"></a>02141 <span class="comment">     * instead of clear-by-read.  Reading with EICS will return the</span>
<a name="l02142"></a>02142 <span class="comment">     * interrupt causes without clearing, which later be done</span>
<a name="l02143"></a>02143 <span class="comment">     * with the write to EICR.</span>
<a name="l02144"></a>02144 <span class="comment">     */</span>
<a name="l02145"></a>02145     eicr = IXGBE_READ_REG(hw, IXGBE_EICS);
<a name="l02146"></a>02146     IXGBE_WRITE_REG(hw, IXGBE_EICR, eicr);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_LSC)
<a name="l02149"></a>02149         ixgbe_check_lsc(adapter);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_MAILBOX)
<a name="l02152"></a>02152         ixgbe_msg_task(adapter);
<a name="l02153"></a>02153 
<a name="l02154"></a>02154     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02155"></a>02155     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02156"></a>02156     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02157"></a>02157         <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_ECC) {
<a name="l02158"></a>02158             e_info(link, <span class="stringliteral">&quot;Received unrecoverable ECC Err, please &quot;</span>
<a name="l02159"></a>02159                    <span class="stringliteral">&quot;reboot\n&quot;</span>);
<a name="l02160"></a>02160             IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_ECC);
<a name="l02161"></a>02161         }
<a name="l02162"></a>02162 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l02163"></a>02163 <span class="preprocessor"></span>        <span class="comment">/* Handle Flow Director Full threshold interrupt */</span>
<a name="l02164"></a>02164         <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_FLOW_DIR) {
<a name="l02165"></a>02165             <span class="keywordtype">int</span> reinit_count = 0;
<a name="l02166"></a>02166             <span class="keywordtype">int</span> i;
<a name="l02167"></a>02167             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l02168"></a>02168                 <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;tx_ring[i];
<a name="l02169"></a>02169                 <span class="keywordflow">if</span> (test_and_clear_bit(__IXGBE_TX_FDIR_INIT_DONE,
<a name="l02170"></a>02170                                &amp;ring-&gt;state))
<a name="l02171"></a>02171                     reinit_count++;
<a name="l02172"></a>02172             }
<a name="l02173"></a>02173             <span class="keywordflow">if</span> (reinit_count) {
<a name="l02174"></a>02174                 <span class="comment">/* no more flow director interrupts until after init */</span>
<a name="l02175"></a>02175                 IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_EIMC_FLOW_DIR);
<a name="l02176"></a>02176                 eicr &amp;= ~IXGBE_EICR_FLOW_DIR;
<a name="l02177"></a>02177                 adapter-&gt;flags2 |= IXGBE_FLAG2_FDIR_REQUIRES_REINIT;
<a name="l02178"></a>02178                 ixgbe_service_event_schedule(adapter);
<a name="l02179"></a>02179             }
<a name="l02180"></a>02180         }
<a name="l02181"></a>02181 <span class="preprocessor">#endif</span>
<a name="l02182"></a>02182 <span class="preprocessor"></span>        ixgbe_check_sfp_event(adapter, eicr);
<a name="l02183"></a>02183         <span class="keywordflow">if</span> ((adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &amp;&amp;
<a name="l02184"></a>02184             ((eicr &amp; IXGBE_EICR_GPI_SDP0) || (eicr &amp; IXGBE_EICR_LSC))) {
<a name="l02185"></a>02185             <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02186"></a>02186                 adapter-&gt;interrupt_event = eicr;
<a name="l02187"></a>02187                 adapter-&gt;flags2 |= IXGBE_FLAG2_TEMP_SENSOR_EVENT;
<a name="l02188"></a>02188                 ixgbe_service_event_schedule(adapter);
<a name="l02189"></a>02189             }
<a name="l02190"></a>02190         }
<a name="l02191"></a>02191         <span class="keywordflow">break</span>;
<a name="l02192"></a>02192     <span class="keywordflow">default</span>:
<a name="l02193"></a>02193         <span class="keywordflow">break</span>;
<a name="l02194"></a>02194     }
<a name="l02195"></a>02195 
<a name="l02196"></a>02196     ixgbe_check_fan_failure(adapter, eicr);
<a name="l02197"></a>02197 
<a name="l02198"></a>02198     <span class="comment">/* re-enable the original interrupt state, no lsc, no queues */</span>
<a name="l02199"></a>02199     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02200"></a>02200         IXGBE_WRITE_REG(hw, IXGBE_EIMS, eicr &amp;
<a name="l02201"></a>02201                         ~(IXGBE_EIMS_LSC | IXGBE_EIMS_RTX_QUEUE));
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02204"></a>02204 }
<a name="l02205"></a>02205 
<a name="l02206"></a>02206 <span class="keywordtype">void</span> ixgbe_irq_enable_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 qmask)
<a name="l02207"></a>02207 {
<a name="l02208"></a>02208     u32 mask;
<a name="l02209"></a>02209     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02210"></a>02210 
<a name="l02211"></a>02211     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02212"></a>02212     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l02213"></a>02213         mask = (IXGBE_EIMS_RTX_QUEUE &amp; qmask);
<a name="l02214"></a>02214         IXGBE_WRITE_REG(hw, IXGBE_EIMS, mask);
<a name="l02215"></a>02215         <span class="keywordflow">break</span>;
<a name="l02216"></a>02216     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02217"></a>02217     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02218"></a>02218         mask = (qmask &amp; 0xFFFFFFFF);
<a name="l02219"></a>02219         <span class="keywordflow">if</span> (mask)
<a name="l02220"></a>02220             IXGBE_WRITE_REG(hw, IXGBE_EIMS_EX(0), mask);
<a name="l02221"></a>02221         mask = (qmask &gt;&gt; 32);
<a name="l02222"></a>02222         <span class="keywordflow">if</span> (mask)
<a name="l02223"></a>02223             IXGBE_WRITE_REG(hw, IXGBE_EIMS_EX(1), mask);
<a name="l02224"></a>02224         <span class="keywordflow">break</span>;
<a name="l02225"></a>02225     <span class="keywordflow">default</span>:
<a name="l02226"></a>02226         <span class="keywordflow">break</span>;
<a name="l02227"></a>02227     }
<a name="l02228"></a>02228     <span class="comment">/* skip the flush */</span>
<a name="l02229"></a>02229 }
<a name="l02230"></a>02230 
<a name="l02231"></a>02231 <span class="keywordtype">void</span> ixgbe_irq_disable_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 qmask)
<a name="l02232"></a>02232 {
<a name="l02233"></a>02233     u32 mask;
<a name="l02234"></a>02234     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02235"></a>02235 
<a name="l02236"></a>02236     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02237"></a>02237     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l02238"></a>02238         mask = (IXGBE_EIMS_RTX_QUEUE &amp; qmask);
<a name="l02239"></a>02239         IXGBE_WRITE_REG(hw, IXGBE_EIMC, mask);
<a name="l02240"></a>02240         <span class="keywordflow">break</span>;
<a name="l02241"></a>02241     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02242"></a>02242     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02243"></a>02243         mask = (qmask &amp; 0xFFFFFFFF);
<a name="l02244"></a>02244         <span class="keywordflow">if</span> (mask)
<a name="l02245"></a>02245             IXGBE_WRITE_REG(hw, IXGBE_EIMC_EX(0), mask);
<a name="l02246"></a>02246         mask = (qmask &gt;&gt; 32);
<a name="l02247"></a>02247         <span class="keywordflow">if</span> (mask)
<a name="l02248"></a>02248             IXGBE_WRITE_REG(hw, IXGBE_EIMC_EX(1), mask);
<a name="l02249"></a>02249         <span class="keywordflow">break</span>;
<a name="l02250"></a>02250     <span class="keywordflow">default</span>:
<a name="l02251"></a>02251         <span class="keywordflow">break</span>;
<a name="l02252"></a>02252     }
<a name="l02253"></a>02253     <span class="comment">/* skip the flush */</span>
<a name="l02254"></a>02254 }
<a name="l02255"></a>02255 
<a name="l02256"></a>02256 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02257"></a>02257 <span class="preprocessor"></span><span class="keyword">static</span> irqreturn_t ixgbe_msix_clean_rings(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02258"></a>02258 {
<a name="l02259"></a>02259     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = data;
<a name="l02260"></a>02260     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>  *adapter = q_vector-&gt;adapter;
<a name="l02261"></a>02261     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a>  *ring;
<a name="l02262"></a>02262     <span class="keywordtype">bool</span> clean_complete = <span class="keyword">true</span>;
<a name="l02263"></a>02263 
<a name="l02264"></a>02264     <span class="keywordflow">if</span> (!q_vector-&gt;tx.ring &amp;&amp; !q_vector-&gt;rx.ring)
<a name="l02265"></a>02265         <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02266"></a>02266 
<a name="l02267"></a>02267     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
<a name="l02268"></a>02268         ixgbe_update_dca(q_vector);
<a name="l02269"></a>02269 
<a name="l02270"></a>02270 <span class="preprocessor">#ifndef ENABLE_DNA</span>
<a name="l02271"></a>02271 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ring = q_vector-&gt;tx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l02272"></a>02272         clean_complete &amp;= !!ixgbe_clean_tx_irq(q_vector, ring,
<a name="l02273"></a>02273                                q_vector-&gt;tx.work_limit);
<a name="l02274"></a>02274 <span class="preprocessor">#endif</span>
<a name="l02275"></a>02275 <span class="preprocessor"></span>
<a name="l02276"></a>02276     <span class="keywordflow">for</span> (ring = q_vector-&gt;rx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l02277"></a>02277         clean_complete &amp;= !!ixgbe_clean_rx_irq(q_vector, ring,
<a name="l02278"></a>02278                                q_vector-&gt;rx.work_limit);
<a name="l02279"></a>02279 
<a name="l02280"></a>02280     <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting &amp; 1)
<a name="l02281"></a>02281         ixgbe_set_itr(q_vector);
<a name="l02282"></a>02282 
<a name="l02283"></a>02283     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02284"></a>02284         u64 eics = ((u64)1 &lt;&lt; q_vector-&gt;v_idx);
<a name="l02285"></a>02285         ixgbe_irq_enable_queues(adapter, eics);
<a name="l02286"></a>02286         <span class="keywordflow">if</span> (!clean_complete)
<a name="l02287"></a>02287             ixgbe_irq_rearm_queues(adapter, eics);
<a name="l02288"></a>02288     }
<a name="l02289"></a>02289 
<a name="l02290"></a>02290     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02291"></a>02291 }
<a name="l02292"></a>02292 <span class="preprocessor">#else </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02293"></a>02293 <span class="keyword">static</span> irqreturn_t ixgbe_msix_clean_rings(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02294"></a>02294 {
<a name="l02295"></a>02295     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = data;
<a name="l02296"></a>02296 
<a name="l02297"></a>02297     <span class="keywordflow">if</span> (!q_vector-&gt;tx.ring &amp;&amp; !q_vector-&gt;rx.ring)
<a name="l02298"></a>02298         <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300     <span class="comment">/* EIAM disabled interrupts (on this vector) for us */</span>
<a name="l02301"></a>02301     napi_schedule(&amp;q_vector-&gt;napi);
<a name="l02302"></a>02302 
<a name="l02303"></a>02303     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02304"></a>02304 }
<a name="l02305"></a>02305 
<a name="l02313"></a>02313 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_poll(<span class="keyword">struct</span> napi_struct *napi, <span class="keywordtype">int</span> budget)
<a name="l02314"></a>02314 {
<a name="l02315"></a>02315     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector =
<a name="l02316"></a>02316                    container_of(napi, <span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a>, napi);
<a name="l02317"></a>02317     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l02318"></a>02318     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring;
<a name="l02319"></a>02319     <span class="keywordtype">int</span> per_ring_budget;
<a name="l02320"></a>02320     <span class="keywordtype">int</span> total_work = 0;
<a name="l02321"></a>02321     <span class="keywordtype">bool</span> clean_complete = <span class="keyword">true</span>;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
<a name="l02324"></a>02324         ixgbe_update_dca(q_vector);
<a name="l02325"></a>02325 
<a name="l02326"></a>02326     <span class="keywordflow">for</span> (ring = q_vector-&gt;tx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l02327"></a>02327         clean_complete &amp;= !!ixgbe_clean_tx_irq(q_vector, ring, budget);
<a name="l02328"></a>02328 
<a name="l02329"></a>02329     <span class="comment">/* attempt to distribute budget to each queue fairly, but don&#39;t allow</span>
<a name="l02330"></a>02330 <span class="comment">     * the budget to go below 1 because we&#39;ll exit polling */</span>
<a name="l02331"></a>02331     <span class="keywordflow">if</span> (q_vector-&gt;rx.count &gt; 1)
<a name="l02332"></a>02332         per_ring_budget = max(budget/q_vector-&gt;rx.count, 1);
<a name="l02333"></a>02333     <span class="keywordflow">else</span>
<a name="l02334"></a>02334         per_ring_budget = budget;
<a name="l02335"></a>02335 
<a name="l02336"></a>02336     <span class="keywordflow">for</span> (ring = q_vector-&gt;rx.ring; ring != NULL; ring = ring-&gt;next)
<a name="l02337"></a>02337         clean_complete &amp;= !!ixgbe_clean_rx_irq(q_vector, ring,
<a name="l02338"></a>02338                                per_ring_budget);
<a name="l02339"></a>02339 
<a name="l02340"></a>02340     <span class="keywordflow">if</span> (!clean_complete)
<a name="l02341"></a>02341         total_work = budget;
<a name="l02342"></a>02342 
<a name="l02343"></a>02343 <span class="preprocessor">#ifndef HAVE_NETDEV_NAPI_LIST</span>
<a name="l02344"></a>02344 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!netif_running(adapter-&gt;netdev))
<a name="l02345"></a>02345         total_work = 0;
<a name="l02346"></a>02346 
<a name="l02347"></a>02347 <span class="preprocessor">#endif</span>
<a name="l02348"></a>02348 <span class="preprocessor"></span>    <span class="comment">/* If all Rx work done, exit the polling mode */</span>
<a name="l02349"></a>02349     <span class="keywordflow">if</span> (total_work &lt; budget) {
<a name="l02350"></a>02350         napi_complete(napi);
<a name="l02351"></a>02351         <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting &amp; 1)
<a name="l02352"></a>02352             ixgbe_set_itr(q_vector);
<a name="l02353"></a>02353         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02354"></a>02354             ixgbe_irq_enable_queues(adapter,
<a name="l02355"></a>02355                         ((u64)1 &lt;&lt; q_vector-&gt;v_idx));
<a name="l02356"></a>02356     }
<a name="l02357"></a>02357 
<a name="l02358"></a>02358     <span class="keywordflow">return</span> total_work;
<a name="l02359"></a>02359 }
<a name="l02360"></a>02360 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02361"></a>02361 
<a name="l02362"></a>02362 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> map_vector_to_rxq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *a, <span class="keywordtype">int</span> v_idx,
<a name="l02363"></a>02363                      <span class="keywordtype">int</span> r_idx)
<a name="l02364"></a>02364 {
<a name="l02365"></a>02365     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = a-&gt;q_vector[v_idx];
<a name="l02366"></a>02366     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = a-&gt;rx_ring[r_idx];
<a name="l02367"></a>02367 
<a name="l02368"></a>02368     rx_ring-&gt;q_vector = q_vector;
<a name="l02369"></a>02369     rx_ring-&gt;next = q_vector-&gt;rx.ring;
<a name="l02370"></a>02370     q_vector-&gt;rx.ring = rx_ring;
<a name="l02371"></a>02371     q_vector-&gt;rx.count++;
<a name="l02372"></a>02372     q_vector-&gt;rx.work_limit = a-&gt;rx_work_limit;
<a name="l02373"></a>02373 }
<a name="l02374"></a>02374 
<a name="l02375"></a>02375 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> map_vector_to_txq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *a, <span class="keywordtype">int</span> v_idx,
<a name="l02376"></a>02376                      <span class="keywordtype">int</span> t_idx)
<a name="l02377"></a>02377 {
<a name="l02378"></a>02378     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = a-&gt;q_vector[v_idx];
<a name="l02379"></a>02379     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = a-&gt;tx_ring[t_idx];
<a name="l02380"></a>02380 
<a name="l02381"></a>02381     tx_ring-&gt;q_vector = q_vector;
<a name="l02382"></a>02382     tx_ring-&gt;next = q_vector-&gt;tx.ring;
<a name="l02383"></a>02383     q_vector-&gt;tx.ring = tx_ring;
<a name="l02384"></a>02384     q_vector-&gt;tx.count++;
<a name="l02385"></a>02385     q_vector-&gt;tx.work_limit = a-&gt;tx_work_limit;
<a name="l02386"></a>02386 }
<a name="l02387"></a>02387 
<a name="l02398"></a>02398 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_map_rings_to_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02399"></a>02399 {
<a name="l02400"></a>02400     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02401"></a>02401     <span class="keywordtype">int</span> rxr_remaining = adapter-&gt;num_rx_queues, rxr_idx = 0;
<a name="l02402"></a>02402     <span class="keywordtype">int</span> txr_remaining = adapter-&gt;num_tx_queues, txr_idx = 0;
<a name="l02403"></a>02403     <span class="keywordtype">int</span> v_start = 0;
<a name="l02404"></a>02404 
<a name="l02405"></a>02405     <span class="comment">/* only one q_vector if MSI-X is disabled. */</span>
<a name="l02406"></a>02406     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l02407"></a>02407         q_vectors = 1;
<a name="l02408"></a>02408 
<a name="l02409"></a>02409     <span class="comment">/*</span>
<a name="l02410"></a>02410 <span class="comment">     * If we don&#39;t have enough vectors for a 1-to-1 mapping, we&#39;ll have to</span>
<a name="l02411"></a>02411 <span class="comment">     * group them so there are multiple queues per vector.</span>
<a name="l02412"></a>02412 <span class="comment">     *</span>
<a name="l02413"></a>02413 <span class="comment">     * Re-adjusting *qpv takes care of the remainder.</span>
<a name="l02414"></a>02414 <span class="comment">     */</span>
<a name="l02415"></a>02415     <span class="keywordflow">for</span> (; v_start &lt; q_vectors &amp;&amp; rxr_remaining; v_start++) {
<a name="l02416"></a>02416         <span class="keywordtype">int</span> rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_start);
<a name="l02417"></a>02417         <span class="keywordflow">for</span> (; rqpv; rqpv--, rxr_idx++, rxr_remaining--)
<a name="l02418"></a>02418             map_vector_to_rxq(adapter, v_start, rxr_idx);
<a name="l02419"></a>02419     }
<a name="l02420"></a>02420 
<a name="l02421"></a>02421     <span class="comment">/*</span>
<a name="l02422"></a>02422 <span class="comment">     * If there are not enough q_vectors for each ring to have it&#39;s own</span>
<a name="l02423"></a>02423 <span class="comment">     * vector then we must pair up Rx/Tx on a each vector</span>
<a name="l02424"></a>02424 <span class="comment">     */</span>
<a name="l02425"></a>02425     <span class="keywordflow">if</span> ((v_start + txr_remaining) &gt; q_vectors)
<a name="l02426"></a>02426         v_start = 0;
<a name="l02427"></a>02427 
<a name="l02428"></a>02428     <span class="keywordflow">for</span> (; v_start &lt; q_vectors &amp;&amp; txr_remaining; v_start++) {
<a name="l02429"></a>02429         <span class="keywordtype">int</span> tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_start);
<a name="l02430"></a>02430         <span class="keywordflow">for</span> (; tqpv; tqpv--, txr_idx++, txr_remaining--)
<a name="l02431"></a>02431             map_vector_to_txq(adapter, v_start, txr_idx);
<a name="l02432"></a>02432     }
<a name="l02433"></a>02433 }
<a name="l02434"></a>02434 
<a name="l02442"></a>02442 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_request_msix_irqs(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02443"></a>02443 {
<a name="l02444"></a>02444     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02445"></a>02445     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02446"></a>02446     <span class="keywordtype">int</span> vector, err;
<a name="l02447"></a>02447     <span class="keywordtype">int</span> ri = 0, ti = 0;
<a name="l02448"></a>02448 
<a name="l02449"></a>02449     <span class="keywordflow">for</span> (vector = 0; vector &lt; q_vectors; vector++) {
<a name="l02450"></a>02450         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[vector];
<a name="l02451"></a>02451 
<a name="l02452"></a>02452         <span class="keywordflow">if</span> (q_vector-&gt;tx.ring &amp;&amp; q_vector-&gt;rx.ring) {
<a name="l02453"></a>02453             snprintf(q_vector-&gt;name, <span class="keyword">sizeof</span>(q_vector-&gt;name) - 1,
<a name="l02454"></a>02454                      <span class="stringliteral">&quot;%s-%s-%d&quot;</span>, netdev-&gt;name, <span class="stringliteral">&quot;TxRx&quot;</span>, ri++);
<a name="l02455"></a>02455             ti++;
<a name="l02456"></a>02456         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (q_vector-&gt;rx.ring) {
<a name="l02457"></a>02457             snprintf(q_vector-&gt;name, <span class="keyword">sizeof</span>(q_vector-&gt;name) - 1,
<a name="l02458"></a>02458                     <span class="stringliteral">&quot;%s-%s-%d&quot;</span>, netdev-&gt;name, <span class="stringliteral">&quot;rx&quot;</span>, ri++);
<a name="l02459"></a>02459         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (q_vector-&gt;tx.ring) {
<a name="l02460"></a>02460             snprintf(q_vector-&gt;name, <span class="keyword">sizeof</span>(q_vector-&gt;name) - 1,
<a name="l02461"></a>02461                     <span class="stringliteral">&quot;%s-%s-%d&quot;</span>, netdev-&gt;name, <span class="stringliteral">&quot;tx&quot;</span>, ti++);
<a name="l02462"></a>02462         } <span class="keywordflow">else</span> {
<a name="l02463"></a>02463             <span class="comment">/* skip this unused q_vector */</span>
<a name="l02464"></a>02464             <span class="keywordflow">continue</span>;
<a name="l02465"></a>02465         }
<a name="l02466"></a>02466         err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02467"></a>02467                   &amp;ixgbe_msix_clean_rings, 0, q_vector-&gt;name,
<a name="l02468"></a>02468                   q_vector);
<a name="l02469"></a>02469         <span class="keywordflow">if</span> (err) {
<a name="l02470"></a>02470             e_err(probe, <span class="stringliteral">&quot;request_irq failed for MSIX interrupt &quot;</span>
<a name="l02471"></a>02471                   <span class="stringliteral">&quot;Error: %d\n&quot;</span>, err);
<a name="l02472"></a>02472             <span class="keywordflow">goto</span> free_queue_irqs;
<a name="l02473"></a>02473         }
<a name="l02474"></a>02474 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l02475"></a>02475 <span class="preprocessor"></span>        <span class="comment">/* If Flow Director is enabled, set interrupt affinity */</span>
<a name="l02476"></a>02476         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) {
<a name="l02477"></a>02477             <span class="comment">/* assign the mask for this irq */</span>
<a name="l02478"></a>02478             irq_set_affinity_hint(adapter-&gt;msix_entries[vector].vector,
<a name="l02479"></a>02479                                   q_vector-&gt;affinity_mask);
<a name="l02480"></a>02480         }
<a name="l02481"></a>02481 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_IRQ_AFFINITY_HINT */</span>
<a name="l02482"></a>02482     }
<a name="l02483"></a>02483 
<a name="l02484"></a>02484     sprintf(adapter-&gt;lsc_int_name, <span class="stringliteral">&quot;%s:lsc&quot;</span>, netdev-&gt;name);
<a name="l02485"></a>02485     err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02486"></a>02486               &amp;ixgbe_msix_lsc, 0, adapter-&gt;lsc_int_name, adapter);
<a name="l02487"></a>02487     <span class="keywordflow">if</span> (err) {
<a name="l02488"></a>02488         e_err(probe, <span class="stringliteral">&quot;request_irq for msix_lsc failed: %d\n&quot;</span>, err);
<a name="l02489"></a>02489         <span class="keywordflow">goto</span> free_queue_irqs;
<a name="l02490"></a>02490     }
<a name="l02491"></a>02491 
<a name="l02492"></a>02492     <span class="keywordflow">return</span> 0;
<a name="l02493"></a>02493 
<a name="l02494"></a>02494 free_queue_irqs:
<a name="l02495"></a>02495     <span class="keywordflow">while</span> (vector) {
<a name="l02496"></a>02496         vector--;
<a name="l02497"></a>02497 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l02498"></a>02498 <span class="preprocessor"></span>        irq_set_affinity_hint(adapter-&gt;msix_entries[vector].vector,
<a name="l02499"></a>02499                       NULL);
<a name="l02500"></a>02500 <span class="preprocessor">#endif</span>
<a name="l02501"></a>02501 <span class="preprocessor"></span>        free_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02502"></a>02502              adapter-&gt;q_vector[vector]);
<a name="l02503"></a>02503     }
<a name="l02504"></a>02504     adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSIX_ENABLED;
<a name="l02505"></a>02505     pci_disable_msix(adapter-&gt;pdev);
<a name="l02506"></a>02506     kfree(adapter-&gt;msix_entries);
<a name="l02507"></a>02507     adapter-&gt;msix_entries = NULL;
<a name="l02508"></a>02508     <span class="keywordflow">return</span> err;
<a name="l02509"></a>02509 }
<a name="l02510"></a>02510 
<a name="l02515"></a>02515 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_irq_enable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, <span class="keywordtype">bool</span> queues, <span class="keywordtype">bool</span> flush)
<a name="l02516"></a>02516 {
<a name="l02517"></a>02517     u64 qmask = ~0;
<a name="l02518"></a>02518     u32 mask = (IXGBE_EIMS_ENABLE_MASK &amp; ~IXGBE_EIMS_RTX_QUEUE);
<a name="l02519"></a>02519 
<a name="l02520"></a>02520     <span class="comment">/* don&#39;t reenable LSC while waiting for link */</span>
<a name="l02521"></a>02521     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_UPDATE)
<a name="l02522"></a>02522         mask &amp;= ~IXGBE_EIMS_LSC;
<a name="l02523"></a>02523 
<a name="l02524"></a>02524     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE)
<a name="l02525"></a>02525         mask |= IXGBE_EIMS_GPI_SDP0;
<a name="l02526"></a>02526     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE)
<a name="l02527"></a>02527         mask |= IXGBE_EIMS_GPI_SDP1;
<a name="l02528"></a>02528     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02529"></a>02529     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02530"></a>02530     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02531"></a>02531         mask |= IXGBE_EIMS_ECC;
<a name="l02532"></a>02532         mask |= IXGBE_EIMS_GPI_SDP1;
<a name="l02533"></a>02533         mask |= IXGBE_EIMS_GPI_SDP2;
<a name="l02534"></a>02534         mask |= IXGBE_EIMS_MAILBOX;
<a name="l02535"></a>02535         <span class="keywordflow">break</span>;
<a name="l02536"></a>02536     <span class="keywordflow">default</span>:
<a name="l02537"></a>02537         <span class="keywordflow">break</span>;
<a name="l02538"></a>02538     }
<a name="l02539"></a>02539     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE)
<a name="l02540"></a>02540         mask |= IXGBE_EIMS_FLOW_DIR;
<a name="l02541"></a>02541 
<a name="l02542"></a>02542     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMS, mask);
<a name="l02543"></a>02543     <span class="keywordflow">if</span> (queues)
<a name="l02544"></a>02544         ixgbe_irq_enable_queues(adapter, qmask);
<a name="l02545"></a>02545     <span class="keywordflow">if</span> (flush)
<a name="l02546"></a>02546         IXGBE_WRITE_FLUSH(&amp;adapter-&gt;hw);
<a name="l02547"></a>02547 
<a name="l02548"></a>02548     <span class="keywordflow">if</span> (adapter-&gt;num_vfs &gt; 32) {
<a name="l02549"></a>02549         u32 eitrsel = (1 &lt;&lt; (adapter-&gt;num_vfs - 32)) - 1;
<a name="l02550"></a>02550         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EITRSEL, eitrsel);
<a name="l02551"></a>02551     }
<a name="l02552"></a>02552 }
<a name="l02553"></a>02553 
<a name="l02559"></a>02559 <span class="keyword">static</span> irqreturn_t ixgbe_intr(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02560"></a>02560 {
<a name="l02561"></a>02561     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = data;
<a name="l02562"></a>02562     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02563"></a>02563     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[0];
<a name="l02564"></a>02564     u32 eicr;
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     <span class="comment">/*</span>
<a name="l02567"></a>02567 <span class="comment">     * Workaround of Silicon errata #26 on 82598.  Mask the interrupt</span>
<a name="l02568"></a>02568 <span class="comment">     * before the read of EICR.</span>
<a name="l02569"></a>02569 <span class="comment">     */</span>
<a name="l02570"></a>02570     IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_IRQ_CLEAR_MASK);
<a name="l02571"></a>02571 
<a name="l02572"></a>02572     <span class="comment">/* for NAPI, using EIAM to auto-mask tx/rx interrupt bits on read</span>
<a name="l02573"></a>02573 <span class="comment">     * therefore no explict interrupt disable is necessary */</span>
<a name="l02574"></a>02574     eicr = IXGBE_READ_REG(hw, IXGBE_EICR);
<a name="l02575"></a>02575     <span class="keywordflow">if</span> (!eicr) {
<a name="l02576"></a>02576         <span class="comment">/*</span>
<a name="l02577"></a>02577 <span class="comment">         * shared interrupt alert!</span>
<a name="l02578"></a>02578 <span class="comment">         * make sure interrupts are enabled because the read will</span>
<a name="l02579"></a>02579 <span class="comment">         * have disabled interrupts due to EIAM</span>
<a name="l02580"></a>02580 <span class="comment">         * finish the workaround of silicon errata #26 on 82598.  Unmask</span>
<a name="l02581"></a>02581 <span class="comment">         * the interrupt that we masked before the EICR read.</span>
<a name="l02582"></a>02582 <span class="comment">         */</span>
<a name="l02583"></a>02583         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02584"></a>02584             ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l02585"></a>02585         <span class="keywordflow">return</span> IRQ_NONE;  <span class="comment">/* Not our interrupt */</span>
<a name="l02586"></a>02586     }
<a name="l02587"></a>02587 
<a name="l02588"></a>02588     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_LSC)
<a name="l02589"></a>02589         ixgbe_check_lsc(adapter);
<a name="l02590"></a>02590 
<a name="l02591"></a>02591     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02592"></a>02592     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02593"></a>02593     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02594"></a>02594         <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_ECC)
<a name="l02595"></a>02595             e_info(link, <span class="stringliteral">&quot;Received unrecoverable ECC Err, please &quot;</span>
<a name="l02596"></a>02596                    <span class="stringliteral">&quot;reboot\n&quot;</span>);
<a name="l02597"></a>02597         ixgbe_check_sfp_event(adapter, eicr);
<a name="l02598"></a>02598         <span class="keywordflow">if</span> ((adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &amp;&amp;
<a name="l02599"></a>02599             ((eicr &amp; IXGBE_EICR_GPI_SDP0) || (eicr &amp; IXGBE_EICR_LSC))) {
<a name="l02600"></a>02600             <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02601"></a>02601                 adapter-&gt;interrupt_event = eicr;
<a name="l02602"></a>02602                 adapter-&gt;flags2 |= IXGBE_FLAG2_TEMP_SENSOR_EVENT;
<a name="l02603"></a>02603                 ixgbe_service_event_schedule(adapter);
<a name="l02604"></a>02604             }
<a name="l02605"></a>02605         }
<a name="l02606"></a>02606         <span class="keywordflow">break</span>;
<a name="l02607"></a>02607     <span class="keywordflow">default</span>:
<a name="l02608"></a>02608         <span class="keywordflow">break</span>;
<a name="l02609"></a>02609     }
<a name="l02610"></a>02610 
<a name="l02611"></a>02611     ixgbe_check_fan_failure(adapter, eicr);
<a name="l02612"></a>02612 
<a name="l02613"></a>02613 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l02614"></a>02614 <span class="preprocessor"></span>    <span class="comment">/* would disable interrupts here but EIAM disabled it */</span>
<a name="l02615"></a>02615     napi_schedule(&amp;q_vector-&gt;napi);
<a name="l02616"></a>02616 
<a name="l02617"></a>02617     <span class="comment">/*</span>
<a name="l02618"></a>02618 <span class="comment">     * re-enable link(maybe) and non-queue interrupts, no flush.</span>
<a name="l02619"></a>02619 <span class="comment">     * ixgbe_poll will re-enable the queue interrupts</span>
<a name="l02620"></a>02620 <span class="comment">     */</span>
<a name="l02621"></a>02621     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02622"></a>02622         ixgbe_irq_enable(adapter, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l02623"></a>02623 <span class="preprocessor">#else</span>
<a name="l02624"></a>02624 <span class="preprocessor"></span>    ixgbe_clean_tx_irq(q_vector, adapter-&gt;tx_ring[0],
<a name="l02625"></a>02625                q_vector-&gt;tx.work_limit);
<a name="l02626"></a>02626     ixgbe_clean_rx_irq(q_vector, adapter-&gt;rx_ring[0],
<a name="l02627"></a>02627                q_vector-&gt;rx.work_limit);
<a name="l02628"></a>02628 
<a name="l02629"></a>02629     <span class="comment">/* dynamically adjust throttle */</span>
<a name="l02630"></a>02630     <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting &amp; 1)
<a name="l02631"></a>02631         ixgbe_set_itr(q_vector);
<a name="l02632"></a>02632 
<a name="l02633"></a>02633     <span class="comment">/*</span>
<a name="l02634"></a>02634 <span class="comment">     * Workaround of Silicon errata #26 on 82598.  Unmask</span>
<a name="l02635"></a>02635 <span class="comment">     * the interrupt that we masked before the EICR read</span>
<a name="l02636"></a>02636 <span class="comment">     * no flush of the re-enable is necessary here</span>
<a name="l02637"></a>02637 <span class="comment">     */</span>
<a name="l02638"></a>02638     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02639"></a>02639         ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">false</span>);
<a name="l02640"></a>02640 <span class="preprocessor">#endif</span>
<a name="l02641"></a>02641 <span class="preprocessor"></span>    <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02642"></a>02642 }
<a name="l02643"></a>02643 
<a name="l02644"></a>02644 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_reset_q_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02645"></a>02645 {
<a name="l02646"></a>02646     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02647"></a>02647     <span class="keywordtype">int</span> i;
<a name="l02648"></a>02648 
<a name="l02649"></a>02649     <span class="comment">/* legacy and MSI only use one vector */</span>
<a name="l02650"></a>02650     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l02651"></a>02651         q_vectors = 1;
<a name="l02652"></a>02652 
<a name="l02653"></a>02653     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l02654"></a>02654         adapter-&gt;rx_ring[i]-&gt;q_vector = NULL;
<a name="l02655"></a>02655         adapter-&gt;rx_ring[i]-&gt;next = NULL;
<a name="l02656"></a>02656     }
<a name="l02657"></a>02657     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l02658"></a>02658         adapter-&gt;tx_ring[i]-&gt;q_vector = NULL;
<a name="l02659"></a>02659         adapter-&gt;tx_ring[i]-&gt;next = NULL;
<a name="l02660"></a>02660     }
<a name="l02661"></a>02661 
<a name="l02662"></a>02662     <span class="keywordflow">for</span> (i = 0; i &lt; q_vectors; i++) {
<a name="l02663"></a>02663         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[i];
<a name="l02664"></a>02664         memset(&amp;q_vector-&gt;rx, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring__container.html">ixgbe_ring_container</a>));
<a name="l02665"></a>02665         memset(&amp;q_vector-&gt;tx, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring__container.html">ixgbe_ring_container</a>));
<a name="l02666"></a>02666         q_vector-&gt;eitr = adapter-&gt;rx_eitr_param;
<a name="l02667"></a>02667     }
<a name="l02668"></a>02668 }
<a name="l02669"></a>02669 
<a name="l02677"></a>02677 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_request_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02678"></a>02678 {
<a name="l02679"></a>02679     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02680"></a>02680     <span class="keywordtype">int</span> err;
<a name="l02681"></a>02681 
<a name="l02682"></a>02682 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l02683"></a>02683 <span class="preprocessor"></span>    e_info(tx_err, <span class="stringliteral">&quot;numa_node before request_irq %d\n&quot;</span>,
<a name="l02684"></a>02684             dev_to_node(&amp;adapter-&gt;pdev-&gt;dev));
<a name="l02685"></a>02685 
<a name="l02686"></a>02686 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l02687"></a>02687     <span class="comment">/* map all of the rings to the q_vectors */</span>
<a name="l02688"></a>02688     ixgbe_map_rings_to_vectors(adapter);
<a name="l02689"></a>02689 
<a name="l02690"></a>02690     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l02691"></a>02691         err = ixgbe_request_msix_irqs(adapter);
<a name="l02692"></a>02692     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED)
<a name="l02693"></a>02693         err = request_irq(adapter-&gt;pdev-&gt;irq, &amp;ixgbe_intr, 0,
<a name="l02694"></a>02694                   netdev-&gt;name, adapter);
<a name="l02695"></a>02695     <span class="keywordflow">else</span>
<a name="l02696"></a>02696         err = request_irq(adapter-&gt;pdev-&gt;irq, &amp;ixgbe_intr, IRQF_SHARED,
<a name="l02697"></a>02697                   netdev-&gt;name, adapter);
<a name="l02698"></a>02698 
<a name="l02699"></a>02699     <span class="keywordflow">if</span> (err) {
<a name="l02700"></a>02700         e_err(probe, <span class="stringliteral">&quot;request_irq failed, Error %d\n&quot;</span>, err);
<a name="l02701"></a>02701 
<a name="l02702"></a>02702         <span class="comment">/* place q_vectors and rings back into a known good state */</span>
<a name="l02703"></a>02703         ixgbe_reset_q_vectors(adapter);
<a name="l02704"></a>02704     }
<a name="l02705"></a>02705 
<a name="l02706"></a>02706     <span class="keywordflow">return</span> err;
<a name="l02707"></a>02707 }
<a name="l02708"></a>02708 
<a name="l02709"></a>02709 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02710"></a>02710 {
<a name="l02711"></a>02711     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l02712"></a>02712         <span class="keywordtype">int</span> i, q_vectors;
<a name="l02713"></a>02713 
<a name="l02714"></a>02714         q_vectors = adapter-&gt;num_msix_vectors;
<a name="l02715"></a>02715         i = q_vectors - 1;
<a name="l02716"></a>02716         free_irq(adapter-&gt;msix_entries[i].vector, adapter);
<a name="l02717"></a>02717         i--;
<a name="l02718"></a>02718 
<a name="l02719"></a>02719         <span class="keywordflow">for</span> (; i &gt;= 0; i--) {
<a name="l02720"></a>02720             <span class="comment">/* free only the irqs that were actually requested */</span>
<a name="l02721"></a>02721             <span class="keywordflow">if</span> (!adapter-&gt;q_vector[i]-&gt;rx.ring &amp;&amp;
<a name="l02722"></a>02722                 !adapter-&gt;q_vector[i]-&gt;tx.ring)
<a name="l02723"></a>02723                 <span class="keywordflow">continue</span>;
<a name="l02724"></a>02724 
<a name="l02725"></a>02725 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l02726"></a>02726 <span class="preprocessor"></span>            <span class="comment">/* clear the affinity_mask in the IRQ descriptor */</span>
<a name="l02727"></a>02727             irq_set_affinity_hint(adapter-&gt;msix_entries[i].vector,
<a name="l02728"></a>02728                           NULL);
<a name="l02729"></a>02729 
<a name="l02730"></a>02730 <span class="preprocessor">#endif</span>
<a name="l02731"></a>02731 <span class="preprocessor"></span>            free_irq(adapter-&gt;msix_entries[i].vector,
<a name="l02732"></a>02732                  adapter-&gt;q_vector[i]);
<a name="l02733"></a>02733         }
<a name="l02734"></a>02734     } <span class="keywordflow">else</span> {
<a name="l02735"></a>02735         free_irq(adapter-&gt;pdev-&gt;irq, adapter);
<a name="l02736"></a>02736     }
<a name="l02737"></a>02737 
<a name="l02738"></a>02738     <span class="comment">/* clear q_vector state information */</span>
<a name="l02739"></a>02739     ixgbe_reset_q_vectors(adapter);
<a name="l02740"></a>02740 }
<a name="l02741"></a>02741 
<a name="l02746"></a>02746 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_irq_disable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02747"></a>02747 {
<a name="l02748"></a>02748     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02749"></a>02749     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l02750"></a>02750         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, ~0);
<a name="l02751"></a>02751         <span class="keywordflow">break</span>;
<a name="l02752"></a>02752     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02753"></a>02753     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02754"></a>02754         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, 0xFFFF0000);
<a name="l02755"></a>02755         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC_EX(0), ~0);
<a name="l02756"></a>02756         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC_EX(1), ~0);
<a name="l02757"></a>02757         <span class="keywordflow">if</span> (adapter-&gt;num_vfs &gt; 32)
<a name="l02758"></a>02758             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EITRSEL, 0);
<a name="l02759"></a>02759         <span class="keywordflow">break</span>;
<a name="l02760"></a>02760     <span class="keywordflow">default</span>:
<a name="l02761"></a>02761         <span class="keywordflow">break</span>;
<a name="l02762"></a>02762     }
<a name="l02763"></a>02763     IXGBE_WRITE_FLUSH(&amp;adapter-&gt;hw);
<a name="l02764"></a>02764     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l02765"></a>02765         <span class="keywordtype">int</span> i;
<a name="l02766"></a>02766         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_msix_vectors; i++)
<a name="l02767"></a>02767             synchronize_irq(adapter-&gt;msix_entries[i].vector);
<a name="l02768"></a>02768     } <span class="keywordflow">else</span> {
<a name="l02769"></a>02769         synchronize_irq(adapter-&gt;pdev-&gt;irq);
<a name="l02770"></a>02770     }
<a name="l02771"></a>02771 }
<a name="l02772"></a>02772 
<a name="l02777"></a>02777 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_msi_and_legacy(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02778"></a>02778 {
<a name="l02779"></a>02779     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02780"></a>02780 
<a name="l02781"></a>02781     IXGBE_WRITE_REG(hw, IXGBE_EITR(0),
<a name="l02782"></a>02782             EITR_INTS_PER_SEC_TO_REG(adapter-&gt;rx_eitr_param));
<a name="l02783"></a>02783 
<a name="l02784"></a>02784     ixgbe_set_ivar(adapter, 0, 0, 0);
<a name="l02785"></a>02785     ixgbe_set_ivar(adapter, 1, 0, 0);
<a name="l02786"></a>02786 
<a name="l02787"></a>02787     e_info(hw, <span class="stringliteral">&quot;Legacy interrupt IVAR setup done\n&quot;</span>);
<a name="l02788"></a>02788 }
<a name="l02789"></a>02789 
<a name="l02797"></a>02797 <span class="keywordtype">void</span> ixgbe_configure_tx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02798"></a>02798                  <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l02799"></a>02799 {
<a name="l02800"></a>02800     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02801"></a>02801     u64 tdba = ring-&gt;dma;
<a name="l02802"></a>02802     <span class="keywordtype">int</span> wait_loop = 10;
<a name="l02803"></a>02803     u32 txdctl = IXGBE_TXDCTL_ENABLE;
<a name="l02804"></a>02804     u8 reg_idx = ring-&gt;reg_idx;
<a name="l02805"></a>02805 
<a name="l02806"></a>02806     <span class="comment">/* disable queue to avoid issues while updating state */</span>
<a name="l02807"></a>02807     IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), 0);
<a name="l02808"></a>02808     IXGBE_WRITE_FLUSH(hw);
<a name="l02809"></a>02809 
<a name="l02810"></a>02810     IXGBE_WRITE_REG(hw, IXGBE_TDBAL(reg_idx),
<a name="l02811"></a>02811             (tdba &amp; DMA_BIT_MASK(32)));
<a name="l02812"></a>02812     IXGBE_WRITE_REG(hw, IXGBE_TDBAH(reg_idx), (tdba &gt;&gt; 32));
<a name="l02813"></a>02813     IXGBE_WRITE_REG(hw, IXGBE_TDLEN(reg_idx),
<a name="l02814"></a>02814             ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a>));
<a name="l02815"></a>02815     IXGBE_WRITE_REG(hw, IXGBE_TDH(reg_idx), 0);
<a name="l02816"></a>02816     IXGBE_WRITE_REG(hw, IXGBE_TDT(reg_idx), 0);
<a name="l02817"></a>02817     ring-&gt;tail = hw-&gt;hw_addr + IXGBE_TDT(reg_idx);
<a name="l02818"></a>02818 
<a name="l02819"></a>02819     <span class="comment">/*</span>
<a name="l02820"></a>02820 <span class="comment">     * set WTHRESH to encourage burst writeback, it should not be set</span>
<a name="l02821"></a>02821 <span class="comment">     * higher than 1 when ITR is 0 as it could cause false TX hangs</span>
<a name="l02822"></a>02822 <span class="comment">     *</span>
<a name="l02823"></a>02823 <span class="comment">     * In order to avoid issues WTHRESH + PTHRESH should always be equal</span>
<a name="l02824"></a>02824 <span class="comment">     * to or less than the number of on chip descriptors, which is</span>
<a name="l02825"></a>02825 <span class="comment">     * currently 40.</span>
<a name="l02826"></a>02826 <span class="comment">     */</span>
<a name="l02827"></a>02827     <span class="comment">/* AHD - what about tx_itr_setting when using seperate TX/RX queues? */</span>
<a name="l02828"></a>02828     <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting == 0)
<a name="l02829"></a>02829         txdctl |= (1 &lt;&lt; 16);    <span class="comment">/* WTHRESH = 1 */</span>
<a name="l02830"></a>02830     <span class="keywordflow">else</span>
<a name="l02831"></a>02831         txdctl |= (8 &lt;&lt; 16);    <span class="comment">/* WTHRESH = 8 */</span>
<a name="l02832"></a>02832 
<a name="l02833"></a>02833     <span class="comment">/* PTHRESH=32 is needed to avoid a Tx hang with DFP enabled. */</span>
<a name="l02834"></a>02834     txdctl |= (1 &lt;&lt; 8) |    <span class="comment">/* HTHRESH = 1 */</span>
<a name="l02835"></a>02835            32;      <span class="comment">/* PTHRESH = 32 */</span>
<a name="l02836"></a>02836 
<a name="l02837"></a>02837     <span class="comment">/* reinitialize flowdirector state */</span>
<a name="l02838"></a>02838     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) &amp;&amp;
<a name="l02839"></a>02839         adapter-&gt;atr_sample_rate) {
<a name="l02840"></a>02840         ring-&gt;atr_sample_rate = adapter-&gt;atr_sample_rate;
<a name="l02841"></a>02841         ring-&gt;atr_count = 0;
<a name="l02842"></a>02842         set_bit(__IXGBE_TX_FDIR_INIT_DONE, &amp;ring-&gt;state);
<a name="l02843"></a>02843     } <span class="keywordflow">else</span> {
<a name="l02844"></a>02844         ring-&gt;atr_sample_rate = 0;
<a name="l02845"></a>02845     }
<a name="l02846"></a>02846 
<a name="l02847"></a>02847     clear_bit(__IXGBE_HANG_CHECK_ARMED, &amp;ring-&gt;state);
<a name="l02848"></a>02848 
<a name="l02849"></a>02849     <span class="comment">/* enable queue */</span>
<a name="l02850"></a>02850     IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), txdctl);
<a name="l02851"></a>02851 
<a name="l02852"></a>02852     <span class="comment">/* TXDCTL.EN will return 0 on 82598 if link is down, so skip it */</span>
<a name="l02853"></a>02853     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB &amp;&amp;
<a name="l02854"></a>02854         !(IXGBE_READ_REG(hw, IXGBE_LINKS) &amp; IXGBE_LINKS_UP))
<a name="l02855"></a>02855         <span class="keywordflow">return</span>;
<a name="l02856"></a>02856 
<a name="l02857"></a>02857     <span class="comment">/* poll to verify queue is enabled */</span>
<a name="l02858"></a>02858     <span class="keywordflow">do</span> {
<a name="l02859"></a>02859         msleep(1);
<a name="l02860"></a>02860         txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(reg_idx));
<a name="l02861"></a>02861     } <span class="keywordflow">while</span> (--wait_loop &amp;&amp; !(txdctl &amp; IXGBE_TXDCTL_ENABLE));
<a name="l02862"></a>02862     <span class="keywordflow">if</span> (!wait_loop)
<a name="l02863"></a>02863         e_err(drv, <span class="stringliteral">&quot;Could not enable Tx Queue %d\n&quot;</span>, reg_idx);
<a name="l02864"></a>02864 }
<a name="l02865"></a>02865 
<a name="l02866"></a>02866 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_mtqc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02867"></a>02867 {
<a name="l02868"></a>02868     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02869"></a>02869     u32 rttdcs;
<a name="l02870"></a>02870     u32 mask;
<a name="l02871"></a>02871 
<a name="l02872"></a>02872     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l02873"></a>02873         <span class="keywordflow">return</span>;
<a name="l02874"></a>02874 
<a name="l02875"></a>02875     <span class="comment">/* disable the arbiter while setting MTQC */</span>
<a name="l02876"></a>02876     rttdcs = IXGBE_READ_REG(hw, IXGBE_RTTDCS);
<a name="l02877"></a>02877     rttdcs |= IXGBE_RTTDCS_ARBDIS;
<a name="l02878"></a>02878     IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, rttdcs);
<a name="l02879"></a>02879 
<a name="l02880"></a>02880     <span class="comment">/* set transmit pool layout */</span>
<a name="l02881"></a>02881     mask = IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_VMDQ_ENABLED;
<a name="l02882"></a>02882     mask |= IXGBE_FLAG_DCB_ENABLED;
<a name="l02883"></a>02883     <span class="keywordflow">switch</span> (adapter-&gt;flags &amp; mask) {
<a name="l02884"></a>02884 
<a name="l02885"></a>02885     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l02886"></a>02886     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED):
<a name="l02887"></a>02887     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l02888"></a>02888         IXGBE_WRITE_REG(hw, IXGBE_MTQC,
<a name="l02889"></a>02889                 (IXGBE_MTQC_VT_ENA | IXGBE_MTQC_64VF));
<a name="l02890"></a>02890         <span class="keywordflow">break</span>;
<a name="l02891"></a>02891     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_DCB_ENABLED):
<a name="l02892"></a>02892     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_DCB_ENABLED):
<a name="l02893"></a>02893     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_VMDQ_ENABLED
<a name="l02894"></a>02894                  | IXGBE_FLAG_DCB_ENABLED):
<a name="l02895"></a>02895         IXGBE_WRITE_REG(hw, IXGBE_MTQC,
<a name="l02896"></a>02896                 (IXGBE_MTQC_RT_ENA
<a name="l02897"></a>02897                     | IXGBE_MTQC_VT_ENA
<a name="l02898"></a>02898                     | IXGBE_MTQC_4TC_4TQ));
<a name="l02899"></a>02899         <span class="keywordflow">break</span>;
<a name="l02900"></a>02900 
<a name="l02901"></a>02901     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED):
<a name="l02902"></a>02902         IXGBE_WRITE_REG(hw, IXGBE_MTQC,
<a name="l02903"></a>02903                 IXGBE_MTQC_RT_ENA | IXGBE_MTQC_8TC_8TQ);
<a name="l02904"></a>02904         <span class="keywordflow">break</span>;
<a name="l02905"></a>02905 
<a name="l02906"></a>02906     <span class="keywordflow">default</span>:
<a name="l02907"></a>02907         IXGBE_WRITE_REG(hw, IXGBE_MTQC, IXGBE_MTQC_64Q_1PB);
<a name="l02908"></a>02908         <span class="keywordflow">break</span>;
<a name="l02909"></a>02909     }
<a name="l02910"></a>02910 
<a name="l02911"></a>02911     <span class="comment">/* re-enable the arbiter */</span>
<a name="l02912"></a>02912     rttdcs &amp;= ~IXGBE_RTTDCS_ARBDIS;
<a name="l02913"></a>02913     IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, rttdcs);
<a name="l02914"></a>02914 }
<a name="l02915"></a>02915 
<a name="l02922"></a>02922 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02923"></a>02923 {
<a name="l02924"></a>02924     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02925"></a>02925     u32 dmatxctl;
<a name="l02926"></a>02926     u32 i;
<a name="l02927"></a>02927 
<a name="l02928"></a>02928 <span class="preprocessor">#ifdef CONFIG_NETDEVICES_MULTIQUEUE</span>
<a name="l02929"></a>02929 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;num_tx_queues &gt; 1)
<a name="l02930"></a>02930         adapter-&gt;netdev-&gt;features |= NETIF_F_MULTI_QUEUE;
<a name="l02931"></a>02931     <span class="keywordflow">else</span>
<a name="l02932"></a>02932         adapter-&gt;netdev-&gt;features &amp;= ~NETIF_F_MULTI_QUEUE;
<a name="l02933"></a>02933 
<a name="l02934"></a>02934 <span class="preprocessor">#endif</span>
<a name="l02935"></a>02935 <span class="preprocessor"></span>    ixgbe_setup_mtqc(adapter);
<a name="l02936"></a>02936 
<a name="l02937"></a>02937     <span class="keywordflow">if</span> (hw-&gt;mac.type != ixgbe_mac_82598EB) {
<a name="l02938"></a>02938         <span class="comment">/* DMATXCTL.EN must be before Tx queues are enabled */</span>
<a name="l02939"></a>02939         dmatxctl = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);
<a name="l02940"></a>02940         dmatxctl |= IXGBE_DMATXCTL_TE;
<a name="l02941"></a>02941         IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, dmatxctl);
<a name="l02942"></a>02942     }
<a name="l02943"></a>02943 
<a name="l02944"></a>02944     <span class="comment">/* Setup the HW Tx Head and Tail descriptor pointers */</span>
<a name="l02945"></a>02945     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l02946"></a>02946         ixgbe_configure_tx_ring(adapter, adapter-&gt;tx_ring[i]);
<a name="l02947"></a>02947 }
<a name="l02948"></a>02948 
<a name="l02949"></a>02949 <span class="preprocessor">#define IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT 2</span>
<a name="l02950"></a>02950 <span class="preprocessor"></span>
<a name="l02951"></a>02951 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_srrctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02952"></a>02952                    <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l02953"></a>02953 {
<a name="l02954"></a>02954     u32 srrctl;
<a name="l02955"></a>02955     u8 reg_idx = rx_ring-&gt;reg_idx;
<a name="l02956"></a>02956 
<a name="l02957"></a>02957     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02958"></a>02958     <span class="keywordflow">case</span> ixgbe_mac_82598EB: {
<a name="l02959"></a>02959         <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *feature = adapter-&gt;ring_feature;
<a name="l02960"></a>02960         <span class="comment">/* program one srrctl register per VMDq index */</span>
<a name="l02961"></a>02961         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l02962"></a>02962             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask;
<a name="l02963"></a>02963             <span class="keywordtype">long</span> shift, len;
<a name="l02964"></a>02964             mask = (<span class="keywordtype">unsigned</span> long) feature[RING_F_VMDQ].mask;
<a name="l02965"></a>02965             len = <span class="keyword">sizeof</span>(feature[RING_F_VMDQ].mask) * 8;
<a name="l02966"></a>02966             shift = find_first_bit(&amp;mask, len);
<a name="l02967"></a>02967             reg_idx = (reg_idx &amp; mask) &gt;&gt; shift;
<a name="l02968"></a>02968         } <span class="keywordflow">else</span> {
<a name="l02969"></a>02969             <span class="comment">/*</span>
<a name="l02970"></a>02970 <span class="comment">             * if VMDq is not active we must program one srrctl</span>
<a name="l02971"></a>02971 <span class="comment">             * register per RSS queue since we have enabled</span>
<a name="l02972"></a>02972 <span class="comment">             * RDRXCTL.MVMEN</span>
<a name="l02973"></a>02973 <span class="comment">             */</span>
<a name="l02974"></a>02974             <span class="keyword">const</span> <span class="keywordtype">int</span> mask = feature[RING_F_RSS].mask;
<a name="l02975"></a>02975             reg_idx = reg_idx &amp; mask;
<a name="l02976"></a>02976         }
<a name="l02977"></a>02977     }
<a name="l02978"></a>02978 
<a name="l02979"></a>02979 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l02980"></a>02980 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(adapter-&gt;num_rx_queues &gt; 1) {
<a name="l02981"></a>02981         <span class="comment">/* We need to set DROPEN on all available queues so that</span>
<a name="l02982"></a>02982 <span class="comment">           when a queue is full, all other queues keep receiving packets</span>
<a name="l02983"></a>02983 <span class="comment">        */</span>
<a name="l02984"></a>02984         u32 i, val, flag = 0, rxctl;
<a name="l02985"></a>02985 
<a name="l02986"></a>02986         <span class="keywordflow">for</span>(i=0; i&lt;adapter-&gt;num_rx_queues; i++) {
<a name="l02987"></a>02987           <span class="keywordflow">if</span>(i == 0)
<a name="l02988"></a>02988         val = 1;
<a name="l02989"></a>02989           <span class="keywordflow">else</span>
<a name="l02990"></a>02990         val = 2 &lt;&lt; (i-1);
<a name="l02991"></a>02991 
<a name="l02992"></a>02992           flag |= val;
<a name="l02993"></a>02993         }
<a name="l02994"></a>02994 
<a name="l02995"></a>02995         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DROPEN, flag);
<a name="l02996"></a>02996 
<a name="l02997"></a>02997         <span class="comment">/* Enable Descriptor Monitor Bypass */</span>
<a name="l02998"></a>02998         rxctl = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL);
<a name="l02999"></a>02999         rxctl |= ~IXGBE_RXCTRL_DMBYPS;
<a name="l03000"></a>03000         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL, rxctl);
<a name="l03001"></a>03001 
<a name="l03002"></a>03002         <span class="keywordflow">if</span>(0)
<a name="l03003"></a>03003           printk(<span class="stringliteral">&quot;[DNA] 82598 [# queues: %u][flag: %02X][RXCTRL: %02X]\n&quot;</span>,
<a name="l03004"></a>03004              adapter-&gt;num_rx_queues, flag, IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL));
<a name="l03005"></a>03005         <span class="comment">/*</span>
<a name="l03006"></a>03006 <span class="comment">          NOTE: this code does not seem to work as it should, thus</span>
<a name="l03007"></a>03007 <span class="comment">          we maintain the dna_clean_rx_irq for 82598</span>
<a name="l03008"></a>03008 <span class="comment">        */</span>
<a name="l03009"></a>03009       }
<a name="l03010"></a>03010 <span class="preprocessor">#endif</span>
<a name="l03011"></a>03011 <span class="preprocessor"></span>
<a name="l03012"></a>03012         <span class="keywordflow">break</span>;
<a name="l03013"></a>03013     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03014"></a>03014     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03015"></a>03015     <span class="keywordflow">default</span>:
<a name="l03016"></a>03016         <span class="keywordflow">break</span>;
<a name="l03017"></a>03017     }
<a name="l03018"></a>03018 
<a name="l03019"></a>03019     srrctl = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_SRRCTL(reg_idx));
<a name="l03020"></a>03020 
<a name="l03021"></a>03021     srrctl &amp;= ~IXGBE_SRRCTL_BSIZEHDR_MASK;
<a name="l03022"></a>03022     srrctl &amp;= ~IXGBE_SRRCTL_BSIZEPKT_MASK;
<a name="l03023"></a>03023 
<a name="l03024"></a>03024     <span class="comment">/* This is used for 82599 to drop packets when a queue is full */</span>
<a name="l03025"></a>03025 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l03026"></a>03026 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(adapter-&gt;hw.mac.type != ixgbe_mac_82598EB)
<a name="l03027"></a>03027       srrctl |= IXGBE_SRRCTL_DROP_EN;
<a name="l03028"></a>03028 <span class="preprocessor">#else</span>
<a name="l03029"></a>03029 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;num_vfs)
<a name="l03030"></a>03030         srrctl |= IXGBE_SRRCTL_DROP_EN;
<a name="l03031"></a>03031 <span class="preprocessor">#endif</span>
<a name="l03032"></a>03032 <span class="preprocessor"></span>
<a name="l03033"></a>03033     srrctl |= (IXGBE_RX_HDR_SIZE &lt;&lt; IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT) &amp;
<a name="l03034"></a>03034            IXGBE_SRRCTL_BSIZEHDR_MASK;
<a name="l03035"></a>03035 
<a name="l03036"></a>03036     <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring)) {
<a name="l03037"></a>03037 <span class="preprocessor">#if (PAGE_SIZE / 2) &gt; IXGBE_MAX_RXBUFFER</span>
<a name="l03038"></a>03038 <span class="preprocessor"></span>        srrctl |= IXGBE_MAX_RXBUFFER &gt;&gt; IXGBE_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03039"></a>03039 <span class="preprocessor">#else</span>
<a name="l03040"></a>03040 <span class="preprocessor"></span>        srrctl |= (PAGE_SIZE / 2) &gt;&gt; IXGBE_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03041"></a>03041 <span class="preprocessor">#endif</span>
<a name="l03042"></a>03042 <span class="preprocessor"></span>        srrctl |= IXGBE_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS;
<a name="l03043"></a>03043     } <span class="keywordflow">else</span> {
<a name="l03044"></a>03044         srrctl |= ALIGN(rx_ring-&gt;rx_buf_len, 1024) &gt;&gt;
<a name="l03045"></a>03045                   IXGBE_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03046"></a>03046         srrctl |= IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF;
<a name="l03047"></a>03047     }
<a name="l03048"></a>03048 
<a name="l03049"></a>03049     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_SRRCTL(reg_idx), srrctl);
<a name="l03050"></a>03050 }
<a name="l03051"></a>03051 
<a name="l03052"></a>03052 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_mrqc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03053"></a>03053 {
<a name="l03054"></a>03054     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03055"></a>03055     <span class="keyword">static</span> <span class="keyword">const</span> u32 seed[10] = { 0xE291D73D, 0x1805EC6C, 0x2A94B30D,
<a name="l03056"></a>03056               0xA54F2BEC, 0xEA49AF7C, 0xE214AD3D, 0xB855AABE,
<a name="l03057"></a>03057               0x6A3E67EA, 0x14364D17, 0x3BED200D};
<a name="l03058"></a>03058     u32 mrqc = 0, reta = 0;
<a name="l03059"></a>03059     u32 rxcsum;
<a name="l03060"></a>03060     <span class="keywordtype">int</span> i, j;
<a name="l03061"></a>03061     <span class="keywordtype">int</span> mask;
<a name="l03062"></a>03062 
<a name="l03063"></a>03063     <span class="comment">/* Fill out hash function seeds */</span>
<a name="l03064"></a>03064     <span class="keywordflow">for</span> (i = 0; i &lt; 10; i++)
<a name="l03065"></a>03065         IXGBE_WRITE_REG(hw, IXGBE_RSSRK(i), seed[i]);
<a name="l03066"></a>03066 
<a name="l03067"></a>03067     <span class="comment">/* Fill out redirection table */</span>
<a name="l03068"></a>03068     <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; 128; i++, j++) {
<a name="l03069"></a>03069         <span class="keywordflow">if</span> (j == adapter-&gt;ring_feature[RING_F_RSS].indices)
<a name="l03070"></a>03070             j = 0;
<a name="l03071"></a>03071         <span class="comment">/* reta = 4-byte sliding window of</span>
<a name="l03072"></a>03072 <span class="comment">         * 0x00..(indices-1)(indices-1)00..etc. */</span>
<a name="l03073"></a>03073         reta = (reta &lt;&lt; 8) | (j * 0x11);
<a name="l03074"></a>03074         <span class="keywordflow">if</span> ((i &amp; 3) == 3)
<a name="l03075"></a>03075             IXGBE_WRITE_REG(hw, IXGBE_RETA(i &gt;&gt; 2), reta);
<a name="l03076"></a>03076     }
<a name="l03077"></a>03077 
<a name="l03078"></a>03078     <span class="comment">/* Disable indicating checksum in descriptor, enables RSS hash */</span>
<a name="l03079"></a>03079     rxcsum = IXGBE_READ_REG(hw, IXGBE_RXCSUM);
<a name="l03080"></a>03080     rxcsum |= IXGBE_RXCSUM_PCSD;
<a name="l03081"></a>03081     IXGBE_WRITE_REG(hw, IXGBE_RXCSUM, rxcsum);
<a name="l03082"></a>03082 
<a name="l03083"></a>03083     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l03084"></a>03084         mask = adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED;
<a name="l03085"></a>03085     <span class="keywordflow">else</span>
<a name="l03086"></a>03086         mask = adapter-&gt;flags &amp; (IXGBE_FLAG_RSS_ENABLED
<a name="l03087"></a>03087                      | IXGBE_FLAG_DCB_ENABLED
<a name="l03088"></a>03088                      | IXGBE_FLAG_VMDQ_ENABLED
<a name="l03089"></a>03089                      | IXGBE_FLAG_SRIOV_ENABLED
<a name="l03090"></a>03090                     );
<a name="l03091"></a>03091 
<a name="l03092"></a>03092     <span class="keywordflow">switch</span> (mask) {
<a name="l03093"></a>03093     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED):
<a name="l03094"></a>03094         mrqc = IXGBE_MRQC_RSSEN;
<a name="l03095"></a>03095         <span class="keywordflow">break</span>;
<a name="l03096"></a>03096     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED):
<a name="l03097"></a>03097         mrqc = IXGBE_MRQC_VMDQEN;
<a name="l03098"></a>03098         <span class="keywordflow">break</span>;
<a name="l03099"></a>03099     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l03100"></a>03100     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_SRIOV_ENABLED):
<a name="l03101"></a>03101         mrqc = IXGBE_MRQC_VMDQEN;
<a name="l03102"></a>03102         <span class="keywordflow">break</span>;
<a name="l03103"></a>03103     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l03104"></a>03104         <span class="keywordflow">if</span> (adapter-&gt;ring_feature[RING_F_RSS].indices == 4)
<a name="l03105"></a>03105             mrqc = IXGBE_MRQC_VMDQRSS32EN;
<a name="l03106"></a>03106         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;ring_feature[RING_F_RSS].indices == 2)
<a name="l03107"></a>03107             mrqc = IXGBE_MRQC_VMDQRSS64EN;
<a name="l03108"></a>03108         <span class="keywordflow">else</span>
<a name="l03109"></a>03109             mrqc = IXGBE_MRQC_VMDQEN;
<a name="l03110"></a>03110         <span class="keywordflow">break</span>;
<a name="l03111"></a>03111     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l03112"></a>03112     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED | IXGBE_FLAG_VMDQ_ENABLED
<a name="l03113"></a>03113                 | IXGBE_FLAG_SRIOV_ENABLED):
<a name="l03114"></a>03114         mrqc = IXGBE_MRQC_VMDQRT4TCEN;  <span class="comment">/* 4 TCs */</span>
<a name="l03115"></a>03115         <span class="keywordflow">break</span>;
<a name="l03116"></a>03116     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED):
<a name="l03117"></a>03117         mrqc = IXGBE_MRQC_RT8TCEN;
<a name="l03118"></a>03118         <span class="keywordflow">break</span>;
<a name="l03119"></a>03119     <span class="keywordflow">default</span>:
<a name="l03120"></a>03120         <span class="keywordflow">break</span>;
<a name="l03121"></a>03121     }
<a name="l03122"></a>03122 
<a name="l03123"></a>03123     <span class="comment">/* Perform hash on these packet types */</span>
<a name="l03124"></a>03124     mrqc |= IXGBE_MRQC_RSS_FIELD_IPV4
<a name="l03125"></a>03125           | IXGBE_MRQC_RSS_FIELD_IPV4_TCP
<a name="l03126"></a>03126           | IXGBE_MRQC_RSS_FIELD_IPV6
<a name="l03127"></a>03127           | IXGBE_MRQC_RSS_FIELD_IPV6_TCP;
<a name="l03128"></a>03128 
<a name="l03129"></a>03129           IXGBE_WRITE_REG(hw, IXGBE_MRQC, mrqc);
<a name="l03130"></a>03130 }
<a name="l03131"></a>03131 
<a name="l03137"></a>03137 <span class="keywordtype">void</span> ixgbe_configure_rscctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03138"></a>03138                 <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03139"></a>03139 {
<a name="l03140"></a>03140     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03141"></a>03141     u32 rscctrl;
<a name="l03142"></a>03142     <span class="keywordtype">int</span> rx_buf_len;
<a name="l03143"></a>03143     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03144"></a>03144 
<a name="l03145"></a>03145     <span class="keywordflow">if</span> (!ring_is_rsc_enabled(ring))
<a name="l03146"></a>03146         <span class="keywordflow">return</span>;
<a name="l03147"></a>03147 
<a name="l03148"></a>03148     rx_buf_len = ring-&gt;rx_buf_len;
<a name="l03149"></a>03149     rscctrl = IXGBE_READ_REG(hw, IXGBE_RSCCTL(reg_idx));
<a name="l03150"></a>03150     rscctrl |= IXGBE_RSCCTL_RSCEN;
<a name="l03151"></a>03151     <span class="comment">/*</span>
<a name="l03152"></a>03152 <span class="comment">     * we must limit the number of descriptors so that</span>
<a name="l03153"></a>03153 <span class="comment">     * the total size of max desc * buf_len is not greater</span>
<a name="l03154"></a>03154 <span class="comment">     * than 65535</span>
<a name="l03155"></a>03155 <span class="comment">     */</span>
<a name="l03156"></a>03156     <span class="keywordflow">if</span> (ring_is_ps_enabled(ring)) {
<a name="l03157"></a>03157 <span class="preprocessor">#if (MAX_SKB_FRAGS &gt; 16)</span>
<a name="l03158"></a>03158 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_16;
<a name="l03159"></a>03159 <span class="preprocessor">#elif (MAX_SKB_FRAGS &gt; 8)</span>
<a name="l03160"></a>03160 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_8;
<a name="l03161"></a>03161 <span class="preprocessor">#elif (MAX_SKB_FRAGS &gt; 4)</span>
<a name="l03162"></a>03162 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_4;
<a name="l03163"></a>03163 <span class="preprocessor">#else</span>
<a name="l03164"></a>03164 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_1;
<a name="l03165"></a>03165 <span class="preprocessor">#endif</span>
<a name="l03166"></a>03166 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l03167"></a>03167         <span class="keywordflow">if</span> (rx_buf_len &lt; IXGBE_RXBUFFER_4096)
<a name="l03168"></a>03168             rscctrl |= IXGBE_RSCCTL_MAXDESC_16;
<a name="l03169"></a>03169         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rx_buf_len &lt; IXGBE_RXBUFFER_8192)
<a name="l03170"></a>03170             rscctrl |= IXGBE_RSCCTL_MAXDESC_8;
<a name="l03171"></a>03171         <span class="keywordflow">else</span>
<a name="l03172"></a>03172             rscctrl |= IXGBE_RSCCTL_MAXDESC_4;
<a name="l03173"></a>03173     }
<a name="l03174"></a>03174 
<a name="l03175"></a>03175     IXGBE_WRITE_REG(hw, IXGBE_RSCCTL(reg_idx), rscctrl);
<a name="l03176"></a>03176 }
<a name="l03177"></a>03177 
<a name="l03183"></a>03183 <span class="keywordtype">void</span> ixgbe_clear_rscctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03184"></a>03184             <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03185"></a>03185 {
<a name="l03186"></a>03186     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03187"></a>03187     u32 rscctrl;
<a name="l03188"></a>03188     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03189"></a>03189 
<a name="l03190"></a>03190     rscctrl = IXGBE_READ_REG(hw, IXGBE_RSCCTL(reg_idx));
<a name="l03191"></a>03191     rscctrl &amp;= ~IXGBE_RSCCTL_RSCEN;
<a name="l03192"></a>03192     IXGBE_WRITE_REG(hw, IXGBE_RSCCTL(reg_idx), rscctrl);
<a name="l03193"></a>03193 
<a name="l03194"></a>03194     clear_ring_rsc_enabled(ring);
<a name="l03195"></a>03195 }
<a name="l03196"></a>03196 
<a name="l03207"></a>03207 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_uta(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03208"></a>03208 {
<a name="l03209"></a>03209     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03210"></a>03210     <span class="keywordtype">int</span> i;
<a name="l03211"></a>03211 
<a name="l03212"></a>03212     <span class="comment">/* The UTA table only exists on 82599 hardware and newer */</span>
<a name="l03213"></a>03213     <span class="keywordflow">if</span> (hw-&gt;mac.type &lt; ixgbe_mac_82599EB)
<a name="l03214"></a>03214         <span class="keywordflow">return</span>;
<a name="l03215"></a>03215 
<a name="l03216"></a>03216     <span class="comment">/* we only need to do this if VMDq is enabled */</span>
<a name="l03217"></a>03217     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp;
<a name="l03218"></a>03218           (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_SRIOV_ENABLED)))
<a name="l03219"></a>03219         <span class="keywordflow">return</span>;
<a name="l03220"></a>03220 
<a name="l03221"></a>03221     <span class="keywordflow">for</span> (i = 0; i &lt; 128; i++)
<a name="l03222"></a>03222         IXGBE_WRITE_REG(hw, IXGBE_UTA(i), ~0);
<a name="l03223"></a>03223 }
<a name="l03224"></a>03224 
<a name="l03225"></a>03225 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_rx_desc_queue_enable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03226"></a>03226                        <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03227"></a>03227 {
<a name="l03228"></a>03228     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03229"></a>03229     <span class="keywordtype">int</span> wait_loop = IXGBE_MAX_RX_DESC_POLL;
<a name="l03230"></a>03230     u32 rxdctl;
<a name="l03231"></a>03231     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03232"></a>03232 
<a name="l03233"></a>03233     <span class="comment">/* RXDCTL.EN will return 0 on 82598 if link is down, so skip it */</span>
<a name="l03234"></a>03234     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB &amp;&amp;
<a name="l03235"></a>03235         !(IXGBE_READ_REG(hw, IXGBE_LINKS) &amp; IXGBE_LINKS_UP))
<a name="l03236"></a>03236         <span class="keywordflow">return</span>;
<a name="l03237"></a>03237 
<a name="l03238"></a>03238     <span class="keywordflow">do</span> {
<a name="l03239"></a>03239         msleep(1);
<a name="l03240"></a>03240         rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03241"></a>03241     } <span class="keywordflow">while</span> (--wait_loop &amp;&amp; !(rxdctl &amp; IXGBE_RXDCTL_ENABLE));
<a name="l03242"></a>03242 
<a name="l03243"></a>03243     <span class="keywordflow">if</span> (!wait_loop) {
<a name="l03244"></a>03244         e_err(drv, <span class="stringliteral">&quot;RXDCTL.ENABLE on Rx queue %d &quot;</span>
<a name="l03245"></a>03245               <span class="stringliteral">&quot;not set within the polling period\n&quot;</span>, reg_idx);
<a name="l03246"></a>03246     }
<a name="l03247"></a>03247 }
<a name="l03248"></a>03248 
<a name="l03249"></a>03249 <span class="keywordtype">void</span> ixgbe_disable_rx_queue(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03250"></a>03250                 <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03251"></a>03251 {
<a name="l03252"></a>03252     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03253"></a>03253     <span class="keywordtype">int</span> wait_loop = IXGBE_MAX_RX_DESC_POLL;
<a name="l03254"></a>03254     u32 rxdctl;
<a name="l03255"></a>03255     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03256"></a>03256 
<a name="l03257"></a>03257     rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03258"></a>03258     rxdctl &amp;= ~IXGBE_RXDCTL_ENABLE;
<a name="l03259"></a>03259 
<a name="l03260"></a>03260     <span class="comment">/* write value back with RXDCTL.ENABLE bit cleared */</span>
<a name="l03261"></a>03261     IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
<a name="l03262"></a>03262 
<a name="l03263"></a>03263     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB &amp;&amp;
<a name="l03264"></a>03264         !(IXGBE_READ_REG(hw, IXGBE_LINKS) &amp; IXGBE_LINKS_UP))
<a name="l03265"></a>03265         <span class="keywordflow">return</span>;
<a name="l03266"></a>03266 
<a name="l03267"></a>03267     <span class="comment">/* the hardware may take up to 100us to really disable the rx queue */</span>
<a name="l03268"></a>03268     <span class="keywordflow">do</span> {
<a name="l03269"></a>03269         udelay(10);
<a name="l03270"></a>03270         rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03271"></a>03271     } <span class="keywordflow">while</span> (--wait_loop &amp;&amp; (rxdctl &amp; IXGBE_RXDCTL_ENABLE));
<a name="l03272"></a>03272 
<a name="l03273"></a>03273     <span class="keywordflow">if</span> (!wait_loop) {
<a name="l03274"></a>03274         e_err(drv, <span class="stringliteral">&quot;RXDCTL.ENABLE on Rx queue %d not cleared within &quot;</span>
<a name="l03275"></a>03275               <span class="stringliteral">&quot;the polling period\n&quot;</span>, reg_idx);
<a name="l03276"></a>03276     }
<a name="l03277"></a>03277 }
<a name="l03278"></a>03278 
<a name="l03279"></a>03279 <span class="keywordtype">void</span> ixgbe_configure_rx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03280"></a>03280                  <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03281"></a>03281 {
<a name="l03282"></a>03282     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03283"></a>03283     u64 rdba = ring-&gt;dma;
<a name="l03284"></a>03284     u32 rxdctl;
<a name="l03285"></a>03285     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03286"></a>03286 
<a name="l03287"></a>03287     <span class="comment">/* disable queue to avoid issues while updating state */</span>
<a name="l03288"></a>03288     rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03289"></a>03289     ixgbe_disable_rx_queue(adapter, ring);
<a name="l03290"></a>03290 
<a name="l03291"></a>03291     IXGBE_WRITE_REG(hw, IXGBE_RDBAL(reg_idx), (rdba &amp; DMA_BIT_MASK(32)));
<a name="l03292"></a>03292     IXGBE_WRITE_REG(hw, IXGBE_RDBAH(reg_idx), (rdba &gt;&gt; 32));
<a name="l03293"></a>03293     IXGBE_WRITE_REG(hw, IXGBE_RDLEN(reg_idx),
<a name="l03294"></a>03294             ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a>));
<a name="l03295"></a>03295     IXGBE_WRITE_REG(hw, IXGBE_RDH(reg_idx), 0);
<a name="l03296"></a>03296     IXGBE_WRITE_REG(hw, IXGBE_RDT(reg_idx), 0);
<a name="l03297"></a>03297     ring-&gt;tail = hw-&gt;hw_addr + IXGBE_RDT(reg_idx);
<a name="l03298"></a>03298 
<a name="l03299"></a>03299     ixgbe_configure_srrctl(adapter, ring);
<a name="l03300"></a>03300     ixgbe_configure_rscctl(adapter, ring);
<a name="l03301"></a>03301 
<a name="l03302"></a>03302     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB) {
<a name="l03303"></a>03303         <span class="comment">/*</span>
<a name="l03304"></a>03304 <span class="comment">         * enable cache line friendly hardware writes:</span>
<a name="l03305"></a>03305 <span class="comment">         * PTHRESH=32 descriptors (half the internal cache),</span>
<a name="l03306"></a>03306 <span class="comment">         * this also removes ugly rx_no_buffer_count increment</span>
<a name="l03307"></a>03307 <span class="comment">         * HTHRESH=4 descriptors (to minimize latency on fetch)</span>
<a name="l03308"></a>03308 <span class="comment">         * WTHRESH=8 burst writeback up to two cache lines</span>
<a name="l03309"></a>03309 <span class="comment">         */</span>
<a name="l03310"></a>03310         rxdctl &amp;= ~0x3FFFFF;
<a name="l03311"></a>03311         rxdctl |=  0x080420;
<a name="l03312"></a>03312     }
<a name="l03313"></a>03313 
<a name="l03314"></a>03314     <span class="comment">/* If operating in IOV mode set RLPML for X540 */</span>
<a name="l03315"></a>03315     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) &amp;&amp;
<a name="l03316"></a>03316         hw-&gt;mac.type == ixgbe_mac_X540) {
<a name="l03317"></a>03317         rxdctl &amp;= ~IXGBE_RXDCTL_RLPMLMASK;
<a name="l03318"></a>03318         rxdctl |= ((ring-&gt;netdev-&gt;mtu + ETH_HLEN +
<a name="l03319"></a>03319                 ETH_FCS_LEN + VLAN_HLEN) | IXGBE_RXDCTL_RLPML_EN);
<a name="l03320"></a>03320     }
<a name="l03321"></a>03321 
<a name="l03322"></a>03322     <span class="comment">/* enable receive descriptor ring */</span>
<a name="l03323"></a>03323     rxdctl |= IXGBE_RXDCTL_ENABLE;
<a name="l03324"></a>03324     IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
<a name="l03325"></a>03325 
<a name="l03326"></a>03326     ixgbe_rx_desc_queue_enable(adapter, ring);
<a name="l03327"></a>03327     ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
<a name="l03328"></a>03328 }
<a name="l03329"></a>03329 
<a name="l03330"></a>03330 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_psrtype(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03331"></a>03331 {
<a name="l03332"></a>03332     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03333"></a>03333     <span class="keywordtype">int</span> p;
<a name="l03334"></a>03334 
<a name="l03335"></a>03335     <span class="comment">/* PSRTYPE must be initialized in non 82598 adapters */</span>
<a name="l03336"></a>03336     u32 psrtype = IXGBE_PSRTYPE_TCPHDR |
<a name="l03337"></a>03337               IXGBE_PSRTYPE_UDPHDR |
<a name="l03338"></a>03338               IXGBE_PSRTYPE_IPV4HDR |
<a name="l03339"></a>03339               IXGBE_PSRTYPE_L2HDR |
<a name="l03340"></a>03340               IXGBE_PSRTYPE_IPV6HDR;
<a name="l03341"></a>03341 
<a name="l03342"></a>03342     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l03343"></a>03343         <span class="keywordflow">return</span>;
<a name="l03344"></a>03344 
<a name="l03345"></a>03345     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED)
<a name="l03346"></a>03346         psrtype |= (adapter-&gt;num_rx_queues_per_pool &lt;&lt; 29);
<a name="l03347"></a>03347 
<a name="l03348"></a>03348     <span class="keywordflow">for</span> (p = 0; p &lt; adapter-&gt;num_rx_pools; p++)
<a name="l03349"></a>03349         IXGBE_WRITE_REG(hw, IXGBE_PSRTYPE(VMDQ_P(p)), psrtype);
<a name="l03350"></a>03350 }
<a name="l03351"></a>03351 
<a name="l03352"></a>03352 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_virtualization(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03353"></a>03353 {
<a name="l03354"></a>03354     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03355"></a>03355     u32 gcr_ext;
<a name="l03356"></a>03356     u32 vt_reg;
<a name="l03357"></a>03357     u32 vt_reg_bits;
<a name="l03358"></a>03358     u32 pool;
<a name="l03359"></a>03359     u32 vmdctl;
<a name="l03360"></a>03360 
<a name="l03361"></a>03361     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED ||
<a name="l03362"></a>03362           adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED))
<a name="l03363"></a>03363         <span class="keywordflow">return</span>;
<a name="l03364"></a>03364 
<a name="l03365"></a>03365     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03366"></a>03366     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03367"></a>03367         vt_reg = IXGBE_VMD_CTL;
<a name="l03368"></a>03368         vt_reg_bits = IXGBE_VMD_CTL_VMDQ_EN;
<a name="l03369"></a>03369         vmdctl = IXGBE_READ_REG(hw, vt_reg);
<a name="l03370"></a>03370         IXGBE_WRITE_REG(hw, vt_reg, vmdctl | vt_reg_bits);
<a name="l03371"></a>03371         <span class="keywordflow">break</span>;
<a name="l03372"></a>03372     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03373"></a>03373     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03374"></a>03374         vt_reg = IXGBE_VT_CTL;
<a name="l03375"></a>03375         vt_reg_bits = IXGBE_VMD_CTL_VMDQ_EN
<a name="l03376"></a>03376                 | IXGBE_VT_CTL_REPLEN;
<a name="l03377"></a>03377         <span class="keywordflow">if</span> (adapter-&gt;num_vfs) {
<a name="l03378"></a>03378             vt_reg_bits &amp;= ~IXGBE_VT_CTL_POOL_MASK;
<a name="l03379"></a>03379             vt_reg_bits |= (adapter-&gt;num_vfs &lt;&lt;
<a name="l03380"></a>03380                     IXGBE_VT_CTL_POOL_SHIFT);
<a name="l03381"></a>03381         }
<a name="l03382"></a>03382         vmdctl = IXGBE_READ_REG(hw, vt_reg);
<a name="l03383"></a>03383         IXGBE_WRITE_REG(hw, vt_reg, vmdctl | vt_reg_bits);
<a name="l03384"></a>03384         <span class="keywordflow">for</span> (pool = 1; pool &lt; adapter-&gt;num_rx_pools; pool++) {
<a name="l03385"></a>03385             u32 vmolr;
<a name="l03386"></a>03386             <span class="keywordtype">int</span> vmdq_pool = VMDQ_P(pool);
<a name="l03387"></a>03387 
<a name="l03388"></a>03388             <span class="comment">/*</span>
<a name="l03389"></a>03389 <span class="comment">            * accept untagged packets until a vlan tag</span>
<a name="l03390"></a>03390 <span class="comment">            * is specifically set for the VMDQ queue/pool</span>
<a name="l03391"></a>03391 <span class="comment">            */</span>
<a name="l03392"></a>03392             vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vmdq_pool));
<a name="l03393"></a>03393             vmolr |= IXGBE_VMOLR_AUPE;
<a name="l03394"></a>03394             vmolr |= IXGBE_VMOLR_BAM;
<a name="l03395"></a>03395             IXGBE_WRITE_REG(hw, IXGBE_VMOLR(vmdq_pool), vmolr);
<a name="l03396"></a>03396         }
<a name="l03397"></a>03397         IXGBE_WRITE_REG(hw, IXGBE_VFRE(0), 0xFFFFFFFF);
<a name="l03398"></a>03398         IXGBE_WRITE_REG(hw, IXGBE_VFRE(1), 0xFFFFFFFF);
<a name="l03399"></a>03399         IXGBE_WRITE_REG(hw, IXGBE_VFTE(0), 0xFFFFFFFF);
<a name="l03400"></a>03400         IXGBE_WRITE_REG(hw, IXGBE_VFTE(1), 0xFFFFFFFF);
<a name="l03401"></a>03401         <span class="keywordflow">break</span>;
<a name="l03402"></a>03402     <span class="keywordflow">default</span>:
<a name="l03403"></a>03403         <span class="keywordflow">break</span>;
<a name="l03404"></a>03404     }
<a name="l03405"></a>03405 
<a name="l03406"></a>03406     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED))
<a name="l03407"></a>03407         <span class="keywordflow">return</span>;
<a name="l03408"></a>03408 
<a name="l03409"></a>03409     <span class="comment">/* Map PF MAC address in RAR Entry 0 to first pool following VFs */</span>
<a name="l03410"></a>03410     hw-&gt;mac.ops.set_vmdq(hw, 0, adapter-&gt;num_vfs);
<a name="l03411"></a>03411 
<a name="l03412"></a>03412     <span class="comment">/*</span>
<a name="l03413"></a>03413 <span class="comment">     * Set up VF register offsets for selected VT Mode,</span>
<a name="l03414"></a>03414 <span class="comment">     * i.e. 32 or 64 VFs for SR-IOV</span>
<a name="l03415"></a>03415 <span class="comment">     */</span>
<a name="l03416"></a>03416     gcr_ext = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);
<a name="l03417"></a>03417     gcr_ext |= IXGBE_GCR_EXT_MSIX_EN;
<a name="l03418"></a>03418     gcr_ext |= IXGBE_GCR_EXT_VT_MODE_64;
<a name="l03419"></a>03419     IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr_ext);
<a name="l03420"></a>03420 
<a name="l03421"></a>03421     <span class="comment">/* enable Tx loopback for VF/PF communication */</span>
<a name="l03422"></a>03422     <span class="keywordflow">if</span> (adapter-&gt;l2loopback_enable)
<a name="l03423"></a>03423         IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);
<a name="l03424"></a>03424     <span class="keywordflow">else</span>
<a name="l03425"></a>03425         IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, 0);
<a name="l03426"></a>03426 
<a name="l03427"></a>03427     hw-&gt;mac.ops.set_mac_anti_spoofing(hw, (adapter-&gt;num_vfs != 0),
<a name="l03428"></a>03428                       adapter-&gt;num_vfs);
<a name="l03429"></a>03429 }
<a name="l03430"></a>03430 
<a name="l03431"></a>03431 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_rx_buffer_len(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03432"></a>03432 {
<a name="l03433"></a>03433     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03434"></a>03434     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l03435"></a>03435     <span class="keywordtype">int</span> max_frame = netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l03436"></a>03436     <span class="keywordtype">int</span> rx_buf_len;
<a name="l03437"></a>03437     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring;
<a name="l03438"></a>03438     <span class="keywordtype">int</span> i;
<a name="l03439"></a>03439     u32 mhadd, hlreg0;
<a name="l03440"></a>03440 
<a name="l03441"></a>03441     <span class="comment">/* Decide whether to use packet split mode or not */</span>
<a name="l03442"></a>03442     <span class="keywordflow">if</span> (netdev-&gt;mtu &gt; ETH_DATA_LEN) {
<a name="l03443"></a>03443         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_PS_CAPABLE)
<a name="l03444"></a>03444             adapter-&gt;flags |= IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03445"></a>03445         <span class="keywordflow">else</span>
<a name="l03446"></a>03446             adapter-&gt;flags &amp;= ~IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03447"></a>03447     } <span class="keywordflow">else</span> {
<a name="l03448"></a>03448         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_1BUF_CAPABLE)
<a name="l03449"></a>03449             adapter-&gt;flags &amp;= ~IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03450"></a>03450         <span class="keywordflow">else</span>
<a name="l03451"></a>03451             adapter-&gt;flags |= IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03452"></a>03452     }
<a name="l03453"></a>03453 
<a name="l03454"></a>03454 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l03455"></a>03455 <span class="preprocessor"></span>    <span class="comment">/* adjust max frame to be able to do baby jumbo for FCoE */</span>
<a name="l03456"></a>03456     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) &amp;&amp;
<a name="l03457"></a>03457         (max_frame &lt; IXGBE_FCOE_JUMBO_FRAME_SIZE))
<a name="l03458"></a>03458         max_frame = IXGBE_FCOE_JUMBO_FRAME_SIZE;
<a name="l03459"></a>03459 
<a name="l03460"></a>03460 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l03461"></a>03461     mhadd = IXGBE_READ_REG(hw, IXGBE_MHADD);
<a name="l03462"></a>03462     <span class="keywordflow">if</span> (max_frame != (mhadd &gt;&gt; IXGBE_MHADD_MFS_SHIFT)) {
<a name="l03463"></a>03463         mhadd &amp;= ~IXGBE_MHADD_MFS_MASK;
<a name="l03464"></a>03464         mhadd |= max_frame &lt;&lt; IXGBE_MHADD_MFS_SHIFT;
<a name="l03465"></a>03465 
<a name="l03466"></a>03466         IXGBE_WRITE_REG(hw, IXGBE_MHADD, mhadd);
<a name="l03467"></a>03467     }
<a name="l03468"></a>03468 
<a name="l03469"></a>03469     <span class="comment">/* MHADD will allow an extra 4 bytes past for vlan tagged frames */</span>
<a name="l03470"></a>03470     max_frame += VLAN_HLEN;
<a name="l03471"></a>03471 
<a name="l03472"></a>03472     <span class="comment">/* Set the RX buffer length according to the mode */</span>
<a name="l03473"></a>03473     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_PS_ENABLED) {
<a name="l03474"></a>03474         rx_buf_len = IXGBE_RX_HDR_SIZE;
<a name="l03475"></a>03475     } <span class="keywordflow">else</span> {
<a name="l03476"></a>03476         <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) &amp;&amp;
<a name="l03477"></a>03477             (max_frame &lt;= MAXIMUM_ETHERNET_VLAN_SIZE))
<a name="l03478"></a>03478             rx_buf_len = MAXIMUM_ETHERNET_VLAN_SIZE;
<a name="l03479"></a>03479         <span class="keywordflow">else</span>
<a name="l03480"></a>03480             rx_buf_len = ALIGN(max_frame, 1024);
<a name="l03481"></a>03481     }
<a name="l03482"></a>03482 
<a name="l03483"></a>03483     hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
<a name="l03484"></a>03484     <span class="comment">/* set jumbo enable since MHADD.MFS is keeping size locked at max_frame */</span>
<a name="l03485"></a>03485     hlreg0 |= IXGBE_HLREG0_JUMBOEN;
<a name="l03486"></a>03486 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l03487"></a>03487 <span class="preprocessor"></span>    hlreg0 &amp;= ~IXGBE_HLREG0_RXCRCSTRP; <span class="comment">/* Disable CRC strip */</span>
<a name="l03488"></a>03488 <span class="preprocessor">#endif</span>
<a name="l03489"></a>03489 <span class="preprocessor"></span>    IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
<a name="l03490"></a>03490 
<a name="l03491"></a>03491     <span class="comment">/*</span>
<a name="l03492"></a>03492 <span class="comment">     * Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<a name="l03493"></a>03493 <span class="comment">     * the Base and Length of the Rx Descriptor Ring</span>
<a name="l03494"></a>03494 <span class="comment">     */</span>
<a name="l03495"></a>03495     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l03496"></a>03496         rx_ring = adapter-&gt;rx_ring[i];
<a name="l03497"></a>03497         rx_ring-&gt;rx_buf_len = rx_buf_len;
<a name="l03498"></a>03498 
<a name="l03499"></a>03499         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_PS_ENABLED)
<a name="l03500"></a>03500             set_ring_ps_enabled(rx_ring);
<a name="l03501"></a>03501         <span class="keywordflow">else</span>
<a name="l03502"></a>03502             clear_ring_ps_enabled(rx_ring);
<a name="l03503"></a>03503 
<a name="l03504"></a>03504         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l03505"></a>03505             set_ring_rsc_enabled(rx_ring);
<a name="l03506"></a>03506 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l03507"></a>03507 <span class="preprocessor"></span>            clear_ring_lro_enabled(rx_ring);
<a name="l03508"></a>03508         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED) {
<a name="l03509"></a>03509             set_ring_lro_enabled(rx_ring);
<a name="l03510"></a>03510             clear_ring_rsc_enabled(rx_ring);
<a name="l03511"></a>03511         } <span class="keywordflow">else</span> {
<a name="l03512"></a>03512             clear_ring_lro_enabled(rx_ring);
<a name="l03513"></a>03513 <span class="preprocessor">#else</span>
<a name="l03514"></a>03514 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l03515"></a>03515 <span class="preprocessor">#endif</span>
<a name="l03516"></a>03516 <span class="preprocessor"></span>            clear_ring_rsc_enabled(rx_ring);
<a name="l03517"></a>03517         }
<a name="l03518"></a>03518 
<a name="l03519"></a>03519 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l03520"></a>03520 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (netdev-&gt;features &amp; NETIF_F_FCOE_MTU) {
<a name="l03521"></a>03521             <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f;
<a name="l03522"></a>03522             f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l03523"></a>03523             <span class="keywordflow">if</span> ((i &gt;= f-&gt;mask) &amp;&amp; (i &lt; f-&gt;mask + f-&gt;indices)) {
<a name="l03524"></a>03524                 clear_ring_ps_enabled(rx_ring);
<a name="l03525"></a>03525                 <span class="keywordflow">if</span> (rx_buf_len &lt; IXGBE_FCOE_JUMBO_FRAME_SIZE)
<a name="l03526"></a>03526                     rx_ring-&gt;rx_buf_len =
<a name="l03527"></a>03527                             IXGBE_FCOE_JUMBO_FRAME_SIZE;
<a name="l03528"></a>03528             }
<a name="l03529"></a>03529         }
<a name="l03530"></a>03530 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l03531"></a>03531     }
<a name="l03532"></a>03532 }
<a name="l03533"></a>03533 
<a name="l03534"></a>03534 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_rdrxctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03535"></a>03535 {
<a name="l03536"></a>03536     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03537"></a>03537     u32 rdrxctl = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
<a name="l03538"></a>03538 
<a name="l03539"></a>03539     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03540"></a>03540     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03541"></a>03541         <span class="comment">/*</span>
<a name="l03542"></a>03542 <span class="comment">         * For VMDq support of different descriptor types or</span>
<a name="l03543"></a>03543 <span class="comment">         * buffer sizes through the use of multiple SRRCTL</span>
<a name="l03544"></a>03544 <span class="comment">         * registers, RDRXCTL.MVMEN must be set to 1</span>
<a name="l03545"></a>03545 <span class="comment">         *</span>
<a name="l03546"></a>03546 <span class="comment">         * also, the manual doesn&#39;t mention it clearly but DCA hints</span>
<a name="l03547"></a>03547 <span class="comment">         * will only use queue 0&#39;s tags unless this bit is set.  Side</span>
<a name="l03548"></a>03548 <span class="comment">         * effects of setting this bit are only that SRRCTL must be</span>
<a name="l03549"></a>03549 <span class="comment">         * fully programmed [0..15]</span>
<a name="l03550"></a>03550 <span class="comment">         */</span>
<a name="l03551"></a>03551         rdrxctl |= IXGBE_RDRXCTL_MVMEN;
<a name="l03552"></a>03552         <span class="keywordflow">break</span>;
<a name="l03553"></a>03553     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03554"></a>03554     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03555"></a>03555         <span class="comment">/* Disable RSC for ACK packets */</span>
<a name="l03556"></a>03556         IXGBE_WRITE_REG(hw, IXGBE_RSCDBU,
<a name="l03557"></a>03557            (IXGBE_RSCDBU_RSCACKDIS | IXGBE_READ_REG(hw, IXGBE_RSCDBU)));
<a name="l03558"></a>03558         rdrxctl &amp;= ~IXGBE_RDRXCTL_RSCFRSTSIZE;
<a name="l03559"></a>03559         <span class="comment">/* hardware requires some bits to be set by default */</span>
<a name="l03560"></a>03560         rdrxctl |= (IXGBE_RDRXCTL_RSCACKC | IXGBE_RDRXCTL_FCOE_WRFIX);
<a name="l03561"></a>03561 <span class="preprocessor">#ifndef ENABLE_DNA</span>
<a name="l03562"></a>03562 <span class="preprocessor"></span>        rdrxctl |= IXGBE_RDRXCTL_CRCSTRIP; <span class="comment">/* Disable CRC strip */</span>
<a name="l03563"></a>03563 <span class="preprocessor">#endif</span>
<a name="l03564"></a>03564 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
<a name="l03565"></a>03565     <span class="keywordflow">default</span>:
<a name="l03566"></a>03566         <span class="comment">/* We should do nothing since we don&#39;t know this hardware */</span>
<a name="l03567"></a>03567         <span class="keywordflow">return</span>;
<a name="l03568"></a>03568     }
<a name="l03569"></a>03569 
<a name="l03570"></a>03570     IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, rdrxctl);
<a name="l03571"></a>03571 }
<a name="l03572"></a>03572 
<a name="l03579"></a>03579 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_rx(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03580"></a>03580 {
<a name="l03581"></a>03581     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03582"></a>03582     <span class="keywordtype">int</span> i;
<a name="l03583"></a>03583     u32 rxctrl;
<a name="l03584"></a>03584 
<a name="l03585"></a>03585     <span class="comment">/* disable receives while setting up the descriptors */</span>
<a name="l03586"></a>03586     rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l03587"></a>03587     IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl &amp; ~IXGBE_RXCTRL_RXEN);
<a name="l03588"></a>03588 
<a name="l03589"></a>03589     ixgbe_setup_psrtype(adapter);
<a name="l03590"></a>03590     ixgbe_setup_rdrxctl(adapter);
<a name="l03591"></a>03591 
<a name="l03592"></a>03592     <span class="comment">/* Program registers for the distribution of queues */</span>
<a name="l03593"></a>03593     ixgbe_setup_mrqc(adapter);
<a name="l03594"></a>03594 
<a name="l03595"></a>03595     ixgbe_set_uta(adapter);
<a name="l03596"></a>03596 
<a name="l03597"></a>03597     <span class="comment">/* set_rx_buffer_len must be called before ring initialization */</span>
<a name="l03598"></a>03598     ixgbe_set_rx_buffer_len(adapter);
<a name="l03599"></a>03599 
<a name="l03600"></a>03600     <span class="comment">/*</span>
<a name="l03601"></a>03601 <span class="comment">     * Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<a name="l03602"></a>03602 <span class="comment">     * the Base and Length of the Rx Descriptor Ring</span>
<a name="l03603"></a>03603 <span class="comment">     */</span>
<a name="l03604"></a>03604     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l03605"></a>03605         ixgbe_configure_rx_ring(adapter, adapter-&gt;rx_ring[i]);
<a name="l03606"></a>03606 
<a name="l03607"></a>03607     <span class="comment">/* disable drop enable for 82598 parts */</span>
<a name="l03608"></a>03608     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l03609"></a>03609         rxctrl |= IXGBE_RXCTRL_DMBYPS;
<a name="l03610"></a>03610 
<a name="l03611"></a>03611     <span class="comment">/* enable all receives */</span>
<a name="l03612"></a>03612     rxctrl |= IXGBE_RXCTRL_RXEN;
<a name="l03613"></a>03613     ixgbe_enable_rx_dma(hw, rxctrl);
<a name="l03614"></a>03614 }
<a name="l03615"></a>03615 
<a name="l03616"></a>03616 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l03617"></a>03617 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_rx_add_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l03618"></a>03618 {
<a name="l03619"></a>03619     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03620"></a>03620     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03621"></a>03621     <span class="keywordtype">int</span> pool_ndx = adapter-&gt;num_vfs;
<a name="l03622"></a>03622 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l03623"></a>03623 <span class="preprocessor"></span>    <span class="keyword">struct </span>net_device *v_netdev;
<a name="l03624"></a>03624 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l03625"></a>03625     <span class="keywordtype">int</span> i;
<a name="l03626"></a>03626 
<a name="l03627"></a>03627         <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_vfta) {
<a name="l03628"></a>03628             hw-&gt;mac.ops.set_vfta(hw, vid, pool_ndx, <span class="keyword">true</span>);
<a name="l03629"></a>03629             <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l03630"></a>03630                 <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l03631"></a>03631                 <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03632"></a>03632                 <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03633"></a>03633                     <span class="comment">/* enable vlan id for all pools */</span>
<a name="l03634"></a>03634                     <span class="keywordflow">for</span> (i = 1; i &lt; adapter-&gt;num_rx_pools; i++) {
<a name="l03635"></a>03635                         hw-&gt;mac.ops.set_vfta(hw, vid, VMDQ_P(i), <span class="keyword">true</span>);
<a name="l03636"></a>03636                     }
<a name="l03637"></a>03637                     <span class="keywordflow">break</span>;
<a name="l03638"></a>03638                 <span class="keywordflow">default</span>:
<a name="l03639"></a>03639                     <span class="keywordflow">break</span>;
<a name="l03640"></a>03640                 }
<a name="l03641"></a>03641             }
<a name="l03642"></a>03642         }
<a name="l03643"></a>03643 
<a name="l03644"></a>03644 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l03645"></a>03645 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l03646"></a>03646 <span class="comment">     * Copy feature flags from netdev to the vlan netdev for this vid.</span>
<a name="l03647"></a>03647 <span class="comment">     * This allows things like TSO to bubble down to our vlan device.</span>
<a name="l03648"></a>03648 <span class="comment">     * Some vlans, such as VLAN 0 for DCB will not have a v_netdev so</span>
<a name="l03649"></a>03649 <span class="comment">     * we will not have a netdev that needs updating.</span>
<a name="l03650"></a>03650 <span class="comment">     */</span>
<a name="l03651"></a>03651     <span class="keywordflow">if</span> (adapter-&gt;vlgrp) {
<a name="l03652"></a>03652         v_netdev = vlan_group_get_device(adapter-&gt;vlgrp, vid);
<a name="l03653"></a>03653         <span class="keywordflow">if</span> (v_netdev) {
<a name="l03654"></a>03654             v_netdev-&gt;features |= adapter-&gt;netdev-&gt;features;
<a name="l03655"></a>03655             vlan_group_set_device(adapter-&gt;vlgrp, vid, v_netdev);
<a name="l03656"></a>03656         }
<a name="l03657"></a>03657     }
<a name="l03658"></a>03658 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l03659"></a>03659 }
<a name="l03660"></a>03660 
<a name="l03661"></a>03661 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_rx_kill_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l03662"></a>03662 {
<a name="l03663"></a>03663     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03664"></a>03664     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03665"></a>03665     <span class="keywordtype">int</span> pool_ndx = adapter-&gt;num_vfs;
<a name="l03666"></a>03666     <span class="keywordtype">int</span> i;
<a name="l03667"></a>03667 
<a name="l03668"></a>03668     <span class="comment">/* User is not allowed to remove vlan ID 0 */</span>
<a name="l03669"></a>03669     <span class="keywordflow">if</span> (!vid)
<a name="l03670"></a>03670         <span class="keywordflow">return</span>;
<a name="l03671"></a>03671 
<a name="l03672"></a>03672     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03673"></a>03673         ixgbe_irq_disable(adapter);
<a name="l03674"></a>03674 
<a name="l03675"></a>03675     vlan_group_set_device(adapter-&gt;vlgrp, vid, NULL);
<a name="l03676"></a>03676 
<a name="l03677"></a>03677     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03678"></a>03678         ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l03679"></a>03679 
<a name="l03680"></a>03680     <span class="comment">/* remove VID from filter table */</span>
<a name="l03681"></a>03681 
<a name="l03682"></a>03682         <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_vfta) {
<a name="l03683"></a>03683             hw-&gt;mac.ops.set_vfta(hw, vid, pool_ndx, <span class="keyword">false</span>);
<a name="l03684"></a>03684             <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l03685"></a>03685                 <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l03686"></a>03686                 <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03687"></a>03687                 <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03688"></a>03688                     <span class="comment">/* remove vlan id from all pools */</span>
<a name="l03689"></a>03689                     <span class="keywordflow">for</span> (i = 1; i &lt; adapter-&gt;num_rx_pools; i++) {
<a name="l03690"></a>03690                         hw-&gt;mac.ops.set_vfta(hw, vid, VMDQ_P(i), <span class="keyword">false</span>);
<a name="l03691"></a>03691                     }
<a name="l03692"></a>03692                     <span class="keywordflow">break</span>;
<a name="l03693"></a>03693                 <span class="keywordflow">default</span>:
<a name="l03694"></a>03694                     <span class="keywordflow">break</span>;
<a name="l03695"></a>03695                 }
<a name="l03696"></a>03696             }
<a name="l03697"></a>03697         }
<a name="l03698"></a>03698 }
<a name="l03699"></a>03699 
<a name="l03700"></a>03700 <span class="preprocessor">#if defined(HAVE_8021P_SUPPORT) || defined(ENABLE_DNA)</span>
<a name="l03701"></a>03701 <span class="preprocessor"></span>
<a name="l03705"></a>03705 <span class="keywordtype">void</span> ixgbe_vlan_stripping_disable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03706"></a>03706 {
<a name="l03707"></a>03707     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03708"></a>03708     u32 vlnctrl;
<a name="l03709"></a>03709     <span class="keywordtype">int</span> i;
<a name="l03710"></a>03710 
<a name="l03711"></a>03711     <span class="comment">/* leave vlan tag stripping enabled for DCB */</span>
<a name="l03712"></a>03712     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)
<a name="l03713"></a>03713         <span class="keywordflow">return</span>;
<a name="l03714"></a>03714 
<a name="l03715"></a>03715     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03716"></a>03716     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03717"></a>03717         vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l03718"></a>03718         vlnctrl &amp;= ~IXGBE_VLNCTRL_VME;
<a name="l03719"></a>03719         IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
<a name="l03720"></a>03720         <span class="keywordflow">break</span>;
<a name="l03721"></a>03721     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03722"></a>03722     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03723"></a>03723         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l03724"></a>03724             u8 reg_idx = adapter-&gt;rx_ring[i]-&gt;reg_idx;
<a name="l03725"></a>03725             vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03726"></a>03726             vlnctrl &amp;= ~IXGBE_RXDCTL_VME;
<a name="l03727"></a>03727             IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), vlnctrl);
<a name="l03728"></a>03728         }
<a name="l03729"></a>03729         <span class="keywordflow">break</span>;
<a name="l03730"></a>03730     <span class="keywordflow">default</span>:
<a name="l03731"></a>03731         <span class="keywordflow">break</span>;
<a name="l03732"></a>03732     }
<a name="l03733"></a>03733 }
<a name="l03734"></a>03734 
<a name="l03735"></a>03735 <span class="preprocessor">#endif</span>
<a name="l03736"></a>03736 <span class="preprocessor"></span>
<a name="l03740"></a>03740 <span class="keywordtype">void</span> ixgbe_vlan_stripping_enable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03741"></a>03741 {
<a name="l03742"></a>03742     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03743"></a>03743     u32 vlnctrl;
<a name="l03744"></a>03744     <span class="keywordtype">int</span> i;
<a name="l03745"></a>03745 
<a name="l03746"></a>03746     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03747"></a>03747     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03748"></a>03748         vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l03749"></a>03749         vlnctrl |= IXGBE_VLNCTRL_VME;
<a name="l03750"></a>03750         IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
<a name="l03751"></a>03751         <span class="keywordflow">break</span>;
<a name="l03752"></a>03752     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03753"></a>03753     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03754"></a>03754         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l03755"></a>03755             u8 reg_idx = adapter-&gt;rx_ring[i]-&gt;reg_idx;
<a name="l03756"></a>03756             vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03757"></a>03757             vlnctrl |= IXGBE_RXDCTL_VME;
<a name="l03758"></a>03758             IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), vlnctrl);
<a name="l03759"></a>03759         }
<a name="l03760"></a>03760         <span class="keywordflow">break</span>;
<a name="l03761"></a>03761     <span class="keywordflow">default</span>:
<a name="l03762"></a>03762         <span class="keywordflow">break</span>;
<a name="l03763"></a>03763     }
<a name="l03764"></a>03764 }
<a name="l03765"></a>03765 
<a name="l03766"></a>03766 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_rx_register(<span class="keyword">struct</span> net_device *netdev,
<a name="l03767"></a>03767                    <span class="keyword">struct</span> vlan_group *grp)
<a name="l03768"></a>03768 {
<a name="l03769"></a>03769     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03770"></a>03770 
<a name="l03771"></a>03771     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03772"></a>03772         ixgbe_irq_disable(adapter);
<a name="l03773"></a>03773     adapter-&gt;vlgrp = grp;
<a name="l03774"></a>03774 
<a name="l03775"></a>03775 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l03776"></a>03776 <span class="preprocessor"></span>    ixgbe_vlan_stripping_disable(adapter);
<a name="l03777"></a>03777 <span class="preprocessor">#else</span>
<a name="l03778"></a>03778 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_8021P_SUPPORT</span>
<a name="l03779"></a>03779 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (grp || (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l03780"></a>03780         <span class="comment">/* enable VLAN tag insert/strip */</span>
<a name="l03781"></a>03781         ixgbe_vlan_stripping_enable(adapter);
<a name="l03782"></a>03782     <span class="keywordflow">else</span>
<a name="l03783"></a>03783         <span class="comment">/* disable VLAN tag insert/strip */</span>
<a name="l03784"></a>03784         ixgbe_vlan_stripping_disable(adapter);
<a name="l03785"></a>03785 
<a name="l03786"></a>03786 <span class="preprocessor">#endif</span>
<a name="l03787"></a>03787 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03788"></a>03788 <span class="preprocessor"></span>
<a name="l03789"></a>03789     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03790"></a>03790         ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l03791"></a>03791 }
<a name="l03792"></a>03792 
<a name="l03793"></a>03793 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_restore_vlan(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03794"></a>03794 {
<a name="l03795"></a>03795     ixgbe_vlan_rx_register(adapter-&gt;netdev, adapter-&gt;vlgrp);
<a name="l03796"></a>03796 
<a name="l03797"></a>03797 <span class="preprocessor">#ifndef HAVE_8021P_SUPPORT</span>
<a name="l03798"></a>03798 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l03799"></a>03799 <span class="comment">     * add vlan ID 0 and enable vlan tag stripping so we</span>
<a name="l03800"></a>03800 <span class="comment">     * always accept priority-tagged traffic</span>
<a name="l03801"></a>03801 <span class="comment">     */</span>
<a name="l03802"></a>03802     ixgbe_vlan_rx_add_vid(adapter-&gt;netdev, 0);
<a name="l03803"></a>03803 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l03804"></a>03804 <span class="preprocessor"></span>    ixgbe_vlan_stripping_disable(adapter);
<a name="l03805"></a>03805 <span class="preprocessor">#else</span>
<a name="l03806"></a>03806 <span class="preprocessor"></span>    ixgbe_vlan_stripping_enable(adapter);
<a name="l03807"></a>03807 <span class="preprocessor">#endif</span>
<a name="l03808"></a>03808 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03809"></a>03809 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;vlgrp) {
<a name="l03810"></a>03810         u16 vid;
<a name="l03811"></a>03811         <span class="keywordflow">for</span> (vid = 0; vid &lt; VLAN_N_VID; vid++) {
<a name="l03812"></a>03812             <span class="keywordflow">if</span> (!vlan_group_get_device(adapter-&gt;vlgrp, vid))
<a name="l03813"></a>03813                 <span class="keywordflow">continue</span>;
<a name="l03814"></a>03814             ixgbe_vlan_rx_add_vid(adapter-&gt;netdev, vid);
<a name="l03815"></a>03815         }
<a name="l03816"></a>03816     }
<a name="l03817"></a>03817 }
<a name="l03818"></a>03818 
<a name="l03819"></a>03819 <span class="preprocessor">#endif</span>
<a name="l03820"></a>03820 <span class="preprocessor"></span><span class="keyword">static</span> u8 *ixgbe_addr_list_itr(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw, u8 **mc_addr_ptr, u32 *vmdq)
<a name="l03821"></a>03821 {
<a name="l03822"></a>03822 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03823"></a>03823 <span class="preprocessor"></span>    <span class="keyword">struct </span>netdev_hw_addr *mc_ptr;
<a name="l03824"></a>03824 <span class="preprocessor">#else</span>
<a name="l03825"></a>03825 <span class="preprocessor"></span>    <span class="keyword">struct </span>dev_mc_list *mc_ptr;
<a name="l03826"></a>03826 <span class="preprocessor">#endif</span>
<a name="l03827"></a>03827 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = hw-&gt;back;
<a name="l03828"></a>03828     u8 *addr = *mc_addr_ptr;
<a name="l03829"></a>03829 
<a name="l03830"></a>03830     *vmdq = adapter-&gt;num_vfs;
<a name="l03831"></a>03831 
<a name="l03832"></a>03832 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03833"></a>03833 <span class="preprocessor"></span>    mc_ptr = container_of(addr, <span class="keyword">struct</span> netdev_hw_addr, addr[0]);
<a name="l03834"></a>03834     <span class="keywordflow">if</span> (mc_ptr-&gt;list.next) {
<a name="l03835"></a>03835         <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03836"></a>03836 
<a name="l03837"></a>03837         ha = list_entry(mc_ptr-&gt;list.next, <span class="keyword">struct</span> netdev_hw_addr, list);
<a name="l03838"></a>03838         *mc_addr_ptr = ha-&gt;addr;
<a name="l03839"></a>03839     }
<a name="l03840"></a>03840 <span class="preprocessor">#else</span>
<a name="l03841"></a>03841 <span class="preprocessor"></span>    mc_ptr = container_of(addr, <span class="keyword">struct</span> dev_mc_list, dmi_addr[0]);
<a name="l03842"></a>03842     <span class="keywordflow">if</span> (mc_ptr-&gt;next)
<a name="l03843"></a>03843         *mc_addr_ptr = mc_ptr-&gt;next-&gt;dmi_addr;
<a name="l03844"></a>03844 <span class="preprocessor">#endif</span>
<a name="l03845"></a>03845 <span class="preprocessor"></span>    <span class="keywordflow">else</span>
<a name="l03846"></a>03846         *mc_addr_ptr = NULL;
<a name="l03847"></a>03847 
<a name="l03848"></a>03848     <span class="keywordflow">return</span> addr;
<a name="l03849"></a>03849 }
<a name="l03850"></a>03850 
<a name="l03860"></a>03860 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_write_mc_addr_list(<span class="keyword">struct</span> net_device *netdev)
<a name="l03861"></a>03861 {
<a name="l03862"></a>03862     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03863"></a>03863     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03864"></a>03864 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03865"></a>03865 <span class="preprocessor"></span>    <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03866"></a>03866 <span class="preprocessor">#endif</span>
<a name="l03867"></a>03867 <span class="preprocessor"></span>    u8  *addr_list = NULL;
<a name="l03868"></a>03868     <span class="keywordtype">int</span> addr_count;
<a name="l03869"></a>03869 
<a name="l03870"></a>03870     <span class="keywordflow">if</span> (netdev_mc_empty(netdev)) {
<a name="l03871"></a>03871         <span class="comment">/* nothing to program, so clear mc list */</span>
<a name="l03872"></a>03872         hw-&gt;mac.ops.update_mc_addr_list(hw, NULL, 0, ixgbe_addr_list_itr);
<a name="l03873"></a>03873         <span class="keywordflow">return</span> 0;
<a name="l03874"></a>03874     }
<a name="l03875"></a>03875 
<a name="l03876"></a>03876     <span class="keywordflow">if</span> (!hw-&gt;mac.ops.update_mc_addr_list)
<a name="l03877"></a>03877         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03878"></a>03878 
<a name="l03879"></a>03879 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03880"></a>03880 <span class="preprocessor"></span>    ha = list_first_entry(&amp;netdev-&gt;mc.list, <span class="keyword">struct</span> netdev_hw_addr, list);
<a name="l03881"></a>03881     addr_list = ha-&gt;addr;
<a name="l03882"></a>03882 <span class="preprocessor">#else</span>
<a name="l03883"></a>03883 <span class="preprocessor"></span>    addr_list = netdev-&gt;mc_list-&gt;dmi_addr;
<a name="l03884"></a>03884 <span class="preprocessor">#endif</span>
<a name="l03885"></a>03885 <span class="preprocessor"></span>    addr_count = netdev_mc_count(netdev);
<a name="l03886"></a>03886 
<a name="l03887"></a>03887     hw-&gt;mac.ops.update_mc_addr_list(hw, addr_list, addr_count, ixgbe_addr_list_itr);
<a name="l03888"></a>03888 
<a name="l03889"></a>03889     <span class="keywordflow">return</span> addr_count;
<a name="l03890"></a>03890 }
<a name="l03891"></a>03891 
<a name="l03892"></a>03892 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l03893"></a>03893 <span class="preprocessor"></span>
<a name="l03902"></a>03902 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_write_uc_addr_list(<span class="keyword">struct</span> net_device *netdev)
<a name="l03903"></a>03903 {
<a name="l03904"></a>03904     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03905"></a>03905     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03906"></a>03906     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vfn = adapter-&gt;num_vfs;
<a name="l03907"></a>03907     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rar_entries = hw-&gt;mac.num_rar_entries - (vfn + 1);
<a name="l03908"></a>03908     <span class="keywordtype">int</span> count = 0;
<a name="l03909"></a>03909 
<a name="l03910"></a>03910     <span class="comment">/* return ENOMEM indicating insufficient memory for addresses */</span>
<a name="l03911"></a>03911     <span class="keywordflow">if</span> (netdev_uc_count(netdev) &gt; rar_entries)
<a name="l03912"></a>03912         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03913"></a>03913 
<a name="l03914"></a>03914     <span class="keywordflow">if</span> (!netdev_uc_empty(netdev) &amp;&amp; rar_entries) {
<a name="l03915"></a>03915 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_UNICAST</span>
<a name="l03916"></a>03916 <span class="preprocessor"></span>        <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03917"></a>03917 <span class="preprocessor">#else</span>
<a name="l03918"></a>03918 <span class="preprocessor"></span>        <span class="keyword">struct </span>dev_mc_list *ha;
<a name="l03919"></a>03919 <span class="preprocessor">#endif</span>
<a name="l03920"></a>03920 <span class="preprocessor"></span>        <span class="comment">/* return error if we do not support writing to RAR table */</span>
<a name="l03921"></a>03921         <span class="keywordflow">if</span> (!hw-&gt;mac.ops.set_rar)
<a name="l03922"></a>03922             <span class="keywordflow">return</span> -ENOMEM;
<a name="l03923"></a>03923 
<a name="l03924"></a>03924         netdev_for_each_uc_addr(ha, netdev) {
<a name="l03925"></a>03925             <span class="keywordflow">if</span> (!rar_entries)
<a name="l03926"></a>03926                 <span class="keywordflow">break</span>;
<a name="l03927"></a>03927 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_UNICAST</span>
<a name="l03928"></a>03928 <span class="preprocessor"></span>            hw-&gt;mac.ops.set_rar(hw, rar_entries--, ha-&gt;addr,
<a name="l03929"></a>03929                         vfn, IXGBE_RAH_AV);
<a name="l03930"></a>03930 <span class="preprocessor">#else</span>
<a name="l03931"></a>03931 <span class="preprocessor"></span>            hw-&gt;mac.ops.set_rar(hw, rar_entries--, ha-&gt;da_addr,
<a name="l03932"></a>03932                         vfn, IXGBE_RAH_AV);
<a name="l03933"></a>03933 <span class="preprocessor">#endif</span>
<a name="l03934"></a>03934 <span class="preprocessor"></span>            count++;
<a name="l03935"></a>03935         }
<a name="l03936"></a>03936     }
<a name="l03937"></a>03937     <span class="comment">/* write the addresses in reverse order to avoid write combining */</span>
<a name="l03938"></a>03938     <span class="keywordflow">for</span> (; rar_entries &gt; 0 ; rar_entries--)
<a name="l03939"></a>03939         hw-&gt;mac.ops.clear_rar(hw, rar_entries);
<a name="l03940"></a>03940 
<a name="l03941"></a>03941     <span class="keywordflow">return</span> count;
<a name="l03942"></a>03942 }
<a name="l03943"></a>03943 
<a name="l03944"></a>03944 <span class="preprocessor">#endif</span>
<a name="l03945"></a>03945 <span class="preprocessor"></span>
<a name="l03954"></a>03954 <span class="keywordtype">void</span> ixgbe_set_rx_mode(<span class="keyword">struct</span> net_device *netdev)
<a name="l03955"></a>03955 {
<a name="l03956"></a>03956     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03957"></a>03957     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03958"></a>03958     u32 fctrl, vmolr = IXGBE_VMOLR_BAM | IXGBE_VMOLR_AUPE;
<a name="l03959"></a>03959     u32 vlnctrl;
<a name="l03960"></a>03960     <span class="keywordtype">int</span> count;
<a name="l03961"></a>03961 
<a name="l03962"></a>03962     <span class="comment">/* Check for Promiscuous and All Multicast modes */</span>
<a name="l03963"></a>03963     fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l03964"></a>03964     vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l03965"></a>03965 
<a name="l03966"></a>03966     <span class="comment">/* set all bits that we expect to always be set */</span>
<a name="l03967"></a>03967     fctrl |= IXGBE_FCTRL_BAM;
<a name="l03968"></a>03968     fctrl |= IXGBE_FCTRL_DPF; <span class="comment">/* discard pause frames when FC enabled */</span>
<a name="l03969"></a>03969     fctrl |= IXGBE_FCTRL_PMCF;
<a name="l03970"></a>03970 
<a name="l03971"></a>03971     <span class="comment">/* clear the bits we are changing the status of */</span>
<a name="l03972"></a>03972     fctrl &amp;= ~(IXGBE_FCTRL_UPE | IXGBE_FCTRL_MPE);
<a name="l03973"></a>03973     vlnctrl  &amp;= ~(IXGBE_VLNCTRL_VFE | IXGBE_VLNCTRL_CFIEN);
<a name="l03974"></a>03974 
<a name="l03975"></a>03975     <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_PROMISC) {
<a name="l03976"></a>03976         hw-&gt;addr_ctrl.user_set_promisc = <span class="keyword">true</span>;
<a name="l03977"></a>03977         fctrl |= (IXGBE_FCTRL_UPE | IXGBE_FCTRL_MPE);
<a name="l03978"></a>03978         vmolr |= IXGBE_VMOLR_MPE;
<a name="l03979"></a>03979     } <span class="keywordflow">else</span> {
<a name="l03980"></a>03980         <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_ALLMULTI) {
<a name="l03981"></a>03981             fctrl |= IXGBE_FCTRL_MPE;
<a name="l03982"></a>03982             vmolr |= IXGBE_VMOLR_MPE;
<a name="l03983"></a>03983         } <span class="keywordflow">else</span> {
<a name="l03984"></a>03984             <span class="comment">/*</span>
<a name="l03985"></a>03985 <span class="comment">             * Write addresses to the MTA, if the attempt fails</span>
<a name="l03986"></a>03986 <span class="comment">             * then we should just turn on promiscous mode so</span>
<a name="l03987"></a>03987 <span class="comment">             * that we can at least receive multicast traffic</span>
<a name="l03988"></a>03988 <span class="comment">             */</span>
<a name="l03989"></a>03989             count = ixgbe_write_mc_addr_list(netdev);
<a name="l03990"></a>03990             <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l03991"></a>03991                 fctrl |= IXGBE_FCTRL_MPE;
<a name="l03992"></a>03992                 vmolr |= IXGBE_VMOLR_MPE;
<a name="l03993"></a>03993             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count) {
<a name="l03994"></a>03994                 vmolr |= IXGBE_VMOLR_ROMPE;
<a name="l03995"></a>03995             }
<a name="l03996"></a>03996         }
<a name="l03997"></a>03997 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l03998"></a>03998 <span class="preprocessor"></span>        <span class="comment">/* enable hardware vlan filtering */</span>
<a name="l03999"></a>03999         vlnctrl |= IXGBE_VLNCTRL_VFE;
<a name="l04000"></a>04000 <span class="preprocessor">#endif</span>
<a name="l04001"></a>04001 <span class="preprocessor"></span>        hw-&gt;addr_ctrl.user_set_promisc = <span class="keyword">false</span>;
<a name="l04002"></a>04002 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l04003"></a>04003 <span class="preprocessor"></span>        <span class="comment">/*</span>
<a name="l04004"></a>04004 <span class="comment">         * Write addresses to available RAR registers, if there is not</span>
<a name="l04005"></a>04005 <span class="comment">         * sufficient space to store all the addresses then enable</span>
<a name="l04006"></a>04006 <span class="comment">         * unicast promiscous mode</span>
<a name="l04007"></a>04007 <span class="comment">         */</span>
<a name="l04008"></a>04008         count = ixgbe_write_uc_addr_list(netdev);
<a name="l04009"></a>04009         <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l04010"></a>04010             fctrl |= IXGBE_FCTRL_UPE;
<a name="l04011"></a>04011             vmolr |= IXGBE_VMOLR_ROPE;
<a name="l04012"></a>04012         }
<a name="l04013"></a>04013 <span class="preprocessor">#endif</span>
<a name="l04014"></a>04014 <span class="preprocessor"></span>    }
<a name="l04015"></a>04015 
<a name="l04016"></a>04016 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l04017"></a>04017 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;num_vfs)
<a name="l04018"></a>04018         ixgbe_restore_vf_multicasts(adapter);
<a name="l04019"></a>04019 
<a name="l04020"></a>04020 <span class="preprocessor">#endif</span>
<a name="l04021"></a>04021 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (hw-&gt;mac.type != ixgbe_mac_82598EB) {
<a name="l04022"></a>04022         vmolr |= IXGBE_READ_REG(hw, IXGBE_VMOLR(adapter-&gt;num_vfs)) &amp;
<a name="l04023"></a>04023              ~(IXGBE_VMOLR_MPE | IXGBE_VMOLR_ROMPE |
<a name="l04024"></a>04024                IXGBE_VMOLR_ROPE);
<a name="l04025"></a>04025         IXGBE_WRITE_REG(hw, IXGBE_VMOLR(adapter-&gt;num_vfs), vmolr);
<a name="l04026"></a>04026     }
<a name="l04027"></a>04027 
<a name="l04028"></a>04028     IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
<a name="l04029"></a>04029     IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
<a name="l04030"></a>04030 }
<a name="l04031"></a>04031 
<a name="l04032"></a>04032 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_napi_enable_all(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04033"></a>04033 {
<a name="l04034"></a>04034 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l04035"></a>04035 <span class="preprocessor"></span>    <span class="keywordtype">int</span> q_idx;
<a name="l04036"></a>04036     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l04037"></a>04037     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l04038"></a>04038 
<a name="l04039"></a>04039     <span class="comment">/* legacy and MSI only use one vector */</span>
<a name="l04040"></a>04040     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l04041"></a>04041         q_vectors = 1;
<a name="l04042"></a>04042 
<a name="l04043"></a>04043     <span class="keywordflow">for</span> (q_idx = 0; q_idx &lt; q_vectors; q_idx++) {
<a name="l04044"></a>04044         q_vector = adapter-&gt;q_vector[q_idx];
<a name="l04045"></a>04045 
<a name="l04046"></a>04046         napi_enable(&amp;q_vector-&gt;napi);
<a name="l04047"></a>04047     }
<a name="l04048"></a>04048 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l04049"></a>04049 }
<a name="l04050"></a>04050 
<a name="l04051"></a>04051 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_napi_disable_all(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04052"></a>04052 {
<a name="l04053"></a>04053 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l04054"></a>04054 <span class="preprocessor"></span>    <span class="keywordtype">int</span> q_idx;
<a name="l04055"></a>04055     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l04056"></a>04056     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l04057"></a>04057 
<a name="l04058"></a>04058     <span class="comment">/* legacy and MSI only use one vector */</span>
<a name="l04059"></a>04059     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l04060"></a>04060         q_vectors = 1;
<a name="l04061"></a>04061 
<a name="l04062"></a>04062     <span class="keywordflow">for</span> (q_idx = 0; q_idx &lt; q_vectors; q_idx++) {
<a name="l04063"></a>04063         q_vector = adapter-&gt;q_vector[q_idx];
<a name="l04064"></a>04064         napi_disable(&amp;q_vector-&gt;napi);
<a name="l04065"></a>04065     }
<a name="l04066"></a>04066 <span class="preprocessor">#endif</span>
<a name="l04067"></a>04067 <span class="preprocessor"></span>}
<a name="l04068"></a>04068 
<a name="l04069"></a>04069 <span class="comment">/*</span>
<a name="l04070"></a>04070 <span class="comment"> * ixgbe_configure_dcb - Configure DCB hardware</span>
<a name="l04071"></a>04071 <span class="comment"> * @adapter: ixgbe adapter struct</span>
<a name="l04072"></a>04072 <span class="comment"> *</span>
<a name="l04073"></a>04073 <span class="comment"> * This is called by the driver on open to configure the DCB hardware.</span>
<a name="l04074"></a>04074 <span class="comment"> * This is also called by the gennetlink interface when reconfiguring</span>
<a name="l04075"></a>04075 <span class="comment"> * the DCB state.</span>
<a name="l04076"></a>04076 <span class="comment"> */</span>
<a name="l04077"></a>04077 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_dcb(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04078"></a>04078 {
<a name="l04079"></a>04079     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04080"></a>04080     u32 max_frame = adapter-&gt;netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l04081"></a>04081 
<a name="l04082"></a>04082     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
<a name="l04083"></a>04083         adapter-&gt;dcb_cfg.fdir_pballoc = adapter-&gt;fdir_pballoc;
<a name="l04084"></a>04084     <span class="keywordflow">else</span>
<a name="l04085"></a>04085         adapter-&gt;dcb_cfg.fdir_pballoc = 0;
<a name="l04086"></a>04086 
<a name="l04087"></a>04087     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)) {
<a name="l04088"></a>04088         <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l04089"></a>04089             netif_set_gso_max_size(adapter-&gt;netdev, 65536);
<a name="l04090"></a>04090         <span class="keywordflow">return</span>;
<a name="l04091"></a>04091     }
<a name="l04092"></a>04092 
<a name="l04093"></a>04093     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l04094"></a>04094         netif_set_gso_max_size(adapter-&gt;netdev, 32768);
<a name="l04095"></a>04095 
<a name="l04096"></a>04096 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l04097"></a>04097 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;features &amp; NETIF_F_FCOE_MTU)
<a name="l04098"></a>04098         max_frame = max_t(<span class="keywordtype">int</span>, max_frame,
<a name="l04099"></a>04099                   IXGBE_FCOE_JUMBO_FRAME_SIZE);
<a name="l04100"></a>04100 <span class="preprocessor">#endif</span>
<a name="l04101"></a>04101 <span class="preprocessor"></span>
<a name="l04102"></a>04102     adapter-&gt;dcb_cfg.num_tcs.pg_tcs = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l04103"></a>04103     ixgbe_dcb_calculate_tc_credits(hw, &amp;adapter-&gt;dcb_cfg, max_frame,
<a name="l04104"></a>04104                        DCB_TX_CONFIG);
<a name="l04105"></a>04105     ixgbe_dcb_calculate_tc_credits(hw, &amp;adapter-&gt;dcb_cfg, max_frame,
<a name="l04106"></a>04106                        DCB_RX_CONFIG);
<a name="l04107"></a>04107 
<a name="l04108"></a>04108     <span class="comment">/* reconfigure the hardware */</span>
<a name="l04109"></a>04109     ixgbe_dcb_hw_config(hw, &amp;adapter-&gt;dcb_cfg);
<a name="l04110"></a>04110 }
<a name="l04111"></a>04111 
<a name="l04112"></a>04112 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l04113"></a>04113 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_lli_82599(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04114"></a>04114 {
<a name="l04115"></a>04115     u16 port;
<a name="l04116"></a>04116 
<a name="l04117"></a>04117     <span class="keywordflow">if</span> (adapter-&gt;lli_etype) {
<a name="l04118"></a>04118         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04119"></a>04119                         (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04120"></a>04120                          IXGBE_IMIR_CTRL_BP_82599));
<a name="l04121"></a>04121         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_ETQS(0), IXGBE_ETQS_LLI);
<a name="l04122"></a>04122         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_ETQF(0),
<a name="l04123"></a>04123                         (adapter-&gt;lli_etype | IXGBE_ETQF_FILTER_EN));
<a name="l04124"></a>04124     }
<a name="l04125"></a>04125 
<a name="l04126"></a>04126     <span class="keywordflow">if</span> (adapter-&gt;lli_port) {
<a name="l04127"></a>04127         port = swab16(adapter-&gt;lli_port);
<a name="l04128"></a>04128         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04129"></a>04129                         (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04130"></a>04130                          IXGBE_IMIR_CTRL_BP_82599));
<a name="l04131"></a>04131         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FTQF(0),
<a name="l04132"></a>04132                         (IXGBE_FTQF_POOL_MASK_EN |
<a name="l04133"></a>04133                          (IXGBE_FTQF_PRIORITY_MASK &lt;&lt;
<a name="l04134"></a>04134                           IXGBE_FTQF_PRIORITY_SHIFT) |
<a name="l04135"></a>04135                          (IXGBE_FTQF_DEST_PORT_MASK &lt;&lt;
<a name="l04136"></a>04136                           IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
<a name="l04137"></a>04137         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_SDPQF(0), (port &lt;&lt; 16));
<a name="l04138"></a>04138     }
<a name="l04139"></a>04139 
<a name="l04140"></a>04140     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_LLI_PUSH) {
<a name="l04141"></a>04141         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l04142"></a>04142         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04143"></a>04143             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04144"></a>04144                             (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04145"></a>04145                              IXGBE_IMIR_CTRL_PSH_82599 | IXGBE_IMIR_CTRL_SYN_82599 |
<a name="l04146"></a>04146                              IXGBE_IMIR_CTRL_URG_82599 | IXGBE_IMIR_CTRL_ACK_82599 |
<a name="l04147"></a>04147                              IXGBE_IMIR_CTRL_RST_82599 | IXGBE_IMIR_CTRL_FIN_82599));
<a name="l04148"></a>04148             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_LLITHRESH, 0xfc000000);
<a name="l04149"></a>04149             <span class="keywordflow">break</span>;
<a name="l04150"></a>04150         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04151"></a>04151             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04152"></a>04152                             (IXGBE_IMIR_LLI_EN_82599 |
<a name="l04153"></a>04153                              IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04154"></a>04154                              IXGBE_IMIR_CTRL_PSH_82599));
<a name="l04155"></a>04155             <span class="keywordflow">break</span>;
<a name="l04156"></a>04156         <span class="keywordflow">default</span>:
<a name="l04157"></a>04157             <span class="keywordflow">break</span>;
<a name="l04158"></a>04158         }
<a name="l04159"></a>04159         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FTQF(0),
<a name="l04160"></a>04160                         (IXGBE_FTQF_POOL_MASK_EN |
<a name="l04161"></a>04161                          (IXGBE_FTQF_PRIORITY_MASK &lt;&lt;
<a name="l04162"></a>04162                           IXGBE_FTQF_PRIORITY_SHIFT) |
<a name="l04163"></a>04163                          (IXGBE_FTQF_5TUPLE_MASK_MASK &lt;&lt;
<a name="l04164"></a>04164                           IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
<a name="l04165"></a>04165 
<a name="l04166"></a>04166         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_SYNQF, 0x80000100);
<a name="l04167"></a>04167     }
<a name="l04168"></a>04168 
<a name="l04169"></a>04169     <span class="keywordflow">if</span> (adapter-&gt;lli_size) {
<a name="l04170"></a>04170         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04171"></a>04171                         (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_CTRL_BP_82599));
<a name="l04172"></a>04172         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_LLITHRESH, adapter-&gt;lli_size);
<a name="l04173"></a>04173         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FTQF(0),
<a name="l04174"></a>04174                         (IXGBE_FTQF_POOL_MASK_EN |
<a name="l04175"></a>04175                          (IXGBE_FTQF_PRIORITY_MASK &lt;&lt;
<a name="l04176"></a>04176                           IXGBE_FTQF_PRIORITY_SHIFT) |
<a name="l04177"></a>04177                          (IXGBE_FTQF_5TUPLE_MASK_MASK &lt;&lt;
<a name="l04178"></a>04178                           IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
<a name="l04179"></a>04179     }
<a name="l04180"></a>04180 
<a name="l04181"></a>04181     <span class="keywordflow">if</span> (adapter-&gt;lli_vlan_pri) {
<a name="l04182"></a>04182         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIRVP,
<a name="l04183"></a>04183                         (IXGBE_IMIRVP_PRIORITY_EN | adapter-&gt;lli_vlan_pri));
<a name="l04184"></a>04184     }
<a name="l04185"></a>04185 }
<a name="l04186"></a>04186 
<a name="l04187"></a>04187 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_lli(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04188"></a>04188 {
<a name="l04189"></a>04189     u16 port;
<a name="l04190"></a>04190 
<a name="l04191"></a>04191     <span class="comment">/* lli should only be enabled with MSI-X and MSI */</span>
<a name="l04192"></a>04192     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED) &amp;&amp;
<a name="l04193"></a>04193         !(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l04194"></a>04194         <span class="keywordflow">return</span>;
<a name="l04195"></a>04195 
<a name="l04196"></a>04196     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type != ixgbe_mac_82598EB) {
<a name="l04197"></a>04197         ixgbe_configure_lli_82599(adapter);
<a name="l04198"></a>04198         <span class="keywordflow">return</span>;
<a name="l04199"></a>04199     }
<a name="l04200"></a>04200 
<a name="l04201"></a>04201     <span class="keywordflow">if</span> (adapter-&gt;lli_port) {
<a name="l04202"></a>04202         <span class="comment">/* use filter 0 for port */</span>
<a name="l04203"></a>04203         port = swab16(adapter-&gt;lli_port);
<a name="l04204"></a>04204         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIR(0),
<a name="l04205"></a>04205                         (port | IXGBE_IMIR_PORT_IM_EN));
<a name="l04206"></a>04206         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIREXT(0),
<a name="l04207"></a>04207                         (IXGBE_IMIREXT_SIZE_BP |
<a name="l04208"></a>04208                          IXGBE_IMIREXT_CTRL_BP));
<a name="l04209"></a>04209     }
<a name="l04210"></a>04210 
<a name="l04211"></a>04211     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_LLI_PUSH) {
<a name="l04212"></a>04212         <span class="comment">/* use filter 1 for push flag */</span>
<a name="l04213"></a>04213         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIR(1),
<a name="l04214"></a>04214                         (IXGBE_IMIR_PORT_BP | IXGBE_IMIR_PORT_IM_EN));
<a name="l04215"></a>04215         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIREXT(1),
<a name="l04216"></a>04216                         (IXGBE_IMIREXT_SIZE_BP |
<a name="l04217"></a>04217                          IXGBE_IMIREXT_CTRL_PSH));
<a name="l04218"></a>04218     }
<a name="l04219"></a>04219 
<a name="l04220"></a>04220     <span class="keywordflow">if</span> (adapter-&gt;lli_size) {
<a name="l04221"></a>04221         <span class="comment">/* use filter 2 for size */</span>
<a name="l04222"></a>04222         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIR(2),
<a name="l04223"></a>04223                         (IXGBE_IMIR_PORT_BP | IXGBE_IMIR_PORT_IM_EN));
<a name="l04224"></a>04224         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIREXT(2),
<a name="l04225"></a>04225                         (adapter-&gt;lli_size | IXGBE_IMIREXT_CTRL_BP));
<a name="l04226"></a>04226     }
<a name="l04227"></a>04227 }
<a name="l04228"></a>04228 
<a name="l04229"></a>04229 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LLI */</span>
<a name="l04230"></a>04230 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l04231"></a>04231 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_fdir_filter_restore(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04232"></a>04232 {
<a name="l04233"></a>04233     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04234"></a>04234     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l04235"></a>04235     <span class="keyword">struct </span><a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *filter;
<a name="l04236"></a>04236 
<a name="l04237"></a>04237     spin_lock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l04238"></a>04238 
<a name="l04239"></a>04239     <span class="keywordflow">if</span> (!hlist_empty(&amp;adapter-&gt;fdir_filter_list))
<a name="l04240"></a>04240         ixgbe_fdir_set_input_mask_82599(hw, &amp;adapter-&gt;fdir_mask);
<a name="l04241"></a>04241 
<a name="l04242"></a>04242     hlist_for_each_entry_safe(filter, node, node2,
<a name="l04243"></a>04243                   &amp;adapter-&gt;fdir_filter_list, fdir_node) {
<a name="l04244"></a>04244         ixgbe_fdir_write_perfect_filter_82599(hw,
<a name="l04245"></a>04245                               &amp;filter-&gt;filter,
<a name="l04246"></a>04246                               filter-&gt;sw_idx,
<a name="l04247"></a>04247                               filter-&gt;action);
<a name="l04248"></a>04248     }
<a name="l04249"></a>04249 
<a name="l04250"></a>04250     spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l04251"></a>04251 }
<a name="l04252"></a>04252 
<a name="l04253"></a>04253 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l04254"></a>04254 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04255"></a>04255 {
<a name="l04256"></a>04256     ixgbe_set_rx_mode(adapter-&gt;netdev);
<a name="l04257"></a>04257 
<a name="l04258"></a>04258 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l04259"></a>04259 <span class="preprocessor"></span>    ixgbe_restore_vlan(adapter);
<a name="l04260"></a>04260 <span class="preprocessor">#endif</span>
<a name="l04261"></a>04261 <span class="preprocessor"></span>    ixgbe_configure_dcb(adapter);
<a name="l04262"></a>04262 
<a name="l04263"></a>04263 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l04264"></a>04264 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED)
<a name="l04265"></a>04265         ixgbe_configure_fcoe(adapter);
<a name="l04266"></a>04266 
<a name="l04267"></a>04267 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l04268"></a>04268     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) {
<a name="l04269"></a>04269         ixgbe_init_fdir_signature_82599(&amp;adapter-&gt;hw,
<a name="l04270"></a>04270                         adapter-&gt;fdir_pballoc);
<a name="l04271"></a>04271     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE) {
<a name="l04272"></a>04272         ixgbe_init_fdir_perfect_82599(&amp;adapter-&gt;hw,
<a name="l04273"></a>04273                           adapter-&gt;fdir_pballoc);
<a name="l04274"></a>04274 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l04275"></a>04275 <span class="preprocessor"></span>        ixgbe_fdir_filter_restore(adapter);
<a name="l04276"></a>04276 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l04277"></a>04277     }
<a name="l04278"></a>04278 
<a name="l04279"></a>04279     ixgbe_configure_virtualization(adapter);
<a name="l04280"></a>04280 
<a name="l04281"></a>04281     ixgbe_configure_tx(adapter);
<a name="l04282"></a>04282     ixgbe_configure_rx(adapter);
<a name="l04283"></a>04283 }
<a name="l04284"></a>04284 
<a name="l04285"></a>04285 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_is_sfp(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw)
<a name="l04286"></a>04286 {
<a name="l04287"></a>04287     <span class="keywordflow">switch</span> (hw-&gt;phy.type) {
<a name="l04288"></a>04288     <span class="keywordflow">case</span> ixgbe_phy_sfp_avago:
<a name="l04289"></a>04289     <span class="keywordflow">case</span> ixgbe_phy_sfp_ftl:
<a name="l04290"></a>04290     <span class="keywordflow">case</span> ixgbe_phy_sfp_intel:
<a name="l04291"></a>04291     <span class="keywordflow">case</span> ixgbe_phy_sfp_unknown:
<a name="l04292"></a>04292     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_tyco:
<a name="l04293"></a>04293     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_unknown:
<a name="l04294"></a>04294     <span class="keywordflow">case</span> ixgbe_phy_sfp_active_unknown:
<a name="l04295"></a>04295     <span class="keywordflow">case</span> ixgbe_phy_sfp_ftl_active:
<a name="l04296"></a>04296         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04297"></a>04297     <span class="keywordflow">case</span> ixgbe_phy_nl:
<a name="l04298"></a>04298         <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l04299"></a>04299             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04300"></a>04300     <span class="keywordflow">default</span>:
<a name="l04301"></a>04301         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04302"></a>04302     }
<a name="l04303"></a>04303 }
<a name="l04304"></a>04304 
<a name="l04309"></a>04309 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_sfp_link_config(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04310"></a>04310 {
<a name="l04311"></a>04311     <span class="comment">/*</span>
<a name="l04312"></a>04312 <span class="comment">     * We are assuming the worst case scenerio here, and that</span>
<a name="l04313"></a>04313 <span class="comment">     * is that an SFP was inserted/removed after the reset</span>
<a name="l04314"></a>04314 <span class="comment">     * but before SFP detection was enabled.  As such the best</span>
<a name="l04315"></a>04315 <span class="comment">     * solution is to just start searching as soon as we start</span>
<a name="l04316"></a>04316 <span class="comment">     */</span>
<a name="l04317"></a>04317     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l04318"></a>04318         adapter-&gt;flags2 |= IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l04319"></a>04319 
<a name="l04320"></a>04320     adapter-&gt;flags2 |= IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l04321"></a>04321 }
<a name="l04322"></a>04322 
<a name="l04329"></a>04329 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_non_sfp_link_config(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw)
<a name="l04330"></a>04330 {
<a name="l04331"></a>04331     u32 autoneg;
<a name="l04332"></a>04332     <span class="keywordtype">bool</span> negotiation, link_up = <span class="keyword">false</span>;
<a name="l04333"></a>04333     u32 ret = IXGBE_ERR_LINK_SETUP;
<a name="l04334"></a>04334 
<a name="l04335"></a>04335     <span class="keywordflow">if</span> (hw-&gt;mac.ops.check_link)
<a name="l04336"></a>04336         ret = hw-&gt;mac.ops.check_link(hw, &amp;autoneg, &amp;link_up, <span class="keyword">false</span>);
<a name="l04337"></a>04337 
<a name="l04338"></a>04338     <span class="keywordflow">if</span> (ret)
<a name="l04339"></a>04339         <span class="keywordflow">goto</span> link_cfg_out;
<a name="l04340"></a>04340 
<a name="l04341"></a>04341     autoneg = hw-&gt;phy.autoneg_advertised;
<a name="l04342"></a>04342     <span class="keywordflow">if</span> ((!autoneg) &amp;&amp; (hw-&gt;mac.ops.get_link_capabilities))
<a name="l04343"></a>04343         ret = hw-&gt;mac.ops.get_link_capabilities(hw, &amp;autoneg,
<a name="l04344"></a>04344                             &amp;negotiation);
<a name="l04345"></a>04345     <span class="keywordflow">if</span> (ret)
<a name="l04346"></a>04346         <span class="keywordflow">goto</span> link_cfg_out;
<a name="l04347"></a>04347 
<a name="l04348"></a>04348     <span class="keywordflow">if</span> (hw-&gt;mac.ops.setup_link)
<a name="l04349"></a>04349         ret = hw-&gt;mac.ops.setup_link(hw, autoneg, negotiation, link_up);
<a name="l04350"></a>04350 link_cfg_out:
<a name="l04351"></a>04351     <span class="keywordflow">return</span> ret;
<a name="l04352"></a>04352 }
<a name="l04353"></a>04353 
<a name="l04361"></a>04361 <span class="keywordtype">void</span> ixgbe_clear_vf_stats_counters(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04362"></a>04362 {
<a name="l04363"></a>04363     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04364"></a>04364     <span class="keywordtype">int</span> i;
<a name="l04365"></a>04365 
<a name="l04366"></a>04366     <span class="keywordflow">for</span>(i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l04367"></a>04367         adapter-&gt;vfinfo[i].last_vfstats.gprc =
<a name="l04368"></a>04368             IXGBE_READ_REG(hw, IXGBE_PVFGPRC(i));
<a name="l04369"></a>04369         adapter-&gt;vfinfo[i].saved_rst_vfstats.gprc +=
<a name="l04370"></a>04370             adapter-&gt;vfinfo[i].vfstats.gprc;
<a name="l04371"></a>04371         adapter-&gt;vfinfo[i].vfstats.gprc = 0;
<a name="l04372"></a>04372         adapter-&gt;vfinfo[i].last_vfstats.gptc =
<a name="l04373"></a>04373             IXGBE_READ_REG(hw, IXGBE_PVFGPTC(i));
<a name="l04374"></a>04374         adapter-&gt;vfinfo[i].saved_rst_vfstats.gptc +=
<a name="l04375"></a>04375             adapter-&gt;vfinfo[i].vfstats.gptc;
<a name="l04376"></a>04376         adapter-&gt;vfinfo[i].vfstats.gptc = 0;
<a name="l04377"></a>04377         adapter-&gt;vfinfo[i].last_vfstats.gorc =
<a name="l04378"></a>04378             IXGBE_READ_REG(hw, IXGBE_PVFGORC_LSB(i));
<a name="l04379"></a>04379         adapter-&gt;vfinfo[i].saved_rst_vfstats.gorc +=
<a name="l04380"></a>04380             adapter-&gt;vfinfo[i].vfstats.gorc;
<a name="l04381"></a>04381         adapter-&gt;vfinfo[i].vfstats.gorc = 0;
<a name="l04382"></a>04382         adapter-&gt;vfinfo[i].last_vfstats.gotc =
<a name="l04383"></a>04383             IXGBE_READ_REG(hw, IXGBE_PVFGOTC_LSB(i));
<a name="l04384"></a>04384         adapter-&gt;vfinfo[i].saved_rst_vfstats.gotc +=
<a name="l04385"></a>04385             adapter-&gt;vfinfo[i].vfstats.gotc;
<a name="l04386"></a>04386         adapter-&gt;vfinfo[i].vfstats.gotc = 0;
<a name="l04387"></a>04387         adapter-&gt;vfinfo[i].last_vfstats.mprc =
<a name="l04388"></a>04388             IXGBE_READ_REG(hw, IXGBE_PVFMPRC(i));
<a name="l04389"></a>04389         adapter-&gt;vfinfo[i].saved_rst_vfstats.mprc +=
<a name="l04390"></a>04390             adapter-&gt;vfinfo[i].vfstats.mprc;
<a name="l04391"></a>04391         adapter-&gt;vfinfo[i].vfstats.mprc = 0;
<a name="l04392"></a>04392     }
<a name="l04393"></a>04393 }
<a name="l04394"></a>04394 
<a name="l04395"></a>04395 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_gpie(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04396"></a>04396 {
<a name="l04397"></a>04397     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04398"></a>04398     u32 gpie = 0;
<a name="l04399"></a>04399 
<a name="l04400"></a>04400     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l04401"></a>04401         gpie = IXGBE_GPIE_MSIX_MODE | IXGBE_GPIE_PBA_SUPPORT |
<a name="l04402"></a>04402                IXGBE_GPIE_OCD;
<a name="l04403"></a>04403 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l04404"></a>04404 <span class="preprocessor"></span>        gpie |= IXGBE_GPIE_EIAME;
<a name="l04405"></a>04405         <span class="comment">/*</span>
<a name="l04406"></a>04406 <span class="comment">         * use EIAM to auto-mask when MSI-X interrupt is asserted</span>
<a name="l04407"></a>04407 <span class="comment">         * this saves a register write for every interrupt</span>
<a name="l04408"></a>04408 <span class="comment">         */</span>
<a name="l04409"></a>04409         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l04410"></a>04410         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l04411"></a>04411             IXGBE_WRITE_REG(hw, IXGBE_EIAM, IXGBE_EICS_RTX_QUEUE);
<a name="l04412"></a>04412             <span class="keywordflow">break</span>;
<a name="l04413"></a>04413         <span class="keywordflow">default</span>:
<a name="l04414"></a>04414         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04415"></a>04415         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04416"></a>04416             IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(0), 0xFFFFFFFF);
<a name="l04417"></a>04417             IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(1), 0xFFFFFFFF);
<a name="l04418"></a>04418             <span class="keywordflow">break</span>;
<a name="l04419"></a>04419         }
<a name="l04420"></a>04420     } <span class="keywordflow">else</span> {
<a name="l04421"></a>04421         <span class="comment">/* legacy interrupts, use EIAM to auto-mask when reading EICR,</span>
<a name="l04422"></a>04422 <span class="comment">         * specifically only auto mask tx and rx interrupts */</span>
<a name="l04423"></a>04423         IXGBE_WRITE_REG(hw, IXGBE_EIAM, IXGBE_EICS_RTX_QUEUE);
<a name="l04424"></a>04424 <span class="preprocessor">#endif</span>
<a name="l04425"></a>04425 <span class="preprocessor"></span>    }
<a name="l04426"></a>04426 
<a name="l04427"></a>04427     <span class="comment">/* XXX: to interrupt immediately for EICS writes, enable this */</span>
<a name="l04428"></a>04428     <span class="comment">/* gpie |= IXGBE_GPIE_EIMEN; */</span>
<a name="l04429"></a>04429 
<a name="l04430"></a>04430     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l04431"></a>04431         gpie &amp;= ~IXGBE_GPIE_VTMODE_MASK;
<a name="l04432"></a>04432         gpie |= IXGBE_GPIE_VTMODE_64;
<a name="l04433"></a>04433     }
<a name="l04434"></a>04434 
<a name="l04435"></a>04435     <span class="comment">/* Enable Thermal over heat sensor interrupt */</span>
<a name="l04436"></a>04436     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE)
<a name="l04437"></a>04437         gpie |= IXGBE_SDP0_GPIEN;
<a name="l04438"></a>04438 
<a name="l04439"></a>04439     <span class="comment">/* Enable fan failure interrupt */</span>
<a name="l04440"></a>04440     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE)
<a name="l04441"></a>04441         gpie |= IXGBE_SDP1_GPIEN;
<a name="l04442"></a>04442 
<a name="l04443"></a>04443     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82599EB)
<a name="l04444"></a>04444         gpie |= IXGBE_SDP1_GPIEN;
<a name="l04445"></a>04445         gpie |= IXGBE_SDP2_GPIEN;
<a name="l04446"></a>04446 
<a name="l04447"></a>04447     IXGBE_WRITE_REG(hw, IXGBE_GPIE, gpie);
<a name="l04448"></a>04448 }
<a name="l04449"></a>04449 
<a name="l04450"></a>04450 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_up_complete(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04451"></a>04451 {
<a name="l04452"></a>04452     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04453"></a>04453     <span class="keywordtype">int</span> err;
<a name="l04454"></a>04454     u32 ctrl_ext;
<a name="l04455"></a>04455 
<a name="l04456"></a>04456     ixgbe_get_hw_control(adapter);
<a name="l04457"></a>04457     ixgbe_setup_gpie(adapter);
<a name="l04458"></a>04458 
<a name="l04459"></a>04459     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l04460"></a>04460         ixgbe_configure_msix(adapter);
<a name="l04461"></a>04461     <span class="keywordflow">else</span>
<a name="l04462"></a>04462         ixgbe_configure_msi_and_legacy(adapter);
<a name="l04463"></a>04463 
<a name="l04464"></a>04464     <span class="comment">/* enable the optics */</span>
<a name="l04465"></a>04465     <span class="keywordflow">if</span> ((hw-&gt;phy.multispeed_fiber) ||
<a name="l04466"></a>04466         ((hw-&gt;mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) &amp;&amp;
<a name="l04467"></a>04467          (hw-&gt;mac.type == ixgbe_mac_82599EB)))
<a name="l04468"></a>04468         ixgbe_enable_tx_laser(hw);
<a name="l04469"></a>04469 
<a name="l04470"></a>04470     clear_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l04471"></a>04471 
<a name="l04472"></a>04472     ixgbe_napi_enable_all(adapter);
<a name="l04473"></a>04473 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l04474"></a>04474 <span class="preprocessor"></span>    ixgbe_configure_lli(adapter);
<a name="l04475"></a>04475 <span class="preprocessor">#endif</span>
<a name="l04476"></a>04476 <span class="preprocessor"></span>
<a name="l04477"></a>04477     <span class="keywordflow">if</span> (ixgbe_is_sfp(hw)) {
<a name="l04478"></a>04478         ixgbe_sfp_link_config(adapter);
<a name="l04479"></a>04479     } <span class="keywordflow">else</span> {
<a name="l04480"></a>04480         err = ixgbe_non_sfp_link_config(hw);
<a name="l04481"></a>04481         <span class="keywordflow">if</span> (err)
<a name="l04482"></a>04482             e_err(probe, <span class="stringliteral">&quot;link_config FAILED %d\n&quot;</span>, err);
<a name="l04483"></a>04483     }
<a name="l04484"></a>04484 
<a name="l04485"></a>04485     <span class="comment">/* clear any pending interrupts, may auto mask */</span>
<a name="l04486"></a>04486     IXGBE_READ_REG(hw, IXGBE_EICR);
<a name="l04487"></a>04487 
<a name="l04488"></a>04488     ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l04489"></a>04489 
<a name="l04490"></a>04490     <span class="comment">/*</span>
<a name="l04491"></a>04491 <span class="comment">     * If this adapter has a fan, check to see if we had a failure</span>
<a name="l04492"></a>04492 <span class="comment">     * before we enabled the interrupt.</span>
<a name="l04493"></a>04493 <span class="comment">     */</span>
<a name="l04494"></a>04494     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE) {
<a name="l04495"></a>04495         u32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
<a name="l04496"></a>04496         <span class="keywordflow">if</span> (esdp &amp; IXGBE_ESDP_SDP1)
<a name="l04497"></a>04497             e_crit(drv, <span class="stringliteral">&quot;Fan has stopped, replace the adapter\n&quot;</span>);
<a name="l04498"></a>04498     }
<a name="l04499"></a>04499 
<a name="l04500"></a>04500     <span class="comment">/* enable transmits */</span>
<a name="l04501"></a>04501     netif_tx_start_all_queues(adapter-&gt;netdev);
<a name="l04502"></a>04502 
<a name="l04503"></a>04503     <span class="comment">/* bring the link up in the watchdog, this could race with our first</span>
<a name="l04504"></a>04504 <span class="comment">     * link up interrupt but shouldn&#39;t be a problem */</span>
<a name="l04505"></a>04505     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l04506"></a>04506     adapter-&gt;link_check_timeout = jiffies;
<a name="l04507"></a>04507     mod_timer(&amp;adapter-&gt;service_timer, jiffies);
<a name="l04508"></a>04508 
<a name="l04509"></a>04509     ixgbe_clear_vf_stats_counters(adapter);
<a name="l04510"></a>04510     <span class="comment">/* Set PF Reset Done bit so PF/VF Mail Ops can work */</span>
<a name="l04511"></a>04511     ctrl_ext = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
<a name="l04512"></a>04512     ctrl_ext |= IXGBE_CTRL_EXT_PFRSTD;
<a name="l04513"></a>04513     IXGBE_WRITE_REG(hw, IXGBE_CTRL_EXT, ctrl_ext);
<a name="l04514"></a>04514 
<a name="l04515"></a>04515     <span class="keywordflow">return</span> 0;
<a name="l04516"></a>04516 }
<a name="l04517"></a>04517 
<a name="l04518"></a>04518 <span class="keywordtype">void</span> ixgbe_reinit_locked(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04519"></a>04519 {
<a name="l04520"></a>04520     WARN_ON(in_interrupt());
<a name="l04521"></a>04521     <span class="comment">/* put off any impending NetWatchDogTimeout */</span>
<a name="l04522"></a>04522     adapter-&gt;netdev-&gt;trans_start = jiffies;
<a name="l04523"></a>04523 
<a name="l04524"></a>04524     <span class="keywordflow">while</span> (test_and_set_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l04525"></a>04525         usleep_range(1000, 2000);
<a name="l04526"></a>04526     ixgbe_down(adapter);
<a name="l04527"></a>04527     <span class="comment">/*</span>
<a name="l04528"></a>04528 <span class="comment">     * If SR-IOV enabled then wait a bit before bringing the adapter</span>
<a name="l04529"></a>04529 <span class="comment">     * back up to give the VFs time to respond to the reset.  The</span>
<a name="l04530"></a>04530 <span class="comment">     * two second wait is based upon the watchdog timer cycle in</span>
<a name="l04531"></a>04531 <span class="comment">     * the VF driver.</span>
<a name="l04532"></a>04532 <span class="comment">     */</span>
<a name="l04533"></a>04533     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l04534"></a>04534         msleep(2000);
<a name="l04535"></a>04535     ixgbe_up(adapter);
<a name="l04536"></a>04536     clear_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state);
<a name="l04537"></a>04537 }
<a name="l04538"></a>04538 
<a name="l04539"></a>04539 <span class="keywordtype">int</span> ixgbe_up(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04540"></a>04540 {
<a name="l04541"></a>04541     <span class="keywordtype">int</span> err;
<a name="l04542"></a>04542 
<a name="l04543"></a>04543     ixgbe_configure(adapter);
<a name="l04544"></a>04544 
<a name="l04545"></a>04545     err = ixgbe_up_complete(adapter);
<a name="l04546"></a>04546 
<a name="l04547"></a>04547     <span class="keywordflow">return</span> err;
<a name="l04548"></a>04548 }
<a name="l04549"></a>04549 
<a name="l04550"></a>04550 <span class="keywordtype">void</span> ixgbe_reset(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04551"></a>04551 {
<a name="l04552"></a>04552     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04553"></a>04553     <span class="keywordtype">int</span> err;
<a name="l04554"></a>04554 
<a name="l04555"></a>04555     <span class="comment">/* lock SFP init bit to prevent race conditions with the watchdog */</span>
<a name="l04556"></a>04556     <span class="keywordflow">while</span> (test_and_set_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state))
<a name="l04557"></a>04557         usleep_range(1000, 2000);
<a name="l04558"></a>04558 
<a name="l04559"></a>04559     <span class="comment">/* clear all SFP and link config related flags while holding SFP_INIT */</span>
<a name="l04560"></a>04560     adapter-&gt;flags2 &amp;= ~(IXGBE_FLAG2_SEARCH_FOR_SFP |
<a name="l04561"></a>04561                  IXGBE_FLAG2_SFP_NEEDS_RESET);
<a name="l04562"></a>04562     adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l04563"></a>04563 
<a name="l04564"></a>04564     err = hw-&gt;mac.ops.init_hw(hw);
<a name="l04565"></a>04565     <span class="keywordflow">switch</span> (err) {
<a name="l04566"></a>04566     <span class="keywordflow">case</span> 0:
<a name="l04567"></a>04567     <span class="keywordflow">case</span> IXGBE_ERR_SFP_NOT_PRESENT:
<a name="l04568"></a>04568     <span class="keywordflow">case</span> IXGBE_ERR_SFP_NOT_SUPPORTED:
<a name="l04569"></a>04569         <span class="keywordflow">break</span>;
<a name="l04570"></a>04570     <span class="keywordflow">case</span> IXGBE_ERR_MASTER_REQUESTS_PENDING:
<a name="l04571"></a>04571         e_dev_err(<span class="stringliteral">&quot;master disable timed out\n&quot;</span>);
<a name="l04572"></a>04572         <span class="keywordflow">break</span>;
<a name="l04573"></a>04573     <span class="keywordflow">case</span> IXGBE_ERR_EEPROM_VERSION:
<a name="l04574"></a>04574         <span class="comment">/* We are running on a pre-production device, log a warning */</span>
<a name="l04575"></a>04575         e_dev_warn(<span class="stringliteral">&quot;This device is a pre-production adapter/LOM. &quot;</span>
<a name="l04576"></a>04576                <span class="stringliteral">&quot;Please be aware there may be issues associated &quot;</span>
<a name="l04577"></a>04577                <span class="stringliteral">&quot;with your hardware.  If you are experiencing &quot;</span>
<a name="l04578"></a>04578                <span class="stringliteral">&quot;problems please contact your Intel or hardware &quot;</span>
<a name="l04579"></a>04579                <span class="stringliteral">&quot;representative who provided you with this &quot;</span>
<a name="l04580"></a>04580                <span class="stringliteral">&quot;hardware.\n&quot;</span>);
<a name="l04581"></a>04581         <span class="keywordflow">break</span>;
<a name="l04582"></a>04582     <span class="keywordflow">default</span>:
<a name="l04583"></a>04583         e_dev_err(<span class="stringliteral">&quot;Hardware Error: %d\n&quot;</span>, err);
<a name="l04584"></a>04584     }
<a name="l04585"></a>04585 
<a name="l04586"></a>04586     clear_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state);
<a name="l04587"></a>04587 
<a name="l04588"></a>04588     <span class="comment">/* reprogram the RAR[0] in case user changed it. */</span>
<a name="l04589"></a>04589     <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_rar)
<a name="l04590"></a>04590         hw-&gt;mac.ops.set_rar(hw, 0, hw-&gt;mac.addr,
<a name="l04591"></a>04591                     adapter-&gt;num_vfs, IXGBE_RAH_AV);
<a name="l04592"></a>04592 }
<a name="l04593"></a>04593 
<a name="l04598"></a>04598 <span class="keywordtype">void</span> ixgbe_clean_rx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l04599"></a>04599 {
<a name="l04600"></a>04600     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = rx_ring-&gt;dev;
<a name="l04601"></a>04601     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
<a name="l04602"></a>04602     u16 i;
<a name="l04603"></a>04603 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l04604"></a>04604 <span class="preprocessor"></span>    <span class="comment">// printk(&quot;[DNA] ixgbe_clean_rx_ring()\n&quot;);</span>
<a name="l04605"></a>04605 <span class="preprocessor">#endif</span>
<a name="l04606"></a>04606 <span class="preprocessor"></span>
<a name="l04607"></a>04607     <span class="comment">/* ring already cleared, nothing to do */</span>
<a name="l04608"></a>04608     <span class="keywordflow">if</span> (!rx_ring-&gt;rx_buffer_info)
<a name="l04609"></a>04609         <span class="keywordflow">return</span>;
<a name="l04610"></a>04610 
<a name="l04611"></a>04611     <span class="comment">/* Free all the Rx ring sk_buffs */</span>
<a name="l04612"></a>04612     <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++) {
<a name="l04613"></a>04613         <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *rx_buffer_info;
<a name="l04614"></a>04614 
<a name="l04615"></a>04615         rx_buffer_info = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l04616"></a>04616         <span class="keywordflow">if</span> (rx_buffer_info-&gt;dma) {
<a name="l04617"></a>04617             dma_unmap_single(dev,
<a name="l04618"></a>04618                      rx_buffer_info-&gt;dma,
<a name="l04619"></a>04619                      rx_ring-&gt;rx_buf_len,
<a name="l04620"></a>04620                      DMA_FROM_DEVICE);
<a name="l04621"></a>04621             rx_buffer_info-&gt;dma = 0;
<a name="l04622"></a>04622         }
<a name="l04623"></a>04623 <span class="preprocessor">#ifndef ENABLE_DNA</span>
<a name="l04624"></a>04624 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (rx_buffer_info-&gt;skb) {
<a name="l04625"></a>04625             <span class="keyword">struct </span>sk_buff *skb = rx_buffer_info-&gt;skb;
<a name="l04626"></a>04626             rx_buffer_info-&gt;skb = NULL;
<a name="l04627"></a>04627             <span class="comment">/* We need to clean up RSC frag lists */</span>
<a name="l04628"></a>04628             skb = ixgbe_merge_active_tail(skb);
<a name="l04629"></a>04629             ixgbe_close_active_frag_list(skb);
<a name="l04630"></a>04630             <span class="keywordflow">if</span> (IXGBE_RSC_CB(skb)-&gt;delay_unmap) {
<a name="l04631"></a>04631                 dma_unmap_single(dev,
<a name="l04632"></a>04632                          IXGBE_RSC_CB(skb)-&gt;dma,
<a name="l04633"></a>04633                          rx_ring-&gt;rx_buf_len,
<a name="l04634"></a>04634                          DMA_FROM_DEVICE);
<a name="l04635"></a>04635                 IXGBE_RSC_CB(skb)-&gt;dma = 0;
<a name="l04636"></a>04636                 IXGBE_RSC_CB(skb)-&gt;delay_unmap = <span class="keyword">false</span>;
<a name="l04637"></a>04637             }
<a name="l04638"></a>04638             dev_kfree_skb(skb);
<a name="l04639"></a>04639         }
<a name="l04640"></a>04640         <span class="keywordflow">if</span> (!rx_buffer_info-&gt;page)
<a name="l04641"></a>04641             <span class="keywordflow">continue</span>;
<a name="l04642"></a>04642         <span class="keywordflow">if</span> (rx_buffer_info-&gt;page_dma) {
<a name="l04643"></a>04643             dma_unmap_page(dev,
<a name="l04644"></a>04644                        rx_buffer_info-&gt;page_dma,
<a name="l04645"></a>04645                        PAGE_SIZE / 2,
<a name="l04646"></a>04646                        DMA_FROM_DEVICE);
<a name="l04647"></a>04647             rx_buffer_info-&gt;page_dma = 0;
<a name="l04648"></a>04648         }
<a name="l04649"></a>04649         put_page(rx_buffer_info-&gt;page);
<a name="l04650"></a>04650         rx_buffer_info-&gt;page = NULL;
<a name="l04651"></a>04651         rx_buffer_info-&gt;page_offset = 0;
<a name="l04652"></a>04652 <span class="preprocessor">#endif</span>
<a name="l04653"></a>04653 <span class="preprocessor"></span>    }
<a name="l04654"></a>04654 
<a name="l04655"></a>04655     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a>) * rx_ring-&gt;count;
<a name="l04656"></a>04656     memset(rx_ring-&gt;rx_buffer_info, 0, size);
<a name="l04657"></a>04657 
<a name="l04658"></a>04658     <span class="comment">/* Zero out the descriptor ring */</span>
<a name="l04659"></a>04659     memset(rx_ring-&gt;desc, 0, rx_ring-&gt;size);
<a name="l04660"></a>04660 
<a name="l04661"></a>04661     rx_ring-&gt;next_to_clean = 0;
<a name="l04662"></a>04662     rx_ring-&gt;next_to_use = 0;
<a name="l04663"></a>04663 
<a name="l04664"></a>04664 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l04665"></a>04665 <span class="preprocessor"></span>    {
<a name="l04666"></a>04666       <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(rx_ring-&gt;netdev);
<a name="l04667"></a>04667       <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a>    *tx_ring = adapter-&gt;tx_ring[rx_ring-&gt;queue_index];
<a name="l04668"></a>04668       <span class="keyword">struct </span>pfring_hooks   *hook = (<span class="keyword">struct </span>pfring_hooks*)rx_ring-&gt;netdev-&gt;pfring_ptr;
<a name="l04669"></a>04669 
<a name="l04670"></a>04670       <span class="keywordflow">if</span>(tx_ring-&gt;dna.rx_tx.tx.packet_memory != 0) {
<a name="l04671"></a>04671         memset(tx_ring-&gt;desc, 0, tx_ring-&gt;size);
<a name="l04672"></a>04672         tx_ring-&gt;next_to_clean = 0;
<a name="l04673"></a>04673         tx_ring-&gt;next_to_use = 0;
<a name="l04674"></a>04674 
<a name="l04675"></a>04675         <span class="keywordflow">if</span>(unlikely(dna_debug)) 
<a name="l04676"></a>04676           printk(<span class="stringliteral">&quot;%s(): Deallocating TX DMA memory\n&quot;</span>, __FUNCTION__);
<a name="l04677"></a>04677 
<a name="l04678"></a>04678         free_contiguous_memory(tx_ring-&gt;dna.rx_tx.tx.packet_memory,
<a name="l04679"></a>04679                    tx_ring-&gt;dna.tot_packet_memory,
<a name="l04680"></a>04680                    tx_ring-&gt;dna.mem_order);
<a name="l04681"></a>04681         tx_ring-&gt;dna.rx_tx.tx.packet_memory = 0;
<a name="l04682"></a>04682       }
<a name="l04683"></a>04683 
<a name="l04684"></a>04684       <span class="keywordflow">if</span>(rx_ring-&gt;dna.rx_tx.rx.packet_memory != 0) {
<a name="l04685"></a>04685         <span class="keywordflow">if</span>(unlikely(dna_debug)) 
<a name="l04686"></a>04686           printk(<span class="stringliteral">&quot;%s(): Deallocating RX DMA memory\n&quot;</span>, __FUNCTION__);
<a name="l04687"></a>04687 
<a name="l04688"></a>04688         free_contiguous_memory(rx_ring-&gt;dna.rx_tx.rx.packet_memory,
<a name="l04689"></a>04689                    rx_ring-&gt;dna.tot_packet_memory, rx_ring-&gt;dna.mem_order);
<a name="l04690"></a>04690 
<a name="l04691"></a>04691         <span class="comment">/* De-register with PF_RING */</span>
<a name="l04692"></a>04692         hook-&gt;ring_dna_device_handler(remove_device_mapping,
<a name="l04693"></a>04693                       rx_ring-&gt;dna.rx_tx.rx.packet_memory,
<a name="l04694"></a>04694                       rx_ring-&gt;dna.packet_num_slots,
<a name="l04695"></a>04695                       rx_ring-&gt;dna.packet_slot_len,
<a name="l04696"></a>04696                       rx_ring-&gt;dna.tot_packet_memory,
<a name="l04697"></a>04697                       rx_ring-&gt;desc,
<a name="l04698"></a>04698                       rx_ring-&gt;count, <span class="comment">/* # of items */</span>
<a name="l04699"></a>04699                       <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a>),
<a name="l04700"></a>04700                       <span class="comment">/* Double because of the shadow descriptors */</span>
<a name="l04701"></a>04701                       2 * rx_ring-&gt;size, <span class="comment">/* tot len (bytes) */</span>
<a name="l04702"></a>04702                       0, NULL, <span class="comment">/* TX */</span>
<a name="l04703"></a>04703                       rx_ring-&gt;queue_index, <span class="comment">/* Channel Id */</span>
<a name="l04704"></a>04704                       (<span class="keywordtype">void</span>*)rx_ring-&gt;netdev-&gt;mem_start,
<a name="l04705"></a>04705                       rx_ring-&gt;netdev-&gt;mem_end - rx_ring-&gt;netdev-&gt;mem_start,
<a name="l04706"></a>04706                       rx_ring-&gt;netdev,
<a name="l04707"></a>04707                       intel_ixgbe,
<a name="l04708"></a>04708                       rx_ring-&gt;netdev-&gt;dev_addr, <span class="comment">/* 6 bytes MAC address */</span>
<a name="l04709"></a>04709                       &amp;rx_ring-&gt;dna.rx_tx.rx.packet_waitqueue,
<a name="l04710"></a>04710                       &amp;rx_ring-&gt;dna.rx_tx.rx.interrupt_received,
<a name="l04711"></a>04711                       (<span class="keywordtype">void</span>*)rx_ring,
<a name="l04712"></a>04712                       NULL,
<a name="l04713"></a>04713                       NULL);
<a name="l04714"></a>04714 
<a name="l04715"></a>04715         rx_ring-&gt;dna.rx_tx.rx.packet_memory = 0;
<a name="l04716"></a>04716       }
<a name="l04717"></a>04717     }
<a name="l04718"></a>04718 <span class="preprocessor">#endif</span>
<a name="l04719"></a>04719 <span class="preprocessor"></span>}
<a name="l04720"></a>04720 
<a name="l04725"></a>04725 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_clean_tx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l04726"></a>04726 {
<a name="l04727"></a>04727     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info;
<a name="l04728"></a>04728     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
<a name="l04729"></a>04729     u16 i;
<a name="l04730"></a>04730 
<a name="l04731"></a>04731     <span class="comment">/* ring already cleared, nothing to do */</span>
<a name="l04732"></a>04732     <span class="keywordflow">if</span> (!tx_ring-&gt;tx_buffer_info)
<a name="l04733"></a>04733         <span class="keywordflow">return</span>;
<a name="l04734"></a>04734 
<a name="l04735"></a>04735     <span class="comment">/* Free all the Tx ring sk_buffs */</span>
<a name="l04736"></a>04736     <span class="keywordflow">for</span> (i = 0; i &lt; tx_ring-&gt;count; i++) {
<a name="l04737"></a>04737         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l04738"></a>04738 <span class="preprocessor">#ifndef ENABLE_DNA</span>
<a name="l04739"></a>04739 <span class="preprocessor"></span>        ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer_info);
<a name="l04740"></a>04740 <span class="preprocessor">#endif</span>
<a name="l04741"></a>04741 <span class="preprocessor"></span>    }
<a name="l04742"></a>04742 
<a name="l04743"></a>04743     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a>) * tx_ring-&gt;count;
<a name="l04744"></a>04744     memset(tx_ring-&gt;tx_buffer_info, 0, size);
<a name="l04745"></a>04745 
<a name="l04746"></a>04746     <span class="comment">/* Zero out the descriptor ring */</span>
<a name="l04747"></a>04747     memset(tx_ring-&gt;desc, 0, tx_ring-&gt;size);
<a name="l04748"></a>04748 
<a name="l04749"></a>04749     tx_ring-&gt;next_to_use = 0;
<a name="l04750"></a>04750     tx_ring-&gt;next_to_clean = 0;
<a name="l04751"></a>04751 }
<a name="l04752"></a>04752 
<a name="l04757"></a>04757 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_clean_all_rx_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04758"></a>04758 {
<a name="l04759"></a>04759     <span class="keywordtype">int</span> i;
<a name="l04760"></a>04760 
<a name="l04761"></a>04761     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l04762"></a>04762         ixgbe_clean_rx_ring(adapter-&gt;rx_ring[i]);
<a name="l04763"></a>04763 }
<a name="l04764"></a>04764 
<a name="l04769"></a>04769 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_clean_all_tx_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04770"></a>04770 {
<a name="l04771"></a>04771     <span class="keywordtype">int</span> i;
<a name="l04772"></a>04772 
<a name="l04773"></a>04773     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l04774"></a>04774         ixgbe_clean_tx_ring(adapter-&gt;tx_ring[i]);
<a name="l04775"></a>04775 }
<a name="l04776"></a>04776 
<a name="l04777"></a>04777 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l04778"></a>04778 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_fdir_filter_exit(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04779"></a>04779 {
<a name="l04780"></a>04780     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l04781"></a>04781     <span class="keyword">struct </span><a class="code" href="structixgbe__fdir__filter.html">ixgbe_fdir_filter</a> *filter;
<a name="l04782"></a>04782 
<a name="l04783"></a>04783     spin_lock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l04784"></a>04784 
<a name="l04785"></a>04785     hlist_for_each_entry_safe(filter, node, node2,
<a name="l04786"></a>04786                   &amp;adapter-&gt;fdir_filter_list, fdir_node) {
<a name="l04787"></a>04787         hlist_del(&amp;filter-&gt;fdir_node);
<a name="l04788"></a>04788         kfree(filter);
<a name="l04789"></a>04789     }
<a name="l04790"></a>04790     adapter-&gt;fdir_filter_count = 0;
<a name="l04791"></a>04791 
<a name="l04792"></a>04792     spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l04793"></a>04793 }
<a name="l04794"></a>04794 
<a name="l04795"></a>04795 <span class="preprocessor">#endif</span>
<a name="l04796"></a>04796 <span class="preprocessor"></span><span class="keywordtype">void</span> ixgbe_down(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04797"></a>04797 {
<a name="l04798"></a>04798     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l04799"></a>04799     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04800"></a>04800     u32 rxctrl;
<a name="l04801"></a>04801     <span class="keywordtype">int</span> i;
<a name="l04802"></a>04802 
<a name="l04803"></a>04803     <span class="comment">/* signal that we are down to the interrupt handler */</span>
<a name="l04804"></a>04804     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l04805"></a>04805 
<a name="l04806"></a>04806     <span class="comment">/* disable receives */</span>
<a name="l04807"></a>04807     rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l04808"></a>04808     IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl &amp; ~IXGBE_RXCTRL_RXEN);
<a name="l04809"></a>04809 
<a name="l04810"></a>04810     <span class="comment">/* disable all enabled rx queues */</span>
<a name="l04811"></a>04811     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l04812"></a>04812         <span class="comment">/* this call also flushes the previous write */</span>
<a name="l04813"></a>04813         ixgbe_disable_rx_queue(adapter, adapter-&gt;rx_ring[i]);
<a name="l04814"></a>04814 
<a name="l04815"></a>04815     usleep_range(10000, 20000);
<a name="l04816"></a>04816 
<a name="l04817"></a>04817     netif_tx_stop_all_queues(netdev);
<a name="l04818"></a>04818 
<a name="l04819"></a>04819     <span class="comment">/* call carrier off first to avoid false dev_watchdog timeouts */</span>
<a name="l04820"></a>04820     netif_carrier_off(netdev);
<a name="l04821"></a>04821     netif_tx_disable(netdev);
<a name="l04822"></a>04822 
<a name="l04823"></a>04823     ixgbe_irq_disable(adapter);
<a name="l04824"></a>04824 
<a name="l04825"></a>04825     ixgbe_napi_disable_all(adapter);
<a name="l04826"></a>04826 
<a name="l04827"></a>04827     adapter-&gt;flags2 &amp;= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
<a name="l04828"></a>04828                  IXGBE_FLAG2_RESET_REQUESTED);
<a name="l04829"></a>04829     adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l04830"></a>04830 
<a name="l04831"></a>04831     del_timer_sync(&amp;adapter-&gt;service_timer);
<a name="l04832"></a>04832 
<a name="l04833"></a>04833     <span class="comment">/* disable receive for all VFs and wait one second */</span>
<a name="l04834"></a>04834     <span class="keywordflow">if</span> (adapter-&gt;num_vfs) {
<a name="l04835"></a>04835         <span class="comment">/* Mark all the VFs as inactive */</span>
<a name="l04836"></a>04836         <span class="keywordflow">for</span> (i = 0 ; i &lt; adapter-&gt;num_vfs; i++)
<a name="l04837"></a>04837             adapter-&gt;vfinfo[i].clear_to_send = 0;
<a name="l04838"></a>04838 
<a name="l04839"></a>04839         <span class="comment">/* ping all the active vfs to let them know we are going down */</span>
<a name="l04840"></a>04840         ixgbe_ping_all_vfs(adapter);
<a name="l04841"></a>04841 
<a name="l04842"></a>04842         <span class="comment">/* Disable all VFTE/VFRE TX/RX */</span>
<a name="l04843"></a>04843         ixgbe_disable_tx_rx(adapter);
<a name="l04844"></a>04844     }
<a name="l04845"></a>04845 
<a name="l04846"></a>04846     <span class="comment">/* disable transmits in the hardware now that interrupts are off */</span>
<a name="l04847"></a>04847     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l04848"></a>04848         u8 reg_idx = adapter-&gt;tx_ring[i]-&gt;reg_idx;
<a name="l04849"></a>04849         IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), 0);
<a name="l04850"></a>04850     }
<a name="l04851"></a>04851 
<a name="l04852"></a>04852     <span class="comment">/* Disable the Tx DMA engine on 82599 and X540 */</span>
<a name="l04853"></a>04853     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l04854"></a>04854     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04855"></a>04855     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04856"></a>04856         IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL,
<a name="l04857"></a>04857                 (IXGBE_READ_REG(hw, IXGBE_DMATXCTL) &amp;
<a name="l04858"></a>04858                  ~IXGBE_DMATXCTL_TE));
<a name="l04859"></a>04859         <span class="keywordflow">break</span>;
<a name="l04860"></a>04860     <span class="keywordflow">default</span>:
<a name="l04861"></a>04861         <span class="keywordflow">break</span>;
<a name="l04862"></a>04862     }
<a name="l04863"></a>04863 
<a name="l04864"></a>04864 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l04865"></a>04865 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!pci_channel_offline(adapter-&gt;pdev))
<a name="l04866"></a>04866 <span class="preprocessor">#endif</span>
<a name="l04867"></a>04867 <span class="preprocessor"></span>        ixgbe_reset(adapter);
<a name="l04868"></a>04868     <span class="comment">/* power down the optics */</span>
<a name="l04869"></a>04869     <span class="keywordflow">if</span> ((hw-&gt;phy.multispeed_fiber) ||
<a name="l04870"></a>04870         ((hw-&gt;mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) &amp;&amp;
<a name="l04871"></a>04871          (hw-&gt;mac.type == ixgbe_mac_82599EB)))
<a name="l04872"></a>04872         ixgbe_disable_tx_laser(hw);
<a name="l04873"></a>04873 
<a name="l04874"></a>04874     ixgbe_clean_all_tx_rings(adapter);
<a name="l04875"></a>04875     ixgbe_clean_all_rx_rings(adapter);
<a name="l04876"></a>04876 
<a name="l04877"></a>04877     <span class="comment">/* since we reset the hardware DCA settings were cleared */</span>
<a name="l04878"></a>04878     ixgbe_setup_dca(adapter);
<a name="l04879"></a>04879 }
<a name="l04880"></a>04880 
<a name="l04881"></a>04881 
<a name="l04891"></a>04891 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_dcb_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04892"></a>04892 {
<a name="l04893"></a>04893     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l04894"></a>04894     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_DCB];
<a name="l04895"></a>04895 
<a name="l04896"></a>04896     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l04897"></a>04897         <span class="keywordflow">return</span> ret;
<a name="l04898"></a>04898 
<a name="l04899"></a>04899 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l04900"></a>04900 <span class="preprocessor"></span>    f-&gt;mask = 0x7 &lt;&lt; 3;
<a name="l04901"></a>04901     adapter-&gt;num_rx_queues = f-&gt;indices;
<a name="l04902"></a>04902     adapter-&gt;num_tx_queues = f-&gt;indices;
<a name="l04903"></a>04903     ret = <span class="keyword">true</span>;
<a name="l04904"></a>04904 <span class="preprocessor">#else</span>
<a name="l04905"></a>04905 <span class="preprocessor"></span>    f-&gt;mask = 0;
<a name="l04906"></a>04906     f-&gt;indices = 0;
<a name="l04907"></a>04907 <span class="preprocessor">#endif</span>
<a name="l04908"></a>04908 <span class="preprocessor"></span>
<a name="l04909"></a>04909     <span class="keywordflow">return</span> ret;
<a name="l04910"></a>04910 }
<a name="l04911"></a>04911 
<a name="l04921"></a>04921 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_vmdq_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04922"></a>04922 {
<a name="l04923"></a>04923     <span class="keywordtype">int</span> vmdq_i = adapter-&gt;ring_feature[RING_F_VMDQ].indices;
<a name="l04924"></a>04924     <span class="keywordtype">int</span> vmdq_m = 0;
<a name="l04925"></a>04925     <span class="keywordtype">int</span> rss_i = adapter-&gt;ring_feature[RING_F_RSS].indices;
<a name="l04926"></a>04926     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l04927"></a>04927     <span class="keywordtype">int</span> rss_shift;
<a name="l04928"></a>04928     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l04929"></a>04929 
<a name="l04930"></a>04930 
<a name="l04931"></a>04931     <span class="keywordflow">switch</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_RSS_ENABLED
<a name="l04932"></a>04932                    | IXGBE_FLAG_DCB_ENABLED
<a name="l04933"></a>04933                    | IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l04934"></a>04934 
<a name="l04935"></a>04935     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l04936"></a>04936         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l04937"></a>04937         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04938"></a>04938         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04939"></a>04939             vmdq_i = min(IXGBE_MAX_VMDQ_INDICES, vmdq_i);
<a name="l04940"></a>04940             <span class="keywordflow">if</span> (vmdq_i &gt; 32)
<a name="l04941"></a>04941                 rss_i = 2;
<a name="l04942"></a>04942             <span class="keywordflow">else</span>
<a name="l04943"></a>04943                 rss_i = 4;
<a name="l04944"></a>04944             i = rss_i;
<a name="l04945"></a>04945             rss_shift = find_first_bit(&amp;i, <span class="keyword">sizeof</span>(i) * 8);
<a name="l04946"></a>04946             vmdq_m = ((IXGBE_MAX_VMDQ_INDICES - 1) &lt;&lt;
<a name="l04947"></a>04947                        rss_shift) &amp; (MAX_RX_QUEUES - 1);
<a name="l04948"></a>04948             <span class="keywordflow">break</span>;
<a name="l04949"></a>04949         <span class="keywordflow">default</span>:
<a name="l04950"></a>04950             <span class="keywordflow">break</span>;
<a name="l04951"></a>04951         }
<a name="l04952"></a>04952         adapter-&gt;num_rx_queues = vmdq_i * rss_i;
<a name="l04953"></a>04953         adapter-&gt;num_tx_queues = min(MAX_TX_QUEUES, vmdq_i * rss_i);
<a name="l04954"></a>04954         ret = <span class="keyword">true</span>;
<a name="l04955"></a>04955         <span class="keywordflow">break</span>;
<a name="l04956"></a>04956 
<a name="l04957"></a>04957     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l04958"></a>04958         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l04959"></a>04959         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l04960"></a>04960             vmdq_m = (IXGBE_MAX_VMDQ_INDICES - 1);
<a name="l04961"></a>04961             <span class="keywordflow">break</span>;
<a name="l04962"></a>04962         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04963"></a>04963         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04964"></a>04964             vmdq_m = (IXGBE_MAX_VMDQ_INDICES - 1) &lt;&lt; 1;
<a name="l04965"></a>04965             <span class="keywordflow">break</span>;
<a name="l04966"></a>04966         <span class="keywordflow">default</span>:
<a name="l04967"></a>04967             <span class="keywordflow">break</span>;
<a name="l04968"></a>04968         }
<a name="l04969"></a>04969         adapter-&gt;num_rx_queues = vmdq_i;
<a name="l04970"></a>04970         adapter-&gt;num_tx_queues = vmdq_i;
<a name="l04971"></a>04971         ret = <span class="keyword">true</span>;
<a name="l04972"></a>04972         <span class="keywordflow">break</span>;
<a name="l04973"></a>04973 
<a name="l04974"></a>04974     <span class="keywordflow">default</span>:
<a name="l04975"></a>04975         ret = <span class="keyword">false</span>;
<a name="l04976"></a>04976         <span class="keywordflow">goto</span> vmdq_queues_out;
<a name="l04977"></a>04977     }
<a name="l04978"></a>04978 
<a name="l04979"></a>04979     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l04980"></a>04980         adapter-&gt;num_rx_pools = vmdq_i;
<a name="l04981"></a>04981         adapter-&gt;num_rx_queues_per_pool = adapter-&gt;num_rx_queues /
<a name="l04982"></a>04982                                           vmdq_i;
<a name="l04983"></a>04983     } <span class="keywordflow">else</span> {
<a name="l04984"></a>04984         adapter-&gt;num_rx_pools = adapter-&gt;num_rx_queues;
<a name="l04985"></a>04985         adapter-&gt;num_rx_queues_per_pool = 1;
<a name="l04986"></a>04986     }
<a name="l04987"></a>04987     <span class="comment">/* save the mask for later use */</span>
<a name="l04988"></a>04988     adapter-&gt;ring_feature[RING_F_VMDQ].mask = vmdq_m;
<a name="l04989"></a>04989 vmdq_queues_out:
<a name="l04990"></a>04990     <span class="keywordflow">return</span> ret;
<a name="l04991"></a>04991 }
<a name="l04992"></a>04992 
<a name="l05001"></a>05001 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_rss_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05002"></a>05002 {
<a name="l05003"></a>05003     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05004"></a>05004     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_RSS];
<a name="l05005"></a>05005 
<a name="l05006"></a>05006     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) {
<a name="l05007"></a>05007         f-&gt;mask = 0xF;
<a name="l05008"></a>05008         adapter-&gt;num_rx_queues = f-&gt;indices;
<a name="l05009"></a>05009 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l05010"></a>05010 <span class="preprocessor"></span>        adapter-&gt;num_tx_queues = f-&gt;indices;
<a name="l05011"></a>05011 <span class="preprocessor">#endif</span>
<a name="l05012"></a>05012 <span class="preprocessor"></span>        ret = <span class="keyword">true</span>;
<a name="l05013"></a>05013     }
<a name="l05014"></a>05014 
<a name="l05015"></a>05015     <span class="keywordflow">return</span> ret;
<a name="l05016"></a>05016 }
<a name="l05017"></a>05017 
<a name="l05028"></a>05028 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_fdir_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05029"></a>05029 {
<a name="l05030"></a>05030     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05031"></a>05031     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f_fdir = &amp;adapter-&gt;ring_feature[RING_F_FDIR];
<a name="l05032"></a>05032 
<a name="l05033"></a>05033     f_fdir-&gt;indices = min((<span class="keywordtype">int</span>)num_online_cpus(), f_fdir-&gt;indices);
<a name="l05034"></a>05034     f_fdir-&gt;mask = 0;
<a name="l05035"></a>05035 
<a name="l05036"></a>05036     <span class="comment">/*</span>
<a name="l05037"></a>05037 <span class="comment">     * Use RSS in addition to Flow Director to ensure the best</span>
<a name="l05038"></a>05038 <span class="comment">     * distribution of flows across cores, even when an FDIR flow</span>
<a name="l05039"></a>05039 <span class="comment">     * isn&#39;t matched.</span>
<a name="l05040"></a>05040 <span class="comment">     */</span>
<a name="l05041"></a>05041     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) &amp;&amp;
<a name="l05042"></a>05042         (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE)) {
<a name="l05043"></a>05043 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l05044"></a>05044 <span class="preprocessor"></span>        adapter-&gt;num_tx_queues = f_fdir-&gt;indices;
<a name="l05045"></a>05045 <span class="preprocessor">#endif</span>
<a name="l05046"></a>05046 <span class="preprocessor"></span>        adapter-&gt;num_rx_queues = f_fdir-&gt;indices;
<a name="l05047"></a>05047         ret = <span class="keyword">true</span>;
<a name="l05048"></a>05048     } <span class="keywordflow">else</span> {
<a name="l05049"></a>05049         adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l05050"></a>05050     }
<a name="l05051"></a>05051     <span class="keywordflow">return</span> ret;
<a name="l05052"></a>05052 }
<a name="l05053"></a>05053 
<a name="l05054"></a>05054 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05055"></a>05055 <span class="preprocessor"></span>
<a name="l05065"></a>05065 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_fcoe_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05066"></a>05066 {
<a name="l05067"></a>05067     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05068"></a>05068     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l05069"></a>05069 
<a name="l05070"></a>05070     f-&gt;indices = min((<span class="keywordtype">int</span>)num_online_cpus(), f-&gt;indices);
<a name="l05071"></a>05071     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) {
<a name="l05072"></a>05072         adapter-&gt;num_rx_queues = 1;
<a name="l05073"></a>05073         adapter-&gt;num_tx_queues = 1;
<a name="l05074"></a>05074         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l05075"></a>05075             ixgbe_set_dcb_queues(adapter);
<a name="l05076"></a>05076         }
<a name="l05077"></a>05077         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) {
<a name="l05078"></a>05078             <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE)
<a name="l05079"></a>05079                 ixgbe_set_fdir_queues(adapter);
<a name="l05080"></a>05080             <span class="keywordflow">else</span>
<a name="l05081"></a>05081                 ixgbe_set_rss_queues(adapter);
<a name="l05082"></a>05082         }
<a name="l05083"></a>05083         <span class="comment">/* adding FCoE queues */</span>
<a name="l05084"></a>05084         f-&gt;mask = adapter-&gt;num_rx_queues;
<a name="l05085"></a>05085         adapter-&gt;num_rx_queues += f-&gt;indices;
<a name="l05086"></a>05086         adapter-&gt;num_tx_queues += f-&gt;indices;
<a name="l05087"></a>05087 
<a name="l05088"></a>05088         ret = <span class="keyword">true</span>;
<a name="l05089"></a>05089     }
<a name="l05090"></a>05090 
<a name="l05091"></a>05091     <span class="keywordflow">return</span> ret;
<a name="l05092"></a>05092 }
<a name="l05093"></a>05093 
<a name="l05094"></a>05094 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05095"></a>05095 
<a name="l05104"></a>05104 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_sriov_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05105"></a>05105 {
<a name="l05106"></a>05106     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05107"></a>05107 }
<a name="l05108"></a>05108 
<a name="l05109"></a>05109 <span class="comment">/*</span>
<a name="l05110"></a>05110 <span class="comment"> * ixgbe_set_num_queues: Allocate queues for device, feature dependant</span>
<a name="l05111"></a>05111 <span class="comment"> * @adapter: board private structure to initialize</span>
<a name="l05112"></a>05112 <span class="comment"> *</span>
<a name="l05113"></a>05113 <span class="comment"> * This is the top level queue allocation routine.  The order here is very</span>
<a name="l05114"></a>05114 <span class="comment"> * important, starting with the &quot;most&quot; number of features turned on at once,</span>
<a name="l05115"></a>05115 <span class="comment"> * and ending with the smallest set of features.  This way large combinations</span>
<a name="l05116"></a>05116 <span class="comment"> * can be allocated if they&#39;re turned on, and smaller combinations are the</span>
<a name="l05117"></a>05117 <span class="comment"> * fallthrough conditions.</span>
<a name="l05118"></a>05118 <span class="comment"> *</span>
<a name="l05119"></a>05119 <span class="comment"> **/</span>
<a name="l05120"></a>05120 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_num_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05121"></a>05121 {
<a name="l05122"></a>05122     <span class="comment">/* Start with base case */</span>
<a name="l05123"></a>05123     adapter-&gt;num_rx_queues = 1;
<a name="l05124"></a>05124     adapter-&gt;num_tx_queues = 1;
<a name="l05125"></a>05125     adapter-&gt;num_rx_pools = adapter-&gt;num_rx_queues;
<a name="l05126"></a>05126     adapter-&gt;num_rx_queues_per_pool = 1;
<a name="l05127"></a>05127 
<a name="l05128"></a>05128     <span class="keywordflow">if</span> (ixgbe_set_sriov_queues(adapter))
<a name="l05129"></a>05129         <span class="keywordflow">return</span>;
<a name="l05130"></a>05130 
<a name="l05131"></a>05131     <span class="keywordflow">if</span> (ixgbe_set_vmdq_queues(adapter))
<a name="l05132"></a>05132         <span class="keywordflow">return</span>;
<a name="l05133"></a>05133 
<a name="l05134"></a>05134 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05135"></a>05135 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ixgbe_set_fcoe_queues(adapter))
<a name="l05136"></a>05136         <span class="keywordflow">return</span>;
<a name="l05137"></a>05137 
<a name="l05138"></a>05138 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05139"></a>05139     <span class="keywordflow">if</span> (ixgbe_set_dcb_queues(adapter))
<a name="l05140"></a>05140         <span class="keywordflow">return</span>;
<a name="l05141"></a>05141 
<a name="l05142"></a>05142     <span class="keywordflow">if</span> (ixgbe_set_fdir_queues(adapter))
<a name="l05143"></a>05143         <span class="keywordflow">return</span>;
<a name="l05144"></a>05144 
<a name="l05145"></a>05145     <span class="keywordflow">if</span> (ixgbe_set_rss_queues(adapter))
<a name="l05146"></a>05146         <span class="keywordflow">return</span>;
<a name="l05147"></a>05147 }
<a name="l05148"></a>05148 
<a name="l05149"></a>05149 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_acquire_msix_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l05150"></a>05150                        <span class="keywordtype">int</span> vectors)
<a name="l05151"></a>05151 {
<a name="l05152"></a>05152     <span class="keywordtype">int</span> err, vector_threshold;
<a name="l05153"></a>05153 
<a name="l05154"></a>05154     <span class="comment">/* We&#39;ll want at least 3 (vector_threshold):</span>
<a name="l05155"></a>05155 <span class="comment">     * 1) TxQ[0] Cleanup</span>
<a name="l05156"></a>05156 <span class="comment">     * 2) RxQ[0] Cleanup</span>
<a name="l05157"></a>05157 <span class="comment">     * 3) Other (Link Status Change, etc.)</span>
<a name="l05158"></a>05158 <span class="comment">     * 4) TCP Timer (optional)</span>
<a name="l05159"></a>05159 <span class="comment">     */</span>
<a name="l05160"></a>05160     vector_threshold = MIN_MSIX_COUNT;
<a name="l05161"></a>05161 
<a name="l05162"></a>05162     <span class="comment">/* The more we get, the more we will assign to Tx/Rx Cleanup</span>
<a name="l05163"></a>05163 <span class="comment">     * for the separate queues...where Rx Cleanup &gt;= Tx Cleanup.</span>
<a name="l05164"></a>05164 <span class="comment">     * Right now, we simply care about how many we&#39;ll get; we&#39;ll</span>
<a name="l05165"></a>05165 <span class="comment">     * set them up later while requesting irq&#39;s.</span>
<a name="l05166"></a>05166 <span class="comment">     */</span>
<a name="l05167"></a>05167     <span class="keywordflow">while</span> (vectors &gt;= vector_threshold) {
<a name="l05168"></a>05168         err = pci_enable_msix(adapter-&gt;pdev, adapter-&gt;msix_entries,
<a name="l05169"></a>05169                       vectors);
<a name="l05170"></a>05170         <span class="keywordflow">if</span> (!err) <span class="comment">/* Success in acquiring all requested vectors. */</span>
<a name="l05171"></a>05171             <span class="keywordflow">break</span>;
<a name="l05172"></a>05172         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err &lt; 0)
<a name="l05173"></a>05173             vectors = 0; <span class="comment">/* Nasty failure, quit now */</span>
<a name="l05174"></a>05174         <span class="keywordflow">else</span> <span class="comment">/* err == number of vectors we should try again with */</span>
<a name="l05175"></a>05175             vectors = err;
<a name="l05176"></a>05176     }
<a name="l05177"></a>05177 
<a name="l05178"></a>05178     <span class="keywordflow">if</span> (vectors &lt; vector_threshold) {
<a name="l05179"></a>05179         <span class="comment">/* Can&#39;t allocate enough MSI-X interrupts?  Oh well.</span>
<a name="l05180"></a>05180 <span class="comment">         * This just means we&#39;ll go with either a single MSI</span>
<a name="l05181"></a>05181 <span class="comment">         * vector or fall back to legacy interrupts.</span>
<a name="l05182"></a>05182 <span class="comment">         */</span>
<a name="l05183"></a>05183         e_warn(hw, <span class="stringliteral">&quot;Unable to allocate MSI-X interrupts\n&quot;</span>);
<a name="l05184"></a>05184         adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSIX_ENABLED;
<a name="l05185"></a>05185         kfree(adapter-&gt;msix_entries);
<a name="l05186"></a>05186         adapter-&gt;msix_entries = NULL;
<a name="l05187"></a>05187     } <span class="keywordflow">else</span> {
<a name="l05188"></a>05188         adapter-&gt;flags |= IXGBE_FLAG_MSIX_ENABLED; <span class="comment">/* Woot! */</span>
<a name="l05189"></a>05189         <span class="comment">/*</span>
<a name="l05190"></a>05190 <span class="comment">         * Adjust for only the vectors we&#39;ll use, which is minimum</span>
<a name="l05191"></a>05191 <span class="comment">         * of max_msix_q_vectors + NON_Q_VECTORS, or the number of</span>
<a name="l05192"></a>05192 <span class="comment">         * vectors we were allocated.</span>
<a name="l05193"></a>05193 <span class="comment">         */</span>
<a name="l05194"></a>05194         adapter-&gt;num_msix_vectors = min(vectors,
<a name="l05195"></a>05195                    adapter-&gt;max_msix_q_vectors + NON_Q_VECTORS);
<a name="l05196"></a>05196     }
<a name="l05197"></a>05197 }
<a name="l05198"></a>05198 
<a name="l05206"></a>05206 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_rss(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05207"></a>05207 {
<a name="l05208"></a>05208     <span class="keywordtype">int</span> i;
<a name="l05209"></a>05209 
<a name="l05210"></a>05210     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED))
<a name="l05211"></a>05211         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05212"></a>05212 
<a name="l05213"></a>05213     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05214"></a>05214         adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05215"></a>05215     for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05216"></a>05216         adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05217"></a>05217 
<a name="l05218"></a>05218     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05219"></a>05219 }
<a name="l05220"></a>05220 
<a name="l05228"></a>05228 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_dcb(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05229"></a>05229 {
<a name="l05230"></a>05230     <span class="keywordtype">int</span> i;
<a name="l05231"></a>05231     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05232"></a>05232     <span class="keywordtype">int</span> dcb_i = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l05233"></a>05233 
<a name="l05234"></a>05234     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l05235"></a>05235         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05236"></a>05236 
<a name="l05237"></a>05237     <span class="comment">/* the number of queues is assumed to be symmetric */</span>
<a name="l05238"></a>05238     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l05239"></a>05239     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l05240"></a>05240         <span class="keywordflow">for</span> (i = 0; i &lt; dcb_i; i++) {
<a name="l05241"></a>05241             adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 3;
<a name="l05242"></a>05242             adapter-&gt;tx_ring[i]-&gt;reg_idx = i &lt;&lt; 2;
<a name="l05243"></a>05243         }
<a name="l05244"></a>05244         ret = <span class="keyword">true</span>;
<a name="l05245"></a>05245         <span class="keywordflow">break</span>;
<a name="l05246"></a>05246     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05247"></a>05247     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05248"></a>05248         <span class="keywordflow">if</span> (dcb_i == 8) {
<a name="l05249"></a>05249             <span class="comment">/*</span>
<a name="l05250"></a>05250 <span class="comment">             * Tx TC0 starts at: descriptor queue 0</span>
<a name="l05251"></a>05251 <span class="comment">             * Tx TC1 starts at: descriptor queue 32</span>
<a name="l05252"></a>05252 <span class="comment">             * Tx TC2 starts at: descriptor queue 64</span>
<a name="l05253"></a>05253 <span class="comment">             * Tx TC3 starts at: descriptor queue 80</span>
<a name="l05254"></a>05254 <span class="comment">             * Tx TC4 starts at: descriptor queue 96</span>
<a name="l05255"></a>05255 <span class="comment">             * Tx TC5 starts at: descriptor queue 104</span>
<a name="l05256"></a>05256 <span class="comment">             * Tx TC6 starts at: descriptor queue 112</span>
<a name="l05257"></a>05257 <span class="comment">             * Tx TC7 starts at: descriptor queue 120</span>
<a name="l05258"></a>05258 <span class="comment">             *</span>
<a name="l05259"></a>05259 <span class="comment">             * Rx TC0-TC7 are offset by 16 queues each</span>
<a name="l05260"></a>05260 <span class="comment">             */</span>
<a name="l05261"></a>05261             <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l05262"></a>05262                 adapter-&gt;tx_ring[i]-&gt;reg_idx = i &lt;&lt; 5;
<a name="l05263"></a>05263                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 4;
<a name="l05264"></a>05264             }
<a name="l05265"></a>05265             <span class="keywordflow">for</span> ( ; i &lt; 5; i++) {
<a name="l05266"></a>05266                 adapter-&gt;tx_ring[i]-&gt;reg_idx = ((i + 2) &lt;&lt; 4);
<a name="l05267"></a>05267                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 4;
<a name="l05268"></a>05268             }
<a name="l05269"></a>05269             <span class="keywordflow">for</span> ( ; i &lt; dcb_i; i++) {
<a name="l05270"></a>05270                 adapter-&gt;tx_ring[i]-&gt;reg_idx = ((i + 8) &lt;&lt; 3);
<a name="l05271"></a>05271                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 4;
<a name="l05272"></a>05272             }
<a name="l05273"></a>05273             ret = <span class="keyword">true</span>;
<a name="l05274"></a>05274         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dcb_i == 4) {
<a name="l05275"></a>05275             <span class="comment">/*</span>
<a name="l05276"></a>05276 <span class="comment">             * Tx TC0 starts at: descriptor queue 0</span>
<a name="l05277"></a>05277 <span class="comment">             * Tx TC1 starts at: descriptor queue 64</span>
<a name="l05278"></a>05278 <span class="comment">             * Tx TC2 starts at: descriptor queue 96</span>
<a name="l05279"></a>05279 <span class="comment">             * Tx TC3 starts at: descriptor queue 112</span>
<a name="l05280"></a>05280 <span class="comment">             *</span>
<a name="l05281"></a>05281 <span class="comment">             * Rx TC0-TC3 are offset by 32 queues each</span>
<a name="l05282"></a>05282 <span class="comment">             */</span>
<a name="l05283"></a>05283             adapter-&gt;tx_ring[0]-&gt;reg_idx = 0;
<a name="l05284"></a>05284             adapter-&gt;tx_ring[1]-&gt;reg_idx = 64;
<a name="l05285"></a>05285             adapter-&gt;tx_ring[2]-&gt;reg_idx = 96;
<a name="l05286"></a>05286             adapter-&gt;tx_ring[3]-&gt;reg_idx = 112;
<a name="l05287"></a>05287             <span class="keywordflow">for</span> (i = 0 ; i &lt; dcb_i; i++)
<a name="l05288"></a>05288                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 5;
<a name="l05289"></a>05289             ret = <span class="keyword">true</span>;
<a name="l05290"></a>05290         }
<a name="l05291"></a>05291         <span class="keywordflow">break</span>;
<a name="l05292"></a>05292     <span class="keywordflow">default</span>:
<a name="l05293"></a>05293         <span class="keywordflow">break</span>;
<a name="l05294"></a>05294     }
<a name="l05295"></a>05295     <span class="keywordflow">return</span> ret;
<a name="l05296"></a>05296 }
<a name="l05297"></a>05297 
<a name="l05307"></a>05307 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_vmdq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05308"></a>05308 {
<a name="l05309"></a>05309     <span class="keywordtype">int</span> i;
<a name="l05310"></a>05310     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05311"></a>05311 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05312"></a>05312 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l05313"></a>05313 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05314"></a>05314     <span class="keywordflow">switch</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_RSS_ENABLED
<a name="l05315"></a>05315                    | IXGBE_FLAG_DCB_ENABLED
<a name="l05316"></a>05316                    | IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l05317"></a>05317 
<a name="l05318"></a>05318     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l05319"></a>05319         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l05320"></a>05320         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05321"></a>05321         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05322"></a>05322             <span class="comment">/* since the # of rss queues per vmdq pool is</span>
<a name="l05323"></a>05323 <span class="comment">             * limited to either 2 or 4, there is no index</span>
<a name="l05324"></a>05324 <span class="comment">             * skipping and we can set them up with no</span>
<a name="l05325"></a>05325 <span class="comment">             * funky mapping</span>
<a name="l05326"></a>05326 <span class="comment">             */</span>
<a name="l05327"></a>05327             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05328"></a>05328                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05329"></a>05329             for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05330"></a>05330                 adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05331"></a>05331             ret = <span class="keyword">true</span>;
<a name="l05332"></a>05332             <span class="keywordflow">break</span>;
<a name="l05333"></a>05333         <span class="keywordflow">default</span>:
<a name="l05334"></a>05334             <span class="keywordflow">break</span>;
<a name="l05335"></a>05335         }
<a name="l05336"></a>05336         <span class="keywordflow">break</span>;
<a name="l05337"></a>05337 
<a name="l05338"></a>05338     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_DCB_ENABLED):
<a name="l05339"></a>05339         <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82599EB) {
<a name="l05340"></a>05340             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l05341"></a>05341                 adapter-&gt;rx_ring[i]-&gt;reg_idx =
<a name="l05342"></a>05342                     (adapter-&gt;num_vfs + i) *
<a name="l05343"></a>05343                      adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l05344"></a>05344 #ifdef IXGBE_FCOE
<a name="l05345"></a>05345                 if (i &gt;= adapter-&gt;num_rx_queues - f-&gt;indices)
<a name="l05346"></a>05346                     adapter-&gt;rx_ring[i]-&gt;reg_idx +=
<a name="l05347"></a>05347                         adapter-&gt;fcoe.tc;
<a name="l05348"></a>05348 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05349"></a>05349             }
<a name="l05350"></a>05350             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l05351"></a>05351                 adapter-&gt;tx_ring[i]-&gt;reg_idx =
<a name="l05352"></a>05352                     (adapter-&gt;num_vfs + i) *
<a name="l05353"></a>05353                      adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l05354"></a>05354 #ifdef IXGBE_FCOE
<a name="l05355"></a>05355                 if (i &gt;= adapter-&gt;num_tx_queues - f-&gt;indices)
<a name="l05356"></a>05356                     adapter-&gt;tx_ring[i]-&gt;reg_idx +=
<a name="l05357"></a>05357                         adapter-&gt;fcoe.tc;
<a name="l05358"></a>05358 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05359"></a>05359             }
<a name="l05360"></a>05360             ret = <span class="keyword">true</span>;
<a name="l05361"></a>05361         }
<a name="l05362"></a>05362         <span class="keywordflow">break</span>;
<a name="l05363"></a>05363 
<a name="l05364"></a>05364     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l05365"></a>05365         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l05366"></a>05366         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l05367"></a>05367             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05368"></a>05368                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05369"></a>05369             for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05370"></a>05370                 adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05371"></a>05371             ret = <span class="keyword">true</span>;
<a name="l05372"></a>05372             <span class="keywordflow">break</span>;
<a name="l05373"></a>05373         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05374"></a>05374         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05375"></a>05375             <span class="comment">/* even without rss, there are 2 queues per</span>
<a name="l05376"></a>05376 <span class="comment">             * pool, the odd numbered ones are unused.</span>
<a name="l05377"></a>05377 <span class="comment">             */</span>
<a name="l05378"></a>05378             for (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05379"></a>05379                 adapter-&gt;rx_ring[i]-&gt;reg_idx = VMDQ_P(i) * 2;
<a name="l05380"></a>05380             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05381"></a>05381                 adapter-&gt;tx_ring[i]-&gt;reg_idx = VMDQ_P(i) * 2;
<a name="l05382"></a>05382             ret = <span class="keyword">true</span>;
<a name="l05383"></a>05383             <span class="keywordflow">break</span>;
<a name="l05384"></a>05384         <span class="keywordflow">default</span>:
<a name="l05385"></a>05385             <span class="keywordflow">break</span>;
<a name="l05386"></a>05386         }
<a name="l05387"></a>05387         <span class="keywordflow">break</span>;
<a name="l05388"></a>05388     }
<a name="l05389"></a>05389 
<a name="l05390"></a>05390     <span class="keywordflow">return</span> ret;
<a name="l05391"></a>05391 }
<a name="l05392"></a>05392 
<a name="l05400"></a>05400 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_fdir(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05401"></a>05401 {
<a name="l05402"></a>05402     <span class="keywordtype">int</span> i;
<a name="l05403"></a>05403     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05404"></a>05404 
<a name="l05405"></a>05405     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) &amp;&amp;
<a name="l05406"></a>05406         (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE)) {
<a name="l05407"></a>05407         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05408"></a>05408             adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05409"></a>05409         for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05410"></a>05410             adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05411"></a>05411         ret = <span class="keyword">true</span>;
<a name="l05412"></a>05412     }
<a name="l05413"></a>05413 
<a name="l05414"></a>05414     <span class="keywordflow">return</span> ret;
<a name="l05415"></a>05415 }
<a name="l05416"></a>05416 
<a name="l05417"></a>05417 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05418"></a>05418 <span class="preprocessor"></span>
<a name="l05425"></a>05425 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_fcoe(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05426"></a>05426 {
<a name="l05427"></a>05427     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l05428"></a>05428     <span class="keywordtype">int</span> i;
<a name="l05429"></a>05429     u8 fcoe_rx_i = 0, fcoe_tx_i = 0;
<a name="l05430"></a>05430 
<a name="l05431"></a>05431     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED))
<a name="l05432"></a>05432         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05433"></a>05433 
<a name="l05434"></a>05434     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l05435"></a>05435         <span class="keyword">struct </span>ixgbe_fcoe *fcoe = &amp;adapter-&gt;fcoe;
<a name="l05436"></a>05436 
<a name="l05437"></a>05437         ixgbe_cache_ring_dcb(adapter);
<a name="l05438"></a>05438         <span class="comment">/* find out queues in TC for FCoE */</span>
<a name="l05439"></a>05439         fcoe_rx_i = adapter-&gt;rx_ring[fcoe-&gt;tc]-&gt;reg_idx + 1;
<a name="l05440"></a>05440         fcoe_tx_i = adapter-&gt;tx_ring[fcoe-&gt;tc]-&gt;reg_idx + 1;
<a name="l05441"></a>05441         <span class="comment">/*</span>
<a name="l05442"></a>05442 <span class="comment">         * In 82599, the number of Tx queues for each traffic</span>
<a name="l05443"></a>05443 <span class="comment">         * class for both 8-TC and 4-TC modes are:</span>
<a name="l05444"></a>05444 <span class="comment">         * TCs  : TC0 TC1 TC2 TC3 TC4 TC5 TC6 TC7</span>
<a name="l05445"></a>05445 <span class="comment">         * 8 TCs:  32  32  16  16   8   8   8   8</span>
<a name="l05446"></a>05446 <span class="comment">         * 4 TCs:  64  64  32  32</span>
<a name="l05447"></a>05447 <span class="comment">         * We have max 8 queues for FCoE, where 8 the is</span>
<a name="l05448"></a>05448 <span class="comment">         * FCoE redirection table size. If TC for FCoE is</span>
<a name="l05449"></a>05449 <span class="comment">         * less than or equal to TC3, we have enough queues</span>
<a name="l05450"></a>05450 <span class="comment">         * to add max of 8 queues for FCoE, so we start FCoE</span>
<a name="l05451"></a>05451 <span class="comment">         * tx queue from the next one, i.e., reg_idx + 1.</span>
<a name="l05452"></a>05452 <span class="comment">         * If TC for FCoE is above TC3, implying 8 TC mode,</span>
<a name="l05453"></a>05453 <span class="comment">         * and we need 8 for FCoE, we have to take all queues</span>
<a name="l05454"></a>05454 <span class="comment">         * in that traffic class for FCoE.</span>
<a name="l05455"></a>05455 <span class="comment">         */</span>
<a name="l05456"></a>05456         <span class="keywordflow">if</span> ((f-&gt;indices == IXGBE_FCRETA_SIZE) &amp;&amp; (fcoe-&gt;tc &gt; 3))
<a name="l05457"></a>05457             fcoe_tx_i--;
<a name="l05458"></a>05458     }
<a name="l05459"></a>05459     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) {
<a name="l05460"></a>05460         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE)
<a name="l05461"></a>05461             ixgbe_cache_ring_fdir(adapter);
<a name="l05462"></a>05462         <span class="keywordflow">else</span>
<a name="l05463"></a>05463             ixgbe_cache_ring_rss(adapter);
<a name="l05464"></a>05464 
<a name="l05465"></a>05465         fcoe_rx_i = f-&gt;mask;
<a name="l05466"></a>05466         fcoe_tx_i = f-&gt;mask;
<a name="l05467"></a>05467     }
<a name="l05468"></a>05468     <span class="keywordflow">for</span> (i = 0; i &lt; f-&gt;indices; i++, fcoe_rx_i++, fcoe_tx_i++) {
<a name="l05469"></a>05469         adapter-&gt;rx_ring[f-&gt;mask + i]-&gt;reg_idx = fcoe_rx_i;
<a name="l05470"></a>05470         adapter-&gt;tx_ring[f-&gt;mask + i]-&gt;reg_idx = fcoe_tx_i;
<a name="l05471"></a>05471     }
<a name="l05472"></a>05472     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05473"></a>05473 }
<a name="l05474"></a>05474 
<a name="l05475"></a>05475 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05476"></a>05476 
<a name="l05484"></a>05484 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_sriov(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05485"></a>05485 {
<a name="l05486"></a>05486     adapter-&gt;rx_ring[0]-&gt;reg_idx = adapter-&gt;num_vfs * 2;
<a name="l05487"></a>05487     adapter-&gt;tx_ring[0]-&gt;reg_idx = adapter-&gt;num_vfs * 2;
<a name="l05488"></a>05488     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05489"></a>05489 }
<a name="l05490"></a>05490 
<a name="l05502"></a>05502 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_cache_ring_register(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05503"></a>05503 {
<a name="l05504"></a>05504     <span class="comment">/* start with default case */</span>
<a name="l05505"></a>05505     adapter-&gt;rx_ring[0]-&gt;reg_idx = 0;
<a name="l05506"></a>05506     adapter-&gt;tx_ring[0]-&gt;reg_idx = 0;
<a name="l05507"></a>05507 
<a name="l05508"></a>05508     <span class="keywordflow">if</span> (ixgbe_cache_ring_sriov(adapter))
<a name="l05509"></a>05509         <span class="keywordflow">return</span>;
<a name="l05510"></a>05510 
<a name="l05511"></a>05511     <span class="keywordflow">if</span> (ixgbe_cache_ring_vmdq(adapter))
<a name="l05512"></a>05512         <span class="keywordflow">return</span>;
<a name="l05513"></a>05513 
<a name="l05514"></a>05514 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05515"></a>05515 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ixgbe_cache_ring_fcoe(adapter))
<a name="l05516"></a>05516         <span class="keywordflow">return</span>;
<a name="l05517"></a>05517 
<a name="l05518"></a>05518 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05519"></a>05519     <span class="keywordflow">if</span> (ixgbe_cache_ring_dcb(adapter))
<a name="l05520"></a>05520         <span class="keywordflow">return</span>;
<a name="l05521"></a>05521 
<a name="l05522"></a>05522     <span class="keywordflow">if</span> (ixgbe_cache_ring_fdir(adapter))
<a name="l05523"></a>05523         <span class="keywordflow">return</span>;
<a name="l05524"></a>05524 
<a name="l05525"></a>05525     <span class="keywordflow">if</span> (ixgbe_cache_ring_rss(adapter))
<a name="l05526"></a>05526         <span class="keywordflow">return</span>;
<a name="l05527"></a>05527 }
<a name="l05528"></a>05528 
<a name="l05537"></a>05537 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_alloc_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05538"></a>05538 {
<a name="l05539"></a>05539     <span class="keywordtype">int</span> i;
<a name="l05540"></a>05540     <span class="keywordtype">int</span> rx_count;
<a name="l05541"></a>05541 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05542"></a>05542 <span class="preprocessor"></span>    <span class="keywordtype">int</span> orig_node = adapter-&gt;node;
<a name="l05543"></a>05543 
<a name="l05544"></a>05544     WARN_ON(orig_node != -1 &amp;&amp; !node_online(orig_node));
<a name="l05545"></a>05545 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05546"></a>05546 
<a name="l05547"></a>05547     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l05548"></a>05548         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;tx_ring[i];
<a name="l05549"></a>05549 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05550"></a>05550 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (orig_node == -1) {
<a name="l05551"></a>05551             <span class="keywordtype">int</span> cur_node = next_online_node(adapter-&gt;node);
<a name="l05552"></a>05552             <span class="keywordflow">if</span> (cur_node == MAX_NUMNODES)
<a name="l05553"></a>05553                 cur_node = first_online_node;
<a name="l05554"></a>05554             adapter-&gt;node = cur_node;
<a name="l05555"></a>05555         }
<a name="l05556"></a>05556 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05557"></a>05557         ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL,
<a name="l05558"></a>05558                     adapter-&gt;node);
<a name="l05559"></a>05559         <span class="keywordflow">if</span> (!ring)
<a name="l05560"></a>05560             ring = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL);
<a name="l05561"></a>05561         <span class="keywordflow">if</span> (!ring)
<a name="l05562"></a>05562             <span class="keywordflow">goto</span> err_tx_ring_allocation;
<a name="l05563"></a>05563         ring-&gt;count = adapter-&gt;tx_ring_count;
<a name="l05564"></a>05564         ring-&gt;queue_index = i;
<a name="l05565"></a>05565         ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l05566"></a>05566         ring-&gt;netdev = adapter-&gt;netdev;
<a name="l05567"></a>05567         ring-&gt;numa_node = adapter-&gt;node;
<a name="l05568"></a>05568 
<a name="l05569"></a>05569         adapter-&gt;tx_ring[i] = ring;
<a name="l05570"></a>05570     }
<a name="l05571"></a>05571 
<a name="l05572"></a>05572 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05573"></a>05573 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l05574"></a>05574     adapter-&gt;node = orig_node;
<a name="l05575"></a>05575 
<a name="l05576"></a>05576 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05577"></a>05577     rx_count = adapter-&gt;rx_ring_count;
<a name="l05578"></a>05578     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l05579"></a>05579         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;rx_ring[i];
<a name="l05580"></a>05580 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05581"></a>05581 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (orig_node == -1) {
<a name="l05582"></a>05582             <span class="keywordtype">int</span> cur_node = next_online_node(adapter-&gt;node);
<a name="l05583"></a>05583             <span class="keywordflow">if</span> (cur_node == MAX_NUMNODES)
<a name="l05584"></a>05584                 cur_node = first_online_node;
<a name="l05585"></a>05585             adapter-&gt;node = cur_node;
<a name="l05586"></a>05586         }
<a name="l05587"></a>05587 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05588"></a>05588         ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL,
<a name="l05589"></a>05589                     adapter-&gt;node);
<a name="l05590"></a>05590         <span class="keywordflow">if</span> (!ring)
<a name="l05591"></a>05591             ring = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL);
<a name="l05592"></a>05592         <span class="keywordflow">if</span> (!ring)
<a name="l05593"></a>05593             <span class="keywordflow">goto</span> err_rx_ring_allocation;
<a name="l05594"></a>05594         ring-&gt;count = rx_count;
<a name="l05595"></a>05595         ring-&gt;queue_index = i;
<a name="l05596"></a>05596         ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l05597"></a>05597         ring-&gt;netdev = adapter-&gt;netdev;
<a name="l05598"></a>05598         ring-&gt;numa_node = adapter-&gt;node;
<a name="l05599"></a>05599 
<a name="l05600"></a>05600         adapter-&gt;rx_ring[i] = ring;
<a name="l05601"></a>05601     }
<a name="l05602"></a>05602 
<a name="l05603"></a>05603 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05604"></a>05604 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l05605"></a>05605     adapter-&gt;node = orig_node;
<a name="l05606"></a>05606 
<a name="l05607"></a>05607 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05608"></a>05608     ixgbe_cache_ring_register(adapter);
<a name="l05609"></a>05609 
<a name="l05610"></a>05610     <span class="keywordflow">return</span> 0;
<a name="l05611"></a>05611 
<a name="l05612"></a>05612 err_rx_ring_allocation:
<a name="l05613"></a>05613     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05614"></a>05614         kfree(adapter-&gt;tx_ring[i]);
<a name="l05615"></a>05615 err_tx_ring_allocation:
<a name="l05616"></a>05616     <span class="keywordflow">return</span> -ENOMEM;
<a name="l05617"></a>05617 }
<a name="l05618"></a>05618 
<a name="l05626"></a>05626 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05627"></a>05627 {
<a name="l05628"></a>05628     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05629"></a>05629     <span class="keywordtype">int</span> err = 0;
<a name="l05630"></a>05630     <span class="keywordtype">int</span> vector, v_budget;
<a name="l05631"></a>05631 
<a name="l05632"></a>05632     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_CAPABLE))
<a name="l05633"></a>05633         <span class="keywordflow">goto</span> try_msi;
<a name="l05634"></a>05634 
<a name="l05635"></a>05635     <span class="comment">/*</span>
<a name="l05636"></a>05636 <span class="comment">     * It&#39;s easy to be greedy for MSI-X vectors, but it really</span>
<a name="l05637"></a>05637 <span class="comment">     * doesn&#39;t do us much good if we have a lot more vectors</span>
<a name="l05638"></a>05638 <span class="comment">     * than CPU&#39;s.  So let&#39;s be conservative and only ask for</span>
<a name="l05639"></a>05639 <span class="comment">     * (roughly) the same number of vectors as there are CPU&#39;s.</span>
<a name="l05640"></a>05640 <span class="comment">     */</span>
<a name="l05641"></a>05641     v_budget = min(adapter-&gt;num_rx_queues + adapter-&gt;num_tx_queues,
<a name="l05642"></a>05642                (<span class="keywordtype">int</span>)num_online_cpus()) + NON_Q_VECTORS;
<a name="l05643"></a>05643 
<a name="l05644"></a>05644     <span class="comment">/*</span>
<a name="l05645"></a>05645 <span class="comment">     * At the same time, hardware can only support a maximum of</span>
<a name="l05646"></a>05646 <span class="comment">     * hw.mac-&gt;max_msix_vectors vectors.  With features</span>
<a name="l05647"></a>05647 <span class="comment">     * such as RSS and VMDq, we can easily surpass the number of Rx and Tx</span>
<a name="l05648"></a>05648 <span class="comment">     * descriptor queues supported by our device.  Thus, we cap it off in</span>
<a name="l05649"></a>05649 <span class="comment">     * those rare cases where the cpu count also exceeds our vector limit.</span>
<a name="l05650"></a>05650 <span class="comment">     */</span>
<a name="l05651"></a>05651     v_budget = min(v_budget, (<span class="keywordtype">int</span>)hw-&gt;mac.max_msix_vectors);
<a name="l05652"></a>05652 
<a name="l05653"></a>05653     <span class="comment">/* A failure in MSI-X entry allocation isn&#39;t fatal, but it does</span>
<a name="l05654"></a>05654 <span class="comment">     * mean we disable MSI-X capabilities of the adapter. */</span>
<a name="l05655"></a>05655     adapter-&gt;msix_entries = kcalloc(v_budget,
<a name="l05656"></a>05656                     <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msix_entry), GFP_KERNEL);
<a name="l05657"></a>05657     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l05658"></a>05658         <span class="keywordflow">for</span> (vector = 0; vector &lt; v_budget; vector++)
<a name="l05659"></a>05659             adapter-&gt;msix_entries[vector].entry = vector;
<a name="l05660"></a>05660 
<a name="l05661"></a>05661         ixgbe_acquire_msix_vectors(adapter, v_budget);
<a name="l05662"></a>05662 
<a name="l05663"></a>05663         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l05664"></a>05664             <span class="keywordflow">goto</span> out;
<a name="l05665"></a>05665     }
<a name="l05666"></a>05666 
<a name="l05667"></a>05667     adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCB_ENABLED;
<a name="l05668"></a>05668     adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCB_CAPABLE;
<a name="l05669"></a>05669     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) {
<a name="l05670"></a>05670         e_err(probe,
<a name="l05671"></a>05671               <span class="stringliteral">&quot;Flow Director is not supported while multiple &quot;</span>
<a name="l05672"></a>05672               <span class="stringliteral">&quot;queues are disabled.  Disabling Flow Director\n&quot;</span>);
<a name="l05673"></a>05673     }
<a name="l05674"></a>05674     adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l05675"></a>05675     adapter-&gt;atr_sample_rate = 0;
<a name="l05676"></a>05676     adapter-&gt;flags &amp;= ~IXGBE_FLAG_VMDQ_ENABLED;
<a name="l05677"></a>05677     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l05678"></a>05678         e_err(probe, <span class="stringliteral">&quot;MSI-X interrupt not available - disabling &quot;</span>
<a name="l05679"></a>05679               <span class="stringliteral">&quot;SR-IOV\n&quot;</span>);
<a name="l05680"></a>05680         ixgbe_disable_sriov(adapter);
<a name="l05681"></a>05681     }
<a name="l05682"></a>05682 
<a name="l05683"></a>05683     adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l05684"></a>05684     ixgbe_set_num_queues(adapter);
<a name="l05685"></a>05685 
<a name="l05686"></a>05686 try_msi:
<a name="l05687"></a>05687     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSI_CAPABLE))
<a name="l05688"></a>05688         <span class="keywordflow">goto</span> out;
<a name="l05689"></a>05689 
<a name="l05690"></a>05690     err = pci_enable_msi(adapter-&gt;pdev);
<a name="l05691"></a>05691     <span class="keywordflow">if</span> (!err) {
<a name="l05692"></a>05692         adapter-&gt;flags |= IXGBE_FLAG_MSI_ENABLED;
<a name="l05693"></a>05693     } <span class="keywordflow">else</span> {
<a name="l05694"></a>05694         e_warn(hw, <span class="stringliteral">&quot;Unable to allocate MSI interrupt, &quot;</span>
<a name="l05695"></a>05695                <span class="stringliteral">&quot;falling back to legacy.  Error: %d\n&quot;</span>, err);
<a name="l05696"></a>05696         <span class="comment">/* reset err */</span>
<a name="l05697"></a>05697         err = 0;
<a name="l05698"></a>05698     }
<a name="l05699"></a>05699 
<a name="l05700"></a>05700 out:
<a name="l05701"></a>05701     <span class="comment">/* Notify the stack of the (possibly) reduced Tx Queue count. */</span>
<a name="l05702"></a>05702     netif_set_real_num_tx_queues(adapter-&gt;netdev,
<a name="l05703"></a>05703                      adapter-&gt;num_rx_pools &gt; 1 ? 1 : adapter-&gt;num_tx_queues);
<a name="l05704"></a>05704     <span class="keywordflow">return</span> err;
<a name="l05705"></a>05705 }
<a name="l05706"></a>05706 
<a name="l05714"></a>05714 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_alloc_q_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05715"></a>05715 {
<a name="l05716"></a>05716     <span class="keywordtype">int</span> v_idx, num_q_vectors;
<a name="l05717"></a>05717     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l05718"></a>05718     <span class="keywordtype">int</span> rx_vectors;
<a name="l05719"></a>05719 
<a name="l05720"></a>05720     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l05721"></a>05721         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l05722"></a>05722         rx_vectors = adapter-&gt;num_rx_queues;
<a name="l05723"></a>05723     } <span class="keywordflow">else</span> {
<a name="l05724"></a>05724         num_q_vectors = 1;
<a name="l05725"></a>05725         rx_vectors = 1;
<a name="l05726"></a>05726     }
<a name="l05727"></a>05727 
<a name="l05728"></a>05728     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; num_q_vectors; v_idx++) {
<a name="l05729"></a>05729         q_vector = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a>),
<a name="l05730"></a>05730                     GFP_KERNEL, adapter-&gt;node);
<a name="l05731"></a>05731         <span class="keywordflow">if</span> (!q_vector)
<a name="l05732"></a>05732             q_vector = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a>),
<a name="l05733"></a>05733                        GFP_KERNEL);
<a name="l05734"></a>05734         <span class="keywordflow">if</span> (!q_vector)
<a name="l05735"></a>05735             <span class="keywordflow">goto</span> err_out;
<a name="l05736"></a>05736 
<a name="l05737"></a>05737         q_vector-&gt;adapter = adapter;
<a name="l05738"></a>05738         q_vector-&gt;v_idx = v_idx;
<a name="l05739"></a>05739 
<a name="l05740"></a>05740 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l05741"></a>05741 <span class="preprocessor"></span>        <span class="comment">/* Allocate the affinity_hint cpumask, configure the mask */</span>
<a name="l05742"></a>05742         <span class="keywordflow">if</span> (!alloc_cpumask_var(&amp;q_vector-&gt;affinity_mask, GFP_KERNEL))
<a name="l05743"></a>05743             <span class="keywordflow">goto</span> err_out;
<a name="l05744"></a>05744         cpumask_set_cpu(v_idx, q_vector-&gt;affinity_mask);
<a name="l05745"></a>05745 <span class="preprocessor">#endif</span>
<a name="l05746"></a>05746 <span class="preprocessor"></span><span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l05747"></a>05747 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (v_idx &lt; rx_vectors) {
<a name="l05748"></a>05748             <span class="keywordtype">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a>);
<a name="l05749"></a>05749             q_vector-&gt;lrolist = vzalloc_node(size, adapter-&gt;node);
<a name="l05750"></a>05750             <span class="keywordflow">if</span> (!q_vector-&gt;lrolist)
<a name="l05751"></a>05751                 q_vector-&gt;lrolist = vzalloc(size);
<a name="l05752"></a>05752             <span class="keywordflow">if</span> (!q_vector-&gt;lrolist) {
<a name="l05753"></a>05753                 kfree(q_vector);
<a name="l05754"></a>05754                 <span class="keywordflow">goto</span> err_out;
<a name="l05755"></a>05755             }
<a name="l05756"></a>05756             ixgbe_lro_ring_init(q_vector-&gt;lrolist);
<a name="l05757"></a>05757         }
<a name="l05758"></a>05758 <span class="preprocessor">#endif</span>
<a name="l05759"></a>05759 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l05760"></a>05760 <span class="preprocessor"></span>        netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi,
<a name="l05761"></a>05761                    ixgbe_poll, 64);
<a name="l05762"></a>05762 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l05763"></a>05763         adapter-&gt;q_vector[v_idx] = q_vector;
<a name="l05764"></a>05764     }
<a name="l05765"></a>05765 
<a name="l05766"></a>05766     <span class="keywordflow">return</span> 0;
<a name="l05767"></a>05767 
<a name="l05768"></a>05768 err_out:
<a name="l05769"></a>05769     <span class="keywordflow">while</span> (v_idx) {
<a name="l05770"></a>05770         v_idx--;
<a name="l05771"></a>05771         q_vector = adapter-&gt;q_vector[v_idx];
<a name="l05772"></a>05772 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l05773"></a>05773 <span class="preprocessor"></span>            netif_napi_del(&amp;q_vector-&gt;napi);
<a name="l05774"></a>05774 <span class="preprocessor">#endif</span>
<a name="l05775"></a>05775 <span class="preprocessor"></span><span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l05776"></a>05776 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (q_vector-&gt;lrolist) {
<a name="l05777"></a>05777             ixgbe_lro_ring_exit(q_vector-&gt;lrolist);
<a name="l05778"></a>05778             vfree(q_vector-&gt;lrolist);
<a name="l05779"></a>05779             q_vector-&gt;lrolist = NULL;
<a name="l05780"></a>05780         }
<a name="l05781"></a>05781 <span class="preprocessor">#endif</span>
<a name="l05782"></a>05782 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l05783"></a>05783 <span class="preprocessor"></span>        free_cpumask_var(q_vector-&gt;affinity_mask);
<a name="l05784"></a>05784 <span class="preprocessor">#endif</span>
<a name="l05785"></a>05785 <span class="preprocessor"></span>        kfree(q_vector);
<a name="l05786"></a>05786         adapter-&gt;q_vector[v_idx] = NULL;
<a name="l05787"></a>05787     }
<a name="l05788"></a>05788     <span class="keywordflow">return</span> -ENOMEM;
<a name="l05789"></a>05789 }
<a name="l05790"></a>05790 
<a name="l05799"></a>05799 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_q_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05800"></a>05800 {
<a name="l05801"></a>05801     <span class="keywordtype">int</span> v_idx, num_q_vectors;
<a name="l05802"></a>05802 
<a name="l05803"></a>05803     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l05804"></a>05804         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l05805"></a>05805     <span class="keywordflow">else</span>
<a name="l05806"></a>05806         num_q_vectors = 1;
<a name="l05807"></a>05807 
<a name="l05808"></a>05808     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; num_q_vectors; v_idx++) {
<a name="l05809"></a>05809         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[v_idx];
<a name="l05810"></a>05810 
<a name="l05811"></a>05811         adapter-&gt;q_vector[v_idx] = NULL;
<a name="l05812"></a>05812 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l05813"></a>05813 <span class="preprocessor"></span>        netif_napi_del(&amp;q_vector-&gt;napi);
<a name="l05814"></a>05814 <span class="preprocessor">#endif</span>
<a name="l05815"></a>05815 <span class="preprocessor"></span><span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l05816"></a>05816 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (q_vector-&gt;lrolist) {
<a name="l05817"></a>05817             ixgbe_lro_ring_exit(q_vector-&gt;lrolist);
<a name="l05818"></a>05818             vfree(q_vector-&gt;lrolist);
<a name="l05819"></a>05819             q_vector-&gt;lrolist = NULL;
<a name="l05820"></a>05820         }
<a name="l05821"></a>05821 <span class="preprocessor">#endif</span>
<a name="l05822"></a>05822 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l05823"></a>05823 <span class="preprocessor"></span>        free_cpumask_var(q_vector-&gt;affinity_mask);
<a name="l05824"></a>05824 <span class="preprocessor">#endif</span>
<a name="l05825"></a>05825 <span class="preprocessor"></span>        kfree(q_vector);
<a name="l05826"></a>05826     }
<a name="l05827"></a>05827 }
<a name="l05828"></a>05828 
<a name="l05829"></a>05829 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_reset_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05830"></a>05830 {
<a name="l05831"></a>05831     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l05832"></a>05832         adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSIX_ENABLED;
<a name="l05833"></a>05833         pci_disable_msix(adapter-&gt;pdev);
<a name="l05834"></a>05834         kfree(adapter-&gt;msix_entries);
<a name="l05835"></a>05835         adapter-&gt;msix_entries = NULL;
<a name="l05836"></a>05836     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED) {
<a name="l05837"></a>05837         adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSI_ENABLED;
<a name="l05838"></a>05838         pci_disable_msi(adapter-&gt;pdev);
<a name="l05839"></a>05839     }
<a name="l05840"></a>05840 }
<a name="l05841"></a>05841 
<a name="l05852"></a>05852 <span class="keywordtype">int</span> ixgbe_init_interrupt_scheme(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05853"></a>05853 {
<a name="l05854"></a>05854     <span class="keywordtype">int</span> err;
<a name="l05855"></a>05855 
<a name="l05856"></a>05856     <span class="comment">/* Number of supported queues */</span>
<a name="l05857"></a>05857     ixgbe_set_num_queues(adapter);
<a name="l05858"></a>05858 
<a name="l05859"></a>05859     err = ixgbe_set_interrupt_capability(adapter);
<a name="l05860"></a>05860     <span class="keywordflow">if</span> (err) {
<a name="l05861"></a>05861         e_err(probe, <span class="stringliteral">&quot;Unable to setup interrupt capabilities\n&quot;</span>);
<a name="l05862"></a>05862         <span class="keywordflow">goto</span> err_set_interrupt;
<a name="l05863"></a>05863     }
<a name="l05864"></a>05864 
<a name="l05865"></a>05865     err = ixgbe_alloc_q_vectors(adapter);
<a name="l05866"></a>05866     <span class="keywordflow">if</span> (err) {
<a name="l05867"></a>05867         e_err(probe, <span class="stringliteral">&quot;Unable to allocate memory for queue vectors\n&quot;</span>);
<a name="l05868"></a>05868         <span class="keywordflow">goto</span> err_alloc_q_vectors;
<a name="l05869"></a>05869     }
<a name="l05870"></a>05870 
<a name="l05871"></a>05871     err = ixgbe_alloc_queues(adapter);
<a name="l05872"></a>05872     <span class="keywordflow">if</span> (err) {
<a name="l05873"></a>05873         e_err(probe, <span class="stringliteral">&quot;Unable to allocate memory for queues\n&quot;</span>);
<a name="l05874"></a>05874         <span class="keywordflow">goto</span> err_alloc_queues;
<a name="l05875"></a>05875     }
<a name="l05876"></a>05876 
<a name="l05877"></a>05877     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l05878"></a>05878 
<a name="l05879"></a>05879     <span class="keywordflow">return</span> 0;
<a name="l05880"></a>05880 
<a name="l05881"></a>05881 err_alloc_queues:
<a name="l05882"></a>05882     ixgbe_free_q_vectors(adapter);
<a name="l05883"></a>05883 err_alloc_q_vectors:
<a name="l05884"></a>05884     ixgbe_reset_interrupt_capability(adapter);
<a name="l05885"></a>05885 err_set_interrupt:
<a name="l05886"></a>05886     <span class="keywordflow">return</span> err;
<a name="l05887"></a>05887 }
<a name="l05888"></a>05888 
<a name="l05896"></a>05896 <span class="keywordtype">void</span> ixgbe_clear_interrupt_scheme(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05897"></a>05897 {
<a name="l05898"></a>05898     <span class="keywordtype">int</span> i;
<a name="l05899"></a>05899 
<a name="l05900"></a>05900     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l05901"></a>05901         kfree(adapter-&gt;tx_ring[i]);
<a name="l05902"></a>05902         adapter-&gt;tx_ring[i] = NULL;
<a name="l05903"></a>05903     }
<a name="l05904"></a>05904     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l05905"></a>05905         kfree(adapter-&gt;rx_ring[i]);
<a name="l05906"></a>05906         adapter-&gt;rx_ring[i] = NULL;
<a name="l05907"></a>05907     }
<a name="l05908"></a>05908 
<a name="l05909"></a>05909     adapter-&gt;num_tx_queues = 0;
<a name="l05910"></a>05910     adapter-&gt;num_rx_queues = 0;
<a name="l05911"></a>05911 
<a name="l05912"></a>05912     ixgbe_free_q_vectors(adapter);
<a name="l05913"></a>05913     ixgbe_reset_interrupt_capability(adapter);
<a name="l05914"></a>05914 }
<a name="l05915"></a>05915 
<a name="l05924"></a>05924 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit ixgbe_sw_init(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05925"></a>05925 {
<a name="l05926"></a>05926     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05927"></a>05927     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l05928"></a>05928     <span class="keywordtype">int</span> err;
<a name="l05929"></a>05929     <span class="keywordtype">int</span> max_frame = adapter-&gt;netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l05930"></a>05930 
<a name="l05931"></a>05931     <span class="comment">/* PCI config space info */</span>
<a name="l05932"></a>05932 
<a name="l05933"></a>05933     hw-&gt;vendor_id = pdev-&gt;vendor;
<a name="l05934"></a>05934     hw-&gt;device_id = pdev-&gt;device;
<a name="l05935"></a>05935     pci_read_config_byte(pdev, PCI_REVISION_ID, &amp;hw-&gt;revision_id);
<a name="l05936"></a>05936     hw-&gt;subsystem_vendor_id = pdev-&gt;subsystem_vendor;
<a name="l05937"></a>05937     hw-&gt;subsystem_device_id = pdev-&gt;subsystem_device;
<a name="l05938"></a>05938 
<a name="l05939"></a>05939     err = ixgbe_init_shared_code(hw);
<a name="l05940"></a>05940     <span class="keywordflow">if</span> (err) {
<a name="l05941"></a>05941         e_err(probe, <span class="stringliteral">&quot;init_shared_code failed: %d\n&quot;</span>, err);
<a name="l05942"></a>05942         <span class="keywordflow">goto</span> out;
<a name="l05943"></a>05943     }
<a name="l05944"></a>05944 
<a name="l05945"></a>05945     <span class="comment">/* Set capability flags */</span>
<a name="l05946"></a>05946     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l05947"></a>05947     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l05948"></a>05948         <span class="keywordflow">if</span> (hw-&gt;device_id == IXGBE_DEV_ID_82598AT)
<a name="l05949"></a>05949             adapter-&gt;flags |= IXGBE_FLAG_FAN_FAIL_CAPABLE;
<a name="l05950"></a>05950 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l05951"></a>05951 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_DCA_CAPABLE;
<a name="l05952"></a>05952 <span class="preprocessor">#endif</span>
<a name="l05953"></a>05953 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_MSI_CAPABLE;
<a name="l05954"></a>05954         adapter-&gt;flags |= IXGBE_FLAG_MSIX_CAPABLE;
<a name="l05955"></a>05955         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_CAPABLE)
<a name="l05956"></a>05956             adapter-&gt;flags |= IXGBE_FLAG_MQ_CAPABLE;
<a name="l05957"></a>05957         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05958"></a>05958             adapter-&gt;flags |= IXGBE_FLAG_DCB_CAPABLE;
<a name="l05959"></a>05959         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05960"></a>05960             adapter-&gt;flags |= IXGBE_FLAG_RSS_CAPABLE;
<a name="l05961"></a>05961         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05962"></a>05962             adapter-&gt;flags |= IXGBE_FLAG_VMDQ_CAPABLE;
<a name="l05963"></a>05963         adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_CAPABLE;
<a name="l05964"></a>05964         adapter-&gt;flags &amp;= ~IXGBE_FLAG_SRIOV_CAPABLE;
<a name="l05965"></a>05965         adapter-&gt;max_msix_q_vectors = IXGBE_MAX_MSIX_Q_VECTORS_82598;
<a name="l05966"></a>05966         <span class="keywordflow">break</span>;
<a name="l05967"></a>05967     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05968"></a>05968     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05969"></a>05969 <span class="preprocessor">#ifndef IXGBE_NO_SMART_SPEED</span>
<a name="l05970"></a>05970 <span class="preprocessor"></span>        hw-&gt;phy.smart_speed = ixgbe_smart_speed_on;
<a name="l05971"></a>05971 <span class="preprocessor">#else</span>
<a name="l05972"></a>05972 <span class="preprocessor"></span>        hw-&gt;phy.smart_speed = ixgbe_smart_speed_off;
<a name="l05973"></a>05973 <span class="preprocessor">#endif</span>
<a name="l05974"></a>05974 <span class="preprocessor"></span>        adapter-&gt;flags2 |= IXGBE_FLAG2_RSC_CAPABLE;
<a name="l05975"></a>05975 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l05976"></a>05976 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_DCA_CAPABLE;
<a name="l05977"></a>05977 <span class="preprocessor">#endif</span>
<a name="l05978"></a>05978 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_MSI_CAPABLE;
<a name="l05979"></a>05979         adapter-&gt;flags |= IXGBE_FLAG_MSIX_CAPABLE;
<a name="l05980"></a>05980         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_CAPABLE)
<a name="l05981"></a>05981             adapter-&gt;flags |= IXGBE_FLAG_MQ_CAPABLE;
<a name="l05982"></a>05982         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05983"></a>05983             adapter-&gt;flags |= IXGBE_FLAG_DCB_CAPABLE;
<a name="l05984"></a>05984         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05985"></a>05985             adapter-&gt;flags |= IXGBE_FLAG_RSS_CAPABLE;
<a name="l05986"></a>05986         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05987"></a>05987             adapter-&gt;flags |= IXGBE_FLAG_VMDQ_CAPABLE;
<a name="l05988"></a>05988 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05989"></a>05989 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE) {
<a name="l05990"></a>05990             adapter-&gt;flags |= IXGBE_FLAG_FCOE_CAPABLE;
<a name="l05991"></a>05991             adapter-&gt;flags &amp;= ~IXGBE_FLAG_FCOE_ENABLED;
<a name="l05992"></a>05992             adapter-&gt;ring_feature[RING_F_FCOE].indices = 0;
<a name="l05993"></a>05993 <span class="preprocessor">#ifdef CONFIG_DCB</span>
<a name="l05994"></a>05994 <span class="preprocessor"></span>            <span class="comment">/* Default traffic class to use for FCoE */</span>
<a name="l05995"></a>05995             adapter-&gt;fcoe.tc = IXGBE_FCOE_DEFTC;
<a name="l05996"></a>05996             adapter-&gt;fcoe.up = IXGBE_FCOE_DEFTC;
<a name="l05997"></a>05997 <span class="preprocessor">#endif</span>
<a name="l05998"></a>05998 <span class="preprocessor"></span>        }
<a name="l05999"></a>05999 <span class="preprocessor">#endif</span>
<a name="l06000"></a>06000 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l06001"></a>06001             adapter-&gt;flags |= IXGBE_FLAG_SRIOV_CAPABLE;
<a name="l06002"></a>06002         <span class="keywordflow">if</span> (hw-&gt;device_id == IXGBE_DEV_ID_82599_T3_LOM)
<a name="l06003"></a>06003             adapter-&gt;flags2 |= IXGBE_FLAG2_TEMP_SENSOR_CAPABLE;
<a name="l06004"></a>06004 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l06005"></a>06005 <span class="preprocessor"></span>        <span class="comment">/* n-tuple support exists, always init our spinlock */</span>
<a name="l06006"></a>06006         spin_lock_init(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l06007"></a>06007 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l06008"></a>06008         adapter-&gt;max_msix_q_vectors = IXGBE_MAX_MSIX_Q_VECTORS_82599;
<a name="l06009"></a>06009         <span class="keywordflow">break</span>;
<a name="l06010"></a>06010     <span class="keywordflow">default</span>:
<a name="l06011"></a>06011         <span class="keywordflow">break</span>;
<a name="l06012"></a>06012     }
<a name="l06013"></a>06013     <span class="comment">/* Default DCB settings, if applicable */</span>
<a name="l06014"></a>06014     adapter-&gt;ring_feature[RING_F_DCB].indices = 8;
<a name="l06015"></a>06015 
<a name="l06016"></a>06016     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_CAPABLE) {
<a name="l06017"></a>06017         <span class="keywordtype">int</span> j, dcb_i;
<a name="l06018"></a>06018         <span class="keyword">struct </span><a class="code" href="structtc__configuration.html">tc_configuration</a> *tc;
<a name="l06019"></a>06019         dcb_i = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l06020"></a>06020         adapter-&gt;dcb_cfg.num_tcs.pg_tcs = dcb_i;
<a name="l06021"></a>06021         adapter-&gt;dcb_cfg.num_tcs.pfc_tcs = dcb_i;
<a name="l06022"></a>06022         <span class="keywordflow">for</span> (j = 0; j &lt; dcb_i; j++) {
<a name="l06023"></a>06023             tc = &amp;adapter-&gt;dcb_cfg.tc_config[j];
<a name="l06024"></a>06024             tc-&gt;path[DCB_TX_CONFIG].bwg_id = 0;
<a name="l06025"></a>06025             tc-&gt;path[DCB_TX_CONFIG].bwg_percent = 100 / dcb_i;
<a name="l06026"></a>06026             tc-&gt;path[DCB_RX_CONFIG].bwg_id = 0;
<a name="l06027"></a>06027             tc-&gt;path[DCB_RX_CONFIG].bwg_percent = 100 / dcb_i;
<a name="l06028"></a>06028             tc-&gt;dcb_pfc = pfc_disabled;
<a name="l06029"></a>06029             <span class="keywordflow">if</span> (j == 0) {
<a name="l06030"></a>06030                 <span class="comment">/* total of all TCs bandwidth needs to be 100 */</span>
<a name="l06031"></a>06031                 tc-&gt;path[DCB_TX_CONFIG].bwg_percent += 100 % dcb_i;
<a name="l06032"></a>06032                 tc-&gt;path[DCB_RX_CONFIG].bwg_percent += 100 % dcb_i;
<a name="l06033"></a>06033             }
<a name="l06034"></a>06034         }
<a name="l06035"></a>06035         adapter-&gt;dcb_cfg.bw_percentage[DCB_TX_CONFIG][0] = 100;
<a name="l06036"></a>06036         adapter-&gt;dcb_cfg.bw_percentage[DCB_RX_CONFIG][0] = 100;
<a name="l06037"></a>06037         adapter-&gt;dcb_cfg.rx_pba_cfg = pba_equal;
<a name="l06038"></a>06038         adapter-&gt;dcb_cfg.pfc_mode_enable = <span class="keyword">false</span>;
<a name="l06039"></a>06039         adapter-&gt;dcb_cfg.round_robin_enable = <span class="keyword">false</span>;
<a name="l06040"></a>06040         adapter-&gt;dcb_set_bitmap = 0x00;
<a name="l06041"></a>06041 
<a name="l06042"></a>06042     }
<a name="l06043"></a>06043     <span class="comment">/* XXX does this need to be initialized even w/o DCB? */</span>
<a name="l06044"></a>06044     ixgbe_copy_dcb_cfg(&amp;adapter-&gt;dcb_cfg, &amp;adapter-&gt;temp_dcb_cfg,
<a name="l06045"></a>06045                adapter-&gt;ring_feature[RING_F_DCB].indices);
<a name="l06046"></a>06046 
<a name="l06047"></a>06047     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82599EB ||
<a name="l06048"></a>06048         hw-&gt;mac.type == ixgbe_mac_X540)
<a name="l06049"></a>06049         hw-&gt;mbx.ops.init_params(hw);
<a name="l06050"></a>06050 
<a name="l06051"></a>06051     <span class="comment">/* default flow control settings */</span>
<a name="l06052"></a>06052     hw-&gt;fc.requested_mode = ixgbe_fc_full;
<a name="l06053"></a>06053     hw-&gt;fc.current_mode = ixgbe_fc_full;    <span class="comment">/* init for ethtool output */</span>
<a name="l06054"></a>06054 
<a name="l06055"></a>06055 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l06056"></a>06056 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l06057"></a>06057 <span class="comment">      Disable flow-control</span>
<a name="l06058"></a>06058 <span class="comment">      </span>
<a name="l06059"></a>06059 <span class="comment">      Currently disabled as we prefer to use ethtool for disabling</span>
<a name="l06060"></a>06060 <span class="comment">      pause frames    </span>
<a name="l06061"></a>06061 <span class="comment">     */</span>
<a name="l06062"></a>06062     <span class="comment">// hw-&gt;fc.requested_mode = ixgbe_fc_none;</span>
<a name="l06063"></a>06063     <span class="comment">// hw-&gt;fc.current_mode = ixgbe_fc_none;</span>
<a name="l06064"></a>06064 <span class="preprocessor">#endif</span>
<a name="l06065"></a>06065 <span class="preprocessor"></span>    adapter-&gt;last_lfc_mode = hw-&gt;fc.current_mode;
<a name="l06066"></a>06066     hw-&gt;fc.high_water = FC_HIGH_WATER(max_frame);
<a name="l06067"></a>06067     hw-&gt;fc.low_water = FC_LOW_WATER(max_frame);
<a name="l06068"></a>06068     hw-&gt;fc.pause_time = IXGBE_DEFAULT_FCPAUSE;
<a name="l06069"></a>06069     hw-&gt;fc.send_xon = <span class="keyword">true</span>;
<a name="l06070"></a>06070     hw-&gt;fc.disable_fc_autoneg = <span class="keyword">false</span>;
<a name="l06071"></a>06071 
<a name="l06072"></a>06072     <span class="comment">/* set default ring sizes */</span>
<a name="l06073"></a>06073     adapter-&gt;tx_ring_count = IXGBE_DEFAULT_TXD;
<a name="l06074"></a>06074     adapter-&gt;rx_ring_count = IXGBE_DEFAULT_RXD;
<a name="l06075"></a>06075 
<a name="l06076"></a>06076     <span class="comment">/* set default work limits */</span>
<a name="l06077"></a>06077     adapter-&gt;tx_work_limit = adapter-&gt;tx_ring_count;
<a name="l06078"></a>06078     adapter-&gt;rx_work_limit = adapter-&gt;rx_ring_count / 2;
<a name="l06079"></a>06079 
<a name="l06080"></a>06080     <span class="comment">/* enable rx csum by default */</span>
<a name="l06081"></a>06081     adapter-&gt;flags |= IXGBE_FLAG_RX_CSUM_ENABLED;
<a name="l06082"></a>06082 
<a name="l06083"></a>06083     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l06084"></a>06084 out:
<a name="l06085"></a>06085     <span class="keywordflow">return</span> err;
<a name="l06086"></a>06086 }
<a name="l06087"></a>06087 
<a name="l06094"></a>06094 <span class="keywordtype">int</span> ixgbe_setup_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l06095"></a>06095 {
<a name="l06096"></a>06096     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = tx_ring-&gt;dev;
<a name="l06097"></a>06097     <span class="keywordtype">int</span> size;
<a name="l06098"></a>06098 
<a name="l06099"></a>06099     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a>) * tx_ring-&gt;count;
<a name="l06100"></a>06100     tx_ring-&gt;tx_buffer_info = vzalloc_node(size, tx_ring-&gt;numa_node);
<a name="l06101"></a>06101     <span class="keywordflow">if</span> (!tx_ring-&gt;tx_buffer_info)
<a name="l06102"></a>06102         tx_ring-&gt;tx_buffer_info = vzalloc(size);
<a name="l06103"></a>06103     <span class="keywordflow">if</span> (!tx_ring-&gt;tx_buffer_info)
<a name="l06104"></a>06104         <span class="keywordflow">goto</span> err;
<a name="l06105"></a>06105 
<a name="l06106"></a>06106     <span class="comment">/* round up to nearest 4K */</span>
<a name="l06107"></a>06107     tx_ring-&gt;size = tx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a>);
<a name="l06108"></a>06108     tx_ring-&gt;size = ALIGN(tx_ring-&gt;size, 4096);
<a name="l06109"></a>06109 
<a name="l06110"></a>06110     tx_ring-&gt;desc = dma_alloc_coherent(dev,
<a name="l06111"></a>06111 #ifdef ENABLE_DNA
<a name="l06112"></a>06112                        2 * <span class="comment">/* Alloc shadow descriptors */</span>
<a name="l06113"></a>06113 #endif
<a name="l06114"></a>06114                        tx_ring-&gt;size,
<a name="l06115"></a>06115                                        &amp;tx_ring-&gt;dma, GFP_KERNEL);
<a name="l06116"></a>06116     <span class="keywordflow">if</span> (!tx_ring-&gt;desc)
<a name="l06117"></a>06117         <span class="keywordflow">goto</span> err;
<a name="l06118"></a>06118 
<a name="l06119"></a>06119     tx_ring-&gt;next_to_use = 0;
<a name="l06120"></a>06120     tx_ring-&gt;next_to_clean = 0;
<a name="l06121"></a>06121     <span class="keywordflow">return</span> 0;
<a name="l06122"></a>06122 
<a name="l06123"></a>06123 err:
<a name="l06124"></a>06124     vfree(tx_ring-&gt;tx_buffer_info);
<a name="l06125"></a>06125     tx_ring-&gt;tx_buffer_info = NULL;
<a name="l06126"></a>06126     dev_err(dev, <span class="stringliteral">&quot;Unable to allocate memory for the Tx descriptor ring\n&quot;</span>);
<a name="l06127"></a>06127     <span class="keywordflow">return</span> -ENOMEM;
<a name="l06128"></a>06128 }
<a name="l06129"></a>06129 
<a name="l06140"></a>06140 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06141"></a>06141 {
<a name="l06142"></a>06142     <span class="keywordtype">int</span> i, err = 0;
<a name="l06143"></a>06143 
<a name="l06144"></a>06144     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l06145"></a>06145 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l06146"></a>06146 <span class="preprocessor"></span>        e_info(tx_err, <span class="stringliteral">&quot;tx[%02d] bd: %d - assigning node %d\n&quot;</span>,
<a name="l06147"></a>06147                i, adapter-&gt;bd_number, adapter-&gt;tx_ring[i]-&gt;numa_node);
<a name="l06148"></a>06148 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l06149"></a>06149         err = ixgbe_setup_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l06150"></a>06150         <span class="keywordflow">if</span> (!err)
<a name="l06151"></a>06151             <span class="keywordflow">continue</span>;
<a name="l06152"></a>06152         e_err(probe, <span class="stringliteral">&quot;Allocation for Tx Queue %u failed\n&quot;</span>, i);
<a name="l06153"></a>06153         <span class="keywordflow">break</span>;
<a name="l06154"></a>06154     }
<a name="l06155"></a>06155 
<a name="l06156"></a>06156     <span class="keywordflow">return</span> err;
<a name="l06157"></a>06157 }
<a name="l06158"></a>06158 
<a name="l06165"></a>06165 <span class="keywordtype">int</span> ixgbe_setup_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l06166"></a>06166 {
<a name="l06167"></a>06167     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = rx_ring-&gt;dev;
<a name="l06168"></a>06168     <span class="keywordtype">int</span> size;
<a name="l06169"></a>06169 
<a name="l06170"></a>06170     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a>) * rx_ring-&gt;count;
<a name="l06171"></a>06171     rx_ring-&gt;rx_buffer_info = vzalloc_node(size, rx_ring-&gt;numa_node);
<a name="l06172"></a>06172     <span class="keywordflow">if</span> (!rx_ring-&gt;rx_buffer_info)
<a name="l06173"></a>06173         rx_ring-&gt;rx_buffer_info = vzalloc(size);
<a name="l06174"></a>06174     <span class="keywordflow">if</span> (!rx_ring-&gt;rx_buffer_info)
<a name="l06175"></a>06175         <span class="keywordflow">goto</span> err;
<a name="l06176"></a>06176 
<a name="l06177"></a>06177     <span class="comment">/* Round up to nearest 4K */</span>
<a name="l06178"></a>06178     rx_ring-&gt;size = rx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a>);
<a name="l06179"></a>06179     rx_ring-&gt;size = ALIGN(rx_ring-&gt;size, 4096);
<a name="l06180"></a>06180 
<a name="l06181"></a>06181     rx_ring-&gt;desc = dma_alloc_coherent(dev,
<a name="l06182"></a>06182 #ifdef ENABLE_DNA
<a name="l06183"></a>06183                        2 * <span class="comment">/* Alloc shadow descriptors */</span>
<a name="l06184"></a>06184 #endif
<a name="l06185"></a>06185                        rx_ring-&gt;size,
<a name="l06186"></a>06186                        &amp;rx_ring-&gt;dma, GFP_KERNEL);
<a name="l06187"></a>06187 
<a name="l06188"></a>06188     <span class="keywordflow">if</span> (!rx_ring-&gt;desc)
<a name="l06189"></a>06189         <span class="keywordflow">goto</span> err;
<a name="l06190"></a>06190 
<a name="l06191"></a>06191     rx_ring-&gt;next_to_clean = 0;
<a name="l06192"></a>06192     rx_ring-&gt;next_to_use = 0;
<a name="l06193"></a>06193 
<a name="l06194"></a>06194     <span class="keywordflow">return</span> 0;
<a name="l06195"></a>06195 err:
<a name="l06196"></a>06196     vfree(rx_ring-&gt;rx_buffer_info);
<a name="l06197"></a>06197     rx_ring-&gt;rx_buffer_info = NULL;
<a name="l06198"></a>06198     dev_err(dev, <span class="stringliteral">&quot;Unable to allocate memory for the Rx descriptor ring\n&quot;</span>);
<a name="l06199"></a>06199     <span class="keywordflow">return</span> -ENOMEM;
<a name="l06200"></a>06200 }
<a name="l06201"></a>06201 
<a name="l06212"></a>06212 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06213"></a>06213 {
<a name="l06214"></a>06214     <span class="keywordtype">int</span> i, err = 0;
<a name="l06215"></a>06215 
<a name="l06216"></a>06216     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l06217"></a>06217 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l06218"></a>06218 <span class="preprocessor"></span>        e_info(rx_err, <span class="stringliteral">&quot;rx[%02d] bd: %d - assigning node %d\n&quot;</span>,
<a name="l06219"></a>06219                i, adapter-&gt;bd_number, adapter-&gt;rx_ring[i]-&gt;numa_node);
<a name="l06220"></a>06220 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l06221"></a>06221         err = ixgbe_setup_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l06222"></a>06222         <span class="keywordflow">if</span> (!err)
<a name="l06223"></a>06223             <span class="keywordflow">continue</span>;
<a name="l06224"></a>06224         e_err(probe, <span class="stringliteral">&quot;Allocation for Rx Queue %u failed\n&quot;</span>, i);
<a name="l06225"></a>06225         <span class="keywordflow">break</span>;
<a name="l06226"></a>06226     }
<a name="l06227"></a>06227 
<a name="l06228"></a>06228     <span class="keywordflow">return</span> err;
<a name="l06229"></a>06229 }
<a name="l06230"></a>06230 
<a name="l06237"></a>06237 <span class="keywordtype">void</span> ixgbe_free_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l06238"></a>06238 {
<a name="l06239"></a>06239     ixgbe_clean_tx_ring(tx_ring);
<a name="l06240"></a>06240 
<a name="l06241"></a>06241     vfree(tx_ring-&gt;tx_buffer_info);
<a name="l06242"></a>06242     tx_ring-&gt;tx_buffer_info = NULL;
<a name="l06243"></a>06243 
<a name="l06244"></a>06244     <span class="comment">/* if not set, then don&#39;t free */</span>
<a name="l06245"></a>06245     <span class="keywordflow">if</span> (!tx_ring-&gt;desc)
<a name="l06246"></a>06246         <span class="keywordflow">return</span>;
<a name="l06247"></a>06247 
<a name="l06248"></a>06248     dma_free_coherent(tx_ring-&gt;dev,
<a name="l06249"></a>06249 #ifdef ENABLE_DNA
<a name="l06250"></a>06250               2 * <span class="comment">/* Shadow descriptors */</span>
<a name="l06251"></a>06251 #endif
<a name="l06252"></a>06252               tx_ring-&gt;size,
<a name="l06253"></a>06253               tx_ring-&gt;desc, tx_ring-&gt;dma);
<a name="l06254"></a>06254 
<a name="l06255"></a>06255     tx_ring-&gt;desc = NULL;
<a name="l06256"></a>06256 }
<a name="l06257"></a>06257 
<a name="l06264"></a>06264 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06265"></a>06265 {
<a name="l06266"></a>06266     <span class="keywordtype">int</span> i;
<a name="l06267"></a>06267 
<a name="l06268"></a>06268     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l06269"></a>06269         <span class="keywordflow">if</span> (adapter-&gt;tx_ring[i]-&gt;desc)
<a name="l06270"></a>06270             ixgbe_free_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l06271"></a>06271 }
<a name="l06272"></a>06272 
<a name="l06279"></a>06279 <span class="keywordtype">void</span> ixgbe_free_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l06280"></a>06280 {
<a name="l06281"></a>06281     ixgbe_clean_rx_ring(rx_ring);
<a name="l06282"></a>06282 
<a name="l06283"></a>06283     vfree(rx_ring-&gt;rx_buffer_info);
<a name="l06284"></a>06284     rx_ring-&gt;rx_buffer_info = NULL;
<a name="l06285"></a>06285 
<a name="l06286"></a>06286     <span class="comment">/* if not set, then don&#39;t free */</span>
<a name="l06287"></a>06287     <span class="keywordflow">if</span> (!rx_ring-&gt;desc)
<a name="l06288"></a>06288         <span class="keywordflow">return</span>;
<a name="l06289"></a>06289 
<a name="l06290"></a>06290     dma_free_coherent(rx_ring-&gt;dev,
<a name="l06291"></a>06291 #ifdef ENABLE_DNA
<a name="l06292"></a>06292               2 * <span class="comment">/* Alloc shadow descriptors */</span>
<a name="l06293"></a>06293 #endif
<a name="l06294"></a>06294               rx_ring-&gt;size,
<a name="l06295"></a>06295               rx_ring-&gt;desc, rx_ring-&gt;dma);
<a name="l06296"></a>06296 
<a name="l06297"></a>06297     rx_ring-&gt;desc = NULL;
<a name="l06298"></a>06298 }
<a name="l06299"></a>06299 
<a name="l06306"></a>06306 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06307"></a>06307 {
<a name="l06308"></a>06308     <span class="keywordtype">int</span> i;
<a name="l06309"></a>06309 
<a name="l06310"></a>06310     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l06311"></a>06311         <span class="keywordflow">if</span> (adapter-&gt;rx_ring[i]-&gt;desc)
<a name="l06312"></a>06312             ixgbe_free_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l06313"></a>06313 }
<a name="l06314"></a>06314 
<a name="l06322"></a>06322 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_change_mtu(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> new_mtu)
<a name="l06323"></a>06323 {
<a name="l06324"></a>06324     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06325"></a>06325     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06326"></a>06326     <span class="keywordtype">int</span> max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l06327"></a>06327 
<a name="l06328"></a>06328     <span class="comment">/* MTU &lt; 68 is an error and causes problems on some kernels */</span>
<a name="l06329"></a>06329     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED &amp;&amp;
<a name="l06330"></a>06330         hw-&gt;mac.type != ixgbe_mac_X540) {
<a name="l06331"></a>06331         <span class="keywordflow">if</span> ((new_mtu &lt; 68) || (max_frame &gt; MAXIMUM_ETHERNET_VLAN_SIZE))
<a name="l06332"></a>06332             <span class="keywordflow">return</span> -EINVAL;
<a name="l06333"></a>06333     } <span class="keywordflow">else</span> {
<a name="l06334"></a>06334         <span class="keywordflow">if</span> ((new_mtu &lt; 68) || (max_frame &gt; IXGBE_MAX_JUMBO_FRAME_SIZE))
<a name="l06335"></a>06335             <span class="keywordflow">return</span> -EINVAL;
<a name="l06336"></a>06336     }
<a name="l06337"></a>06337 
<a name="l06338"></a>06338     e_info(probe, <span class="stringliteral">&quot;changing MTU from %d to %d\n&quot;</span>, netdev-&gt;mtu, new_mtu);
<a name="l06339"></a>06339     <span class="comment">/* must set new MTU before calling down or up */</span>
<a name="l06340"></a>06340     netdev-&gt;mtu = new_mtu;
<a name="l06341"></a>06341 
<a name="l06342"></a>06342     hw-&gt;fc.high_water = FC_HIGH_WATER(max_frame);
<a name="l06343"></a>06343     hw-&gt;fc.low_water = FC_LOW_WATER(max_frame);
<a name="l06344"></a>06344 
<a name="l06345"></a>06345     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l06346"></a>06346         ixgbe_reinit_locked(adapter);
<a name="l06347"></a>06347 
<a name="l06348"></a>06348     <span class="keywordflow">return</span> 0;
<a name="l06349"></a>06349 }
<a name="l06350"></a>06350 
<a name="l06363"></a>06363 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_open(<span class="keyword">struct</span> net_device *netdev)
<a name="l06364"></a>06364 {
<a name="l06365"></a>06365     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06366"></a>06366     <span class="keywordtype">int</span> err;
<a name="l06367"></a>06367 
<a name="l06368"></a>06368     <span class="comment">/* disallow open during test */</span>
<a name="l06369"></a>06369     <span class="keywordflow">if</span> (test_bit(__IXGBE_TESTING, &amp;adapter-&gt;state))
<a name="l06370"></a>06370         <span class="keywordflow">return</span> -EBUSY;
<a name="l06371"></a>06371 
<a name="l06372"></a>06372     netif_carrier_off(netdev);
<a name="l06373"></a>06373 
<a name="l06374"></a>06374     <span class="comment">/* allocate transmit descriptors */</span>
<a name="l06375"></a>06375     err = ixgbe_setup_all_tx_resources(adapter);
<a name="l06376"></a>06376     <span class="keywordflow">if</span> (err)
<a name="l06377"></a>06377         <span class="keywordflow">goto</span> err_setup_tx;
<a name="l06378"></a>06378 
<a name="l06379"></a>06379     <span class="comment">/* allocate receive descriptors */</span>
<a name="l06380"></a>06380     err = ixgbe_setup_all_rx_resources(adapter);
<a name="l06381"></a>06381     <span class="keywordflow">if</span> (err)
<a name="l06382"></a>06382         <span class="keywordflow">goto</span> err_setup_rx;
<a name="l06383"></a>06383 
<a name="l06384"></a>06384     ixgbe_configure(adapter);
<a name="l06385"></a>06385 
<a name="l06386"></a>06386     err = ixgbe_request_irq(adapter);
<a name="l06387"></a>06387     <span class="keywordflow">if</span> (err)
<a name="l06388"></a>06388         <span class="keywordflow">goto</span> err_req_irq;
<a name="l06389"></a>06389 
<a name="l06390"></a>06390     err = ixgbe_up_complete(adapter);
<a name="l06391"></a>06391     <span class="keywordflow">if</span> (err)
<a name="l06392"></a>06392         <span class="keywordflow">goto</span> err_setup_rx;
<a name="l06393"></a>06393 
<a name="l06394"></a>06394 
<a name="l06395"></a>06395 
<a name="l06396"></a>06396     <span class="keywordflow">return</span> 0;
<a name="l06397"></a>06397 
<a name="l06398"></a>06398 err_req_irq:
<a name="l06399"></a>06399     ixgbe_down(adapter);
<a name="l06400"></a>06400     ixgbe_release_hw_control(adapter);
<a name="l06401"></a>06401     ixgbe_free_irq(adapter);
<a name="l06402"></a>06402 err_setup_rx:
<a name="l06403"></a>06403     ixgbe_free_all_rx_resources(adapter);
<a name="l06404"></a>06404 err_setup_tx:
<a name="l06405"></a>06405     ixgbe_free_all_tx_resources(adapter);
<a name="l06406"></a>06406     ixgbe_reset(adapter);
<a name="l06407"></a>06407 
<a name="l06408"></a>06408     <span class="keywordflow">return</span> err;
<a name="l06409"></a>06409 }
<a name="l06410"></a>06410 
<a name="l06422"></a>06422 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_close(<span class="keyword">struct</span> net_device *netdev)
<a name="l06423"></a>06423 {
<a name="l06424"></a>06424     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06425"></a>06425 
<a name="l06426"></a>06426     ixgbe_down(adapter);
<a name="l06427"></a>06427     ixgbe_free_irq(adapter);
<a name="l06428"></a>06428 
<a name="l06429"></a>06429 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l06430"></a>06430 <span class="preprocessor"></span>    ixgbe_fdir_filter_exit(adapter);
<a name="l06431"></a>06431 
<a name="l06432"></a>06432 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l06433"></a>06433     ixgbe_free_all_tx_resources(adapter);
<a name="l06434"></a>06434     ixgbe_free_all_rx_resources(adapter);
<a name="l06435"></a>06435 
<a name="l06436"></a>06436     ixgbe_release_hw_control(adapter);
<a name="l06437"></a>06437 
<a name="l06438"></a>06438     <span class="keywordflow">return</span> 0;
<a name="l06439"></a>06439 }
<a name="l06440"></a>06440 
<a name="l06441"></a>06441 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06442"></a>06442 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06443"></a>06443 {
<a name="l06444"></a>06444     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l06445"></a>06445     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06446"></a>06446     u32 err;
<a name="l06447"></a>06447 
<a name="l06448"></a>06448     pci_set_power_state(pdev, PCI_D0);
<a name="l06449"></a>06449     pci_restore_state(pdev);
<a name="l06450"></a>06450     <span class="comment">/*</span>
<a name="l06451"></a>06451 <span class="comment">     * pci_restore_state clears dev-&gt;state_saved so call</span>
<a name="l06452"></a>06452 <span class="comment">     * pci_save_state to restore it.</span>
<a name="l06453"></a>06453 <span class="comment">     */</span>
<a name="l06454"></a>06454     pci_save_state(pdev);
<a name="l06455"></a>06455 
<a name="l06456"></a>06456     err = pci_enable_device_mem(pdev);
<a name="l06457"></a>06457     <span class="keywordflow">if</span> (err) {
<a name="l06458"></a>06458         e_dev_err(<span class="stringliteral">&quot;Cannot enable PCI device from suspend\n&quot;</span>);
<a name="l06459"></a>06459         <span class="keywordflow">return</span> err;
<a name="l06460"></a>06460     }
<a name="l06461"></a>06461     pci_set_master(pdev);
<a name="l06462"></a>06462 
<a name="l06463"></a>06463     pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l06464"></a>06464 
<a name="l06465"></a>06465     err = ixgbe_init_interrupt_scheme(adapter);
<a name="l06466"></a>06466     <span class="keywordflow">if</span> (err) {
<a name="l06467"></a>06467         e_dev_err(<span class="stringliteral">&quot;Cannot initialize interrupts for device\n&quot;</span>);
<a name="l06468"></a>06468         <span class="keywordflow">return</span> err;
<a name="l06469"></a>06469     }
<a name="l06470"></a>06470 
<a name="l06471"></a>06471     ixgbe_reset(adapter);
<a name="l06472"></a>06472 
<a name="l06473"></a>06473     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_WUS, ~0);
<a name="l06474"></a>06474 
<a name="l06475"></a>06475     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l06476"></a>06476         err = ixgbe_open(netdev);
<a name="l06477"></a>06477         <span class="keywordflow">if</span> (err)
<a name="l06478"></a>06478             <span class="keywordflow">return</span> err;
<a name="l06479"></a>06479     }
<a name="l06480"></a>06480 
<a name="l06481"></a>06481     netif_device_attach(netdev);
<a name="l06482"></a>06482 
<a name="l06483"></a>06483     <span class="keywordflow">return</span> 0;
<a name="l06484"></a>06484 }
<a name="l06485"></a>06485 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PM */</span>
<a name="l06486"></a>06486 
<a name="l06487"></a>06487 <span class="comment">/*</span>
<a name="l06488"></a>06488 <span class="comment"> * __ixgbe_shutdown is not used when power management</span>
<a name="l06489"></a>06489 <span class="comment"> * is disabled on older kernels (&lt;2.6.12). causes a compile</span>
<a name="l06490"></a>06490 <span class="comment"> * warning/error, because it is defined and not used.</span>
<a name="l06491"></a>06491 <span class="comment"> */</span>
<a name="l06492"></a>06492 <span class="preprocessor">#if defined(CONFIG_PM) || !defined(USE_REBOOT_NOTIFIER)</span>
<a name="l06493"></a>06493 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> __ixgbe_shutdown(<span class="keyword">struct</span> pci_dev *pdev, <span class="keywordtype">bool</span> *enable_wake)
<a name="l06494"></a>06494 {
<a name="l06495"></a>06495     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l06496"></a>06496     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06497"></a>06497     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06498"></a>06498     u32 ctrl, fctrl;
<a name="l06499"></a>06499     u32 wufc = adapter-&gt;wol;
<a name="l06500"></a>06500 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06501"></a>06501 <span class="preprocessor"></span>    <span class="keywordtype">int</span> retval = 0;
<a name="l06502"></a>06502 <span class="preprocessor">#endif</span>
<a name="l06503"></a>06503 <span class="preprocessor"></span>
<a name="l06504"></a>06504     netif_device_detach(netdev);
<a name="l06505"></a>06505 
<a name="l06506"></a>06506     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l06507"></a>06507         ixgbe_down(adapter);
<a name="l06508"></a>06508         ixgbe_free_irq(adapter);
<a name="l06509"></a>06509         ixgbe_free_all_tx_resources(adapter);
<a name="l06510"></a>06510         ixgbe_free_all_rx_resources(adapter);
<a name="l06511"></a>06511     }
<a name="l06512"></a>06512 
<a name="l06513"></a>06513     ixgbe_clear_interrupt_scheme(adapter);
<a name="l06514"></a>06514 
<a name="l06515"></a>06515 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06516"></a>06516 <span class="preprocessor"></span>    retval = pci_save_state(pdev);
<a name="l06517"></a>06517     <span class="keywordflow">if</span> (retval)
<a name="l06518"></a>06518         <span class="keywordflow">return</span> retval;
<a name="l06519"></a>06519 
<a name="l06520"></a>06520 <span class="preprocessor">#endif</span>
<a name="l06521"></a>06521 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (wufc) {
<a name="l06522"></a>06522         ixgbe_set_rx_mode(netdev);
<a name="l06523"></a>06523 
<a name="l06524"></a>06524         <span class="comment">/* turn on all-multi mode if wake on multicast is enabled */</span>
<a name="l06525"></a>06525         <span class="keywordflow">if</span> (wufc &amp; IXGBE_WUFC_MC) {
<a name="l06526"></a>06526             fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l06527"></a>06527             fctrl |= IXGBE_FCTRL_MPE;
<a name="l06528"></a>06528             IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
<a name="l06529"></a>06529         }
<a name="l06530"></a>06530 
<a name="l06531"></a>06531         ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
<a name="l06532"></a>06532         ctrl |= IXGBE_CTRL_GIO_DIS;
<a name="l06533"></a>06533         IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
<a name="l06534"></a>06534 
<a name="l06535"></a>06535         IXGBE_WRITE_REG(hw, IXGBE_WUFC, wufc);
<a name="l06536"></a>06536     } <span class="keywordflow">else</span> {
<a name="l06537"></a>06537         IXGBE_WRITE_REG(hw, IXGBE_WUC, 0);
<a name="l06538"></a>06538         IXGBE_WRITE_REG(hw, IXGBE_WUFC, 0);
<a name="l06539"></a>06539     }
<a name="l06540"></a>06540 
<a name="l06541"></a>06541     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l06542"></a>06542     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l06543"></a>06543         pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l06544"></a>06544         <span class="keywordflow">break</span>;
<a name="l06545"></a>06545     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l06546"></a>06546     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l06547"></a>06547         pci_wake_from_d3(pdev, !!wufc);
<a name="l06548"></a>06548         <span class="keywordflow">break</span>;
<a name="l06549"></a>06549     <span class="keywordflow">default</span>:
<a name="l06550"></a>06550         <span class="keywordflow">break</span>;
<a name="l06551"></a>06551     }
<a name="l06552"></a>06552 
<a name="l06553"></a>06553     *enable_wake = !!wufc;
<a name="l06554"></a>06554 
<a name="l06555"></a>06555     ixgbe_release_hw_control(adapter);
<a name="l06556"></a>06556 
<a name="l06557"></a>06557     pci_disable_device(pdev);
<a name="l06558"></a>06558 
<a name="l06559"></a>06559     <span class="keywordflow">return</span> 0;
<a name="l06560"></a>06560 }
<a name="l06561"></a>06561 <span class="preprocessor">#endif </span><span class="comment">/* defined(CONFIG_PM) || !defined(USE_REBOOT_NOTIFIER) */</span>
<a name="l06562"></a>06562 
<a name="l06563"></a>06563 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06564"></a>06564 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_suspend(<span class="keyword">struct</span> pci_dev *pdev, pm_message_t <a class="code" href="structstate.html">state</a>)
<a name="l06565"></a>06565 {
<a name="l06566"></a>06566     <span class="keywordtype">int</span> retval;
<a name="l06567"></a>06567     <span class="keywordtype">bool</span> wake;
<a name="l06568"></a>06568 
<a name="l06569"></a>06569     retval = __ixgbe_shutdown(pdev, &amp;wake);
<a name="l06570"></a>06570     <span class="keywordflow">if</span> (retval)
<a name="l06571"></a>06571         <span class="keywordflow">return</span> retval;
<a name="l06572"></a>06572 
<a name="l06573"></a>06573     <span class="keywordflow">if</span> (wake) {
<a name="l06574"></a>06574         pci_prepare_to_sleep(pdev);
<a name="l06575"></a>06575     } <span class="keywordflow">else</span> {
<a name="l06576"></a>06576         pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l06577"></a>06577         pci_set_power_state(pdev, PCI_D3hot);
<a name="l06578"></a>06578     }
<a name="l06579"></a>06579 
<a name="l06580"></a>06580     <span class="keywordflow">return</span> 0;
<a name="l06581"></a>06581 }
<a name="l06582"></a>06582 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PM */</span>
<a name="l06583"></a>06583 
<a name="l06584"></a>06584 <span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l06585"></a>06585 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_shutdown(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06586"></a>06586 {
<a name="l06587"></a>06587     <span class="keywordtype">bool</span> wake;
<a name="l06588"></a>06588 
<a name="l06589"></a>06589     __ixgbe_shutdown(pdev, &amp;wake);
<a name="l06590"></a>06590 
<a name="l06591"></a>06591     <span class="keywordflow">if</span> (system_state == SYSTEM_POWER_OFF) {
<a name="l06592"></a>06592         pci_wake_from_d3(pdev, wake);
<a name="l06593"></a>06593         pci_set_power_state(pdev, PCI_D3hot);
<a name="l06594"></a>06594     }
<a name="l06595"></a>06595 }
<a name="l06596"></a>06596 
<a name="l06597"></a>06597 <span class="preprocessor">#endif</span>
<a name="l06598"></a>06598 <span class="preprocessor"></span>
<a name="l06605"></a>06605 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *ixgbe_get_stats(<span class="keyword">struct</span> net_device *netdev)
<a name="l06606"></a>06606 {
<a name="l06607"></a>06607 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l06608"></a>06608 <span class="preprocessor"></span>    <span class="comment">/* only return the current stats */</span>
<a name="l06609"></a>06609     <span class="keywordflow">return</span> &amp;netdev-&gt;stats;
<a name="l06610"></a>06610 <span class="preprocessor">#else</span>
<a name="l06611"></a>06611 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06612"></a>06612 
<a name="l06613"></a>06613     <span class="comment">/* only return the current stats */</span>
<a name="l06614"></a>06614     <span class="keywordflow">return</span> &amp;adapter-&gt;net_stats;
<a name="l06615"></a>06615 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_STATS_IN_NETDEV */</span>
<a name="l06616"></a>06616 }
<a name="l06617"></a>06617 
<a name="l06622"></a>06622 <span class="keywordtype">void</span> ixgbe_update_stats(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06623"></a>06623 {
<a name="l06624"></a>06624     <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *net_stats = ixgbe_get_stats(adapter-&gt;netdev);
<a name="l06625"></a>06625     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06626"></a>06626     <span class="keyword">struct </span><a class="code" href="structixgbe__hw__stats.html">ixgbe_hw_stats</a> *hwstats = &amp;adapter-&gt;stats;
<a name="l06627"></a>06627     u64 total_mpc = 0;
<a name="l06628"></a>06628     u32 i, missed_rx = 0, mpc, bprc, lxon, lxoff, xon_off_tot;
<a name="l06629"></a>06629     u64 non_eop_descs = 0, restart_queue = 0, tx_busy = 0;
<a name="l06630"></a>06630     u64 alloc_rx_page_failed = 0, alloc_rx_buff_failed = 0;
<a name="l06631"></a>06631     u64 bytes = 0, packets = 0;
<a name="l06632"></a>06632 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l06633"></a>06633 <span class="preprocessor"></span>    u32 flushed = 0, coal = 0, recycled = 0;
<a name="l06634"></a>06634     <span class="keywordtype">int</span> num_q_vectors = 1;
<a name="l06635"></a>06635 <span class="preprocessor">#endif</span>
<a name="l06636"></a>06636 <span class="preprocessor"></span>
<a name="l06637"></a>06637     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) ||
<a name="l06638"></a>06638         test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l06639"></a>06639         <span class="keywordflow">return</span>;
<a name="l06640"></a>06640 
<a name="l06641"></a>06641 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l06642"></a>06642 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l06643"></a>06643         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l06644"></a>06644 
<a name="l06645"></a>06645 <span class="preprocessor">#endif</span>
<a name="l06646"></a>06646 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l06647"></a>06647         u64 rsc_count = 0;
<a name="l06648"></a>06648         u64 rsc_flush = 0;
<a name="l06649"></a>06649         <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l06650"></a>06650             adapter-&gt;hw_rx_no_dma_resources +=
<a name="l06651"></a>06651                          IXGBE_READ_REG(hw, IXGBE_QPRDC(i));
<a name="l06652"></a>06652         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l06653"></a>06653             rsc_count += adapter-&gt;rx_ring[i]-&gt;rx_stats.rsc_count;
<a name="l06654"></a>06654             rsc_flush += adapter-&gt;rx_ring[i]-&gt;rx_stats.rsc_flush;
<a name="l06655"></a>06655         }
<a name="l06656"></a>06656         adapter-&gt;rsc_total_count = rsc_count;
<a name="l06657"></a>06657         adapter-&gt;rsc_total_flush = rsc_flush;
<a name="l06658"></a>06658     }
<a name="l06659"></a>06659 
<a name="l06660"></a>06660 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l06661"></a>06661 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; num_q_vectors; i++) {
<a name="l06662"></a>06662         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[i];
<a name="l06663"></a>06663         <span class="keywordflow">if</span> (!q_vector || !q_vector-&gt;lrolist)
<a name="l06664"></a>06664             <span class="keywordflow">continue</span>;
<a name="l06665"></a>06665         flushed += q_vector-&gt;lrolist-&gt;stats.flushed;
<a name="l06666"></a>06666         coal += q_vector-&gt;lrolist-&gt;stats.coal;
<a name="l06667"></a>06667         recycled += q_vector-&gt;lrolist-&gt;stats.recycled;
<a name="l06668"></a>06668     }
<a name="l06669"></a>06669     adapter-&gt;lro_stats.flushed = flushed;
<a name="l06670"></a>06670     adapter-&gt;lro_stats.coal = coal;
<a name="l06671"></a>06671     adapter-&gt;lro_stats.recycled = recycled;
<a name="l06672"></a>06672 
<a name="l06673"></a>06673 <span class="preprocessor">#endif</span>
<a name="l06674"></a>06674 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l06675"></a>06675         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = adapter-&gt;rx_ring[i];
<a name="l06676"></a>06676         non_eop_descs += rx_ring-&gt;rx_stats.non_eop_descs;
<a name="l06677"></a>06677         alloc_rx_page_failed += rx_ring-&gt;rx_stats.alloc_rx_page_failed;
<a name="l06678"></a>06678         alloc_rx_buff_failed += rx_ring-&gt;rx_stats.alloc_rx_buff_failed;
<a name="l06679"></a>06679         bytes += rx_ring-&gt;stats.bytes;
<a name="l06680"></a>06680         packets += rx_ring-&gt;stats.packets;
<a name="l06681"></a>06681 
<a name="l06682"></a>06682     }
<a name="l06683"></a>06683     adapter-&gt;non_eop_descs = non_eop_descs;
<a name="l06684"></a>06684     adapter-&gt;alloc_rx_page_failed = alloc_rx_page_failed;
<a name="l06685"></a>06685     adapter-&gt;alloc_rx_buff_failed = alloc_rx_buff_failed;
<a name="l06686"></a>06686     net_stats-&gt;rx_bytes = bytes;
<a name="l06687"></a>06687     net_stats-&gt;rx_packets = packets;
<a name="l06688"></a>06688 
<a name="l06689"></a>06689     bytes = 0;
<a name="l06690"></a>06690     packets = 0;
<a name="l06691"></a>06691     <span class="comment">/* gather some stats to the adapter struct that are per queue */</span>
<a name="l06692"></a>06692     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l06693"></a>06693         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l06694"></a>06694         restart_queue += tx_ring-&gt;tx_stats.restart_queue;
<a name="l06695"></a>06695         tx_busy += tx_ring-&gt;tx_stats.tx_busy;
<a name="l06696"></a>06696         bytes += tx_ring-&gt;stats.bytes;
<a name="l06697"></a>06697         packets += tx_ring-&gt;stats.packets;
<a name="l06698"></a>06698     }
<a name="l06699"></a>06699     adapter-&gt;restart_queue = restart_queue;
<a name="l06700"></a>06700     adapter-&gt;tx_busy = tx_busy;
<a name="l06701"></a>06701     net_stats-&gt;tx_bytes = bytes;
<a name="l06702"></a>06702     net_stats-&gt;tx_packets = packets;
<a name="l06703"></a>06703 
<a name="l06704"></a>06704     hwstats-&gt;crcerrs += IXGBE_READ_REG(hw, IXGBE_CRCERRS);
<a name="l06705"></a>06705     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {
<a name="l06706"></a>06706         <span class="comment">/* for packet buffers not used, the register should read 0 */</span>
<a name="l06707"></a>06707         mpc = IXGBE_READ_REG(hw, IXGBE_MPC(i));
<a name="l06708"></a>06708         missed_rx += mpc;
<a name="l06709"></a>06709         hwstats-&gt;mpc[i] += mpc;
<a name="l06710"></a>06710         total_mpc += hwstats-&gt;mpc[i];
<a name="l06711"></a>06711         <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l06712"></a>06712             hwstats-&gt;rnbc[i] += IXGBE_READ_REG(hw, IXGBE_RNBC(i));
<a name="l06713"></a>06713         hwstats-&gt;qptc[i] += IXGBE_READ_REG(hw, IXGBE_QPTC(i));
<a name="l06714"></a>06714         hwstats-&gt;qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC(i));
<a name="l06715"></a>06715         hwstats-&gt;qprc[i] += IXGBE_READ_REG(hw, IXGBE_QPRC(i));
<a name="l06716"></a>06716         hwstats-&gt;qbrc[i] += IXGBE_READ_REG(hw, IXGBE_QBRC(i));
<a name="l06717"></a>06717         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l06718"></a>06718         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l06719"></a>06719             hwstats-&gt;pxonrxc[i] += IXGBE_READ_REG(hw,
<a name="l06720"></a>06720                                   IXGBE_PXONRXC(i));
<a name="l06721"></a>06721             <span class="keywordflow">break</span>;
<a name="l06722"></a>06722         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l06723"></a>06723         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l06724"></a>06724             hwstats-&gt;pxonrxc[i] += IXGBE_READ_REG(hw,
<a name="l06725"></a>06725                                 IXGBE_PXONRXCNT(i));
<a name="l06726"></a>06726             <span class="keywordflow">break</span>;
<a name="l06727"></a>06727         <span class="keywordflow">default</span>:
<a name="l06728"></a>06728             <span class="keywordflow">break</span>;
<a name="l06729"></a>06729         }
<a name="l06730"></a>06730         hwstats-&gt;pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
<a name="l06731"></a>06731         hwstats-&gt;pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
<a name="l06732"></a>06732     }
<a name="l06733"></a>06733     hwstats-&gt;gprc += IXGBE_READ_REG(hw, IXGBE_GPRC);
<a name="l06734"></a>06734     <span class="comment">/* work around hardware counting issue */</span>
<a name="l06735"></a>06735     hwstats-&gt;gprc -= missed_rx;
<a name="l06736"></a>06736 
<a name="l06737"></a>06737 
<a name="l06738"></a>06738     ixgbe_update_xoff_received(adapter);
<a name="l06739"></a>06739 
<a name="l06740"></a>06740     <span class="comment">/* 82598 hardware only has a 32 bit counter in the high register */</span>
<a name="l06741"></a>06741     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l06742"></a>06742     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l06743"></a>06743         hwstats-&gt;lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXC);
<a name="l06744"></a>06744         hwstats-&gt;gorc += IXGBE_READ_REG(hw, IXGBE_GORCH);
<a name="l06745"></a>06745         hwstats-&gt;gotc += IXGBE_READ_REG(hw, IXGBE_GOTCH);
<a name="l06746"></a>06746         hwstats-&gt;tor += IXGBE_READ_REG(hw, IXGBE_TORH);
<a name="l06747"></a>06747         <span class="keywordflow">break</span>;
<a name="l06748"></a>06748     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l06749"></a>06749     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l06750"></a>06750         hwstats-&gt;gorc += IXGBE_READ_REG(hw, IXGBE_GORCL);
<a name="l06751"></a>06751         IXGBE_READ_REG(hw, IXGBE_GORCH); <span class="comment">/* to clear */</span>
<a name="l06752"></a>06752         hwstats-&gt;gotc += IXGBE_READ_REG(hw, IXGBE_GOTCL);
<a name="l06753"></a>06753         IXGBE_READ_REG(hw, IXGBE_GOTCH); <span class="comment">/* to clear */</span>
<a name="l06754"></a>06754         hwstats-&gt;tor += IXGBE_READ_REG(hw, IXGBE_TORL);
<a name="l06755"></a>06755         IXGBE_READ_REG(hw, IXGBE_TORH); <span class="comment">/* to clear */</span>
<a name="l06756"></a>06756         hwstats-&gt;lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
<a name="l06757"></a>06757 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l06758"></a>06758 <span class="preprocessor"></span>        hwstats-&gt;fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
<a name="l06759"></a>06759         hwstats-&gt;fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
<a name="l06760"></a>06760 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l06761"></a>06761 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l06762"></a>06762 <span class="preprocessor"></span>        hwstats-&gt;fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
<a name="l06763"></a>06763         hwstats-&gt;fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
<a name="l06764"></a>06764         hwstats-&gt;fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
<a name="l06765"></a>06765         hwstats-&gt;fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
<a name="l06766"></a>06766         hwstats-&gt;fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
<a name="l06767"></a>06767         hwstats-&gt;fcoedwrc += IXGBE_READ_REG(hw, IXGBE_FCOEDWRC);
<a name="l06768"></a>06768         hwstats-&gt;fcoedwtc += IXGBE_READ_REG(hw, IXGBE_FCOEDWTC);
<a name="l06769"></a>06769 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l06770"></a>06770         <span class="keywordflow">break</span>;
<a name="l06771"></a>06771     <span class="keywordflow">default</span>:
<a name="l06772"></a>06772         <span class="keywordflow">break</span>;
<a name="l06773"></a>06773     }
<a name="l06774"></a>06774     bprc = IXGBE_READ_REG(hw, IXGBE_BPRC);
<a name="l06775"></a>06775     hwstats-&gt;bprc += bprc;
<a name="l06776"></a>06776     hwstats-&gt;mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
<a name="l06777"></a>06777     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l06778"></a>06778         hwstats-&gt;mprc -= bprc;
<a name="l06779"></a>06779     hwstats-&gt;roc += IXGBE_READ_REG(hw, IXGBE_ROC);
<a name="l06780"></a>06780     hwstats-&gt;prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
<a name="l06781"></a>06781     hwstats-&gt;prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
<a name="l06782"></a>06782     hwstats-&gt;prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
<a name="l06783"></a>06783     hwstats-&gt;prc511 += IXGBE_READ_REG(hw, IXGBE_PRC511);
<a name="l06784"></a>06784     hwstats-&gt;prc1023 += IXGBE_READ_REG(hw, IXGBE_PRC1023);
<a name="l06785"></a>06785     hwstats-&gt;prc1522 += IXGBE_READ_REG(hw, IXGBE_PRC1522);
<a name="l06786"></a>06786     hwstats-&gt;rlec += IXGBE_READ_REG(hw, IXGBE_RLEC);
<a name="l06787"></a>06787     lxon = IXGBE_READ_REG(hw, IXGBE_LXONTXC);
<a name="l06788"></a>06788     hwstats-&gt;lxontxc += lxon;
<a name="l06789"></a>06789     lxoff = IXGBE_READ_REG(hw, IXGBE_LXOFFTXC);
<a name="l06790"></a>06790     hwstats-&gt;lxofftxc += lxoff;
<a name="l06791"></a>06791     hwstats-&gt;ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
<a name="l06792"></a>06792     hwstats-&gt;gptc += IXGBE_READ_REG(hw, IXGBE_GPTC);
<a name="l06793"></a>06793     hwstats-&gt;mptc += IXGBE_READ_REG(hw, IXGBE_MPTC);
<a name="l06794"></a>06794     <span class="comment">/*</span>
<a name="l06795"></a>06795 <span class="comment">     * 82598 errata - tx of flow control packets is included in tx counters</span>
<a name="l06796"></a>06796 <span class="comment">     */</span>
<a name="l06797"></a>06797     xon_off_tot = lxon + lxoff;
<a name="l06798"></a>06798     hwstats-&gt;gptc -= xon_off_tot;
<a name="l06799"></a>06799     hwstats-&gt;mptc -= xon_off_tot;
<a name="l06800"></a>06800     hwstats-&gt;gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
<a name="l06801"></a>06801     hwstats-&gt;ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
<a name="l06802"></a>06802     hwstats-&gt;rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
<a name="l06803"></a>06803     hwstats-&gt;rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
<a name="l06804"></a>06804     hwstats-&gt;tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
<a name="l06805"></a>06805     hwstats-&gt;ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
<a name="l06806"></a>06806     hwstats-&gt;ptc64 -= xon_off_tot;
<a name="l06807"></a>06807     hwstats-&gt;ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
<a name="l06808"></a>06808     hwstats-&gt;ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
<a name="l06809"></a>06809     hwstats-&gt;ptc511 += IXGBE_READ_REG(hw, IXGBE_PTC511);
<a name="l06810"></a>06810     hwstats-&gt;ptc1023 += IXGBE_READ_REG(hw, IXGBE_PTC1023);
<a name="l06811"></a>06811     hwstats-&gt;ptc1522 += IXGBE_READ_REG(hw, IXGBE_PTC1522);
<a name="l06812"></a>06812     hwstats-&gt;bptc += IXGBE_READ_REG(hw, IXGBE_BPTC);
<a name="l06813"></a>06813 
<a name="l06814"></a>06814     <span class="comment">/* Fill out the OS statistics structure */</span>
<a name="l06815"></a>06815     net_stats-&gt;multicast = hwstats-&gt;mprc;
<a name="l06816"></a>06816 
<a name="l06817"></a>06817     <span class="comment">/* Rx Errors */</span>
<a name="l06818"></a>06818     net_stats-&gt;rx_errors = hwstats-&gt;crcerrs +
<a name="l06819"></a>06819                        hwstats-&gt;rlec;
<a name="l06820"></a>06820     net_stats-&gt;rx_dropped = 0;
<a name="l06821"></a>06821     net_stats-&gt;rx_length_errors = hwstats-&gt;rlec;
<a name="l06822"></a>06822     net_stats-&gt;rx_crc_errors = hwstats-&gt;crcerrs;
<a name="l06823"></a>06823     net_stats-&gt;rx_missed_errors = total_mpc;
<a name="l06824"></a>06824 
<a name="l06825"></a>06825     <span class="comment">/*</span>
<a name="l06826"></a>06826 <span class="comment">     * VF Stats Collection - skip while resetting because these</span>
<a name="l06827"></a>06827 <span class="comment">     * are not clear on read and otherwise you&#39;ll sometimes get</span>
<a name="l06828"></a>06828 <span class="comment">     * crazy values.</span>
<a name="l06829"></a>06829 <span class="comment">     */</span>
<a name="l06830"></a>06830     <span class="keywordflow">if</span> (!test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state)) {
<a name="l06831"></a>06831         <span class="keywordflow">for</span>(i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l06832"></a>06832             UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPRC(i),         \
<a name="l06833"></a>06833                     adapter-&gt;vfinfo[i].last_vfstats.gprc, \
<a name="l06834"></a>06834                     adapter-&gt;vfinfo[i].vfstats.gprc);
<a name="l06835"></a>06835             UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPTC(i),         \
<a name="l06836"></a>06836                     adapter-&gt;vfinfo[i].last_vfstats.gptc, \
<a name="l06837"></a>06837                     adapter-&gt;vfinfo[i].vfstats.gptc);
<a name="l06838"></a>06838             UPDATE_VF_COUNTER_36bit(IXGBE_PVFGORC_LSB(i),         \
<a name="l06839"></a>06839                     IXGBE_PVFGORC_MSB(i),             \
<a name="l06840"></a>06840                     adapter-&gt;vfinfo[i].last_vfstats.gorc, \
<a name="l06841"></a>06841                     adapter-&gt;vfinfo[i].vfstats.gorc);
<a name="l06842"></a>06842             UPDATE_VF_COUNTER_36bit(IXGBE_PVFGOTC_LSB(i),         \
<a name="l06843"></a>06843                     IXGBE_PVFGOTC_MSB(i),             \
<a name="l06844"></a>06844                     adapter-&gt;vfinfo[i].last_vfstats.gotc, \
<a name="l06845"></a>06845                     adapter-&gt;vfinfo[i].vfstats.gotc);
<a name="l06846"></a>06846             UPDATE_VF_COUNTER_32bit(IXGBE_PVFMPRC(i),         \
<a name="l06847"></a>06847                     adapter-&gt;vfinfo[i].last_vfstats.mprc, \
<a name="l06848"></a>06848                     adapter-&gt;vfinfo[i].vfstats.mprc);
<a name="l06849"></a>06849         }
<a name="l06850"></a>06850     }
<a name="l06851"></a>06851 }
<a name="l06852"></a>06852 
<a name="l06853"></a>06853 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l06854"></a>06854 <span class="preprocessor"></span>
<a name="l06858"></a>06858 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_fdir_reinit_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06859"></a>06859 {
<a name="l06860"></a>06860     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06861"></a>06861     <span class="keywordtype">int</span> i;
<a name="l06862"></a>06862 
<a name="l06863"></a>06863     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_FDIR_REQUIRES_REINIT))
<a name="l06864"></a>06864         <span class="keywordflow">return</span>;
<a name="l06865"></a>06865 
<a name="l06866"></a>06866     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_FDIR_REQUIRES_REINIT;
<a name="l06867"></a>06867 
<a name="l06868"></a>06868     <span class="comment">/* if interface is down do nothing */</span>
<a name="l06869"></a>06869     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l06870"></a>06870         <span class="keywordflow">return</span>;
<a name="l06871"></a>06871 
<a name="l06872"></a>06872     <span class="comment">/* do nothing if we are not using signature filters */</span>
<a name="l06873"></a>06873     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE))
<a name="l06874"></a>06874         <span class="keywordflow">return</span>;
<a name="l06875"></a>06875 
<a name="l06876"></a>06876     adapter-&gt;fdir_overflow++;
<a name="l06877"></a>06877 
<a name="l06878"></a>06878     <span class="keywordflow">if</span> (ixgbe_reinit_fdir_tables_82599(hw) == 0) {
<a name="l06879"></a>06879         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l06880"></a>06880             set_bit(__IXGBE_TX_FDIR_INIT_DONE,
<a name="l06881"></a>06881                     &amp;(adapter-&gt;tx_ring[i]-&gt;state));
<a name="l06882"></a>06882         <span class="comment">/* re-enable flow director interrupts */</span>
<a name="l06883"></a>06883         IXGBE_WRITE_REG(hw, IXGBE_EIMS, IXGBE_EIMS_FLOW_DIR);
<a name="l06884"></a>06884     } <span class="keywordflow">else</span> {
<a name="l06885"></a>06885         e_err(probe, <span class="stringliteral">&quot;failed to finish FDIR re-initialization, &quot;</span>
<a name="l06886"></a>06886               <span class="stringliteral">&quot;ignored adding FDIR ATR filters\n&quot;</span>);
<a name="l06887"></a>06887     }
<a name="l06888"></a>06888 }
<a name="l06889"></a>06889 
<a name="l06890"></a>06890 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l06891"></a>06891 
<a name="l06900"></a>06900 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_hang_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06901"></a>06901 {
<a name="l06902"></a>06902     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06903"></a>06903     u64 eics = 0;
<a name="l06904"></a>06904     <span class="keywordtype">int</span> i;
<a name="l06905"></a>06905 
<a name="l06906"></a>06906     <span class="comment">/* If we&#39;re down or resetting, just bail */</span>
<a name="l06907"></a>06907     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) ||
<a name="l06908"></a>06908         test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l06909"></a>06909         <span class="keywordflow">return</span>;
<a name="l06910"></a>06910 
<a name="l06911"></a>06911     <span class="comment">/* Force detection of hung controller */</span>
<a name="l06912"></a>06912     <span class="keywordflow">if</span> (netif_carrier_ok(adapter-&gt;netdev)) {
<a name="l06913"></a>06913         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l06914"></a>06914             set_check_for_tx_hang(adapter-&gt;tx_ring[i]);
<a name="l06915"></a>06915     }
<a name="l06916"></a>06916 
<a name="l06917"></a>06917     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)) {
<a name="l06918"></a>06918         <span class="comment">/*</span>
<a name="l06919"></a>06919 <span class="comment">         * for legacy and MSI interrupts don&#39;t set any bits</span>
<a name="l06920"></a>06920 <span class="comment">         * that are enabled for EIAM, because this operation</span>
<a name="l06921"></a>06921 <span class="comment">         * would set *both* EIMS and EICS for any bit in EIAM</span>
<a name="l06922"></a>06922 <span class="comment">         */</span>
<a name="l06923"></a>06923         IXGBE_WRITE_REG(hw, IXGBE_EICS,
<a name="l06924"></a>06924             (IXGBE_EICS_TCP_TIMER | IXGBE_EICS_OTHER));
<a name="l06925"></a>06925     } <span class="keywordflow">else</span> {
<a name="l06926"></a>06926         <span class="comment">/* get one bit for every active tx/rx interrupt vector */</span>
<a name="l06927"></a>06927         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_msix_vectors - NON_Q_VECTORS; i++) {
<a name="l06928"></a>06928             <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *qv = adapter-&gt;q_vector[i];
<a name="l06929"></a>06929             <span class="keywordflow">if</span> (qv-&gt;rx.ring || qv-&gt;tx.ring)
<a name="l06930"></a>06930                 eics |= ((u64)1 &lt;&lt; i);
<a name="l06931"></a>06931         }
<a name="l06932"></a>06932     }
<a name="l06933"></a>06933 
<a name="l06934"></a>06934     <span class="comment">/* Cause software interrupt to ensure rings are cleaned */</span>
<a name="l06935"></a>06935     ixgbe_irq_rearm_queues(adapter, eics);
<a name="l06936"></a>06936 
<a name="l06937"></a>06937 }
<a name="l06938"></a>06938 
<a name="l06944"></a>06944 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_update_link(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06945"></a>06945 {
<a name="l06946"></a>06946     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06947"></a>06947     u32 link_speed = adapter-&gt;link_speed;
<a name="l06948"></a>06948     <span class="keywordtype">bool</span> link_up = adapter-&gt;link_up;
<a name="l06949"></a>06949     <span class="keywordtype">int</span> i;
<a name="l06950"></a>06950 
<a name="l06951"></a>06951     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_UPDATE))
<a name="l06952"></a>06952         <span class="keywordflow">return</span>;
<a name="l06953"></a>06953 
<a name="l06954"></a>06954     <span class="keywordflow">if</span> (hw-&gt;mac.ops.check_link) {
<a name="l06955"></a>06955         hw-&gt;mac.ops.check_link(hw, &amp;link_speed, &amp;link_up, <span class="keyword">false</span>);
<a name="l06956"></a>06956     } <span class="keywordflow">else</span> {
<a name="l06957"></a>06957         <span class="comment">/* always assume link is up, if no check link function */</span>
<a name="l06958"></a>06958         link_speed = IXGBE_LINK_SPEED_10GB_FULL;
<a name="l06959"></a>06959         link_up = <span class="keyword">true</span>;
<a name="l06960"></a>06960     }
<a name="l06961"></a>06961     <span class="keywordflow">if</span> (link_up) {
<a name="l06962"></a>06962         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l06963"></a>06963             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TRAFFIC_CLASS; i++)
<a name="l06964"></a>06964                 hw-&gt;mac.ops.fc_enable(hw, i);
<a name="l06965"></a>06965         } <span class="keywordflow">else</span> {
<a name="l06966"></a>06966             hw-&gt;mac.ops.fc_enable(hw, 0);
<a name="l06967"></a>06967         }
<a name="l06968"></a>06968     }
<a name="l06969"></a>06969 
<a name="l06970"></a>06970     <span class="keywordflow">if</span> (link_up ||
<a name="l06971"></a>06971         time_after(jiffies, (adapter-&gt;link_check_timeout +
<a name="l06972"></a>06972                  IXGBE_TRY_LINK_TIMEOUT))) {
<a name="l06973"></a>06973         adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l06974"></a>06974         IXGBE_WRITE_REG(hw, IXGBE_EIMS, IXGBE_EIMC_LSC);
<a name="l06975"></a>06975         IXGBE_WRITE_FLUSH(hw);
<a name="l06976"></a>06976     }
<a name="l06977"></a>06977 
<a name="l06978"></a>06978     adapter-&gt;link_up = link_up;
<a name="l06979"></a>06979     adapter-&gt;link_speed = link_speed;
<a name="l06980"></a>06980 }
<a name="l06981"></a>06981 
<a name="l06987"></a>06987 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_link_is_up(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06988"></a>06988 {
<a name="l06989"></a>06989     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06990"></a>06990     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06991"></a>06991     u32 link_speed = adapter-&gt;link_speed;
<a name="l06992"></a>06992     <span class="keywordtype">bool</span> flow_rx, flow_tx;
<a name="l06993"></a>06993 
<a name="l06994"></a>06994     <span class="comment">/* only continue if link was previously down */</span>
<a name="l06995"></a>06995     <span class="keywordflow">if</span> (netif_carrier_ok(netdev))
<a name="l06996"></a>06996         <span class="keywordflow">return</span>;
<a name="l06997"></a>06997 
<a name="l06998"></a>06998     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l06999"></a>06999 
<a name="l07000"></a>07000     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l07001"></a>07001     <span class="keywordflow">case</span> ixgbe_mac_82598EB: {
<a name="l07002"></a>07002         u32 frctl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l07003"></a>07003         u32 rmcs = IXGBE_READ_REG(hw, IXGBE_RMCS);
<a name="l07004"></a>07004         flow_rx = !!(frctl &amp; IXGBE_FCTRL_RFCE);
<a name="l07005"></a>07005         flow_tx = !!(rmcs &amp; IXGBE_RMCS_TFCE_802_3X);
<a name="l07006"></a>07006     }
<a name="l07007"></a>07007         <span class="keywordflow">break</span>;
<a name="l07008"></a>07008     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l07009"></a>07009     <span class="keywordflow">case</span> ixgbe_mac_82599EB: {
<a name="l07010"></a>07010         u32 mflcn = IXGBE_READ_REG(hw, IXGBE_MFLCN);
<a name="l07011"></a>07011         u32 fccfg = IXGBE_READ_REG(hw, IXGBE_FCCFG);
<a name="l07012"></a>07012         flow_rx = !!(mflcn &amp; IXGBE_MFLCN_RFCE);
<a name="l07013"></a>07013         flow_tx = !!(fccfg &amp; IXGBE_FCCFG_TFCE_802_3X);
<a name="l07014"></a>07014     }
<a name="l07015"></a>07015         <span class="keywordflow">break</span>;
<a name="l07016"></a>07016     <span class="keywordflow">default</span>:
<a name="l07017"></a>07017         flow_tx = <span class="keyword">false</span>;
<a name="l07018"></a>07018         flow_rx = <span class="keyword">false</span>;
<a name="l07019"></a>07019         <span class="keywordflow">break</span>;
<a name="l07020"></a>07020     }
<a name="l07021"></a>07021     e_info(drv, <span class="stringliteral">&quot;NIC Link is Up %s, Flow Control: %s\n&quot;</span>,
<a name="l07022"></a>07022            (link_speed == IXGBE_LINK_SPEED_10GB_FULL ?
<a name="l07023"></a>07023            <span class="stringliteral">&quot;10 Gbps&quot;</span> :
<a name="l07024"></a>07024            (link_speed == IXGBE_LINK_SPEED_1GB_FULL ?
<a name="l07025"></a>07025            <span class="stringliteral">&quot;1 Gbps&quot;</span> :
<a name="l07026"></a>07026            (link_speed == IXGBE_LINK_SPEED_100_FULL ?
<a name="l07027"></a>07027            <span class="stringliteral">&quot;100 Mbps&quot;</span> :
<a name="l07028"></a>07028            <span class="stringliteral">&quot;unknown speed&quot;</span>))),
<a name="l07029"></a>07029            ((flow_rx &amp;&amp; flow_tx) ? <span class="stringliteral">&quot;RX/TX&quot;</span> :
<a name="l07030"></a>07030            (flow_rx ? <span class="stringliteral">&quot;RX&quot;</span> :
<a name="l07031"></a>07031            (flow_tx ? <span class="stringliteral">&quot;TX&quot;</span> : <span class="stringliteral">&quot;None&quot;</span>))));
<a name="l07032"></a>07032 
<a name="l07033"></a>07033     netif_carrier_on(netdev);
<a name="l07034"></a>07034 <span class="preprocessor">#ifdef HAVE_IPLINK_VF_CONFIG</span>
<a name="l07035"></a>07035 <span class="preprocessor"></span>    ixgbe_check_vf_rate_limit(adapter);
<a name="l07036"></a>07036 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_IPLINK_VF_CONFIG */</span>
<a name="l07037"></a>07037     netif_tx_wake_all_queues(netdev);
<a name="l07038"></a>07038 }
<a name="l07039"></a>07039 
<a name="l07045"></a>07045 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_link_is_down(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>* adapter)
<a name="l07046"></a>07046 {
<a name="l07047"></a>07047     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l07048"></a>07048     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07049"></a>07049 
<a name="l07050"></a>07050     adapter-&gt;link_up = <span class="keyword">false</span>;
<a name="l07051"></a>07051     adapter-&gt;link_speed = 0;
<a name="l07052"></a>07052 
<a name="l07053"></a>07053     <span class="comment">/* only continue if link was up previously */</span>
<a name="l07054"></a>07054     <span class="keywordflow">if</span> (!netif_carrier_ok(netdev))
<a name="l07055"></a>07055         <span class="keywordflow">return</span>;
<a name="l07056"></a>07056 
<a name="l07057"></a>07057     <span class="comment">/* poll for SFP+ cable when link is down */</span>
<a name="l07058"></a>07058     <span class="keywordflow">if</span> (ixgbe_is_sfp(hw) &amp;&amp; hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l07059"></a>07059         adapter-&gt;flags2 |= IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l07060"></a>07060 
<a name="l07061"></a>07061     e_info(drv, <span class="stringliteral">&quot;NIC Link is Down\n&quot;</span>);
<a name="l07062"></a>07062     netif_carrier_off(netdev);
<a name="l07063"></a>07063     netif_tx_stop_all_queues(netdev);
<a name="l07064"></a>07064 }
<a name="l07065"></a>07065 
<a name="l07070"></a>07070 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_flush_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07071"></a>07071 {
<a name="l07072"></a>07072     <span class="keywordtype">int</span> i;
<a name="l07073"></a>07073     <span class="keywordtype">int</span> some_tx_pending = 0;
<a name="l07074"></a>07074 
<a name="l07075"></a>07075     <span class="keywordflow">if</span> (!netif_carrier_ok(adapter-&gt;netdev)) {
<a name="l07076"></a>07076         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l07077"></a>07077             <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l07078"></a>07078             <span class="keywordflow">if</span> (tx_ring-&gt;next_to_use != tx_ring-&gt;next_to_clean) {
<a name="l07079"></a>07079                 some_tx_pending = 1;
<a name="l07080"></a>07080                 <span class="keywordflow">break</span>;
<a name="l07081"></a>07081             }
<a name="l07082"></a>07082         }
<a name="l07083"></a>07083 
<a name="l07084"></a>07084         <span class="keywordflow">if</span> (some_tx_pending) {
<a name="l07085"></a>07085             <span class="comment">/* We&#39;ve lost link, so the controller stops DMA,</span>
<a name="l07086"></a>07086 <span class="comment">             * but we&#39;ve got queued Tx work that&#39;s never going</span>
<a name="l07087"></a>07087 <span class="comment">             * to get done, so reset controller to flush Tx.</span>
<a name="l07088"></a>07088 <span class="comment">             * (Do the reset outside of interrupt context).</span>
<a name="l07089"></a>07089 <span class="comment">             */</span>
<a name="l07090"></a>07090             adapter-&gt;flags2 |= IXGBE_FLAG2_RESET_REQUESTED;
<a name="l07091"></a>07091         }
<a name="l07092"></a>07092     }
<a name="l07093"></a>07093 }
<a name="l07094"></a>07094 
<a name="l07095"></a>07095 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_spoof_check(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07096"></a>07096 {
<a name="l07097"></a>07097     u32 ssvpc;
<a name="l07098"></a>07098 
<a name="l07099"></a>07099     <span class="comment">/* Do not perform spoof check for 82598 */</span>
<a name="l07100"></a>07100     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l07101"></a>07101         <span class="keywordflow">return</span>;
<a name="l07102"></a>07102 
<a name="l07103"></a>07103     ssvpc = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_SSVPC);
<a name="l07104"></a>07104 
<a name="l07105"></a>07105     <span class="comment">/*</span>
<a name="l07106"></a>07106 <span class="comment">     * ssvpc register is cleared on read, if zero then no</span>
<a name="l07107"></a>07107 <span class="comment">     * spoofed packets in the last interval.</span>
<a name="l07108"></a>07108 <span class="comment">     */</span>
<a name="l07109"></a>07109     <span class="keywordflow">if</span> (!ssvpc)
<a name="l07110"></a>07110         <span class="keywordflow">return</span>;
<a name="l07111"></a>07111 
<a name="l07112"></a>07112     e_warn(drv, <span class="stringliteral">&quot;%d Spoofed packets detected\n&quot;</span>, ssvpc);
<a name="l07113"></a>07113 }
<a name="l07114"></a>07114 
<a name="l07119"></a>07119 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07120"></a>07120 {
<a name="l07121"></a>07121     <span class="comment">/* if interface is down do nothing */</span>
<a name="l07122"></a>07122     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l07123"></a>07123         <span class="keywordflow">return</span>;
<a name="l07124"></a>07124 
<a name="l07125"></a>07125     ixgbe_watchdog_update_link(adapter);
<a name="l07126"></a>07126 
<a name="l07127"></a>07127     <span class="keywordflow">if</span> (adapter-&gt;link_up)
<a name="l07128"></a>07128         ixgbe_watchdog_link_is_up(adapter);
<a name="l07129"></a>07129     <span class="keywordflow">else</span>
<a name="l07130"></a>07130         ixgbe_watchdog_link_is_down(adapter);
<a name="l07131"></a>07131 
<a name="l07132"></a>07132     ixgbe_spoof_check(adapter);
<a name="l07133"></a>07133     ixgbe_update_stats(adapter);
<a name="l07134"></a>07134 
<a name="l07135"></a>07135     ixgbe_watchdog_flush_tx(adapter);
<a name="l07136"></a>07136 }
<a name="l07137"></a>07137 
<a name="l07142"></a>07142 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_sfp_detection_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07143"></a>07143 {
<a name="l07144"></a>07144     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07145"></a>07145     s32 err;
<a name="l07146"></a>07146 
<a name="l07147"></a>07147     <span class="comment">/* not searching for SFP so there is nothing to do here */</span>
<a name="l07148"></a>07148     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SEARCH_FOR_SFP) &amp;&amp;
<a name="l07149"></a>07149         !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SFP_NEEDS_RESET))
<a name="l07150"></a>07150         <span class="keywordflow">return</span>;
<a name="l07151"></a>07151 
<a name="l07152"></a>07152     <span class="comment">/* someone else is in init, wait until next service event */</span>
<a name="l07153"></a>07153     <span class="keywordflow">if</span> (test_and_set_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state))
<a name="l07154"></a>07154         <span class="keywordflow">return</span>;
<a name="l07155"></a>07155 
<a name="l07156"></a>07156     err = hw-&gt;phy.ops.identify_sfp(hw);
<a name="l07157"></a>07157     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_SUPPORTED)
<a name="l07158"></a>07158         <span class="keywordflow">goto</span> sfp_out;
<a name="l07159"></a>07159 
<a name="l07160"></a>07160     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_PRESENT) {
<a name="l07161"></a>07161         <span class="comment">/* If no cable is present, then we need to reset</span>
<a name="l07162"></a>07162 <span class="comment">         * the next time we find a good cable. */</span>
<a name="l07163"></a>07163         adapter-&gt;flags2 |= IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l07164"></a>07164     }
<a name="l07165"></a>07165 
<a name="l07166"></a>07166     <span class="comment">/* exit on error */</span>
<a name="l07167"></a>07167     <span class="keywordflow">if</span> (err)
<a name="l07168"></a>07168         <span class="keywordflow">goto</span> sfp_out;
<a name="l07169"></a>07169 
<a name="l07170"></a>07170     <span class="comment">/* exit if reset not needed */</span>
<a name="l07171"></a>07171     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SFP_NEEDS_RESET))
<a name="l07172"></a>07172         <span class="keywordflow">goto</span> sfp_out;
<a name="l07173"></a>07173 
<a name="l07174"></a>07174     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l07175"></a>07175 
<a name="l07176"></a>07176     <span class="comment">/*</span>
<a name="l07177"></a>07177 <span class="comment">     * A module may be identified correctly, but the EEPROM may not have</span>
<a name="l07178"></a>07178 <span class="comment">     * support for that module.  setup_sfp() will fail in that case, so</span>
<a name="l07179"></a>07179 <span class="comment">     * we should not allow that module to load.</span>
<a name="l07180"></a>07180 <span class="comment">     */</span>
<a name="l07181"></a>07181     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l07182"></a>07182         err = hw-&gt;phy.ops.reset(hw);
<a name="l07183"></a>07183     <span class="keywordflow">else</span>
<a name="l07184"></a>07184         err = hw-&gt;mac.ops.setup_sfp(hw);
<a name="l07185"></a>07185 
<a name="l07186"></a>07186     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_SUPPORTED)
<a name="l07187"></a>07187         <span class="keywordflow">goto</span> sfp_out;
<a name="l07188"></a>07188 
<a name="l07189"></a>07189     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l07190"></a>07190     e_info(probe, <span class="stringliteral">&quot;detected SFP+: %d\n&quot;</span>, hw-&gt;phy.sfp_type);
<a name="l07191"></a>07191 
<a name="l07192"></a>07192 sfp_out:
<a name="l07193"></a>07193     clear_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state);
<a name="l07194"></a>07194 
<a name="l07195"></a>07195     <span class="keywordflow">if</span> ((err == IXGBE_ERR_SFP_NOT_SUPPORTED) &amp;&amp;
<a name="l07196"></a>07196         adapter-&gt;netdev_registered) {
<a name="l07197"></a>07197         e_dev_err(<span class="stringliteral">&quot;failed to initialize because an unsupported &quot;</span>
<a name="l07198"></a>07198               <span class="stringliteral">&quot;SFP+ module type was detected.\n&quot;</span>);
<a name="l07199"></a>07199         e_dev_err(<span class="stringliteral">&quot;Reload the driver after installing a &quot;</span>
<a name="l07200"></a>07200               <span class="stringliteral">&quot;supported module.\n&quot;</span>);
<a name="l07201"></a>07201         unregister_netdev(adapter-&gt;netdev);
<a name="l07202"></a>07202         adapter-&gt;netdev_registered = <span class="keyword">false</span>;
<a name="l07203"></a>07203     }
<a name="l07204"></a>07204 }
<a name="l07205"></a>07205 
<a name="l07210"></a>07210 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_sfp_link_config_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07211"></a>07211 {
<a name="l07212"></a>07212     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07213"></a>07213     u32 autoneg;
<a name="l07214"></a>07214     <span class="keywordtype">bool</span> negotiation;
<a name="l07215"></a>07215 
<a name="l07216"></a>07216     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_CONFIG))
<a name="l07217"></a>07217         <span class="keywordflow">return</span>;
<a name="l07218"></a>07218 
<a name="l07219"></a>07219     <span class="comment">/* someone else is in init, wait until next service event */</span>
<a name="l07220"></a>07220     <span class="keywordflow">if</span> (test_and_set_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state))
<a name="l07221"></a>07221         <span class="keywordflow">return</span>;
<a name="l07222"></a>07222 
<a name="l07223"></a>07223     adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l07224"></a>07224 
<a name="l07225"></a>07225     autoneg = hw-&gt;phy.autoneg_advertised;
<a name="l07226"></a>07226     <span class="keywordflow">if</span> ((!autoneg) &amp;&amp; (hw-&gt;mac.ops.get_link_capabilities))
<a name="l07227"></a>07227         hw-&gt;mac.ops.get_link_capabilities(hw, &amp;autoneg, &amp;negotiation);
<a name="l07228"></a>07228     hw-&gt;mac.autotry_restart = <span class="keyword">false</span>;
<a name="l07229"></a>07229     <span class="keywordflow">if</span> (hw-&gt;mac.ops.setup_link)
<a name="l07230"></a>07230         hw-&gt;mac.ops.setup_link(hw, autoneg, negotiation, <span class="keyword">true</span>);
<a name="l07231"></a>07231 
<a name="l07232"></a>07232     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l07233"></a>07233     adapter-&gt;link_check_timeout = jiffies;
<a name="l07234"></a>07234     clear_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state);
<a name="l07235"></a>07235 }
<a name="l07236"></a>07236 
<a name="l07241"></a>07241 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_timer(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l07242"></a>07242 {
<a name="l07243"></a>07243     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = (<span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *)data;
<a name="l07244"></a>07244     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> next_event_offset;
<a name="l07245"></a>07245 
<a name="l07246"></a>07246     <span class="comment">/* poll faster when waiting for link */</span>
<a name="l07247"></a>07247     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_UPDATE)
<a name="l07248"></a>07248         next_event_offset = HZ / 10;
<a name="l07249"></a>07249     <span class="keywordflow">else</span>
<a name="l07250"></a>07250         next_event_offset = HZ * 2;
<a name="l07251"></a>07251 
<a name="l07252"></a>07252     <span class="comment">/* Reset the timer */</span>
<a name="l07253"></a>07253     mod_timer(&amp;adapter-&gt;service_timer, next_event_offset + jiffies);
<a name="l07254"></a>07254 
<a name="l07255"></a>07255     ixgbe_service_event_schedule(adapter);
<a name="l07256"></a>07256 }
<a name="l07257"></a>07257 
<a name="l07258"></a>07258 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_reset_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07259"></a>07259 {
<a name="l07260"></a>07260     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RESET_REQUESTED))
<a name="l07261"></a>07261         <span class="keywordflow">return</span>;
<a name="l07262"></a>07262 
<a name="l07263"></a>07263     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RESET_REQUESTED;
<a name="l07264"></a>07264 
<a name="l07265"></a>07265     <span class="comment">/* If we&#39;re already down or resetting, just bail */</span>
<a name="l07266"></a>07266     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) ||
<a name="l07267"></a>07267         test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l07268"></a>07268         <span class="keywordflow">return</span>;
<a name="l07269"></a>07269 
<a name="l07270"></a>07270     adapter-&gt;tx_timeout_count++;
<a name="l07271"></a>07271 
<a name="l07272"></a>07272     ixgbe_reinit_locked(adapter);
<a name="l07273"></a>07273 }
<a name="l07274"></a>07274 
<a name="l07279"></a>07279 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_task(<span class="keyword">struct</span> work_struct *work)
<a name="l07280"></a>07280 {
<a name="l07281"></a>07281     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = container_of(work,
<a name="l07282"></a>07282                              <span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>,
<a name="l07283"></a>07283                              service_task);
<a name="l07284"></a>07284 
<a name="l07285"></a>07285     ixgbe_reset_subtask(adapter);
<a name="l07286"></a>07286     ixgbe_sfp_detection_subtask(adapter);
<a name="l07287"></a>07287     ixgbe_sfp_link_config_subtask(adapter);
<a name="l07288"></a>07288     ixgbe_check_overtemp_subtask(adapter);
<a name="l07289"></a>07289     ixgbe_watchdog_subtask(adapter);
<a name="l07290"></a>07290 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l07291"></a>07291 <span class="preprocessor"></span>    ixgbe_fdir_reinit_subtask(adapter);
<a name="l07292"></a>07292 <span class="preprocessor">#endif</span>
<a name="l07293"></a>07293 <span class="preprocessor"></span>    ixgbe_check_hang_subtask(adapter);
<a name="l07294"></a>07294 
<a name="l07295"></a>07295     ixgbe_service_event_complete(adapter);
<a name="l07296"></a>07296 }
<a name="l07297"></a>07297 
<a name="l07298"></a>07298 <span class="keywordtype">void</span> ixgbe_tx_ctxtdesc(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, u32 vlan_macip_lens,
<a name="l07299"></a>07299                u32 fcoe_sof_eof, u32 type_tucmd, u32 mss_l4len_idx)
<a name="l07300"></a>07300 {
<a name="l07301"></a>07301     <span class="keyword">struct </span><a class="code" href="structixgbe__adv__tx__context__desc.html">ixgbe_adv_tx_context_desc</a> *context_desc;
<a name="l07302"></a>07302     u16 i = tx_ring-&gt;next_to_use;
<a name="l07303"></a>07303 
<a name="l07304"></a>07304     context_desc = IXGBE_TX_CTXTDESC_ADV(tx_ring, i);
<a name="l07305"></a>07305 
<a name="l07306"></a>07306     i++;
<a name="l07307"></a>07307     tx_ring-&gt;next_to_use = (i &lt; tx_ring-&gt;count) ? i : 0;
<a name="l07308"></a>07308 
<a name="l07309"></a>07309     <span class="comment">/* set bits to identify this as an advanced context descriptor */</span>
<a name="l07310"></a>07310     type_tucmd |= IXGBE_TXD_CMD_DEXT | IXGBE_ADVTXD_DTYP_CTXT;
<a name="l07311"></a>07311 
<a name="l07312"></a>07312     context_desc-&gt;vlan_macip_lens   = cpu_to_le32(vlan_macip_lens);
<a name="l07313"></a>07313     context_desc-&gt;seqnum_seed   = cpu_to_le32(fcoe_sof_eof);
<a name="l07314"></a>07314     context_desc-&gt;type_tucmd_mlhl   = cpu_to_le32(type_tucmd);
<a name="l07315"></a>07315     context_desc-&gt;mss_l4len_idx = cpu_to_le32(mss_l4len_idx);
<a name="l07316"></a>07316 }
<a name="l07317"></a>07317 
<a name="l07318"></a>07318 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_tso(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, <span class="keyword">struct</span> sk_buff *skb,
<a name="l07319"></a>07319              u32 tx_flags, __be16 protocol, u8 *hdr_len)
<a name="l07320"></a>07320 {
<a name="l07321"></a>07321 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l07322"></a>07322 <span class="preprocessor"></span>    <span class="keywordtype">int</span> err;
<a name="l07323"></a>07323     u32 vlan_macip_lens, type_tucmd;
<a name="l07324"></a>07324     u32 mss_l4len_idx, l4len;
<a name="l07325"></a>07325 
<a name="l07326"></a>07326     <span class="keywordflow">if</span> (!skb_is_gso(skb))
<a name="l07327"></a>07327 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l07328"></a>07328         <span class="keywordflow">return</span> 0;
<a name="l07329"></a>07329 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l07330"></a>07330 <span class="preprocessor"></span>
<a name="l07331"></a>07331     <span class="keywordflow">if</span> (skb_header_cloned(skb)) {
<a name="l07332"></a>07332         err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
<a name="l07333"></a>07333         <span class="keywordflow">if</span> (err)
<a name="l07334"></a>07334             <span class="keywordflow">return</span> err;
<a name="l07335"></a>07335     }
<a name="l07336"></a>07336 
<a name="l07337"></a>07337     <span class="comment">/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */</span>
<a name="l07338"></a>07338     type_tucmd = IXGBE_ADVTXD_TUCMD_L4T_TCP;
<a name="l07339"></a>07339 
<a name="l07340"></a>07340     <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_IP)) {
<a name="l07341"></a>07341         <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = ip_hdr(skb);
<a name="l07342"></a>07342         iph-&gt;tot_len = 0;
<a name="l07343"></a>07343         iph-&gt;check = 0;
<a name="l07344"></a>07344         tcp_hdr(skb)-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr,
<a name="l07345"></a>07345                              iph-&gt;daddr, 0,
<a name="l07346"></a>07346                              IPPROTO_TCP,
<a name="l07347"></a>07347                              0);
<a name="l07348"></a>07348         type_tucmd |= IXGBE_ADVTXD_TUCMD_IPV4;
<a name="l07349"></a>07349 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l07350"></a>07350 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (skb_is_gso_v6(skb)) {
<a name="l07351"></a>07351         ipv6_hdr(skb)-&gt;payload_len = 0;
<a name="l07352"></a>07352         tcp_hdr(skb)-&gt;check =
<a name="l07353"></a>07353             ~csum_ipv6_magic(&amp;ipv6_hdr(skb)-&gt;saddr,
<a name="l07354"></a>07354                      &amp;ipv6_hdr(skb)-&gt;daddr,
<a name="l07355"></a>07355                      0, IPPROTO_TCP, 0);
<a name="l07356"></a>07356 <span class="preprocessor">#endif</span>
<a name="l07357"></a>07357 <span class="preprocessor"></span>    }
<a name="l07358"></a>07358 
<a name="l07359"></a>07359     l4len = tcp_hdrlen(skb);
<a name="l07360"></a>07360     *hdr_len = skb_transport_offset(skb) + l4len;
<a name="l07361"></a>07361 
<a name="l07362"></a>07362     <span class="comment">/* mss_l4len_id: use 1 as index for TSO */</span>
<a name="l07363"></a>07363     mss_l4len_idx = l4len &lt;&lt; IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07364"></a>07364     mss_l4len_idx |= skb_shinfo(skb)-&gt;gso_size &lt;&lt; IXGBE_ADVTXD_MSS_SHIFT;
<a name="l07365"></a>07365     mss_l4len_idx |= 1 &lt;&lt; IXGBE_ADVTXD_IDX_SHIFT;
<a name="l07366"></a>07366 
<a name="l07367"></a>07367     <span class="comment">/* vlan_macip_lens: HEADLEN, MACLEN, VLAN tag */</span>
<a name="l07368"></a>07368     vlan_macip_lens = skb_network_header_len(skb);
<a name="l07369"></a>07369     vlan_macip_lens |= skb_network_offset(skb) &lt;&lt; IXGBE_ADVTXD_MACLEN_SHIFT;
<a name="l07370"></a>07370     vlan_macip_lens |= tx_flags &amp; IXGBE_TX_FLAGS_VLAN_MASK;
<a name="l07371"></a>07371 
<a name="l07372"></a>07372     ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0, type_tucmd,
<a name="l07373"></a>07373                       mss_l4len_idx);
<a name="l07374"></a>07374 
<a name="l07375"></a>07375     <span class="keywordflow">return</span> 1;
<a name="l07376"></a>07376 <span class="preprocessor">#endif</span>
<a name="l07377"></a>07377 <span class="preprocessor"></span>}
<a name="l07378"></a>07378 
<a name="l07379"></a>07379 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_tx_csum(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l07380"></a>07380               <span class="keyword">struct</span> sk_buff *skb, u32 tx_flags,
<a name="l07381"></a>07381               __be16 protocol)
<a name="l07382"></a>07382 {
<a name="l07383"></a>07383     u32 vlan_macip_lens = 0;
<a name="l07384"></a>07384     u32 mss_l4len_idx = 0;
<a name="l07385"></a>07385     u32 type_tucmd = 0;
<a name="l07386"></a>07386 
<a name="l07387"></a>07387     <span class="keywordflow">if</span> (skb-&gt;ip_summed != CHECKSUM_PARTIAL) {
<a name="l07388"></a>07388         <span class="keywordflow">if</span> (!(tx_flags &amp; IXGBE_TX_FLAGS_HW_VLAN) &amp;&amp;
<a name="l07389"></a>07389         !(tx_flags &amp; IXGBE_TX_FLAGS_TXSW))
<a name="l07390"></a>07390             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l07391"></a>07391     } <span class="keywordflow">else</span> {
<a name="l07392"></a>07392         u8 l4_hdr = 0;
<a name="l07393"></a>07393         <span class="keywordflow">switch</span> (protocol) {
<a name="l07394"></a>07394         <span class="keywordflow">case</span> __constant_htons(ETH_P_IP):
<a name="l07395"></a>07395             vlan_macip_lens |= skb_network_header_len(skb);
<a name="l07396"></a>07396             type_tucmd |= IXGBE_ADVTXD_TUCMD_IPV4;
<a name="l07397"></a>07397             l4_hdr = ip_hdr(skb)-&gt;protocol;
<a name="l07398"></a>07398             <span class="keywordflow">break</span>;
<a name="l07399"></a>07399 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l07400"></a>07400 <span class="preprocessor"></span>        <span class="keywordflow">case</span> __constant_htons(ETH_P_IPV6):
<a name="l07401"></a>07401             vlan_macip_lens |= skb_network_header_len(skb);
<a name="l07402"></a>07402             l4_hdr = ipv6_hdr(skb)-&gt;nexthdr;
<a name="l07403"></a>07403             <span class="keywordflow">break</span>;
<a name="l07404"></a>07404 <span class="preprocessor">#endif</span>
<a name="l07405"></a>07405 <span class="preprocessor"></span>        <span class="keywordflow">default</span>:
<a name="l07406"></a>07406             <span class="keywordflow">if</span> (unlikely(net_ratelimit())) {
<a name="l07407"></a>07407                 dev_warn(tx_ring-&gt;dev,
<a name="l07408"></a>07408                  <span class="stringliteral">&quot;partial checksum but proto=%x!\n&quot;</span>,
<a name="l07409"></a>07409                  skb-&gt;protocol);
<a name="l07410"></a>07410             }
<a name="l07411"></a>07411             <span class="keywordflow">break</span>;
<a name="l07412"></a>07412         }
<a name="l07413"></a>07413 
<a name="l07414"></a>07414         <span class="keywordflow">switch</span> (l4_hdr) {
<a name="l07415"></a>07415         <span class="keywordflow">case</span> IPPROTO_TCP:
<a name="l07416"></a>07416             type_tucmd |= IXGBE_ADVTXD_TUCMD_L4T_TCP;
<a name="l07417"></a>07417             mss_l4len_idx = tcp_hdrlen(skb) &lt;&lt;
<a name="l07418"></a>07418                     IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07419"></a>07419             <span class="keywordflow">break</span>;
<a name="l07420"></a>07420 <span class="preprocessor">#ifdef HAVE_SCTP</span>
<a name="l07421"></a>07421 <span class="preprocessor"></span>        <span class="keywordflow">case</span> IPPROTO_SCTP:
<a name="l07422"></a>07422             type_tucmd |= IXGBE_ADVTXD_TUCMD_L4T_SCTP;
<a name="l07423"></a>07423             mss_l4len_idx = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sctphdr) &lt;&lt;
<a name="l07424"></a>07424                     IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07425"></a>07425             <span class="keywordflow">break</span>;
<a name="l07426"></a>07426 <span class="preprocessor">#endif</span>
<a name="l07427"></a>07427 <span class="preprocessor"></span>        <span class="keywordflow">case</span> IPPROTO_UDP:
<a name="l07428"></a>07428             mss_l4len_idx = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structudphdr.html">udphdr</a>) &lt;&lt;
<a name="l07429"></a>07429                     IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07430"></a>07430             <span class="keywordflow">break</span>;
<a name="l07431"></a>07431         <span class="keywordflow">default</span>:
<a name="l07432"></a>07432             <span class="keywordflow">if</span> (unlikely(net_ratelimit())) {
<a name="l07433"></a>07433                 dev_warn(tx_ring-&gt;dev,
<a name="l07434"></a>07434                  <span class="stringliteral">&quot;partial checksum but l4 proto=%x!\n&quot;</span>,
<a name="l07435"></a>07435                  skb-&gt;protocol);
<a name="l07436"></a>07436             }
<a name="l07437"></a>07437             <span class="keywordflow">break</span>;
<a name="l07438"></a>07438         }
<a name="l07439"></a>07439     }
<a name="l07440"></a>07440 
<a name="l07441"></a>07441     vlan_macip_lens |= skb_network_offset(skb) &lt;&lt; IXGBE_ADVTXD_MACLEN_SHIFT;
<a name="l07442"></a>07442     vlan_macip_lens |= tx_flags &amp; IXGBE_TX_FLAGS_VLAN_MASK;
<a name="l07443"></a>07443 
<a name="l07444"></a>07444     ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0,
<a name="l07445"></a>07445               type_tucmd, mss_l4len_idx);
<a name="l07446"></a>07446 
<a name="l07447"></a>07447     <span class="keywordflow">return</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL);
<a name="l07448"></a>07448 }
<a name="l07449"></a>07449 
<a name="l07450"></a>07450 <span class="keyword">static</span> __le32 ixgbe_tx_cmd_type(u32 tx_flags)
<a name="l07451"></a>07451 {
<a name="l07452"></a>07452     <span class="comment">/* set type for advanced descriptor with frame checksum insertion */</span>
<a name="l07453"></a>07453     __le32 cmd_type = cpu_to_le32(IXGBE_ADVTXD_DTYP_DATA |
<a name="l07454"></a>07454                       IXGBE_ADVTXD_DCMD_IFCS |
<a name="l07455"></a>07455                       IXGBE_ADVTXD_DCMD_DEXT);
<a name="l07456"></a>07456 
<a name="l07457"></a>07457     <span class="comment">/* set HW vlan bit if vlan is present */</span>
<a name="l07458"></a>07458     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_HW_VLAN)
<a name="l07459"></a>07459         cmd_type |= cpu_to_le32(IXGBE_ADVTXD_DCMD_VLE);
<a name="l07460"></a>07460 
<a name="l07461"></a>07461     <span class="comment">/* set segmentation enable bits for TSO/FSO */</span>
<a name="l07462"></a>07462 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07463"></a>07463 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((tx_flags &amp; IXGBE_TX_FLAGS_TSO) || (tx_flags &amp; IXGBE_TX_FLAGS_FSO))
<a name="l07464"></a>07464 <span class="preprocessor">#else</span>
<a name="l07465"></a>07465 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TSO)
<a name="l07466"></a>07466 <span class="preprocessor">#endif</span>
<a name="l07467"></a>07467 <span class="preprocessor"></span>      cmd_type |= cpu_to_le32(IXGBE_ADVTXD_DCMD_TSE);
<a name="l07468"></a>07468 
<a name="l07469"></a>07469     <span class="keywordflow">return</span> cmd_type;
<a name="l07470"></a>07470 }
<a name="l07471"></a>07471 
<a name="l07472"></a>07472 <span class="keyword">static</span> __le32 ixgbe_tx_olinfo_status(u32 tx_flags, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> paylen)
<a name="l07473"></a>07473 {
<a name="l07474"></a>07474     __le32 olinfo_status =
<a name="l07475"></a>07475         cpu_to_le32(paylen &lt;&lt; IXGBE_ADVTXD_PAYLEN_SHIFT);
<a name="l07476"></a>07476 
<a name="l07477"></a>07477     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TSO) {
<a name="l07478"></a>07478         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_POPTS_TXSM |
<a name="l07479"></a>07479                         (1 &lt;&lt; IXGBE_ADVTXD_IDX_SHIFT));
<a name="l07480"></a>07480         <span class="comment">/* enble IPv4 checksum for TSO */</span>
<a name="l07481"></a>07481         <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_IPV4)
<a name="l07482"></a>07482             olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_POPTS_IXSM);
<a name="l07483"></a>07483     }
<a name="l07484"></a>07484 
<a name="l07485"></a>07485     <span class="comment">/* enable L4 checksum for TSO and TX checksum offload */</span>
<a name="l07486"></a>07486     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_CSUM)
<a name="l07487"></a>07487         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_POPTS_TXSM);
<a name="l07488"></a>07488 
<a name="l07489"></a>07489 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07490"></a>07490 <span class="preprocessor"></span>    <span class="comment">/* use index 1 context for FCOE/FSO */</span>
<a name="l07491"></a>07491     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_FCOE)
<a name="l07492"></a>07492         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_CC |
<a name="l07493"></a>07493                         (1 &lt;&lt; IXGBE_ADVTXD_IDX_SHIFT));
<a name="l07494"></a>07494 
<a name="l07495"></a>07495 <span class="preprocessor">#endif</span>
<a name="l07496"></a>07496 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l07497"></a>07497 <span class="comment">     * Check Context must be set if Tx switch is enabled, which it</span>
<a name="l07498"></a>07498 <span class="comment">     * always is for case where virtual functions are running</span>
<a name="l07499"></a>07499 <span class="comment">     */</span>
<a name="l07500"></a>07500     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TXSW)
<a name="l07501"></a>07501         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_CC);
<a name="l07502"></a>07502     <span class="keywordflow">return</span> olinfo_status;
<a name="l07503"></a>07503 }
<a name="l07504"></a>07504 
<a name="l07505"></a>07505 <span class="preprocessor">#define IXGBE_TXD_CMD (IXGBE_TXD_CMD_EOP | \</span>
<a name="l07506"></a>07506 <span class="preprocessor">               IXGBE_TXD_CMD_RS)</span>
<a name="l07507"></a>07507 <span class="preprocessor"></span>
<a name="l07508"></a>07508 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_tx_map(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l07509"></a>07509              <span class="keyword">struct</span> sk_buff *skb,
<a name="l07510"></a>07510              <span class="keyword">struct</span> <a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *first,
<a name="l07511"></a>07511              u32 tx_flags,
<a name="l07512"></a>07512              <span class="keyword">const</span> u8 hdr_len)
<a name="l07513"></a>07513 {
<a name="l07514"></a>07514     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = tx_ring-&gt;dev;
<a name="l07515"></a>07515     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info;
<a name="l07516"></a>07516     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a> *tx_desc;
<a name="l07517"></a>07517     dma_addr_t dma = 0;
<a name="l07518"></a>07518     __le32 cmd_type, olinfo_status;
<a name="l07519"></a>07519 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07520"></a>07520 <span class="preprocessor"></span>    <span class="keyword">struct </span>skb_frag_struct *frag;
<a name="l07521"></a>07521     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0;
<a name="l07522"></a>07522     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data_len = skb-&gt;data_len;
<a name="l07523"></a>07523 <span class="preprocessor">#endif</span>
<a name="l07524"></a>07524 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = skb_headlen(skb);
<a name="l07525"></a>07525     u32 offset = 0;
<a name="l07526"></a>07526     u32 paylen = skb-&gt;len - hdr_len;
<a name="l07527"></a>07527     u16 i = tx_ring-&gt;next_to_use;
<a name="l07528"></a>07528     u16 gso_segs;
<a name="l07529"></a>07529 
<a name="l07530"></a>07530 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l07531"></a>07531 <span class="preprocessor"></span>    <span class="keywordflow">return</span>; <span class="comment">/* We don&#39;t allow apps to send data */</span>  
<a name="l07532"></a>07532 <span class="preprocessor">#endif</span>
<a name="l07533"></a>07533 <span class="preprocessor"></span>
<a name="l07534"></a>07534 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07535"></a>07535 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_FCOE) {
<a name="l07536"></a>07536         <span class="keywordflow">if</span> (data_len &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fcoe_crc_eof)) {
<a name="l07537"></a>07537             data_len -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fcoe_crc_eof);
<a name="l07538"></a>07538         } <span class="keywordflow">else</span> {
<a name="l07539"></a>07539             size -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fcoe_crc_eof) - data_len;
<a name="l07540"></a>07540             data_len = 0;
<a name="l07541"></a>07541         }
<a name="l07542"></a>07542     }
<a name="l07543"></a>07543 
<a name="l07544"></a>07544 <span class="preprocessor">#endif</span>
<a name="l07545"></a>07545 <span class="preprocessor"></span>
<a name="l07546"></a>07546     dma = dma_map_single(dev, skb-&gt;data, size, DMA_TO_DEVICE);
<a name="l07547"></a>07547     <span class="keywordflow">if</span> (dma_mapping_error(dev, dma))
<a name="l07548"></a>07548         <span class="keywordflow">goto</span> dma_error;
<a name="l07549"></a>07549 
<a name="l07550"></a>07550     cmd_type = ixgbe_tx_cmd_type(tx_flags);
<a name="l07551"></a>07551     olinfo_status = ixgbe_tx_olinfo_status(tx_flags, paylen);
<a name="l07552"></a>07552 
<a name="l07553"></a>07553     tx_desc = IXGBE_TX_DESC_ADV(tx_ring, i);
<a name="l07554"></a>07554 
<a name="l07555"></a>07555 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07556"></a>07556 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (;;) {
<a name="l07557"></a>07557 <span class="preprocessor">#endif</span>
<a name="l07558"></a>07558 <span class="preprocessor"></span>        <span class="keywordflow">while</span> (size &gt; IXGBE_MAX_DATA_PER_TXD) {
<a name="l07559"></a>07559             tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma + offset);
<a name="l07560"></a>07560             tx_desc-&gt;read.cmd_type_len =
<a name="l07561"></a>07561                 cmd_type | cpu_to_le32(IXGBE_MAX_DATA_PER_TXD);
<a name="l07562"></a>07562             tx_desc-&gt;read.olinfo_status = olinfo_status;
<a name="l07563"></a>07563 
<a name="l07564"></a>07564             offset += IXGBE_MAX_DATA_PER_TXD;
<a name="l07565"></a>07565             size -= IXGBE_MAX_DATA_PER_TXD;
<a name="l07566"></a>07566 
<a name="l07567"></a>07567             tx_desc++;
<a name="l07568"></a>07568             i++;
<a name="l07569"></a>07569             <span class="keywordflow">if</span> (i == tx_ring-&gt;count) {
<a name="l07570"></a>07570                 tx_desc = IXGBE_TX_DESC_ADV(tx_ring, 0);
<a name="l07571"></a>07571                 i = 0;
<a name="l07572"></a>07572             }
<a name="l07573"></a>07573         }
<a name="l07574"></a>07574 
<a name="l07575"></a>07575         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l07576"></a>07576         tx_buffer_info-&gt;length = offset + size;
<a name="l07577"></a>07577         tx_buffer_info-&gt;tx_flags = tx_flags;
<a name="l07578"></a>07578         tx_buffer_info-&gt;dma = dma;
<a name="l07579"></a>07579         tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma + offset);
<a name="l07580"></a>07580         tx_desc-&gt;read.cmd_type_len = cmd_type | cpu_to_le32(size);
<a name="l07581"></a>07581         tx_desc-&gt;read.olinfo_status = olinfo_status;
<a name="l07582"></a>07582 
<a name="l07583"></a>07583 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07584"></a>07584 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!data_len)
<a name="l07585"></a>07585             <span class="keywordflow">break</span>;
<a name="l07586"></a>07586 
<a name="l07587"></a>07587         frag = &amp;skb_shinfo(skb)-&gt;frags[f];
<a name="l07588"></a>07588 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07589"></a>07589 <span class="preprocessor"></span>        size = min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, data_len, frag-&gt;size);
<a name="l07590"></a>07590 <span class="preprocessor">#else</span>
<a name="l07591"></a>07591 <span class="preprocessor"></span>        size = frag-&gt;size;
<a name="l07592"></a>07592 <span class="preprocessor">#endif</span>
<a name="l07593"></a>07593 <span class="preprocessor"></span>        data_len -= size;
<a name="l07594"></a>07594         f++;
<a name="l07595"></a>07595 
<a name="l07596"></a>07596         offset = 0;
<a name="l07597"></a>07597         tx_flags |= IXGBE_TX_FLAGS_MAPPED_AS_PAGE;
<a name="l07598"></a>07598 
<a name="l07599"></a>07599         dma = dma_map_page(dev, frag-&gt;page, frag-&gt;page_offset,
<a name="l07600"></a>07600                    size, DMA_TO_DEVICE);
<a name="l07601"></a>07601         <span class="keywordflow">if</span> (dma_mapping_error(dev, dma))
<a name="l07602"></a>07602             <span class="keywordflow">goto</span> dma_error;
<a name="l07603"></a>07603 
<a name="l07604"></a>07604         tx_desc++;
<a name="l07605"></a>07605         i++;
<a name="l07606"></a>07606         <span class="keywordflow">if</span> (i == tx_ring-&gt;count) {
<a name="l07607"></a>07607             tx_desc = IXGBE_TX_DESC_ADV(tx_ring, 0);
<a name="l07608"></a>07608             i = 0;
<a name="l07609"></a>07609         }
<a name="l07610"></a>07610     }
<a name="l07611"></a>07611 
<a name="l07612"></a>07612 <span class="preprocessor">#endif </span><span class="comment">/* MAX_SKB_FRAGS */</span>
<a name="l07613"></a>07613 
<a name="l07614"></a>07614     tx_desc-&gt;read.cmd_type_len |= cpu_to_le32(IXGBE_TXD_CMD);
<a name="l07615"></a>07615 
<a name="l07616"></a>07616     i++;
<a name="l07617"></a>07617     <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l07618"></a>07618         i = 0;
<a name="l07619"></a>07619 
<a name="l07620"></a>07620     tx_ring-&gt;next_to_use = i;
<a name="l07621"></a>07621 
<a name="l07622"></a>07622 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l07623"></a>07623 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TSO)
<a name="l07624"></a>07624         gso_segs = skb_shinfo(skb)-&gt;gso_segs;
<a name="l07625"></a>07625 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07626"></a>07626 <span class="preprocessor"></span>    <span class="comment">/* adjust for FCoE Sequence Offload */</span>
<a name="l07627"></a>07627     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_FSO)
<a name="l07628"></a>07628         gso_segs = DIV_ROUND_UP(skb-&gt;len - hdr_len,
<a name="l07629"></a>07629                     skb_shinfo(skb)-&gt;gso_size);
<a name="l07630"></a>07630 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07631"></a>07631     <span class="keywordflow">else</span>
<a name="l07632"></a>07632 <span class="preprocessor">#endif</span>
<a name="l07633"></a>07633 <span class="preprocessor"></span>        gso_segs = 1;
<a name="l07634"></a>07634 
<a name="l07635"></a>07635     <span class="comment">/* multiply data chunks by size of headers */</span>
<a name="l07636"></a>07636     tx_buffer_info-&gt;bytecount = paylen + (gso_segs * hdr_len);
<a name="l07637"></a>07637     tx_buffer_info-&gt;gso_segs = gso_segs;
<a name="l07638"></a>07638     tx_buffer_info-&gt;skb = skb;
<a name="l07639"></a>07639 
<a name="l07640"></a>07640     <span class="comment">/* set the timestamp */</span>
<a name="l07641"></a>07641     first-&gt;time_stamp = jiffies;
<a name="l07642"></a>07642 
<a name="l07643"></a>07643     <span class="comment">/*</span>
<a name="l07644"></a>07644 <span class="comment">     * Force memory writes to complete before letting h/w</span>
<a name="l07645"></a>07645 <span class="comment">     * know there are new descriptors to fetch.  (Only</span>
<a name="l07646"></a>07646 <span class="comment">     * applicable for weak-ordered memory model archs,</span>
<a name="l07647"></a>07647 <span class="comment">     * such as IA-64).</span>
<a name="l07648"></a>07648 <span class="comment">     */</span>
<a name="l07649"></a>07649     wmb();
<a name="l07650"></a>07650 
<a name="l07651"></a>07651     <span class="comment">/* set next_to_watch value indicating a packet is present */</span>
<a name="l07652"></a>07652     first-&gt;next_to_watch = tx_desc;
<a name="l07653"></a>07653 
<a name="l07654"></a>07654     <span class="comment">/* notify HW of packet */</span>
<a name="l07655"></a>07655     writel(i, tx_ring-&gt;tail);
<a name="l07656"></a>07656 
<a name="l07657"></a>07657     <span class="keywordflow">return</span>;
<a name="l07658"></a>07658 dma_error:
<a name="l07659"></a>07659     dev_err(dev, <span class="stringliteral">&quot;TX DMA map failed\n&quot;</span>);
<a name="l07660"></a>07660 
<a name="l07661"></a>07661     <span class="comment">/* clear dma mappings for failed tx_buffer_info map */</span>
<a name="l07662"></a>07662     <span class="keywordflow">for</span> (;;) {
<a name="l07663"></a>07663         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l07664"></a>07664         ixgbe_unmap_tx_resource(tx_ring, tx_buffer_info);
<a name="l07665"></a>07665         <span class="keywordflow">if</span> (tx_buffer_info == first)
<a name="l07666"></a>07666             <span class="keywordflow">break</span>;
<a name="l07667"></a>07667         <span class="keywordflow">if</span> (i == 0)
<a name="l07668"></a>07668             i = tx_ring-&gt;count;
<a name="l07669"></a>07669         i--;
<a name="l07670"></a>07670     }
<a name="l07671"></a>07671 
<a name="l07672"></a>07672     dev_kfree_skb_any(skb);
<a name="l07673"></a>07673 
<a name="l07674"></a>07674     tx_ring-&gt;next_to_use = i;
<a name="l07675"></a>07675 }
<a name="l07676"></a>07676 
<a name="l07677"></a>07677 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_atr(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring, <span class="keyword">struct</span> sk_buff *skb,
<a name="l07678"></a>07678               u32 tx_flags, __be16 protocol)
<a name="l07679"></a>07679 {
<a name="l07680"></a>07680     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = ring-&gt;q_vector;
<a name="l07681"></a>07681     <span class="keyword">union </span><a class="code" href="unionixgbe__atr__hash__dword.html">ixgbe_atr_hash_dword</a> input = { .dword = 0 };
<a name="l07682"></a>07682     <span class="keyword">union </span><a class="code" href="unionixgbe__atr__hash__dword.html">ixgbe_atr_hash_dword</a> common = { .dword = 0 };
<a name="l07683"></a>07683     <span class="keyword">union </span>{
<a name="l07684"></a>07684         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *network;
<a name="l07685"></a>07685         <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *ipv4;
<a name="l07686"></a>07686         <span class="keyword">struct </span>ipv6hdr *ipv6;
<a name="l07687"></a>07687     } hdr;
<a name="l07688"></a>07688     <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *th;
<a name="l07689"></a>07689     __be16 vlan_id;
<a name="l07690"></a>07690 
<a name="l07691"></a>07691     <span class="comment">/* if ring doesn&#39;t have a interrupt vector, cannot perform ATR */</span>
<a name="l07692"></a>07692     <span class="keywordflow">if</span> (!q_vector)
<a name="l07693"></a>07693         <span class="keywordflow">return</span>;
<a name="l07694"></a>07694 
<a name="l07695"></a>07695     <span class="comment">/* do nothing if sampling is disabled */</span>
<a name="l07696"></a>07696     <span class="keywordflow">if</span> (!ring-&gt;atr_sample_rate)
<a name="l07697"></a>07697         <span class="keywordflow">return</span>;
<a name="l07698"></a>07698 
<a name="l07699"></a>07699     ring-&gt;atr_count++;
<a name="l07700"></a>07700 
<a name="l07701"></a>07701     <span class="comment">/* snag network header to get L4 type and address */</span>
<a name="l07702"></a>07702     hdr.network = skb_network_header(skb);
<a name="l07703"></a>07703 
<a name="l07704"></a>07704     <span class="comment">/* Currently only IPv4/IPv6 with TCP is supported */</span>
<a name="l07705"></a>07705     <span class="keywordflow">if</span> ((protocol != __constant_htons(ETH_P_IPV6) ||
<a name="l07706"></a>07706          hdr.ipv6-&gt;nexthdr != IPPROTO_TCP) &amp;&amp;
<a name="l07707"></a>07707         (protocol != __constant_htons(ETH_P_IP) ||
<a name="l07708"></a>07708          hdr.ipv4-&gt;protocol != IPPROTO_TCP))
<a name="l07709"></a>07709         <span class="keywordflow">return</span>;
<a name="l07710"></a>07710 
<a name="l07711"></a>07711     th = tcp_hdr(skb);
<a name="l07712"></a>07712 
<a name="l07713"></a>07713     <span class="comment">/* skip this packet since the socket is closing */</span>
<a name="l07714"></a>07714     <span class="keywordflow">if</span> (th-&gt;fin)
<a name="l07715"></a>07715         <span class="keywordflow">return</span>;
<a name="l07716"></a>07716 
<a name="l07717"></a>07717     <span class="comment">/* sample on all syn packets or once every atr sample count */</span>
<a name="l07718"></a>07718     <span class="keywordflow">if</span> (!th-&gt;syn &amp;&amp; (ring-&gt;atr_count &lt; ring-&gt;atr_sample_rate))
<a name="l07719"></a>07719         <span class="keywordflow">return</span>;
<a name="l07720"></a>07720 
<a name="l07721"></a>07721     <span class="comment">/* reset sample count */</span>
<a name="l07722"></a>07722     ring-&gt;atr_count = 0;
<a name="l07723"></a>07723 
<a name="l07724"></a>07724     vlan_id = htons(tx_flags &gt;&gt; IXGBE_TX_FLAGS_VLAN_SHIFT);
<a name="l07725"></a>07725 
<a name="l07726"></a>07726     <span class="comment">/*</span>
<a name="l07727"></a>07727 <span class="comment">     * src and dst are inverted, think how the receiver sees them</span>
<a name="l07728"></a>07728 <span class="comment">     *</span>
<a name="l07729"></a>07729 <span class="comment">     * The input is broken into two sections, a non-compressed section</span>
<a name="l07730"></a>07730 <span class="comment">     * containing vm_pool, vlan_id, and flow_type.  The rest of the data</span>
<a name="l07731"></a>07731 <span class="comment">     * is XORed together and stored in the compressed dword.</span>
<a name="l07732"></a>07732 <span class="comment">     */</span>
<a name="l07733"></a>07733     input.formatted.vlan_id = vlan_id;
<a name="l07734"></a>07734 
<a name="l07735"></a>07735     <span class="comment">/*</span>
<a name="l07736"></a>07736 <span class="comment">     * since src port and flex bytes occupy the same word XOR them together</span>
<a name="l07737"></a>07737 <span class="comment">     * and write the value to source port portion of compressed dword</span>
<a name="l07738"></a>07738 <span class="comment">     */</span>
<a name="l07739"></a>07739     <span class="keywordflow">if</span> (vlan_id)
<a name="l07740"></a>07740         common.port.src ^= th-&gt;dest ^ __constant_htons(ETH_P_8021Q);
<a name="l07741"></a>07741     <span class="keywordflow">else</span>
<a name="l07742"></a>07742         common.port.src ^= th-&gt;dest ^ protocol;
<a name="l07743"></a>07743     common.port.dst ^= th-&gt;source;
<a name="l07744"></a>07744 
<a name="l07745"></a>07745     <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_IP)) {
<a name="l07746"></a>07746         input.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;
<a name="l07747"></a>07747         common.ip ^= hdr.ipv4-&gt;saddr ^ hdr.ipv4-&gt;daddr;
<a name="l07748"></a>07748     } <span class="keywordflow">else</span> {
<a name="l07749"></a>07749         input.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_TCPV6;
<a name="l07750"></a>07750         common.ip ^= hdr.ipv6-&gt;saddr.s6_addr32[0] ^
<a name="l07751"></a>07751                  hdr.ipv6-&gt;saddr.s6_addr32[1] ^
<a name="l07752"></a>07752                  hdr.ipv6-&gt;saddr.s6_addr32[2] ^
<a name="l07753"></a>07753                  hdr.ipv6-&gt;saddr.s6_addr32[3] ^
<a name="l07754"></a>07754                  hdr.ipv6-&gt;daddr.s6_addr32[0] ^
<a name="l07755"></a>07755                  hdr.ipv6-&gt;daddr.s6_addr32[1] ^
<a name="l07756"></a>07756                  hdr.ipv6-&gt;daddr.s6_addr32[2] ^
<a name="l07757"></a>07757                  hdr.ipv6-&gt;daddr.s6_addr32[3];
<a name="l07758"></a>07758     }
<a name="l07759"></a>07759 
<a name="l07760"></a>07760     <span class="comment">/* This assumes the Rx queue and Tx queue are bound to the same CPU */</span>
<a name="l07761"></a>07761     ixgbe_fdir_add_signature_filter_82599(&amp;q_vector-&gt;adapter-&gt;hw,
<a name="l07762"></a>07762                           input, common, ring-&gt;queue_index);
<a name="l07763"></a>07763 }
<a name="l07764"></a>07764 
<a name="l07765"></a>07765 <span class="keyword">static</span> <span class="keywordtype">int</span> __ixgbe_maybe_stop_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, u16 size)
<a name="l07766"></a>07766 {
<a name="l07767"></a>07767     netif_stop_subqueue(netdev_ring(tx_ring), ring_queue_index(tx_ring));
<a name="l07768"></a>07768     <span class="comment">/* Herbert&#39;s original patch had:</span>
<a name="l07769"></a>07769 <span class="comment">     *  smp_mb__after_netif_stop_queue();</span>
<a name="l07770"></a>07770 <span class="comment">     * but since that doesn&#39;t exist yet, just open code it. */</span>
<a name="l07771"></a>07771     smp_mb();
<a name="l07772"></a>07772 
<a name="l07773"></a>07773     <span class="comment">/* We need to check again in a case another CPU has just</span>
<a name="l07774"></a>07774 <span class="comment">     * made room available. */</span>
<a name="l07775"></a>07775     <span class="keywordflow">if</span> (likely(ixgbe_desc_unused(tx_ring) &lt; size))
<a name="l07776"></a>07776         <span class="keywordflow">return</span> -EBUSY;
<a name="l07777"></a>07777 
<a name="l07778"></a>07778     <span class="comment">/* A reprieve! - use start_queue because it doesn&#39;t call schedule */</span>
<a name="l07779"></a>07779     netif_start_subqueue(netdev_ring(tx_ring), ring_queue_index(tx_ring));
<a name="l07780"></a>07780     ++tx_ring-&gt;tx_stats.restart_queue;
<a name="l07781"></a>07781     <span class="keywordflow">return</span> 0;
<a name="l07782"></a>07782 }
<a name="l07783"></a>07783 
<a name="l07784"></a>07784 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ixgbe_maybe_stop_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, u16 size)
<a name="l07785"></a>07785 {
<a name="l07786"></a>07786     <span class="keywordflow">if</span> (likely(ixgbe_desc_unused(tx_ring) &gt;= size))
<a name="l07787"></a>07787         <span class="keywordflow">return</span> 0;
<a name="l07788"></a>07788     <span class="keywordflow">return</span> __ixgbe_maybe_stop_tx(tx_ring, size);
<a name="l07789"></a>07789 }
<a name="l07790"></a>07790 
<a name="l07791"></a>07791 netdev_tx_t ixgbe_xmit_frame_ring(<span class="keyword">struct</span> sk_buff *skb,
<a name="l07792"></a>07792               <span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l07793"></a>07793               <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l07794"></a>07794 {
<a name="l07795"></a>07795     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *first;
<a name="l07796"></a>07796     <span class="keywordtype">int</span> tso;
<a name="l07797"></a>07797     u32 tx_flags = 0;
<a name="l07798"></a>07798 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07799"></a>07799 <span class="preprocessor"></span><span class="preprocessor">#if PAGE_SIZE &gt; IXGBE_MAX_DATA_PER_TXD</span>
<a name="l07800"></a>07800 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> f;
<a name="l07801"></a>07801 <span class="preprocessor">#endif</span>
<a name="l07802"></a>07802 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l07803"></a>07803 <span class="preprocessor"></span>    u16 count = TXD_USE_COUNT(skb_headlen(skb));
<a name="l07804"></a>07804     __be16 protocol = skb-&gt;protocol;
<a name="l07805"></a>07805     u8 hdr_len = 0;
<a name="l07806"></a>07806 
<a name="l07807"></a>07807     <span class="comment">/*</span>
<a name="l07808"></a>07808 <span class="comment">     * need: 1 descriptor per page * PAGE_SIZE/IXGBE_MAX_DATA_PER_TXD,</span>
<a name="l07809"></a>07809 <span class="comment">     *       + 1 desc for skb_head_len/IXGBE_MAX_DATA_PER_TXD,</span>
<a name="l07810"></a>07810 <span class="comment">     *       + 2 desc gap to keep tail from touching head,</span>
<a name="l07811"></a>07811 <span class="comment">     *       + 1 desc for context descriptor,</span>
<a name="l07812"></a>07812 <span class="comment">     * otherwise try next time</span>
<a name="l07813"></a>07813 <span class="comment">     */</span>
<a name="l07814"></a>07814 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07815"></a>07815 <span class="preprocessor"></span><span class="preprocessor">#if PAGE_SIZE &gt; IXGBE_MAX_DATA_PER_TXD</span>
<a name="l07816"></a>07816 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (f = 0; f &lt; skb_shinfo(skb)-&gt;nr_frags; f++)
<a name="l07817"></a>07817         count += TXD_USE_COUNT(skb_shinfo(skb)-&gt;frags[f].size);
<a name="l07818"></a>07818 <span class="preprocessor">#else</span>
<a name="l07819"></a>07819 <span class="preprocessor"></span>    count += skb_shinfo(skb)-&gt;nr_frags;
<a name="l07820"></a>07820 <span class="preprocessor">#endif</span>
<a name="l07821"></a>07821 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l07822"></a>07822 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ixgbe_maybe_stop_tx(tx_ring, count + 3)) {
<a name="l07823"></a>07823         tx_ring-&gt;tx_stats.tx_busy++;
<a name="l07824"></a>07824         <span class="keywordflow">return</span> NETDEV_TX_BUSY;
<a name="l07825"></a>07825     }
<a name="l07826"></a>07826 
<a name="l07827"></a>07827 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l07828"></a>07828 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l07829"></a>07829 <span class="comment">     * Use the l2switch_enable flag - would be false if the DMA</span>
<a name="l07830"></a>07830 <span class="comment">     * Tx switch had been disabled.</span>
<a name="l07831"></a>07831 <span class="comment">     */</span>
<a name="l07832"></a>07832     <span class="keywordflow">if</span> (adapter-&gt;l2switch_enable)
<a name="l07833"></a>07833         tx_flags |= IXGBE_TX_FLAGS_TXSW;
<a name="l07834"></a>07834 
<a name="l07835"></a>07835 <span class="preprocessor">#endif</span>
<a name="l07836"></a>07836 <span class="preprocessor"></span>    <span class="comment">/* if we have a HW VLAN tag being added default to the HW one */</span>
<a name="l07837"></a>07837     <span class="keywordflow">if</span> (vlan_tx_tag_present(skb)) {
<a name="l07838"></a>07838         tx_flags |= vlan_tx_tag_get(skb) &lt;&lt; IXGBE_TX_FLAGS_VLAN_SHIFT;
<a name="l07839"></a>07839         tx_flags |= IXGBE_TX_FLAGS_HW_VLAN;
<a name="l07840"></a>07840     <span class="comment">/* else if it is a SW VLAN check the next protocol and store the tag */</span>
<a name="l07841"></a>07841     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_8021Q)) {
<a name="l07842"></a>07842         <span class="keyword">struct </span>vlan_hdr *vhdr, _vhdr;
<a name="l07843"></a>07843         vhdr = skb_header_pointer(skb, ETH_HLEN, <span class="keyword">sizeof</span>(_vhdr), &amp;_vhdr);
<a name="l07844"></a>07844         <span class="keywordflow">if</span> (!vhdr)
<a name="l07845"></a>07845             <span class="keywordflow">goto</span> out_drop;
<a name="l07846"></a>07846 
<a name="l07847"></a>07847         protocol = vhdr-&gt;h_vlan_encapsulated_proto;
<a name="l07848"></a>07848         tx_flags |= ntohs(vhdr-&gt;h_vlan_TCI) &lt;&lt; IXGBE_TX_FLAGS_VLAN_SHIFT;
<a name="l07849"></a>07849         tx_flags |= IXGBE_TX_FLAGS_SW_VLAN;
<a name="l07850"></a>07850     }
<a name="l07851"></a>07851 
<a name="l07852"></a>07852 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l07853"></a>07853 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) &amp;&amp;
<a name="l07854"></a>07854         skb-&gt;priority != TC_PRIO_CONTROL) {
<a name="l07855"></a>07855         tx_flags &amp;= ~IXGBE_TX_FLAGS_VLAN_PRIO_MASK;
<a name="l07856"></a>07856 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07857"></a>07857 <span class="preprocessor"></span>        <span class="comment">/* for FCoE with DCB, we force the priority to what</span>
<a name="l07858"></a>07858 <span class="comment">         * was specified by the switch */</span>
<a name="l07859"></a>07859         <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) &amp;&amp;
<a name="l07860"></a>07860             ((protocol == __constant_htons(ETH_P_FCOE)) ||
<a name="l07861"></a>07861              (protocol == __constant_htons(ETH_P_FIP))))
<a name="l07862"></a>07862             tx_flags |= adapter-&gt;fcoe.up &lt;&lt;
<a name="l07863"></a>07863                         IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT;
<a name="l07864"></a>07864         <span class="keywordflow">else</span>
<a name="l07865"></a>07865 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07866"></a>07866             tx_flags |= skb-&gt;queue_mapping &lt;&lt;
<a name="l07867"></a>07867                     IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT;
<a name="l07868"></a>07868         <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_SW_VLAN) {
<a name="l07869"></a>07869             <span class="keyword">struct </span>vlan_ethhdr *vhdr;
<a name="l07870"></a>07870             <span class="keywordflow">if</span> (skb_header_cloned(skb) &amp;&amp;
<a name="l07871"></a>07871                 pskb_expand_head(skb, 0, 0, GFP_ATOMIC))
<a name="l07872"></a>07872                 <span class="keywordflow">goto</span> out_drop;
<a name="l07873"></a>07873             vhdr = (<span class="keyword">struct </span>vlan_ethhdr *)skb-&gt;data;
<a name="l07874"></a>07874             vhdr-&gt;h_vlan_TCI = htons(tx_flags &gt;&gt;
<a name="l07875"></a>07875                          IXGBE_TX_FLAGS_VLAN_SHIFT);
<a name="l07876"></a>07876         } <span class="keywordflow">else</span> {
<a name="l07877"></a>07877             tx_flags |= IXGBE_TX_FLAGS_HW_VLAN;
<a name="l07878"></a>07878         }
<a name="l07879"></a>07879     }
<a name="l07880"></a>07880 
<a name="l07881"></a>07881 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l07882"></a>07882     <span class="comment">/* record the location of the first descriptor for this packet */</span>
<a name="l07883"></a>07883     first = &amp;tx_ring-&gt;tx_buffer_info[tx_ring-&gt;next_to_use];
<a name="l07884"></a>07884 
<a name="l07885"></a>07885 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07886"></a>07886 <span class="preprocessor"></span>    <span class="comment">/* setup tx offload for FCoE */</span>
<a name="l07887"></a>07887     <span class="keywordflow">if</span> ((protocol == __constant_htons(ETH_P_FCOE)) &amp;&amp;
<a name="l07888"></a>07888         (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED)) {
<a name="l07889"></a>07889         tso = ixgbe_fso(tx_ring, skb, tx_flags, &amp;hdr_len);
<a name="l07890"></a>07890         <span class="keywordflow">if</span> (tso &lt; 0)
<a name="l07891"></a>07891             <span class="keywordflow">goto</span> out_drop;
<a name="l07892"></a>07892         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tso)
<a name="l07893"></a>07893             tx_flags |= IXGBE_TX_FLAGS_FSO |
<a name="l07894"></a>07894                     IXGBE_TX_FLAGS_FCOE;
<a name="l07895"></a>07895         <span class="keywordflow">else</span>
<a name="l07896"></a>07896             tx_flags |= IXGBE_TX_FLAGS_FCOE;
<a name="l07897"></a>07897 
<a name="l07898"></a>07898         <span class="keywordflow">goto</span> xmit_fcoe;
<a name="l07899"></a>07899     }
<a name="l07900"></a>07900 
<a name="l07901"></a>07901 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07902"></a>07902     <span class="comment">/* setup IPv4/IPv6 offloads */</span>
<a name="l07903"></a>07903     <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_IP))
<a name="l07904"></a>07904         tx_flags |= IXGBE_TX_FLAGS_IPV4;
<a name="l07905"></a>07905 
<a name="l07906"></a>07906     tso = ixgbe_tso(tx_ring, skb, tx_flags, protocol, &amp;hdr_len);
<a name="l07907"></a>07907     <span class="keywordflow">if</span> (tso &lt; 0)
<a name="l07908"></a>07908         <span class="keywordflow">goto</span> out_drop;
<a name="l07909"></a>07909     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tso)
<a name="l07910"></a>07910         tx_flags |= IXGBE_TX_FLAGS_TSO;
<a name="l07911"></a>07911     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ixgbe_tx_csum(tx_ring, skb, tx_flags, protocol))
<a name="l07912"></a>07912         tx_flags |= IXGBE_TX_FLAGS_CSUM;
<a name="l07913"></a>07913 
<a name="l07914"></a>07914     <span class="comment">/* add the ATR filter if ATR is on */</span>
<a name="l07915"></a>07915     <span class="keywordflow">if</span> (test_bit(__IXGBE_TX_FDIR_INIT_DONE, &amp;tx_ring-&gt;state))
<a name="l07916"></a>07916         ixgbe_atr(tx_ring, skb, tx_flags, protocol);
<a name="l07917"></a>07917 
<a name="l07918"></a>07918 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07919"></a>07919 <span class="preprocessor"></span>xmit_fcoe:
<a name="l07920"></a>07920 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07921"></a>07921 
<a name="l07922"></a>07922     ixgbe_tx_map(tx_ring, skb, first, tx_flags, hdr_len);
<a name="l07923"></a>07923 
<a name="l07924"></a>07924 <span class="preprocessor">#ifndef HAVE_TRANS_START_IN_QUEUE</span>
<a name="l07925"></a>07925 <span class="preprocessor"></span>    netdev_ring(tx_ring)-&gt;trans_start = jiffies;
<a name="l07926"></a>07926 <span class="preprocessor">#endif</span>
<a name="l07927"></a>07927 <span class="preprocessor"></span>
<a name="l07928"></a>07928     ixgbe_maybe_stop_tx(tx_ring, DESC_NEEDED);
<a name="l07929"></a>07929 
<a name="l07930"></a>07930     <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l07931"></a>07931 
<a name="l07932"></a>07932 out_drop:
<a name="l07933"></a>07933     dev_kfree_skb_any(skb);
<a name="l07934"></a>07934     <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l07935"></a>07935 }
<a name="l07936"></a>07936 
<a name="l07937"></a>07937 <span class="keyword">static</span> netdev_tx_t ixgbe_xmit_frame(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *netdev)
<a name="l07938"></a>07938 {
<a name="l07939"></a>07939     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07940"></a>07940     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring;
<a name="l07941"></a>07941 
<a name="l07942"></a>07942 <span class="preprocessor">#ifdef ENABLE_DNA</span>
<a name="l07943"></a>07943 <span class="preprocessor"></span>    <span class="comment">/* We don&#39;t allow legacy send when in DNA */</span>
<a name="l07944"></a>07944     <span class="keywordflow">return</span>(NETDEV_TX_BUSY);
<a name="l07945"></a>07945 <span class="preprocessor">#endif</span>
<a name="l07946"></a>07946 <span class="preprocessor"></span>
<a name="l07947"></a>07947 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l07948"></a>07948 <span class="preprocessor"></span>    tx_ring = adapter-&gt;tx_ring[skb-&gt;queue_mapping];
<a name="l07949"></a>07949 <span class="preprocessor">#else</span>
<a name="l07950"></a>07950 <span class="preprocessor"></span>    tx_ring = adapter-&gt;tx_ring[0];
<a name="l07951"></a>07951 <span class="preprocessor">#endif</span>
<a name="l07952"></a>07952 <span class="preprocessor"></span>    <span class="keywordflow">return</span> ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
<a name="l07953"></a>07953 }
<a name="l07954"></a>07954 
<a name="l07962"></a>07962 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_mac(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">void</span> *p)
<a name="l07963"></a>07963 {
<a name="l07964"></a>07964     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07965"></a>07965     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07966"></a>07966     <span class="keyword">struct </span>sockaddr *addr = p;
<a name="l07967"></a>07967 
<a name="l07968"></a>07968     <span class="keywordflow">if</span> (!is_valid_ether_addr(addr-&gt;sa_data))
<a name="l07969"></a>07969         <span class="keywordflow">return</span> -EADDRNOTAVAIL;
<a name="l07970"></a>07970 
<a name="l07971"></a>07971     memcpy(netdev-&gt;dev_addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l07972"></a>07972     memcpy(hw-&gt;mac.addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l07973"></a>07973 
<a name="l07974"></a>07974     <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_rar)
<a name="l07975"></a>07975         hw-&gt;mac.ops.set_rar(hw, 0, hw-&gt;mac.addr,
<a name="l07976"></a>07976                     adapter-&gt;num_vfs, IXGBE_RAH_AV);
<a name="l07977"></a>07977 
<a name="l07978"></a>07978     <span class="keywordflow">return</span> 0;
<a name="l07979"></a>07979 }
<a name="l07980"></a>07980 
<a name="l07981"></a>07981 <span class="preprocessor">#if defined(HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN)</span>
<a name="l07982"></a>07982 <span class="preprocessor"></span>
<a name="l07989"></a>07989 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_add_sanmac_netdev(<span class="keyword">struct</span> net_device *dev)
<a name="l07990"></a>07990 {
<a name="l07991"></a>07991     <span class="keywordtype">int</span> err = 0;
<a name="l07992"></a>07992     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l07993"></a>07993     <span class="keyword">struct </span><a class="code" href="structixgbe__mac__info.html">ixgbe_mac_info</a> *mac = &amp;adapter-&gt;hw.mac;
<a name="l07994"></a>07994 
<a name="l07995"></a>07995     <span class="keywordflow">if</span> (is_valid_ether_addr(mac-&gt;san_addr)) {
<a name="l07996"></a>07996         rtnl_lock();
<a name="l07997"></a>07997         err = dev_addr_add(dev, mac-&gt;san_addr, NETDEV_HW_ADDR_T_SAN);
<a name="l07998"></a>07998         rtnl_unlock();
<a name="l07999"></a>07999     }
<a name="l08000"></a>08000     <span class="keywordflow">return</span> err;
<a name="l08001"></a>08001 }
<a name="l08002"></a>08002 
<a name="l08010"></a>08010 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_del_sanmac_netdev(<span class="keyword">struct</span> net_device *dev)
<a name="l08011"></a>08011 {
<a name="l08012"></a>08012     <span class="keywordtype">int</span> err = 0;
<a name="l08013"></a>08013     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l08014"></a>08014     <span class="keyword">struct </span><a class="code" href="structixgbe__mac__info.html">ixgbe_mac_info</a> *mac = &amp;adapter-&gt;hw.mac;
<a name="l08015"></a>08015 
<a name="l08016"></a>08016     <span class="keywordflow">if</span> (is_valid_ether_addr(mac-&gt;san_addr)) {
<a name="l08017"></a>08017         rtnl_lock();
<a name="l08018"></a>08018         err = dev_addr_del(dev, mac-&gt;san_addr, NETDEV_HW_ADDR_T_SAN);
<a name="l08019"></a>08019         rtnl_unlock();
<a name="l08020"></a>08020     }
<a name="l08021"></a>08021     <span class="keywordflow">return</span> err;
<a name="l08022"></a>08022 }
<a name="l08023"></a>08023 
<a name="l08024"></a>08024 <span class="preprocessor">#endif </span><span class="comment">/* (HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN) */</span>
<a name="l08025"></a>08025 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l08026"></a>08026 <span class="preprocessor"></span>
<a name="l08032"></a>08032 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_ioctl(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *ifr, <span class="keywordtype">int</span> cmd)
<a name="l08033"></a>08033 {
<a name="l08034"></a>08034     <span class="keywordflow">switch</span> (cmd) {
<a name="l08035"></a>08035     <span class="keywordflow">case</span> SIOCETHTOOL:
<a name="l08036"></a>08036         <span class="keywordflow">return</span> ethtool_ioctl(ifr);
<a name="l08037"></a>08037     <span class="keywordflow">default</span>:
<a name="l08038"></a>08038         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l08039"></a>08039     }
<a name="l08040"></a>08040 }
<a name="l08041"></a>08041 
<a name="l08042"></a>08042 <span class="preprocessor">#endif</span>
<a name="l08043"></a>08043 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l08044"></a>08044 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l08045"></a>08045 <span class="comment"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<a name="l08046"></a>08046 <span class="comment"> * without having to re-enable interrupts. It&#39;s not called while</span>
<a name="l08047"></a>08047 <span class="comment"> * the interrupt routine is executing.</span>
<a name="l08048"></a>08048 <span class="comment"> */</span>
<a name="l08049"></a>08049 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_netpoll(<span class="keyword">struct</span> net_device *netdev)
<a name="l08050"></a>08050 {
<a name="l08051"></a>08051     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l08052"></a>08052     <span class="keywordtype">int</span> i;
<a name="l08053"></a>08053 
<a name="l08054"></a>08054     <span class="comment">/* if interface is down do nothing */</span>
<a name="l08055"></a>08055     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l08056"></a>08056         <span class="keywordflow">return</span>;
<a name="l08057"></a>08057 
<a name="l08058"></a>08058 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l08059"></a>08059 <span class="preprocessor"></span>    ixgbe_irq_disable(adapter);
<a name="l08060"></a>08060 <span class="preprocessor">#endif</span>
<a name="l08061"></a>08061 <span class="preprocessor"></span>    adapter-&gt;flags |= IXGBE_FLAG_IN_NETPOLL;
<a name="l08062"></a>08062     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l08063"></a>08063         <span class="keywordtype">int</span> num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l08064"></a>08064         <span class="keywordflow">for</span> (i = 0; i &lt; num_q_vectors; i++) {
<a name="l08065"></a>08065             <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[i];
<a name="l08066"></a>08066             ixgbe_msix_clean_rings(0, q_vector);
<a name="l08067"></a>08067         }
<a name="l08068"></a>08068     } <span class="keywordflow">else</span> {
<a name="l08069"></a>08069         ixgbe_intr(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l08070"></a>08070     }
<a name="l08071"></a>08071     adapter-&gt;flags &amp;= ~IXGBE_FLAG_IN_NETPOLL;
<a name="l08072"></a>08072 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l08073"></a>08073 <span class="preprocessor"></span>    ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l08074"></a>08074 <span class="preprocessor">#endif</span>
<a name="l08075"></a>08075 <span class="preprocessor"></span>}
<a name="l08076"></a>08076 
<a name="l08077"></a>08077 <span class="preprocessor">#endif</span>
<a name="l08078"></a>08078 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NETDEV_SELECT_QUEUE</span>
<a name="l08079"></a>08079 <span class="preprocessor"></span><span class="keyword">static</span> u16 ixgbe_select_queue(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> sk_buff *skb)
<a name="l08080"></a>08080 {
<a name="l08081"></a>08081     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l08082"></a>08082     <span class="keywordtype">int</span> txq = smp_processor_id();
<a name="l08083"></a>08083 
<a name="l08084"></a>08084 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08085"></a>08085 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((skb-&gt;protocol == __constant_htons(ETH_P_FCOE)) ||
<a name="l08086"></a>08086         (skb-&gt;protocol == __constant_htons(ETH_P_FIP))) {
<a name="l08087"></a>08087         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) {
<a name="l08088"></a>08088             txq &amp;= (adapter-&gt;ring_feature[RING_F_FCOE].indices - 1);
<a name="l08089"></a>08089             txq += adapter-&gt;ring_feature[RING_F_FCOE].mask;
<a name="l08090"></a>08090             <span class="keywordflow">return</span> txq;
<a name="l08091"></a>08091         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l08092"></a>08092             txq = adapter-&gt;fcoe.up;
<a name="l08093"></a>08093             <span class="keywordflow">return</span> txq;
<a name="l08094"></a>08094         }
<a name="l08095"></a>08095     }
<a name="l08096"></a>08096 
<a name="l08097"></a>08097 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l08098"></a>08098     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) {
<a name="l08099"></a>08099         <span class="keywordflow">while</span> (unlikely(txq &gt;= dev-&gt;real_num_tx_queues))
<a name="l08100"></a>08100             txq -= dev-&gt;real_num_tx_queues;
<a name="l08101"></a>08101         <span class="keywordflow">return</span> txq;
<a name="l08102"></a>08102     }
<a name="l08103"></a>08103 
<a name="l08104"></a>08104     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l08105"></a>08105         <span class="keywordflow">if</span> (skb-&gt;priority == TC_PRIO_CONTROL)
<a name="l08106"></a>08106             txq = adapter-&gt;ring_feature[RING_F_DCB].indices - 1;
<a name="l08107"></a>08107         <span class="keywordflow">else</span>
<a name="l08108"></a>08108             txq = (skb-&gt;vlan_tci &amp; IXGBE_TX_FLAGS_VLAN_PRIO_MASK)
<a name="l08109"></a>08109                    &gt;&gt; 13;
<a name="l08110"></a>08110         <span class="keywordflow">return</span> txq;
<a name="l08111"></a>08111     }
<a name="l08112"></a>08112     <span class="keywordflow">return</span> skb_tx_hash(dev, skb);
<a name="l08113"></a>08113 }
<a name="l08114"></a>08114 
<a name="l08115"></a>08115 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_SELECT_QUEUE */</span>
<a name="l08116"></a>08116 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l08117"></a>08117 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>net_device_ops ixgbe_netdev_ops = {
<a name="l08118"></a>08118     .ndo_open       = &amp;ixgbe_open,
<a name="l08119"></a>08119     .ndo_stop       = &amp;ixgbe_close,
<a name="l08120"></a>08120     .ndo_start_xmit     = &amp;ixgbe_xmit_frame,
<a name="l08121"></a>08121     .ndo_get_stats      = &amp;ixgbe_get_stats,
<a name="l08122"></a>08122     .ndo_set_rx_mode    = &amp;ixgbe_set_rx_mode,
<a name="l08123"></a>08123     .ndo_set_multicast_list = &amp;ixgbe_set_rx_mode,
<a name="l08124"></a>08124     .ndo_validate_addr  = eth_validate_addr,
<a name="l08125"></a>08125     .ndo_set_mac_address    = &amp;ixgbe_set_mac,
<a name="l08126"></a>08126     .ndo_change_mtu     = &amp;ixgbe_change_mtu,
<a name="l08127"></a>08127 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l08128"></a>08128 <span class="preprocessor"></span>    .ndo_do_ioctl       = &amp;ixgbe_ioctl,
<a name="l08129"></a>08129 <span class="preprocessor">#endif</span>
<a name="l08130"></a>08130 <span class="preprocessor"></span>    .ndo_tx_timeout     = &amp;ixgbe_tx_timeout,
<a name="l08131"></a>08131 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l08132"></a>08132 <span class="preprocessor"></span>    .ndo_vlan_rx_register   = &amp;ixgbe_vlan_rx_register,
<a name="l08133"></a>08133     .ndo_vlan_rx_add_vid    = &amp;ixgbe_vlan_rx_add_vid,
<a name="l08134"></a>08134     .ndo_vlan_rx_kill_vid   = &amp;ixgbe_vlan_rx_kill_vid,
<a name="l08135"></a>08135 <span class="preprocessor">#endif</span>
<a name="l08136"></a>08136 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_IPLINK_VF_CONFIG</span>
<a name="l08137"></a>08137 <span class="preprocessor"></span>    .ndo_set_vf_mac     = ixgbe_ndo_set_vf_mac,
<a name="l08138"></a>08138     .ndo_set_vf_vlan    = ixgbe_ndo_set_vf_vlan,
<a name="l08139"></a>08139     .ndo_set_vf_tx_rate = ixgbe_ndo_set_vf_bw,
<a name="l08140"></a>08140     .ndo_get_vf_config  = ixgbe_ndo_get_vf_config,
<a name="l08141"></a>08141 <span class="preprocessor">#endif</span>
<a name="l08142"></a>08142 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l08143"></a>08143 <span class="preprocessor"></span>    .ndo_poll_controller    = &amp;ixgbe_netpoll,
<a name="l08144"></a>08144 <span class="preprocessor">#endif</span>
<a name="l08145"></a>08145 <span class="preprocessor"></span>    .ndo_select_queue   = &amp;ixgbe_select_queue,
<a name="l08146"></a>08146 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08147"></a>08147 <span class="preprocessor"></span>    .ndo_fcoe_ddp_setup = ixgbe_fcoe_ddp_get,
<a name="l08148"></a>08148 <span class="preprocessor">#ifdef HAVE_NETDEV_OPS_FCOE_DDP_TARGET</span>
<a name="l08149"></a>08149 <span class="preprocessor"></span>    .ndo_fcoe_ddp_target = ixgbe_fcoe_ddp_target,
<a name="l08150"></a>08150 <span class="preprocessor">#endif</span>
<a name="l08151"></a>08151 <span class="preprocessor"></span>    .ndo_fcoe_ddp_done = ixgbe_fcoe_ddp_put,
<a name="l08152"></a>08152 <span class="preprocessor">#ifdef HAVE_NETDEV_OPS_FCOE_ENABLE</span>
<a name="l08153"></a>08153 <span class="preprocessor"></span>    .ndo_fcoe_enable = ixgbe_fcoe_enable,
<a name="l08154"></a>08154     .ndo_fcoe_disable = ixgbe_fcoe_disable,
<a name="l08155"></a>08155 <span class="preprocessor">#endif</span>
<a name="l08156"></a>08156 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NETDEV_OPS_FCOE_GETWWN</span>
<a name="l08157"></a>08157 <span class="preprocessor"></span>    .ndo_fcoe_get_wwn = ixgbe_fcoe_get_wwn,
<a name="l08158"></a>08158 <span class="preprocessor">#endif</span>
<a name="l08159"></a>08159 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l08160"></a>08160 };
<a name="l08161"></a>08161 
<a name="l08162"></a>08162 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l08163"></a>08163 
<a name="l08164"></a>08164 
<a name="l08165"></a>08165 
<a name="l08166"></a>08166 <span class="keywordtype">void</span> ixgbe_assign_netdev_ops(<span class="keyword">struct</span> net_device *dev)
<a name="l08167"></a>08167 {
<a name="l08168"></a>08168 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l08169"></a>08169 <span class="preprocessor"></span>    dev-&gt;netdev_ops = &amp;ixgbe_netdev_ops;
<a name="l08170"></a>08170 <span class="preprocessor">#else </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l08171"></a>08171     dev-&gt;open = &amp;ixgbe_open;
<a name="l08172"></a>08172     dev-&gt;stop = &amp;ixgbe_close;
<a name="l08173"></a>08173     dev-&gt;hard_start_xmit = &amp;ixgbe_xmit_frame;
<a name="l08174"></a>08174     dev-&gt;get_stats = &amp;ixgbe_get_stats;
<a name="l08175"></a>08175 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l08176"></a>08176 <span class="preprocessor"></span>    dev-&gt;set_rx_mode = &amp;ixgbe_set_rx_mode;
<a name="l08177"></a>08177 <span class="preprocessor">#endif</span>
<a name="l08178"></a>08178 <span class="preprocessor"></span>    dev-&gt;set_multicast_list = &amp;ixgbe_set_rx_mode;
<a name="l08179"></a>08179     dev-&gt;set_mac_address = &amp;ixgbe_set_mac;
<a name="l08180"></a>08180     dev-&gt;change_mtu = &amp;ixgbe_change_mtu;
<a name="l08181"></a>08181 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l08182"></a>08182 <span class="preprocessor"></span>    dev-&gt;do_ioctl = &amp;ixgbe_ioctl;
<a name="l08183"></a>08183 <span class="preprocessor">#endif</span>
<a name="l08184"></a>08184 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_TX_TIMEOUT</span>
<a name="l08185"></a>08185 <span class="preprocessor"></span>    dev-&gt;tx_timeout = &amp;ixgbe_tx_timeout;
<a name="l08186"></a>08186 <span class="preprocessor">#endif</span>
<a name="l08187"></a>08187 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l08188"></a>08188 <span class="preprocessor"></span>    dev-&gt;vlan_rx_register = &amp;ixgbe_vlan_rx_register;
<a name="l08189"></a>08189     dev-&gt;vlan_rx_add_vid = &amp;ixgbe_vlan_rx_add_vid;
<a name="l08190"></a>08190     dev-&gt;vlan_rx_kill_vid = &amp;ixgbe_vlan_rx_kill_vid;
<a name="l08191"></a>08191 <span class="preprocessor">#endif</span>
<a name="l08192"></a>08192 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l08193"></a>08193 <span class="preprocessor"></span>    dev-&gt;poll_controller = &amp;ixgbe_netpoll;
<a name="l08194"></a>08194 <span class="preprocessor">#endif</span>
<a name="l08195"></a>08195 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NETDEV_SELECT_QUEUE</span>
<a name="l08196"></a>08196 <span class="preprocessor"></span>    dev-&gt;select_queue = &amp;ixgbe_select_queue;
<a name="l08197"></a>08197 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_SELECT_QUEUE */</span>
<a name="l08198"></a>08198 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l08199"></a>08199     ixgbe_set_ethtool_ops(dev);
<a name="l08200"></a>08200     dev-&gt;watchdog_timeo = 5 * HZ;
<a name="l08201"></a>08201 }
<a name="l08202"></a>08202 
<a name="l08203"></a>08203 <span class="keyword">static</span> <span class="keywordtype">void</span> __devinit ixgbe_probe_vf(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l08204"></a>08204 {
<a name="l08205"></a>08205 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l08206"></a>08206 <span class="preprocessor"></span>    <span class="keywordtype">int</span> err;
<a name="l08207"></a>08207 
<a name="l08208"></a>08208     err = pci_enable_sriov(adapter-&gt;pdev, adapter-&gt;num_vfs);
<a name="l08209"></a>08209     <span class="keywordflow">if</span> (err) {
<a name="l08210"></a>08210         e_err(probe, <span class="stringliteral">&quot;Failed to enable PCI sriov: %d\n&quot;</span>, err);
<a name="l08211"></a>08211         <span class="keywordflow">goto</span> err_novfs;
<a name="l08212"></a>08212     }
<a name="l08213"></a>08213     <span class="comment">/* If call to enable VFs succeeded then allocate memory</span>
<a name="l08214"></a>08214 <span class="comment">     * for per VF control structures.</span>
<a name="l08215"></a>08215 <span class="comment">     */</span>
<a name="l08216"></a>08216     adapter-&gt;vfinfo =
<a name="l08217"></a>08217         kcalloc(adapter-&gt;num_vfs,
<a name="l08218"></a>08218             <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvf__data__storage.html">vf_data_storage</a>), GFP_KERNEL);
<a name="l08219"></a>08219     <span class="keywordflow">if</span> (adapter-&gt;vfinfo) {
<a name="l08220"></a>08220         adapter-&gt;l2switch_enable = <span class="keyword">true</span>;
<a name="l08221"></a>08221         adapter-&gt;repl_enable = <span class="keyword">true</span>;
<a name="l08222"></a>08222 
<a name="l08223"></a>08223         <span class="comment">/* RSS not compatible with SR-IOV operation */</span>
<a name="l08224"></a>08224         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l08225"></a>08225 
<a name="l08226"></a>08226         <span class="comment">/* Disable RSC when in SR-IOV mode */</span>
<a name="l08227"></a>08227         adapter-&gt;flags2 &amp;= ~(IXGBE_FLAG2_RSC_CAPABLE |
<a name="l08228"></a>08228                      IXGBE_FLAG2_RSC_ENABLED);
<a name="l08229"></a>08229 
<a name="l08230"></a>08230 
<a name="l08231"></a>08231         <span class="keywordflow">return</span>;
<a name="l08232"></a>08232     }
<a name="l08233"></a>08233 
<a name="l08234"></a>08234     <span class="comment">/* Oh oh */</span>
<a name="l08235"></a>08235     e_err(probe, <span class="stringliteral">&quot;Unable to allocate memory for VF Data Storage - &quot;</span>
<a name="l08236"></a>08236           <span class="stringliteral">&quot;SRIOV disabled\n&quot;</span>);
<a name="l08237"></a>08237     pci_disable_sriov(adapter-&gt;pdev);
<a name="l08238"></a>08238 
<a name="l08239"></a>08239 err_novfs:
<a name="l08240"></a>08240     adapter-&gt;flags &amp;= ~IXGBE_FLAG_SRIOV_ENABLED;
<a name="l08241"></a>08241     adapter-&gt;num_vfs = 0;
<a name="l08242"></a>08242 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PCI_IOV */</span>
<a name="l08243"></a>08243 }
<a name="l08244"></a>08244 
<a name="l08256"></a>08256 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit ixgbe_probe(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l08257"></a>08257                  <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *ent)
<a name="l08258"></a>08258 {
<a name="l08259"></a>08259     <span class="keyword">struct </span>net_device *netdev;
<a name="l08260"></a>08260     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = NULL;
<a name="l08261"></a>08261     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = NULL;
<a name="l08262"></a>08262     <span class="keyword">static</span> <span class="keywordtype">int</span> cards_found;
<a name="l08263"></a>08263     <span class="keywordtype">int</span> i, err, pci_using_dac;
<a name="l08264"></a>08264     <span class="keywordtype">char</span> *info_string, *i_s_var;
<a name="l08265"></a>08265 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l08266"></a>08266 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices;
<a name="l08267"></a>08267 <span class="preprocessor">#endif</span>
<a name="l08268"></a>08268 <span class="preprocessor"></span>    u8 part_str[IXGBE_PBANUM_LENGTH];
<a name="l08269"></a>08269     <span class="keyword">enum</span> ixgbe_mac_type mac_type = ixgbe_mac_unknown;
<a name="l08270"></a>08270 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08271"></a>08271 <span class="preprocessor"></span>    u16 device_caps;
<a name="l08272"></a>08272 <span class="preprocessor">#endif</span>
<a name="l08273"></a>08273 <span class="preprocessor"></span>
<a name="l08274"></a>08274     err = pci_enable_device_mem(pdev);
<a name="l08275"></a>08275     <span class="keywordflow">if</span> (err)
<a name="l08276"></a>08276         <span class="keywordflow">return</span> err;
<a name="l08277"></a>08277 
<a name="l08278"></a>08278     <span class="keywordflow">if</span> (!dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64)) &amp;&amp;
<a name="l08279"></a>08279         !dma_set_coherent_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64))) {
<a name="l08280"></a>08280         pci_using_dac = 1;
<a name="l08281"></a>08281     } <span class="keywordflow">else</span> {
<a name="l08282"></a>08282         err = dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(32));
<a name="l08283"></a>08283         <span class="keywordflow">if</span> (err) {
<a name="l08284"></a>08284             err = dma_set_coherent_mask(pci_dev_to_dev(pdev),
<a name="l08285"></a>08285                                               DMA_BIT_MASK(32));
<a name="l08286"></a>08286             <span class="keywordflow">if</span> (err) {
<a name="l08287"></a>08287                 dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;No usable DMA &quot;</span>
<a name="l08288"></a>08288                         <span class="stringliteral">&quot;configuration, aborting\n&quot;</span>);
<a name="l08289"></a>08289                 <span class="keywordflow">goto</span> err_dma;
<a name="l08290"></a>08290             }
<a name="l08291"></a>08291         }
<a name="l08292"></a>08292         pci_using_dac = 0;
<a name="l08293"></a>08293     }
<a name="l08294"></a>08294 
<a name="l08295"></a>08295     err = pci_request_selected_regions(pdev, pci_select_bars(pdev,
<a name="l08296"></a>08296                        IORESOURCE_MEM), ixgbe_driver_name);
<a name="l08297"></a>08297     <span class="keywordflow">if</span> (err) {
<a name="l08298"></a>08298         dev_err(pci_dev_to_dev(pdev),
<a name="l08299"></a>08299             <span class="stringliteral">&quot;pci_request_selected_regions failed 0x%x\n&quot;</span>, err);
<a name="l08300"></a>08300         <span class="keywordflow">goto</span> err_pci_reg;
<a name="l08301"></a>08301     }
<a name="l08302"></a>08302 
<a name="l08303"></a>08303     <span class="comment">/*</span>
<a name="l08304"></a>08304 <span class="comment">     * The mac_type is needed before we have the adapter is  set up</span>
<a name="l08305"></a>08305 <span class="comment">     * so rather than maintain two devID -&gt; MAC tables we dummy up</span>
<a name="l08306"></a>08306 <span class="comment">     * an ixgbe_hw stuct and use ixgbe_set_mac_type.</span>
<a name="l08307"></a>08307 <span class="comment">     */</span>
<a name="l08308"></a>08308     hw = vmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a>));
<a name="l08309"></a>08309     <span class="keywordflow">if</span> (!hw) {
<a name="l08310"></a>08310         printk(KERN_INFO <span class="stringliteral">&quot;Unable to allocate memory for early mac &quot;</span>
<a name="l08311"></a>08311             <span class="stringliteral">&quot;check\n&quot;</span>);
<a name="l08312"></a>08312     } <span class="keywordflow">else</span> {
<a name="l08313"></a>08313         hw-&gt;vendor_id = pdev-&gt;vendor;
<a name="l08314"></a>08314         hw-&gt;device_id = pdev-&gt;device;
<a name="l08315"></a>08315         ixgbe_set_mac_type(hw);
<a name="l08316"></a>08316         mac_type = hw-&gt;mac.type;
<a name="l08317"></a>08317         vfree(hw);
<a name="l08318"></a>08318     }
<a name="l08319"></a>08319 
<a name="l08320"></a>08320     <span class="comment">/*</span>
<a name="l08321"></a>08321 <span class="comment">     * Workaround of Silicon errata on 82598. Disable LOs in the PCI switch</span>
<a name="l08322"></a>08322 <span class="comment">     * port to which the 82598 is connected to prevent duplicate</span>
<a name="l08323"></a>08323 <span class="comment">     * completions caused by LOs.  We need the mac type so that we only</span>
<a name="l08324"></a>08324 <span class="comment">     * do this on 82598 devices, ixgbe_set_mac_type does this for us if</span>
<a name="l08325"></a>08325 <span class="comment">     * we set it&#39;s device ID.</span>
<a name="l08326"></a>08326 <span class="comment">     */</span>
<a name="l08327"></a>08327     <span class="keywordflow">if</span> (mac_type == ixgbe_mac_82598EB)
<a name="l08328"></a>08328         pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S);
<a name="l08329"></a>08329 
<a name="l08330"></a>08330     pci_enable_pcie_error_reporting(pdev);
<a name="l08331"></a>08331 
<a name="l08332"></a>08332     pci_set_master(pdev);
<a name="l08333"></a>08333 
<a name="l08334"></a>08334 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l08335"></a>08335 <span class="preprocessor"></span>    indices = num_possible_cpus();
<a name="l08336"></a>08336     <span class="keywordflow">if</span> (mac_type == ixgbe_mac_unknown)
<a name="l08337"></a>08337         indices = max_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, IXGBE_MAX_RSS_INDICES,
<a name="l08338"></a>08338                 IXGBE_MAX_FDIR_INDICES);
<a name="l08339"></a>08339     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mac_type == ixgbe_mac_82598EB)
<a name="l08340"></a>08340         indices = min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, indices, IXGBE_MAX_RSS_INDICES);
<a name="l08341"></a>08341     <span class="keywordflow">else</span>
<a name="l08342"></a>08342         indices = min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, indices, IXGBE_MAX_FDIR_INDICES);
<a name="l08343"></a>08343     indices = max_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, indices, IXGBE_MAX_DCB_INDICES);
<a name="l08344"></a>08344 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08345"></a>08345 <span class="preprocessor"></span>    indices += min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, num_possible_cpus(),
<a name="l08346"></a>08346               IXGBE_MAX_FCOE_INDICES);
<a name="l08347"></a>08347 <span class="preprocessor">#endif</span>
<a name="l08348"></a>08348 <span class="preprocessor"></span>    netdev = alloc_etherdev_mq(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>), indices);
<a name="l08349"></a>08349 <span class="preprocessor">#else</span>
<a name="l08350"></a>08350 <span class="preprocessor"></span>    netdev = alloc_etherdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>));
<a name="l08351"></a>08351 <span class="preprocessor">#endif</span>
<a name="l08352"></a>08352 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!netdev) {
<a name="l08353"></a>08353         err = -ENOMEM;
<a name="l08354"></a>08354         <span class="keywordflow">goto</span> err_alloc_etherdev;
<a name="l08355"></a>08355     }
<a name="l08356"></a>08356 
<a name="l08357"></a>08357     SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);
<a name="l08358"></a>08358 
<a name="l08359"></a>08359     adapter = netdev_priv(netdev);
<a name="l08360"></a>08360     pci_set_drvdata(pdev, adapter);
<a name="l08361"></a>08361 
<a name="l08362"></a>08362     adapter-&gt;netdev = netdev;
<a name="l08363"></a>08363     adapter-&gt;pdev = pdev;
<a name="l08364"></a>08364     hw = &amp;adapter-&gt;hw;
<a name="l08365"></a>08365     hw-&gt;back = adapter;
<a name="l08366"></a>08366     adapter-&gt;msg_enable = (1 &lt;&lt; DEFAULT_DEBUG_LEVEL_SHIFT) - 1;
<a name="l08367"></a>08367 
<a name="l08368"></a>08368 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l08369"></a>08369 <span class="preprocessor"></span>    e_info(tx_err, <span class="stringliteral">&quot;my (original) node was: %d\n&quot;</span>, dev_to_node(&amp;pdev-&gt;dev));
<a name="l08370"></a>08370 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l08371"></a>08371 
<a name="l08372"></a>08372 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l08373"></a>08373 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l08374"></a>08374 <span class="comment">     * call save state here in standalone driver because it relies on</span>
<a name="l08375"></a>08375 <span class="comment">     * adapter struct to exist, and needs to call netdev_priv</span>
<a name="l08376"></a>08376 <span class="comment">     */</span>
<a name="l08377"></a>08377     pci_save_state(pdev);
<a name="l08378"></a>08378 
<a name="l08379"></a>08379 <span class="preprocessor">#endif</span>
<a name="l08380"></a>08380 <span class="preprocessor"></span><span class="preprocessor">#ifndef ENABLE_DNA</span>
<a name="l08381"></a>08381 <span class="preprocessor"></span>    hw-&gt;hw_addr = ioremap(pci_resource_start(pdev, 0),
<a name="l08382"></a>08382                   pci_resource_len(pdev, 0));
<a name="l08383"></a>08383 <span class="preprocessor">#else</span>
<a name="l08384"></a>08384 <span class="preprocessor"></span>    {
<a name="l08385"></a>08385       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mmio_start;
<a name="l08386"></a>08386       <span class="keywordtype">int</span>           mmio_len;
<a name="l08387"></a>08387 
<a name="l08388"></a>08388       adapter-&gt;hw.hw_addr =
<a name="l08389"></a>08389         ioremap((mmio_start = pci_resource_start(pdev, 0)),
<a name="l08390"></a>08390             (mmio_len = pci_resource_len(pdev, 0)));
<a name="l08391"></a>08391 
<a name="l08392"></a>08392       netdev-&gt;mem_start = mmio_start;
<a name="l08393"></a>08393       netdev-&gt;mem_end = mmio_start + mmio_len;
<a name="l08394"></a>08394       <span class="keywordflow">if</span>(dna_debug) {
<a name="l08395"></a>08395         printk(<span class="stringliteral">&quot;[mmio_start=0x%lx][mmio_len=0x%x]\n&quot;</span>,
<a name="l08396"></a>08396            mmio_start, mmio_len);
<a name="l08397"></a>08397       }
<a name="l08398"></a>08398     }
<a name="l08399"></a>08399 <span class="preprocessor">#endif</span>
<a name="l08400"></a>08400 <span class="preprocessor"></span>
<a name="l08401"></a>08401     <span class="keywordflow">if</span> (!hw-&gt;hw_addr) {
<a name="l08402"></a>08402         err = -EIO;
<a name="l08403"></a>08403         <span class="keywordflow">goto</span> err_ioremap;
<a name="l08404"></a>08404     }
<a name="l08405"></a>08405 
<a name="l08406"></a>08406     ixgbe_assign_netdev_ops(netdev);
<a name="l08407"></a>08407 
<a name="l08408"></a>08408     strncpy(netdev-&gt;name, pci_name(pdev), <span class="keyword">sizeof</span>(netdev-&gt;name) - 1);
<a name="l08409"></a>08409 
<a name="l08410"></a>08410     adapter-&gt;bd_number = cards_found;
<a name="l08411"></a>08411 
<a name="l08412"></a>08412     <span class="comment">/* setup the private structure */</span>
<a name="l08413"></a>08413     err = ixgbe_sw_init(adapter);
<a name="l08414"></a>08414     <span class="keywordflow">if</span> (err)
<a name="l08415"></a>08415         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08416"></a>08416 
<a name="l08417"></a>08417     <span class="comment">/* Make it possible the adapter to be woken up via WOL */</span>
<a name="l08418"></a>08418     <span class="keywordflow">switch</span>(adapter-&gt;hw.mac.type) {
<a name="l08419"></a>08419     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l08420"></a>08420     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l08421"></a>08421         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_WUS, ~0);
<a name="l08422"></a>08422         <span class="keywordflow">break</span>;
<a name="l08423"></a>08423     <span class="keywordflow">default</span>:
<a name="l08424"></a>08424         <span class="keywordflow">break</span>;
<a name="l08425"></a>08425     }
<a name="l08426"></a>08426 
<a name="l08427"></a>08427     <span class="comment">/*</span>
<a name="l08428"></a>08428 <span class="comment">     * If we have a fan, this is as early we know, warn if we</span>
<a name="l08429"></a>08429 <span class="comment">     * have had a failure.</span>
<a name="l08430"></a>08430 <span class="comment">     */</span>
<a name="l08431"></a>08431     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE) {
<a name="l08432"></a>08432         u32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
<a name="l08433"></a>08433         <span class="keywordflow">if</span> (esdp &amp; IXGBE_ESDP_SDP1)
<a name="l08434"></a>08434             e_crit(probe, <span class="stringliteral">&quot;Fan has stopped, replace the adapter\n&quot;</span>);
<a name="l08435"></a>08435     }
<a name="l08436"></a>08436 
<a name="l08437"></a>08437     <span class="comment">/* reset_hw fills in the perm_addr as well */</span>
<a name="l08438"></a>08438     hw-&gt;phy.reset_if_overtemp = <span class="keyword">true</span>;
<a name="l08439"></a>08439     err = hw-&gt;mac.ops.reset_hw(hw);
<a name="l08440"></a>08440     hw-&gt;phy.reset_if_overtemp = <span class="keyword">false</span>;
<a name="l08441"></a>08441     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_PRESENT &amp;&amp;
<a name="l08442"></a>08442         hw-&gt;mac.type == ixgbe_mac_82598EB) {
<a name="l08443"></a>08443         err = 0;
<a name="l08444"></a>08444     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_SUPPORTED) {
<a name="l08445"></a>08445         e_dev_err(<span class="stringliteral">&quot;failed to load because an unsupported SFP+ &quot;</span>
<a name="l08446"></a>08446               <span class="stringliteral">&quot;module type was detected.\n&quot;</span>);
<a name="l08447"></a>08447         e_dev_err(<span class="stringliteral">&quot;Reload the driver after installing a supported &quot;</span>
<a name="l08448"></a>08448               <span class="stringliteral">&quot;module.\n&quot;</span>);
<a name="l08449"></a>08449         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08450"></a>08450     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err) {
<a name="l08451"></a>08451         e_dev_err(<span class="stringliteral">&quot;HW Init failed: %d\n&quot;</span>, err);
<a name="l08452"></a>08452         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08453"></a>08453     }
<a name="l08454"></a>08454 
<a name="l08455"></a>08455     <span class="comment">/*</span>
<a name="l08456"></a>08456 <span class="comment">     * check_options must be called before setup_link to set up</span>
<a name="l08457"></a>08457 <span class="comment">     * hw-&gt;fc completely</span>
<a name="l08458"></a>08458 <span class="comment">     */</span>
<a name="l08459"></a>08459     ixgbe_check_options(adapter);
<a name="l08460"></a>08460 
<a name="l08461"></a>08461     e_info(tx_err, <span class="stringliteral">&quot;my (preferred) node is: %d\n&quot;</span>, adapter-&gt;node);
<a name="l08462"></a>08462 
<a name="l08463"></a>08463     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l08464"></a>08464         ixgbe_probe_vf(adapter);
<a name="l08465"></a>08465 
<a name="l08466"></a>08466 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l08467"></a>08467 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l08468"></a>08468 <span class="preprocessor"></span>    netdev-&gt;features = NETIF_F_SG |
<a name="l08469"></a>08469                NETIF_F_IP_CSUM |
<a name="l08470"></a>08470                NETIF_F_HW_VLAN_TX |
<a name="l08471"></a>08471                NETIF_F_HW_VLAN_RX |
<a name="l08472"></a>08472                NETIF_F_HW_VLAN_FILTER;
<a name="l08473"></a>08473 
<a name="l08474"></a>08474 <span class="preprocessor">#else</span>
<a name="l08475"></a>08475 <span class="preprocessor"></span>    netdev-&gt;features = NETIF_F_SG | NETIF_F_IP_CSUM;
<a name="l08476"></a>08476 
<a name="l08477"></a>08477 <span class="preprocessor">#endif</span>
<a name="l08478"></a>08478 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l08479"></a>08479 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_IPV6_CSUM;
<a name="l08480"></a>08480 <span class="preprocessor">#endif</span>
<a name="l08481"></a>08481 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l08482"></a>08482 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO;
<a name="l08483"></a>08483 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l08484"></a>08484 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO6;
<a name="l08485"></a>08485 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO6 */</span>
<a name="l08486"></a>08486 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l08487"></a>08487 <span class="preprocessor">#ifdef NETIF_F_GRO</span>
<a name="l08488"></a>08488 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_GRO;
<a name="l08489"></a>08489 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_GRO */</span>
<a name="l08490"></a>08490 
<a name="l08491"></a>08491 
<a name="l08492"></a>08492     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82599EB)
<a name="l08493"></a>08493         netdev-&gt;features |= NETIF_F_SCTP_CSUM;
<a name="l08494"></a>08494 
<a name="l08495"></a>08495 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l08496"></a>08496 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l08497"></a>08497 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_TSO;
<a name="l08498"></a>08498 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l08499"></a>08499 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_TSO6;
<a name="l08500"></a>08500 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO6 */</span>
<a name="l08501"></a>08501 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l08502"></a>08502     netdev-&gt;vlan_features |= NETIF_F_IP_CSUM;
<a name="l08503"></a>08503 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l08504"></a>08504 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_IPV6_CSUM;
<a name="l08505"></a>08505 <span class="preprocessor">#endif</span>
<a name="l08506"></a>08506 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_SG;
<a name="l08507"></a>08507 
<a name="l08508"></a>08508 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l08509"></a>08509 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l08510"></a>08510 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l08511"></a>08511 <span class="comment">     * If perfect filters were enabled in check_options(), enable them</span>
<a name="l08512"></a>08512 <span class="comment">     * on the netdevice too.</span>
<a name="l08513"></a>08513 <span class="comment">     */</span>
<a name="l08514"></a>08514     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
<a name="l08515"></a>08515         netdev-&gt;features |= NETIF_F_NTUPLE;
<a name="l08516"></a>08516 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l08517"></a>08517     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED)
<a name="l08518"></a>08518         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l08519"></a>08519     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)
<a name="l08520"></a>08520         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l08521"></a>08521     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l08522"></a>08522         adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l08523"></a>08523 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l08524"></a>08524 <span class="preprocessor"></span>        <span class="comment">/* clear n-tuple support in the netdev unconditionally */</span>
<a name="l08525"></a>08525         netdev-&gt;features &amp;= ~NETIF_F_NTUPLE;
<a name="l08526"></a>08526 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l08527"></a>08527     }
<a name="l08528"></a>08528 
<a name="l08529"></a>08529     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE) {
<a name="l08530"></a>08530         netdev-&gt;features |= NETIF_F_LRO;
<a name="l08531"></a>08531         adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SWLRO_ENABLED;
<a name="l08532"></a>08532         <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting == 0 ||
<a name="l08533"></a>08533             adapter-&gt;rx_itr_setting &gt; IXGBE_MAX_RSC_INT_RATE) {
<a name="l08534"></a>08534             adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_ENABLED;
<a name="l08535"></a>08535             e_info(probe, <span class="stringliteral">&quot;InterruptThrottleRate set too high, &quot;</span>
<a name="l08536"></a>08536                    <span class="stringliteral">&quot;disabling RSC\n&quot;</span>);
<a name="l08537"></a>08537         } <span class="keywordflow">else</span> {
<a name="l08538"></a>08538             adapter-&gt;flags2 |= IXGBE_FLAG2_RSC_ENABLED;
<a name="l08539"></a>08539         }
<a name="l08540"></a>08540     } <span class="keywordflow">else</span> {
<a name="l08541"></a>08541 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l08542"></a>08542 <span class="preprocessor"></span>        netdev-&gt;features |= NETIF_F_LRO;
<a name="l08543"></a>08543         adapter-&gt;flags2 |= IXGBE_FLAG2_SWLRO_ENABLED;
<a name="l08544"></a>08544 <span class="preprocessor">#endif</span>
<a name="l08545"></a>08545 <span class="preprocessor"></span>        adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_ENABLED;
<a name="l08546"></a>08546     }
<a name="l08547"></a>08547 <span class="preprocessor">#ifdef CONFIG_DCB</span>
<a name="l08548"></a>08548 <span class="preprocessor"></span>    netdev-&gt;dcbnl_ops = &amp;dcbnl_ops;
<a name="l08549"></a>08549 <span class="preprocessor">#endif</span>
<a name="l08550"></a>08550 <span class="preprocessor"></span>
<a name="l08551"></a>08551 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08552"></a>08552 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_FSO</span>
<a name="l08553"></a>08553 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_CAPABLE) {
<a name="l08554"></a>08554         ixgbe_get_device_caps(hw, &amp;device_caps);
<a name="l08555"></a>08555         <span class="keywordflow">if</span> (device_caps &amp; IXGBE_DEVICE_CAPS_FCOE_OFFLOADS) {
<a name="l08556"></a>08556             adapter-&gt;flags &amp;= ~IXGBE_FLAG_FCOE_ENABLED;
<a name="l08557"></a>08557             adapter-&gt;flags &amp;= ~IXGBE_FLAG_FCOE_CAPABLE;
<a name="l08558"></a>08558             e_info(probe, <span class="stringliteral">&quot;FCoE offload feature is not available. &quot;</span>
<a name="l08559"></a>08559                    <span class="stringliteral">&quot;Disabling FCoE offload feature\n&quot;</span>);
<a name="l08560"></a>08560         }
<a name="l08561"></a>08561 <span class="preprocessor">#ifndef HAVE_NETDEV_OPS_FCOE_ENABLE</span>
<a name="l08562"></a>08562 <span class="preprocessor"></span>        <span class="keywordflow">else</span> {
<a name="l08563"></a>08563             adapter-&gt;flags |= IXGBE_FLAG_FCOE_ENABLED;
<a name="l08564"></a>08564             adapter-&gt;ring_feature[RING_F_FCOE].indices =
<a name="l08565"></a>08565                     IXGBE_FCRETA_SIZE;
<a name="l08566"></a>08566             netdev-&gt;features |= NETIF_F_FSO;
<a name="l08567"></a>08567             netdev-&gt;features |= NETIF_F_FCOE_CRC;
<a name="l08568"></a>08568             netdev-&gt;features |= NETIF_F_FCOE_MTU;
<a name="l08569"></a>08569             netdev-&gt;fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX - 1;
<a name="l08570"></a>08570         }
<a name="l08571"></a>08571 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_OPS_FCOE_ENABLE */</span>
<a name="l08572"></a>08572     }
<a name="l08573"></a>08573 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l08574"></a>08574 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_CAPABLE) {
<a name="l08575"></a>08575         netdev-&gt;vlan_features |= NETIF_F_FSO;
<a name="l08576"></a>08576         netdev-&gt;vlan_features |= NETIF_F_FCOE_CRC;
<a name="l08577"></a>08577         netdev-&gt;vlan_features |= NETIF_F_FCOE_MTU;
<a name="l08578"></a>08578     }
<a name="l08579"></a>08579 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l08580"></a>08580 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_FSO */</span>
<a name="l08581"></a>08581 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l08582"></a>08582     <span class="keywordflow">if</span> (pci_using_dac) {
<a name="l08583"></a>08583         netdev-&gt;features |= NETIF_F_HIGHDMA;
<a name="l08584"></a>08584 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l08585"></a>08585 <span class="preprocessor"></span>        netdev-&gt;vlan_features |= NETIF_F_HIGHDMA;
<a name="l08586"></a>08586 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l08587"></a>08587     }
<a name="l08588"></a>08588 
<a name="l08589"></a>08589 <span class="preprocessor">#endif </span><span class="comment">/* MAX_SKB_FRAGS */</span>
<a name="l08590"></a>08590     <span class="comment">/* make sure the EEPROM is good */</span>
<a name="l08591"></a>08591     <span class="keywordflow">if</span> (hw-&gt;eeprom.ops.validate_checksum &amp;&amp;
<a name="l08592"></a>08592         (hw-&gt;eeprom.ops.validate_checksum(hw, NULL) &lt; 0)) {
<a name="l08593"></a>08593         e_dev_err(<span class="stringliteral">&quot;The EEPROM Checksum Is Not Valid\n&quot;</span>);
<a name="l08594"></a>08594         err = -EIO;
<a name="l08595"></a>08595         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08596"></a>08596     }
<a name="l08597"></a>08597 
<a name="l08598"></a>08598     memcpy(netdev-&gt;dev_addr, hw-&gt;mac.perm_addr, netdev-&gt;addr_len);
<a name="l08599"></a>08599 <span class="preprocessor">#ifdef ETHTOOL_GPERMADDR</span>
<a name="l08600"></a>08600 <span class="preprocessor"></span>    memcpy(netdev-&gt;perm_addr, hw-&gt;mac.perm_addr, netdev-&gt;addr_len);
<a name="l08601"></a>08601 
<a name="l08602"></a>08602     <span class="keywordflow">if</span> (ixgbe_validate_mac_addr(netdev-&gt;perm_addr)) {
<a name="l08603"></a>08603         e_dev_err(<span class="stringliteral">&quot;invalid MAC address\n&quot;</span>);
<a name="l08604"></a>08604         err = -EIO;
<a name="l08605"></a>08605         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08606"></a>08606     }
<a name="l08607"></a>08607 <span class="preprocessor">#else</span>
<a name="l08608"></a>08608 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ixgbe_validate_mac_addr(netdev-&gt;dev_addr)) {
<a name="l08609"></a>08609         e_dev_err(<span class="stringliteral">&quot;invalid MAC address\n&quot;</span>);
<a name="l08610"></a>08610         err = -EIO;
<a name="l08611"></a>08611         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08612"></a>08612     }
<a name="l08613"></a>08613 <span class="preprocessor">#endif</span>
<a name="l08614"></a>08614 <span class="preprocessor"></span>    ixgbe_insert_mac_addr(hw, hw-&gt;mac.perm_addr, 0);
<a name="l08615"></a>08615 
<a name="l08616"></a>08616     <span class="comment">/* power down the optics */</span>
<a name="l08617"></a>08617     <span class="keywordflow">if</span> ((hw-&gt;phy.multispeed_fiber) ||
<a name="l08618"></a>08618         ((hw-&gt;mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) &amp;&amp;
<a name="l08619"></a>08619          (hw-&gt;mac.type == ixgbe_mac_82599EB)))
<a name="l08620"></a>08620         ixgbe_disable_tx_laser(hw);
<a name="l08621"></a>08621 
<a name="l08622"></a>08622     setup_timer(&amp;adapter-&gt;service_timer, &amp;ixgbe_service_timer,
<a name="l08623"></a>08623                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) adapter);
<a name="l08624"></a>08624 
<a name="l08625"></a>08625     INIT_WORK(&amp;adapter-&gt;service_task, ixgbe_service_task);
<a name="l08626"></a>08626     clear_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state);
<a name="l08627"></a>08627 
<a name="l08628"></a>08628     err = ixgbe_init_interrupt_scheme(adapter);
<a name="l08629"></a>08629     <span class="keywordflow">if</span> (err)
<a name="l08630"></a>08630         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08631"></a>08631 
<a name="l08632"></a>08632     <span class="comment">/* WOL not supported for all but the following */</span>
<a name="l08633"></a>08633     adapter-&gt;wol = 0;
<a name="l08634"></a>08634     <span class="keywordflow">switch</span> (pdev-&gt;device) {
<a name="l08635"></a>08635     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_SFP:
<a name="l08636"></a>08636         <span class="comment">/* Only this subdevice supports WOL */</span>
<a name="l08637"></a>08637         <span class="keywordflow">if</span> (pdev-&gt;subsystem_device == IXGBE_SUBDEV_ID_82599_SFP)
<a name="l08638"></a>08638             adapter-&gt;wol = IXGBE_WUFC_MAG;
<a name="l08639"></a>08639         <span class="keywordflow">break</span>;
<a name="l08640"></a>08640     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_COMBO_BACKPLANE:
<a name="l08641"></a>08641         <span class="comment">/* All except this subdevice support WOL */</span>
<a name="l08642"></a>08642         <span class="keywordflow">if</span> (pdev-&gt;subsystem_device != IXGBE_SUBDEV_ID_82599_KX4_KR_MEZZ)
<a name="l08643"></a>08643             adapter-&gt;wol = IXGBE_WUFC_MAG;
<a name="l08644"></a>08644         <span class="keywordflow">break</span>;
<a name="l08645"></a>08645     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_KX4:
<a name="l08646"></a>08646         adapter-&gt;wol = IXGBE_WUFC_MAG;
<a name="l08647"></a>08647         <span class="keywordflow">break</span>;
<a name="l08648"></a>08648     }
<a name="l08649"></a>08649     device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);
<a name="l08650"></a>08650 
<a name="l08651"></a>08651     <span class="comment">/* save off EEPROM version number */</span>
<a name="l08652"></a>08652     ixgbe_read_eeprom(hw, 0x29, &amp;adapter-&gt;eeprom_version);
<a name="l08653"></a>08653 
<a name="l08654"></a>08654     <span class="comment">/* reset the hardware with the new settings */</span>
<a name="l08655"></a>08655     err = hw-&gt;mac.ops.start_hw(hw);
<a name="l08656"></a>08656     <span class="keywordflow">if</span> (err == IXGBE_ERR_EEPROM_VERSION) {
<a name="l08657"></a>08657         <span class="comment">/* We are running on a pre-production device, log a warning */</span>
<a name="l08658"></a>08658         e_dev_warn(<span class="stringliteral">&quot;This device is a pre-production adapter/LOM. &quot;</span>
<a name="l08659"></a>08659                <span class="stringliteral">&quot;Please be aware there may be issues associated &quot;</span>
<a name="l08660"></a>08660                <span class="stringliteral">&quot;with your hardware.  If you are experiencing &quot;</span>
<a name="l08661"></a>08661                <span class="stringliteral">&quot;problems please contact your Intel or hardware &quot;</span>
<a name="l08662"></a>08662                <span class="stringliteral">&quot;representative who provided you with this &quot;</span>
<a name="l08663"></a>08663                <span class="stringliteral">&quot;hardware.\n&quot;</span>);
<a name="l08664"></a>08664     }
<a name="l08665"></a>08665     <span class="comment">/* pick up the PCI bus settings for reporting later */</span>
<a name="l08666"></a>08666     <span class="keywordflow">if</span> (hw-&gt;mac.ops.get_bus_info)
<a name="l08667"></a>08667         hw-&gt;mac.ops.get_bus_info(hw);
<a name="l08668"></a>08668 
<a name="l08669"></a>08669 
<a name="l08670"></a>08670     strcpy(netdev-&gt;name, <span class="stringliteral">&quot;eth%d&quot;</span>);
<a name="l08671"></a>08671     err = register_netdev(netdev);
<a name="l08672"></a>08672     <span class="keywordflow">if</span> (err)
<a name="l08673"></a>08673         <span class="keywordflow">goto</span> err_register;
<a name="l08674"></a>08674 
<a name="l08675"></a>08675     adapter-&gt;netdev_registered = <span class="keyword">true</span>;
<a name="l08676"></a>08676     <span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span>
<a name="l08677"></a>08677     netif_carrier_off(netdev);
<a name="l08678"></a>08678     <span class="comment">/* keep stopping all the transmit queues for older kernels */</span>
<a name="l08679"></a>08679     netif_tx_stop_all_queues(netdev);
<a name="l08680"></a>08680 
<a name="l08681"></a>08681     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_CAPABLE) {
<a name="l08682"></a>08682         err = dca_add_requester(&amp;pdev-&gt;dev);
<a name="l08683"></a>08683         <span class="keywordflow">switch</span> (err) {
<a name="l08684"></a>08684         <span class="keywordflow">case</span> 0:
<a name="l08685"></a>08685             adapter-&gt;flags |= IXGBE_FLAG_DCA_ENABLED;
<a name="l08686"></a>08686             ixgbe_setup_dca(adapter);
<a name="l08687"></a>08687             <span class="keywordflow">break</span>;
<a name="l08688"></a>08688         <span class="comment">/* -19 is returned from the kernel when no provider is found */</span>
<a name="l08689"></a>08689         <span class="keywordflow">case</span> -19:
<a name="l08690"></a>08690             e_info(rx_err, <span class="stringliteral">&quot;No DCA provider found. Please &quot;</span>
<a name="l08691"></a>08691                    <span class="stringliteral">&quot;start ioatdma for DCA functionality.\n&quot;</span>);
<a name="l08692"></a>08692             <span class="keywordflow">break</span>;
<a name="l08693"></a>08693         <span class="keywordflow">default</span>:
<a name="l08694"></a>08694             e_info(probe, <span class="stringliteral">&quot;DCA registration failed: %d\n&quot;</span>, err);
<a name="l08695"></a>08695             <span class="keywordflow">break</span>;
<a name="l08696"></a>08696         }
<a name="l08697"></a>08697     }
<a name="l08698"></a>08698 
<a name="l08699"></a>08699     <span class="comment">/* print all messages at the end so that we use our eth%d name */</span>
<a name="l08700"></a>08700     <span class="comment">/* print bus type/speed/width info */</span>
<a name="l08701"></a>08701     e_dev_info(<span class="stringliteral">&quot;(PCI Express:%s:%s) &quot;</span>,
<a name="l08702"></a>08702            (hw-&gt;bus.speed == ixgbe_bus_speed_5000 ? <span class="stringliteral">&quot;5.0GT/s&quot;</span> :
<a name="l08703"></a>08703            hw-&gt;bus.speed == ixgbe_bus_speed_2500 ? <span class="stringliteral">&quot;2.5GT/s&quot;</span> :
<a name="l08704"></a>08704            <span class="stringliteral">&quot;Unknown&quot;</span>),
<a name="l08705"></a>08705            (hw-&gt;bus.width == ixgbe_bus_width_pcie_x8 ? <span class="stringliteral">&quot;Width x8&quot;</span> :
<a name="l08706"></a>08706            hw-&gt;bus.width == ixgbe_bus_width_pcie_x4 ? <span class="stringliteral">&quot;Width x4&quot;</span> :
<a name="l08707"></a>08707            hw-&gt;bus.width == ixgbe_bus_width_pcie_x1 ? <span class="stringliteral">&quot;Width x1&quot;</span> :
<a name="l08708"></a>08708            <span class="stringliteral">&quot;Unknown&quot;</span>));
<a name="l08709"></a>08709 
<a name="l08710"></a>08710     <span class="comment">/* print the MAC address */</span>
<a name="l08711"></a>08711     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++)
<a name="l08712"></a>08712         printk(<span class="stringliteral">&quot;%2.2x%c&quot;</span>, netdev-&gt;dev_addr[i], i == 5 ? <span class="charliteral">&#39;\n&#39;</span> : <span class="charliteral">&#39;:&#39;</span>);
<a name="l08713"></a>08713 
<a name="l08714"></a>08714     <span class="comment">/* First try to read PBA as a string */</span>
<a name="l08715"></a>08715     err = ixgbe_read_pba_string(hw, part_str, IXGBE_PBANUM_LENGTH);
<a name="l08716"></a>08716     <span class="keywordflow">if</span> (err)
<a name="l08717"></a>08717         strncpy(part_str, <span class="stringliteral">&quot;Unknown&quot;</span>, IXGBE_PBANUM_LENGTH);
<a name="l08718"></a>08718     <span class="keywordflow">if</span> (ixgbe_is_sfp(hw) &amp;&amp; hw-&gt;phy.sfp_type != ixgbe_sfp_type_not_present)
<a name="l08719"></a>08719         e_info(probe, <span class="stringliteral">&quot;MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n&quot;</span>,
<a name="l08720"></a>08720                hw-&gt;mac.type, hw-&gt;phy.type, hw-&gt;phy.sfp_type, part_str);
<a name="l08721"></a>08721     <span class="keywordflow">else</span>
<a name="l08722"></a>08722         e_info(probe, <span class="stringliteral">&quot;MAC: %d, PHY: %d, PBA No: %s\n&quot;</span>,
<a name="l08723"></a>08723               hw-&gt;mac.type, hw-&gt;phy.type, part_str);
<a name="l08724"></a>08724 
<a name="l08725"></a>08725     <span class="keywordflow">if</span> (((hw-&gt;bus.speed == ixgbe_bus_speed_2500) &amp;&amp;
<a name="l08726"></a>08726          (hw-&gt;bus.width &lt;= ixgbe_bus_width_pcie_x4)) ||
<a name="l08727"></a>08727         (hw-&gt;bus.width &lt;= ixgbe_bus_width_pcie_x2)) {
<a name="l08728"></a>08728         e_dev_warn(<span class="stringliteral">&quot;PCI-Express bandwidth available for this card is &quot;</span>
<a name="l08729"></a>08729                <span class="stringliteral">&quot;not sufficient for optimal performance.\n&quot;</span>);
<a name="l08730"></a>08730         e_dev_warn(<span class="stringliteral">&quot;For optimal performance a x8 PCI-Express slot &quot;</span>
<a name="l08731"></a>08731                <span class="stringliteral">&quot;is required.\n&quot;</span>);
<a name="l08732"></a>08732     }
<a name="l08733"></a>08733 
<a name="l08734"></a>08734 <span class="preprocessor">#define INFO_STRING_LEN 255</span>
<a name="l08735"></a>08735 <span class="preprocessor"></span>    info_string = kzalloc(INFO_STRING_LEN, GFP_KERNEL);
<a name="l08736"></a>08736     <span class="keywordflow">if</span> (!info_string) {
<a name="l08737"></a>08737         e_err(probe, <span class="stringliteral">&quot;allocation for info string failed\n&quot;</span>);
<a name="l08738"></a>08738         <span class="keywordflow">goto</span> no_info_string;
<a name="l08739"></a>08739     }
<a name="l08740"></a>08740     i_s_var = info_string;
<a name="l08741"></a>08741     i_s_var += sprintf(info_string, <span class="stringliteral">&quot;Enabled Features: &quot;</span>);
<a name="l08742"></a>08742     i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;RxQ: %d TxQ: %d &quot;</span>,
<a name="l08743"></a>08743                adapter-&gt;num_rx_queues, adapter-&gt;num_tx_queues);
<a name="l08744"></a>08744 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08745"></a>08745 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED)
<a name="l08746"></a>08746         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;FCoE &quot;</span>);
<a name="l08747"></a>08747 <span class="preprocessor">#endif</span>
<a name="l08748"></a>08748 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE)
<a name="l08749"></a>08749         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;FdirHash &quot;</span>);
<a name="l08750"></a>08750     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
<a name="l08751"></a>08751         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;FdirPerfect &quot;</span>);
<a name="l08752"></a>08752     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)
<a name="l08753"></a>08753         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;DCB &quot;</span>);
<a name="l08754"></a>08754     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED)
<a name="l08755"></a>08755         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;RSS &quot;</span>);
<a name="l08756"></a>08756     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
<a name="l08757"></a>08757         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;DCA &quot;</span>);
<a name="l08758"></a>08758 <span class="preprocessor">#ifndef NETIF_F_GRO</span>
<a name="l08759"></a>08759 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED)
<a name="l08760"></a>08760         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;LRO &quot;</span>);
<a name="l08761"></a>08761 <span class="preprocessor">#endif</span>
<a name="l08762"></a>08762 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED)
<a name="l08763"></a>08763         i_s_var += sprintf(i_s_var, <span class="stringliteral">&quot;RSC &quot;</span>);
<a name="l08764"></a>08764 
<a name="l08765"></a>08765     BUG_ON(i_s_var &gt; (info_string + INFO_STRING_LEN));
<a name="l08766"></a>08766     <span class="comment">/* end features printing */</span>
<a name="l08767"></a>08767     e_info(probe, <span class="stringliteral">&quot;%s\n&quot;</span>, info_string);
<a name="l08768"></a>08768     kfree(info_string);
<a name="l08769"></a>08769 no_info_string:
<a name="l08770"></a>08770 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l08771"></a>08771 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l08772"></a>08772         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vfs; i++)
<a name="l08773"></a>08773             ixgbe_vf_configuration(pdev, (i | 0x10000000));
<a name="l08774"></a>08774     }
<a name="l08775"></a>08775 <span class="preprocessor">#endif</span>
<a name="l08776"></a>08776 <span class="preprocessor"></span>
<a name="l08777"></a>08777     <span class="comment">/* Inform firmware of driver version */</span>
<a name="l08778"></a>08778     ixgbe_set_fw_drv_ver(hw, MAJ, MIN, BUILD, FW_CEM_UNUSED_VER);
<a name="l08779"></a>08779 
<a name="l08780"></a>08780 <span class="preprocessor">#if defined(HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN)</span>
<a name="l08781"></a>08781 <span class="preprocessor"></span>    <span class="comment">/* add san mac addr to netdev */</span>
<a name="l08782"></a>08782     ixgbe_add_sanmac_netdev(netdev);
<a name="l08783"></a>08783 
<a name="l08784"></a>08784 <span class="preprocessor">#endif </span><span class="comment">/* (HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; (NETDEV_HW_ADDR_T_SAN) */</span>
<a name="l08785"></a>08785     e_info(probe, <span class="stringliteral">&quot;Intel(R) 10 Gigabit Network Connection\n&quot;</span>);
<a name="l08786"></a>08786     cards_found++;
<a name="l08787"></a>08787     <span class="keywordflow">return</span> 0;
<a name="l08788"></a>08788 
<a name="l08789"></a>08789 err_register:
<a name="l08790"></a>08790     ixgbe_clear_interrupt_scheme(adapter);
<a name="l08791"></a>08791     ixgbe_release_hw_control(adapter);
<a name="l08792"></a>08792 err_sw_init:
<a name="l08793"></a>08793     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l08794"></a>08794         ixgbe_disable_sriov(adapter);
<a name="l08795"></a>08795     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l08796"></a>08796     iounmap(hw-&gt;hw_addr);
<a name="l08797"></a>08797 err_ioremap:
<a name="l08798"></a>08798     free_netdev(netdev);
<a name="l08799"></a>08799 err_alloc_etherdev:
<a name="l08800"></a>08800     pci_release_selected_regions(pdev,
<a name="l08801"></a>08801                      pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l08802"></a>08802 err_pci_reg:
<a name="l08803"></a>08803 err_dma:
<a name="l08804"></a>08804 
<a name="l08805"></a>08805     pci_disable_device(pdev);
<a name="l08806"></a>08806     <span class="keywordflow">return</span> err;
<a name="l08807"></a>08807 }
<a name="l08808"></a>08808 
<a name="l08818"></a>08818 <span class="keyword">static</span> <span class="keywordtype">void</span> __devexit ixgbe_remove(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l08819"></a>08819 {
<a name="l08820"></a>08820     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08821"></a>08821     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l08822"></a>08822 
<a name="l08823"></a>08823 
<a name="l08824"></a>08824     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l08825"></a>08825     cancel_work_sync(&amp;adapter-&gt;service_task);
<a name="l08826"></a>08826 
<a name="l08827"></a>08827     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED) {
<a name="l08828"></a>08828         adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCA_ENABLED;
<a name="l08829"></a>08829         dca_remove_requester(&amp;pdev-&gt;dev);
<a name="l08830"></a>08830         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DCA_CTRL, 1);
<a name="l08831"></a>08831     }
<a name="l08832"></a>08832 
<a name="l08833"></a>08833 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08834"></a>08834 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED)
<a name="l08835"></a>08835         ixgbe_cleanup_fcoe(adapter);
<a name="l08836"></a>08836 
<a name="l08837"></a>08837 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l08838"></a>08838 <span class="preprocessor">#if defined(HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN)</span>
<a name="l08839"></a>08839 <span class="preprocessor"></span>    <span class="comment">/* remove the added san mac */</span>
<a name="l08840"></a>08840     ixgbe_del_sanmac_netdev(netdev);
<a name="l08841"></a>08841 
<a name="l08842"></a>08842 <span class="preprocessor">#endif </span><span class="comment">/* (HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; (NETDEV_HW_ADDR_T_SAN) */</span>
<a name="l08843"></a>08843     <span class="keywordflow">if</span> (adapter-&gt;netdev_registered) {
<a name="l08844"></a>08844         unregister_netdev(netdev);
<a name="l08845"></a>08845         adapter-&gt;netdev_registered = <span class="keyword">false</span>;
<a name="l08846"></a>08846     }
<a name="l08847"></a>08847     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l08848"></a>08848         ixgbe_disable_sriov(adapter);
<a name="l08849"></a>08849 
<a name="l08850"></a>08850     ixgbe_clear_interrupt_scheme(adapter);
<a name="l08851"></a>08851     ixgbe_release_hw_control(adapter);
<a name="l08852"></a>08852 
<a name="l08853"></a>08853     iounmap(adapter-&gt;hw.hw_addr);
<a name="l08854"></a>08854     pci_release_selected_regions(pdev,
<a name="l08855"></a>08855                      pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l08856"></a>08856 
<a name="l08857"></a>08857     free_netdev(netdev);
<a name="l08858"></a>08858 
<a name="l08859"></a>08859     pci_disable_pcie_error_reporting(pdev);
<a name="l08860"></a>08860 
<a name="l08861"></a>08861     pci_disable_device(pdev);
<a name="l08862"></a>08862 }
<a name="l08863"></a>08863 
<a name="l08864"></a>08864 u16 ixgbe_read_pci_cfg_word(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw, u32 reg)
<a name="l08865"></a>08865 {
<a name="l08866"></a>08866     u16 value;
<a name="l08867"></a>08867     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = hw-&gt;back;
<a name="l08868"></a>08868 
<a name="l08869"></a>08869     pci_read_config_word(adapter-&gt;pdev, reg, &amp;value);
<a name="l08870"></a>08870     <span class="keywordflow">return</span> value;
<a name="l08871"></a>08871 }
<a name="l08872"></a>08872 
<a name="l08873"></a>08873 <span class="keywordtype">void</span> ixgbe_write_pci_cfg_word(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw, u32 reg, u16 value)
<a name="l08874"></a>08874 {
<a name="l08875"></a>08875     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = hw-&gt;back;
<a name="l08876"></a>08876 
<a name="l08877"></a>08877     pci_write_config_word(adapter-&gt;pdev, reg, value);
<a name="l08878"></a>08878 }
<a name="l08879"></a>08879 
<a name="l08880"></a>08880 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l08881"></a>08881 <span class="preprocessor"></span>
<a name="l08889"></a>08889 <span class="keyword">static</span> pci_ers_result_t ixgbe_io_error_detected(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l08890"></a>08890                         pci_channel_state_t state)
<a name="l08891"></a>08891 {
<a name="l08892"></a>08892     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08893"></a>08893     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l08894"></a>08894 
<a name="l08895"></a>08895     netif_device_detach(netdev);
<a name="l08896"></a>08896 
<a name="l08897"></a>08897     <span class="keywordflow">if</span> (state == pci_channel_io_perm_failure)
<a name="l08898"></a>08898         <span class="keywordflow">return</span> PCI_ERS_RESULT_DISCONNECT;
<a name="l08899"></a>08899 
<a name="l08900"></a>08900     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l08901"></a>08901         ixgbe_down(adapter);
<a name="l08902"></a>08902     pci_disable_device(pdev);
<a name="l08903"></a>08903 
<a name="l08904"></a>08904     <span class="comment">/* Request a slot reset. */</span>
<a name="l08905"></a>08905     <span class="keywordflow">return</span> PCI_ERS_RESULT_NEED_RESET;
<a name="l08906"></a>08906 }
<a name="l08907"></a>08907 
<a name="l08914"></a>08914 <span class="keyword">static</span> pci_ers_result_t ixgbe_io_slot_reset(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l08915"></a>08915 {
<a name="l08916"></a>08916     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08917"></a>08917     pci_ers_result_t result;
<a name="l08918"></a>08918 
<a name="l08919"></a>08919     <span class="keywordflow">if</span> (pci_enable_device_mem(pdev)) {
<a name="l08920"></a>08920         e_err(probe, <span class="stringliteral">&quot;Cannot re-enable PCI device after reset.\n&quot;</span>);
<a name="l08921"></a>08921         result = PCI_ERS_RESULT_DISCONNECT;
<a name="l08922"></a>08922     } <span class="keywordflow">else</span> {
<a name="l08923"></a>08923         pci_set_master(pdev);
<a name="l08924"></a>08924         pci_restore_state(pdev);
<a name="l08925"></a>08925         <span class="comment">/*</span>
<a name="l08926"></a>08926 <span class="comment">         * After second error pci-&gt;state_saved is false, this</span>
<a name="l08927"></a>08927 <span class="comment">         * resets it so EEH doesn&#39;t break.</span>
<a name="l08928"></a>08928 <span class="comment">         */</span>
<a name="l08929"></a>08929         pci_save_state(pdev);
<a name="l08930"></a>08930 
<a name="l08931"></a>08931         pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l08932"></a>08932 
<a name="l08933"></a>08933         ixgbe_reset(adapter);
<a name="l08934"></a>08934         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_WUS, ~0);
<a name="l08935"></a>08935         result = PCI_ERS_RESULT_RECOVERED;
<a name="l08936"></a>08936     }
<a name="l08937"></a>08937 
<a name="l08938"></a>08938     pci_cleanup_aer_uncorrect_error_status(pdev);
<a name="l08939"></a>08939 
<a name="l08940"></a>08940     <span class="keywordflow">return</span> result;
<a name="l08941"></a>08941 }
<a name="l08942"></a>08942 
<a name="l08950"></a>08950 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_io_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l08951"></a>08951 {
<a name="l08952"></a>08952     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08953"></a>08953     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l08954"></a>08954 
<a name="l08955"></a>08955     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l08956"></a>08956         <span class="keywordflow">if</span> (ixgbe_up(adapter)) {
<a name="l08957"></a>08957             e_info(probe, <span class="stringliteral">&quot;ixgbe_up failed after reset\n&quot;</span>);
<a name="l08958"></a>08958             <span class="keywordflow">return</span>;
<a name="l08959"></a>08959         }
<a name="l08960"></a>08960     }
<a name="l08961"></a>08961 
<a name="l08962"></a>08962     netif_device_attach(netdev);
<a name="l08963"></a>08963 }
<a name="l08964"></a>08964 
<a name="l08965"></a>08965 <span class="keyword">static</span> <span class="keyword">struct </span>pci_error_handlers ixgbe_err_handler = {
<a name="l08966"></a>08966     .error_detected = ixgbe_io_error_detected,
<a name="l08967"></a>08967     .slot_reset = ixgbe_io_slot_reset,
<a name="l08968"></a>08968     .resume = ixgbe_io_resume,
<a name="l08969"></a>08969 };
<a name="l08970"></a>08970 
<a name="l08971"></a>08971 <span class="preprocessor">#endif</span>
<a name="l08972"></a>08972 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span>pci_driver ixgbe_driver = {
<a name="l08973"></a>08973     .name     = ixgbe_driver_name,
<a name="l08974"></a>08974     .id_table = ixgbe_pci_tbl,
<a name="l08975"></a>08975     .probe    = ixgbe_probe,
<a name="l08976"></a>08976     .remove   = __devexit_p(ixgbe_remove),
<a name="l08977"></a>08977 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l08978"></a>08978 <span class="preprocessor"></span>    .suspend  = ixgbe_suspend,
<a name="l08979"></a>08979     .resume   = ixgbe_resume,
<a name="l08980"></a>08980 <span class="preprocessor">#endif</span>
<a name="l08981"></a>08981 <span class="preprocessor"></span><span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l08982"></a>08982 <span class="preprocessor"></span>    .shutdown = ixgbe_shutdown,
<a name="l08983"></a>08983 <span class="preprocessor">#endif</span>
<a name="l08984"></a>08984 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l08985"></a>08985 <span class="preprocessor"></span>    .err_handler = &amp;ixgbe_err_handler
<a name="l08986"></a>08986 <span class="preprocessor">#endif</span>
<a name="l08987"></a>08987 <span class="preprocessor"></span>};
<a name="l08988"></a>08988 
<a name="l08989"></a>08989 <span class="keywordtype">bool</span> ixgbe_is_ixgbe(<span class="keyword">struct</span> pci_dev *pcidev)
<a name="l08990"></a>08990 {
<a name="l08991"></a>08991     <span class="keywordflow">if</span> (pci_dev_driver(pcidev) != &amp;ixgbe_driver)
<a name="l08992"></a>08992         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l08993"></a>08993     <span class="keywordflow">else</span>
<a name="l08994"></a>08994         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l08995"></a>08995 }
<a name="l08996"></a>08996 
<a name="l09003"></a>09003 <span class="keyword">static</span> <span class="keywordtype">int</span> __init ixgbe_init_module(<span class="keywordtype">void</span>)
<a name="l09004"></a>09004 {
<a name="l09005"></a>09005     <span class="keywordtype">int</span> ret;
<a name="l09006"></a>09006     pr_info(<span class="stringliteral">&quot;%s - version %s\n&quot;</span>, ixgbe_driver_string, ixgbe_driver_version);
<a name="l09007"></a>09007     pr_info(<span class="stringliteral">&quot;%s\n&quot;</span>, ixgbe_copyright);
<a name="l09008"></a>09008 
<a name="l09009"></a>09009 <span class="preprocessor">#ifndef CONFIG_DCB</span>
<a name="l09010"></a>09010 <span class="preprocessor"></span>    ixgbe_dcb_netlink_register();
<a name="l09011"></a>09011 <span class="preprocessor">#endif</span>
<a name="l09012"></a>09012 <span class="preprocessor"></span><span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l09013"></a>09013 <span class="preprocessor"></span>    dca_register_notify(&amp;dca_notifier);
<a name="l09014"></a>09014 
<a name="l09015"></a>09015 <span class="preprocessor">#endif</span>
<a name="l09016"></a>09016 <span class="preprocessor"></span>    ret = pci_register_driver(&amp;ixgbe_driver);
<a name="l09017"></a>09017     <span class="keywordflow">return</span> ret;
<a name="l09018"></a>09018 }
<a name="l09019"></a>09019 
<a name="l09020"></a>09020 module_init(ixgbe_init_module);
<a name="l09021"></a>09021 
<a name="l09028"></a>09028 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit ixgbe_exit_module(<span class="keywordtype">void</span>)
<a name="l09029"></a>09029 {
<a name="l09030"></a>09030 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l09031"></a>09031 <span class="preprocessor"></span>    dca_unregister_notify(&amp;dca_notifier);
<a name="l09032"></a>09032 <span class="preprocessor">#endif</span>
<a name="l09033"></a>09033 <span class="preprocessor"></span><span class="preprocessor">#ifndef CONFIG_DCB</span>
<a name="l09034"></a>09034 <span class="preprocessor"></span>    ixgbe_dcb_netlink_unregister();
<a name="l09035"></a>09035 <span class="preprocessor">#endif</span>
<a name="l09036"></a>09036 <span class="preprocessor"></span>    pci_unregister_driver(&amp;ixgbe_driver);
<a name="l09037"></a>09037 }
<a name="l09038"></a>09038 
<a name="l09039"></a>09039 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l09040"></a>09040 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_notify_dca(<span class="keyword">struct</span> notifier_block *nb, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l09041"></a>09041                 <span class="keywordtype">void</span> *p)
<a name="l09042"></a>09042 {
<a name="l09043"></a>09043     <span class="keywordtype">int</span> ret_val;
<a name="l09044"></a>09044 
<a name="l09045"></a>09045     ret_val = driver_for_each_device(&amp;ixgbe_driver.driver, NULL, &amp;event,
<a name="l09046"></a>09046                      __ixgbe_notify_dca);
<a name="l09047"></a>09047 
<a name="l09048"></a>09048     <span class="keywordflow">return</span> ret_val ? NOTIFY_BAD : NOTIFY_DONE;
<a name="l09049"></a>09049 }
<a name="l09050"></a>09050 <span class="preprocessor">#endif</span>
<a name="l09051"></a>09051 <span class="preprocessor"></span>module_exit(ixgbe_exit_module);
<a name="l09052"></a>09052 
<a name="l09053"></a>09053 <span class="comment">/* ixgbe_main.c */</span>
<a name="l09054"></a>09054 
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:28 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
