<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/igb/igb-3.0.22/src/igb_main.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_3c2810a9602a6e1cace3517f89aee72b.html">igb</a>      </li>
      <li class="navelem"><a class="el" href="dir_7e6283e46a535da0a7c1aa2c5482db05.html">igb-3.0.22</a>      </li>
      <li class="navelem"><a class="el" href="dir_0c425da04c49dcf9213f9b26dcbb667f.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">igb_main.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Intel(R) Gigabit Ethernet Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">  Copyright(c) 2007-2010 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">  under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">  version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">  more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">  The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00024"></a>00024 <span class="comment">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">*******************************************************************************/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;linux/init.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;linux/vmalloc.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;linux/pagemap.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;linux/netdevice.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;linux/tcp.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/checksum.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/ipv6.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;net/ip6_checksum.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#endif</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIOCGMIIPHY</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/mii.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIOCETHTOOL</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/ethtool.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/if_vlan.h&gt;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;igb.h&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;igb_vmdq.h&quot;</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#include &quot;../../../../../kernel/linux/pf_ring.h&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#endif</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a>00057 <span class="preprocessor">#define DRV_DEBUG</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#define DRV_HW_PERF</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#define VERSION_SUFFIX</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="preprocessor">#define MAJ 3</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define MIN 0</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#define BUILD 22</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define DRV_VERSION __stringify(MAJ) &quot;.&quot; __stringify(MIN) &quot;.&quot; __stringify(BUILD) VERSION_SUFFIX DRV_DEBUG DRV_HW_PERF</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="keywordtype">char</span> igb_driver_name[] = <span class="stringliteral">&quot;igb&quot;</span>;
<a name="l00067"></a>00067 <span class="keywordtype">char</span> igb_driver_version[] = DRV_VERSION;
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> igb_driver_string[] =
<a name="l00069"></a>00069                                 <span class="stringliteral">&quot;Intel(R) Gigabit Ethernet Network Driver&quot;</span>;
<a name="l00070"></a>00070 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> igb_copyright[] = <span class="stringliteral">&quot;Copyright (c) 2007-2010 Intel Corporation.&quot;</span>;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keyword">struct </span>pci_device_id igb_pci_tbl[] = {
<a name="l00073"></a>00073     { PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_COPPER) },
<a name="l00074"></a>00074     { PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_FIBER) },
<a name="l00075"></a>00075     { PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SERDES) },
<a name="l00076"></a>00076     { PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SGMII) },
<a name="l00077"></a>00077     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER) },
<a name="l00078"></a>00078     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_FIBER) },
<a name="l00079"></a>00079     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SERDES) },
<a name="l00080"></a>00080     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SGMII) },
<a name="l00081"></a>00081     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER_DUAL) },
<a name="l00082"></a>00082     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_QUAD_FIBER) },
<a name="l00083"></a>00083     { PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SGMII) },
<a name="l00084"></a>00084     { PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SERDES) },
<a name="l00085"></a>00085     { PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_BACKPLANE) },
<a name="l00086"></a>00086     { PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SFP) },
<a name="l00087"></a>00087     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576) },
<a name="l00088"></a>00088     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS) },
<a name="l00089"></a>00089     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS_SERDES) },
<a name="l00090"></a>00090     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_FIBER) },
<a name="l00091"></a>00091     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES) },
<a name="l00092"></a>00092     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES_QUAD) },
<a name="l00093"></a>00093     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER) },
<a name="l00094"></a>00094     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER_ET2) },
<a name="l00095"></a>00095     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_COPPER) },
<a name="l00096"></a>00096     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_FIBER_SERDES) },
<a name="l00097"></a>00097     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82575GB_QUAD_COPPER) },
<a name="l00098"></a>00098     <span class="comment">/* required last entry */</span>
<a name="l00099"></a>00099     {0, }
<a name="l00100"></a>00100 };
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 MODULE_DEVICE_TABLE(pci, igb_pci_tbl);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keywordtype">void</span> igb_reset(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00105"></a>00105 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_setup_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00106"></a>00106 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_setup_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00107"></a>00107 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_free_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_free_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00109"></a>00109 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_setup_mrqc(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00110"></a>00110 <span class="keywordtype">void</span> igb_update_stats(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00111"></a>00111 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_probe(<span class="keyword">struct</span> pci_dev *, <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *);
<a name="l00112"></a>00112 <span class="keyword">static</span> <span class="keywordtype">void</span> __devexit igb_remove(<span class="keyword">struct</span> pci_dev *pdev);
<a name="l00113"></a>00113 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_sw_init(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00114"></a>00114 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_open(<span class="keyword">struct</span> net_device *);
<a name="l00115"></a>00115 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_close(<span class="keyword">struct</span> net_device *);
<a name="l00116"></a>00116 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_configure_tx(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_configure_rx(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_all_tx_rings(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00119"></a>00119 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_all_rx_rings(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00120"></a>00120 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_tx_ring(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *);
<a name="l00121"></a>00121 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_rx_mode(<span class="keyword">struct</span> net_device *);
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_update_phy_info(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_watchdog(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_watchdog_task(<span class="keyword">struct</span> work_struct *);
<a name="l00125"></a>00125 <span class="keyword">static</span> netdev_tx_t igb_xmit_frame(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *);
<a name="l00126"></a>00126 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *igb_get_stats(<span class="keyword">struct</span> net_device *);
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_change_mtu(<span class="keyword">struct</span> net_device *, <span class="keywordtype">int</span>);
<a name="l00128"></a>00128 <span class="keywordtype">void</span> igb_full_sync_mac_table(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter);
<a name="l00129"></a>00129 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_mac(<span class="keyword">struct</span> net_device *, <span class="keywordtype">void</span> *);
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_uta(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter);
<a name="l00131"></a>00131 <span class="keyword">static</span> irqreturn_t igb_intr(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *);
<a name="l00132"></a>00132 <span class="keyword">static</span> irqreturn_t igb_intr_msi(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *);
<a name="l00133"></a>00133 <span class="keyword">static</span> irqreturn_t igb_msix_other(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *);
<a name="l00134"></a>00134 <span class="keyword">static</span> irqreturn_t igb_msix_ring(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *);
<a name="l00135"></a>00135 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_update_dca(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *);
<a name="l00137"></a>00137 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_setup_dca(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00138"></a>00138 <span class="preprocessor">#endif </span><span class="comment">/* IGB_DCA */</span>
<a name="l00139"></a>00139 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_poll(<span class="keyword">struct</span> napi_struct *, <span class="keywordtype">int</span>);
<a name="l00140"></a>00140 <span class="keyword">static</span> <span class="keywordtype">bool</span> igb_clean_tx_irq(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *, <span class="keywordtype">int</span>);
<a name="l00141"></a>00141 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_rx_irq(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>);
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ioctl(<span class="keyword">struct</span> net_device *, <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *, <span class="keywordtype">int</span> cmd);
<a name="l00143"></a>00143 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_tx_timeout(<span class="keyword">struct</span> net_device *);
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_reset_task(<span class="keyword">struct</span> work_struct *);
<a name="l00145"></a>00145 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vlan_rx_register(<span class="keyword">struct</span> net_device *, <span class="keyword">struct</span> vlan_group *);
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vlan_rx_add_vid(<span class="keyword">struct</span> net_device *, u16);
<a name="l00147"></a>00147 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vlan_rx_kill_vid(<span class="keyword">struct</span> net_device *, u16);
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_restore_vlan(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00149"></a>00149 <span class="keywordtype">void</span> igb_rar_set(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 index);
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_ping_all_vfs(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00151"></a>00151 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_msg_task(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00152"></a>00152 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vmm_control(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00153"></a>00153 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_vf_mac(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *);
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_restore_vf_multicasts(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter);
<a name="l00155"></a>00155 <span class="preprocessor">#ifdef IFLA_VF_MAX</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_set_vf_mac( <span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> vf, u8 *mac);
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_set_vf_vlan(<span class="keyword">struct</span> net_device *netdev,
<a name="l00158"></a>00158                    <span class="keywordtype">int</span> vf, u16 vlan, u8 qos);
<a name="l00159"></a>00159 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_set_vf_bw(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> vf, <span class="keywordtype">int</span> tx_rate);
<a name="l00160"></a>00160 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_get_vf_config(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> vf,
<a name="l00161"></a>00161                  <span class="keyword">struct</span> ifla_vf_info *ivi);
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_check_vf_rate_limit(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *);
<a name="l00163"></a>00163 <span class="preprocessor">#endif</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> igb_suspend(<span class="keyword">struct</span> pci_dev *, pm_message_t);
<a name="l00166"></a>00166 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_resume(<span class="keyword">struct</span> pci_dev *);
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_shutdown(<span class="keyword">struct</span> pci_dev *);
<a name="l00170"></a>00170 <span class="preprocessor">#else</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> igb_notify_reboot(<span class="keyword">struct</span> notifier_block *, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">void</span> *);
<a name="l00172"></a>00172 <span class="keyword">static</span> <span class="keyword">struct </span>notifier_block igb_notifier_reboot = {
<a name="l00173"></a>00173     .notifier_call  = igb_notify_reboot,
<a name="l00174"></a>00174     .next       = NULL,
<a name="l00175"></a>00175     .priority   = 0
<a name="l00176"></a>00176 };
<a name="l00177"></a>00177 <span class="preprocessor">#endif</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> igb_notify_dca(<span class="keyword">struct</span> notifier_block *, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">void</span> *);
<a name="l00180"></a>00180 <span class="keyword">static</span> <span class="keyword">struct </span>notifier_block dca_notifier = {
<a name="l00181"></a>00181     .notifier_call  = igb_notify_dca,
<a name="l00182"></a>00182     .next       = NULL,
<a name="l00183"></a>00183     .priority   = 0
<a name="l00184"></a>00184 };
<a name="l00185"></a>00185 <span class="preprocessor">#endif</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="comment">/* for netdump / net console */</span>
<a name="l00188"></a>00188 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_netpoll(<span class="keyword">struct</span> net_device *);
<a name="l00189"></a>00189 <span class="preprocessor">#endif</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>
<a name="l00191"></a>00191 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span><span class="keyword">static</span> pci_ers_result_t igb_io_error_detected(<span class="keyword">struct</span> pci_dev *,
<a name="l00193"></a>00193              pci_channel_state_t);
<a name="l00194"></a>00194 <span class="keyword">static</span> pci_ers_result_t igb_io_slot_reset(<span class="keyword">struct</span> pci_dev *);
<a name="l00195"></a>00195 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_io_resume(<span class="keyword">struct</span> pci_dev *);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="keyword">static</span> <span class="keyword">struct </span>pci_error_handlers igb_err_handler = {
<a name="l00198"></a>00198     .error_detected = igb_io_error_detected,
<a name="l00199"></a>00199     .slot_reset = igb_io_slot_reset,
<a name="l00200"></a>00200     .resume = igb_io_resume,
<a name="l00201"></a>00201 };
<a name="l00202"></a>00202 <span class="preprocessor">#endif</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>
<a name="l00204"></a>00204 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_init_fw(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keyword">struct </span>pci_driver igb_driver = {
<a name="l00208"></a>00208     .name     = igb_driver_name,
<a name="l00209"></a>00209     .id_table = igb_pci_tbl,
<a name="l00210"></a>00210     .probe    = igb_probe,
<a name="l00211"></a>00211     .remove   = __devexit_p(igb_remove),
<a name="l00212"></a>00212 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>    <span class="comment">/* Power Managment Hooks */</span>
<a name="l00214"></a>00214     .suspend  = igb_suspend,
<a name="l00215"></a>00215     .resume   = igb_resume,
<a name="l00216"></a>00216 <span class="preprocessor">#endif</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span><span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>    .shutdown = igb_shutdown,
<a name="l00219"></a>00219 <span class="preprocessor">#endif</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>    .err_handler = &amp;igb_err_handler
<a name="l00222"></a>00222 <span class="preprocessor">#endif</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span>};
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 MODULE_AUTHOR(<span class="stringliteral">&quot;Intel Corporation, &lt;e1000-devel@lists.sourceforge.net&gt;&quot;</span>);
<a name="l00226"></a>00226 MODULE_DESCRIPTION(<span class="stringliteral">&quot;Intel(R) Gigabit Ethernet Network Driver&quot;</span>);
<a name="l00227"></a>00227 MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);
<a name="l00228"></a>00228 MODULE_VERSION(DRV_VERSION);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vfta_set(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 vid, <span class="keywordtype">bool</span> add)
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232     <span class="keyword">struct </span><a class="code" href="structe1000__host__mng__dhcp__cookie.html">e1000_host_mng_dhcp_cookie</a> *mng_cookie = &amp;hw-&gt;mng_cookie;
<a name="l00233"></a>00233     u32 index = (vid &gt;&gt; E1000_VFTA_ENTRY_SHIFT) &amp; E1000_VFTA_ENTRY_MASK;
<a name="l00234"></a>00234     u32 mask = 1 &lt;&lt; (vid &amp; E1000_VFTA_ENTRY_BIT_SHIFT_MASK);
<a name="l00235"></a>00235     u32 vfta;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="comment">/*</span>
<a name="l00238"></a>00238 <span class="comment">     * if this is the management vlan the only option is to add it in so</span>
<a name="l00239"></a>00239 <span class="comment">     * that the management pass through will continue to work</span>
<a name="l00240"></a>00240 <span class="comment">     */</span>
<a name="l00241"></a>00241     <span class="keywordflow">if</span> ((mng_cookie-&gt;status &amp; E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &amp;&amp;
<a name="l00242"></a>00242         (vid == mng_cookie-&gt;vlan_id))
<a name="l00243"></a>00243         add = TRUE;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     vfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);
<a name="l00246"></a>00246     <span class="keywordflow">if</span> (add)
<a name="l00247"></a>00247         vfta |= mask;
<a name="l00248"></a>00248     <span class="keywordflow">else</span>
<a name="l00249"></a>00249         vfta &amp;= ~mask;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     e1000_write_vfta(hw, index, vfta);
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>
<a name="l00258"></a>00258 <span class="keyword">static</span> cycle_t igb_read_clock(<span class="keyword">const</span> <span class="keyword">struct</span> cyclecounter *tc)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter =
<a name="l00261"></a>00261         container_of(tc, <span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a>, cycles);
<a name="l00262"></a>00262     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00263"></a>00263     u64 stamp = 0;
<a name="l00264"></a>00264     <span class="keywordtype">int</span> shift = 0;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266     <span class="comment">/*</span>
<a name="l00267"></a>00267 <span class="comment">     * The timestamp latches on lowest register read. For the 82580</span>
<a name="l00268"></a>00268 <span class="comment">     * the lowest register is SYSTIMR instead of SYSTIML.  However we never</span>
<a name="l00269"></a>00269 <span class="comment">     * adjusted TIMINCA so SYSTIMR will just read as all 0s so ignore it.</span>
<a name="l00270"></a>00270 <span class="comment">     */</span>
<a name="l00271"></a>00271     <span class="keywordflow">if</span> (hw-&gt;mac.type &gt;= e1000_82580) {
<a name="l00272"></a>00272         stamp = E1000_READ_REG(hw, E1000_SYSTIMR) &gt;&gt; 8;
<a name="l00273"></a>00273         shift = IGB_82580_TSYNC_SHIFT;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     stamp |= (u64)E1000_READ_REG(hw, E1000_SYSTIML) &lt;&lt; shift;
<a name="l00277"></a>00277     stamp |= (u64)E1000_READ_REG(hw, E1000_SYSTIML) &lt;&lt; shift;
<a name="l00278"></a>00278     stamp |= (u64)E1000_READ_REG(hw, E1000_SYSTIML) &lt;&lt; shift;
<a name="l00279"></a>00279     stamp |= (u64)E1000_READ_REG(hw, E1000_SYSTIML) &lt;&lt; shift;
<a name="l00280"></a>00280     stamp |= (u64)E1000_READ_REG(hw, E1000_SYSTIMH) &lt;&lt; (shift + 32);
<a name="l00281"></a>00281     <span class="keywordflow">return</span> stamp;
<a name="l00282"></a>00282 }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="preprocessor">#endif </span><span class="comment">/* SIOCSHWTSTAMP */</span>
<a name="l00285"></a>00285 <span class="keyword">static</span> <span class="keywordtype">int</span> debug = NETIF_MSG_DRV | NETIF_MSG_PROBE;
<a name="l00286"></a>00286 module_param(debug, <span class="keywordtype">int</span>, 0);
<a name="l00287"></a>00287 MODULE_PARM_DESC(debug, <span class="stringliteral">&quot;Debug level (0=none, ..., 16=all)&quot;</span>);
<a name="l00288"></a>00288 
<a name="l00295"></a>00295 <span class="keyword">static</span> <span class="keywordtype">int</span> __init igb_init_module(<span class="keywordtype">void</span>)
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297     <span class="keywordtype">int</span> ret;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     printk(KERN_INFO <span class="stringliteral">&quot;%s - version %s\n&quot;</span>,
<a name="l00300"></a>00300            igb_driver_string, igb_driver_version);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     printk(KERN_INFO <span class="stringliteral">&quot;%s\n&quot;</span>, igb_copyright);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span>    dca_register_notify(&amp;dca_notifier);
<a name="l00306"></a>00306 <span class="preprocessor">#endif</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>    ret = pci_register_driver(&amp;igb_driver);
<a name="l00308"></a>00308 <span class="preprocessor">#ifdef USE_REBOOT_NOTIFIER</span>
<a name="l00309"></a>00309 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ret &gt;= 0) {
<a name="l00310"></a>00310         register_reboot_notifier(&amp;igb_notifier_reboot);
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312 <span class="preprocessor">#endif</span>
<a name="l00313"></a>00313 <span class="preprocessor"></span>    <span class="keywordflow">return</span> ret;
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 module_init(igb_init_module);
<a name="l00317"></a>00317 
<a name="l00324"></a>00324 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit igb_exit_module(<span class="keywordtype">void</span>)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l00327"></a>00327 <span class="preprocessor"></span>    dca_unregister_notify(&amp;dca_notifier);
<a name="l00328"></a>00328 <span class="preprocessor">#endif</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span><span class="preprocessor">#ifdef USE_REBOOT_NOTIFIER</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>    unregister_reboot_notifier(&amp;igb_notifier_reboot);
<a name="l00331"></a>00331 <span class="preprocessor">#endif</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>    pci_unregister_driver(&amp;igb_driver);
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 module_exit(igb_exit_module);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="preprocessor">#define Q_IDX_82576(i) (((i &amp; 0x1) &lt;&lt; 3) + (i &gt;&gt; 1))</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span>
<a name="l00345"></a>00345 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_cache_ring_register(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00346"></a>00346 {
<a name="l00347"></a>00347     <span class="keywordtype">int</span> i = 0, j = 0;
<a name="l00348"></a>00348     u32 rbase_offset = adapter-&gt;vfs_allocated_count;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l00351"></a>00351     <span class="keywordflow">case</span> e1000_82576:
<a name="l00352"></a>00352         <span class="comment">/* The queues are allocated for virtualization such that VF 0</span>
<a name="l00353"></a>00353 <span class="comment">         * is allocated queues 0 and 8, VF 1 queues 1 and 9, etc.</span>
<a name="l00354"></a>00354 <span class="comment">         * In order to avoid collision we start at the first free queue</span>
<a name="l00355"></a>00355 <span class="comment">         * and continue consuming queues in the same sequence</span>
<a name="l00356"></a>00356 <span class="comment">         */</span>
<a name="l00357"></a>00357         <span class="keywordflow">if</span> ((adapter-&gt;rss_queues &gt; 1) &amp;&amp; adapter-&gt;vmdq_pools) {
<a name="l00358"></a>00358             <span class="keywordflow">for</span> (; i &lt; adapter-&gt;rss_queues; i++)
<a name="l00359"></a>00359                 adapter-&gt;rx_ring[i]-&gt;reg_idx = rbase_offset +
<a name="l00360"></a>00360                                                Q_IDX_82576(i);
<a name="l00361"></a>00361         }
<a name="l00362"></a>00362     <span class="keywordflow">case</span> e1000_82575:
<a name="l00363"></a>00363     <span class="keywordflow">case</span> e1000_82580:
<a name="l00364"></a>00364     <span class="keywordflow">case</span> e1000_i350:
<a name="l00365"></a>00365     <span class="keywordflow">default</span>:
<a name="l00366"></a>00366         <span class="keywordflow">for</span> (; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l00367"></a>00367             adapter-&gt;rx_ring[i]-&gt;reg_idx = rbase_offset + i;
<a name="l00368"></a>00368         for (; j &lt; adapter-&gt;num_tx_queues; j++)
<a name="l00369"></a>00369             adapter-&gt;tx_ring[j]-&gt;reg_idx = rbase_offset + j;
<a name="l00370"></a>00370         <span class="keywordflow">break</span>;
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_free_queues(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00375"></a>00375 {
<a name="l00376"></a>00376     <span class="keywordtype">int</span> i;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l00379"></a>00379         kfree(adapter-&gt;tx_ring[i]);
<a name="l00380"></a>00380         adapter-&gt;tx_ring[i] = NULL;
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l00383"></a>00383         kfree(adapter-&gt;rx_ring[i]);
<a name="l00384"></a>00384         adapter-&gt;rx_ring[i] = NULL;
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386     adapter-&gt;num_rx_queues = 0;
<a name="l00387"></a>00387     adapter-&gt;num_tx_queues = 0;
<a name="l00388"></a>00388 }
<a name="l00389"></a>00389 
<a name="l00397"></a>00397 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_alloc_queues(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399     <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *ring;
<a name="l00400"></a>00400     <span class="keywordtype">int</span> i;
<a name="l00401"></a>00401 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l00402"></a>00402 <span class="preprocessor"></span>    <span class="keywordtype">int</span> orig_node = adapter-&gt;node;
<a name="l00403"></a>00403 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l00406"></a>00406 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (orig_node == -1) {
<a name="l00408"></a>00408             <span class="keywordtype">int</span> cur_node = next_online_node(adapter-&gt;node);
<a name="l00409"></a>00409             <span class="keywordflow">if</span> (cur_node == MAX_NUMNODES)
<a name="l00410"></a>00410                 cur_node = first_online_node;
<a name="l00411"></a>00411             adapter-&gt;node = cur_node;
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l00414"></a>00414         ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a>), GFP_KERNEL,
<a name="l00415"></a>00415                             adapter-&gt;node);
<a name="l00416"></a>00416         <span class="keywordflow">if</span> (!ring)
<a name="l00417"></a>00417             ring = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a>), GFP_KERNEL);
<a name="l00418"></a>00418         <span class="keywordflow">if</span> (!ring)
<a name="l00419"></a>00419             <span class="keywordflow">goto</span> err;
<a name="l00420"></a>00420         ring-&gt;count = adapter-&gt;tx_ring_count;
<a name="l00421"></a>00421         ring-&gt;queue_index = i;
<a name="l00422"></a>00422         ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l00423"></a>00423         ring-&gt;netdev = adapter-&gt;netdev;
<a name="l00424"></a>00424         ring-&gt;numa_node = adapter-&gt;node;
<a name="l00425"></a>00425         <span class="comment">/* For 82575, context index must be unique per ring. */</span>
<a name="l00426"></a>00426         <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == e1000_82575)
<a name="l00427"></a>00427             set_bit(IGB_RING_FLAG_TX_CTX_IDX, &amp;ring-&gt;flags);
<a name="l00428"></a>00428         adapter-&gt;tx_ring[i] = ring;
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l00432"></a>00432     adapter-&gt;node = orig_node;
<a name="l00433"></a>00433 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l00436"></a>00436 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (orig_node == -1) {
<a name="l00438"></a>00438             <span class="keywordtype">int</span> cur_node = next_online_node(adapter-&gt;node);
<a name="l00439"></a>00439             <span class="keywordflow">if</span> (cur_node == MAX_NUMNODES)
<a name="l00440"></a>00440                 cur_node = first_online_node;
<a name="l00441"></a>00441             adapter-&gt;node = cur_node;
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l00444"></a>00444         ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a>), GFP_KERNEL,
<a name="l00445"></a>00445                             adapter-&gt;node);
<a name="l00446"></a>00446         <span class="keywordflow">if</span> (!ring)
<a name="l00447"></a>00447             ring = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a>), GFP_KERNEL);
<a name="l00448"></a>00448         <span class="keywordflow">if</span> (!ring)
<a name="l00449"></a>00449             <span class="keywordflow">goto</span> err;
<a name="l00450"></a>00450         ring-&gt;count = adapter-&gt;rx_ring_count;
<a name="l00451"></a>00451         ring-&gt;queue_index = i;
<a name="l00452"></a>00452         ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l00453"></a>00453         ring-&gt;netdev = adapter-&gt;netdev;
<a name="l00454"></a>00454         ring-&gt;numa_node = adapter-&gt;node;
<a name="l00455"></a>00455 <span class="preprocessor">#ifdef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span>        ring-&gt;rx_buffer_len = MAXIMUM_ETHERNET_VLAN_SIZE;
<a name="l00457"></a>00457 <span class="preprocessor">#endif</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span>        <span class="comment">/* enable rx checksum */</span>
<a name="l00459"></a>00459         set_bit(IGB_RING_FLAG_RX_CSUM, &amp;ring-&gt;flags);
<a name="l00460"></a>00460         <span class="comment">/* set flag indicating ring supports SCTP checksum offload */</span>
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type &gt;= e1000_82576)
<a name="l00462"></a>00462             set_bit(IGB_RING_FLAG_RX_SCTP_CSUM, &amp;ring-&gt;flags);
<a name="l00463"></a>00463 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l00464"></a>00464 <span class="preprocessor"></span>        <span class="comment">/* set flag enabling LRO */</span>
<a name="l00465"></a>00465         <span class="keywordflow">if</span> (i &lt; adapter-&gt;rss_queues)
<a name="l00466"></a>00466             set_bit(IGB_RING_FLAG_RX_LRO, &amp;ring-&gt;flags);
<a name="l00467"></a>00467 <span class="preprocessor">#endif</span>
<a name="l00468"></a>00468 <span class="preprocessor"></span>        <span class="comment">/* On i350, loopback VLAN packets have the tag byte-swapped. */</span>
<a name="l00469"></a>00469         <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == e1000_i350)
<a name="l00470"></a>00470             set_bit(IGB_RING_FLAG_RX_LB_VLAN_BSWAP, &amp;ring-&gt;flags);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         adapter-&gt;rx_ring[i] = ring;
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l00475"></a>00475 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l00476"></a>00476     adapter-&gt;node = orig_node;
<a name="l00477"></a>00477 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l00478"></a>00478 
<a name="l00479"></a>00479     igb_cache_ring_register(adapter);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 err:
<a name="l00484"></a>00484 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l00485"></a>00485 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l00486"></a>00486     adapter-&gt;node = orig_node;
<a name="l00487"></a>00487 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l00488"></a>00488     igb_free_queues(adapter);
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="keywordflow">return</span> -ENOMEM;
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_configure_lli(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00494"></a>00494 {
<a name="l00495"></a>00495     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00496"></a>00496     u16 port;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498     <span class="comment">/* LLI should only be enabled for MSI-X or MSI interrupts */</span>
<a name="l00499"></a>00499     <span class="keywordflow">if</span> (!adapter-&gt;msix_entries &amp;&amp; !(adapter-&gt;flags &amp; IGB_FLAG_HAS_MSI))
<a name="l00500"></a>00500         <span class="keywordflow">return</span>;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="keywordflow">if</span> (adapter-&gt;lli_port) {
<a name="l00503"></a>00503         <span class="comment">/* use filter 0 for port */</span>
<a name="l00504"></a>00504         port = htons((u16)adapter-&gt;lli_port);
<a name="l00505"></a>00505         E1000_WRITE_REG(hw, E1000_IMIR(0),
<a name="l00506"></a>00506             (port | E1000_IMIR_PORT_IM_EN));
<a name="l00507"></a>00507         E1000_WRITE_REG(hw, E1000_IMIREXT(0),
<a name="l00508"></a>00508             (E1000_IMIREXT_SIZE_BP | E1000_IMIREXT_CTRL_BP));
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_LLI_PUSH) {
<a name="l00512"></a>00512         <span class="comment">/* use filter 1 for push flag */</span>
<a name="l00513"></a>00513         E1000_WRITE_REG(hw, E1000_IMIR(1),
<a name="l00514"></a>00514             (E1000_IMIR_PORT_BP | E1000_IMIR_PORT_IM_EN));
<a name="l00515"></a>00515         E1000_WRITE_REG(hw, E1000_IMIREXT(1),
<a name="l00516"></a>00516             (E1000_IMIREXT_SIZE_BP | E1000_IMIREXT_CTRL_PSH));
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     <span class="keywordflow">if</span> (adapter-&gt;lli_size) {
<a name="l00520"></a>00520         <span class="comment">/* use filter 2 for size */</span>
<a name="l00521"></a>00521         E1000_WRITE_REG(hw, E1000_IMIR(2),
<a name="l00522"></a>00522             (E1000_IMIR_PORT_BP | E1000_IMIR_PORT_IM_EN));
<a name="l00523"></a>00523         E1000_WRITE_REG(hw, E1000_IMIREXT(2),
<a name="l00524"></a>00524             (adapter-&gt;lli_size | E1000_IMIREXT_CTRL_BP));
<a name="l00525"></a>00525     }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="preprocessor">#define IGB_N0_QUEUE -1</span>
<a name="l00530"></a>00530 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_assign_vector(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector, <span class="keywordtype">int</span> msix_vector)
<a name="l00531"></a>00531 {
<a name="l00532"></a>00532     u32 msixbm = 0;
<a name="l00533"></a>00533     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l00534"></a>00534     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00535"></a>00535     u32 ivar, index;
<a name="l00536"></a>00536     <span class="keywordtype">int</span> rx_queue = IGB_N0_QUEUE;
<a name="l00537"></a>00537     <span class="keywordtype">int</span> tx_queue = IGB_N0_QUEUE;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539     <span class="keywordflow">if</span> (q_vector-&gt;rx_ring)
<a name="l00540"></a>00540         rx_queue = q_vector-&gt;rx_ring-&gt;reg_idx;
<a name="l00541"></a>00541     <span class="keywordflow">if</span> (q_vector-&gt;tx_ring)
<a name="l00542"></a>00542         tx_queue = q_vector-&gt;tx_ring-&gt;reg_idx;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00545"></a>00545     <span class="keywordflow">case</span> e1000_82575:
<a name="l00546"></a>00546         <span class="comment">/* The 82575 assigns vectors using a bitmask, which matches the</span>
<a name="l00547"></a>00547 <span class="comment">           bitmask for the EICR/EIMS/EIMC registers.  To assign one</span>
<a name="l00548"></a>00548 <span class="comment">           or more queues to a vector, we write the appropriate bits</span>
<a name="l00549"></a>00549 <span class="comment">           into the MSIXBM register for that vector. */</span>
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (rx_queue &gt; IGB_N0_QUEUE)
<a name="l00551"></a>00551             msixbm = E1000_EICR_RX_QUEUE0 &lt;&lt; rx_queue;
<a name="l00552"></a>00552         <span class="keywordflow">if</span> (tx_queue &gt; IGB_N0_QUEUE)
<a name="l00553"></a>00553             msixbm |= E1000_EICR_TX_QUEUE0 &lt;&lt; tx_queue;
<a name="l00554"></a>00554         <span class="keywordflow">if</span> (!adapter-&gt;msix_entries &amp;&amp; msix_vector == 0)
<a name="l00555"></a>00555             msixbm |= E1000_EIMS_OTHER;
<a name="l00556"></a>00556         E1000_WRITE_REG_ARRAY(hw, E1000_MSIXBM(0), msix_vector, msixbm);
<a name="l00557"></a>00557         q_vector-&gt;eims_value = msixbm;
<a name="l00558"></a>00558         <span class="keywordflow">break</span>;
<a name="l00559"></a>00559     <span class="keywordflow">case</span> e1000_82576:
<a name="l00560"></a>00560         <span class="comment">/* 82576 uses a table-based method for assigning vectors.</span>
<a name="l00561"></a>00561 <span class="comment">           Each queue has a single entry in the table to which we write</span>
<a name="l00562"></a>00562 <span class="comment">           a vector number along with a &quot;valid&quot; bit.  Sadly, the layout</span>
<a name="l00563"></a>00563 <span class="comment">           of the table is somewhat counterintuitive. */</span>
<a name="l00564"></a>00564         <span class="keywordflow">if</span> (rx_queue &gt; IGB_N0_QUEUE) {
<a name="l00565"></a>00565             index = (rx_queue &amp; 0x7);
<a name="l00566"></a>00566             ivar = E1000_READ_REG_ARRAY(hw, E1000_IVAR0, index);
<a name="l00567"></a>00567             <span class="keywordflow">if</span> (rx_queue &lt; 8) {
<a name="l00568"></a>00568                 <span class="comment">/* vector goes into low byte of register */</span>
<a name="l00569"></a>00569                 ivar = ivar &amp; 0xFFFFFF00;
<a name="l00570"></a>00570                 ivar |= msix_vector | E1000_IVAR_VALID;
<a name="l00571"></a>00571             } <span class="keywordflow">else</span> {
<a name="l00572"></a>00572                 <span class="comment">/* vector goes into third byte of register */</span>
<a name="l00573"></a>00573                 ivar = ivar &amp; 0xFF00FFFF;
<a name="l00574"></a>00574                 ivar |= (msix_vector | E1000_IVAR_VALID) &lt;&lt; 16;
<a name="l00575"></a>00575             }
<a name="l00576"></a>00576             E1000_WRITE_REG_ARRAY(hw, E1000_IVAR0, index, ivar);
<a name="l00577"></a>00577         }
<a name="l00578"></a>00578         <span class="keywordflow">if</span> (tx_queue &gt; IGB_N0_QUEUE) {
<a name="l00579"></a>00579             index = (tx_queue &amp; 0x7);
<a name="l00580"></a>00580             ivar = E1000_READ_REG_ARRAY(hw, E1000_IVAR0, index);
<a name="l00581"></a>00581             <span class="keywordflow">if</span> (tx_queue &lt; 8) {
<a name="l00582"></a>00582                 <span class="comment">/* vector goes into second byte of register */</span>
<a name="l00583"></a>00583                 ivar = ivar &amp; 0xFFFF00FF;
<a name="l00584"></a>00584                 ivar |= (msix_vector | E1000_IVAR_VALID) &lt;&lt; 8;
<a name="l00585"></a>00585             } <span class="keywordflow">else</span> {
<a name="l00586"></a>00586                 <span class="comment">/* vector goes into high byte of register */</span>
<a name="l00587"></a>00587                 ivar = ivar &amp; 0x00FFFFFF;
<a name="l00588"></a>00588                 ivar |= (msix_vector | E1000_IVAR_VALID) &lt;&lt; 24;
<a name="l00589"></a>00589             }
<a name="l00590"></a>00590             E1000_WRITE_REG_ARRAY(hw, E1000_IVAR0, index, ivar);
<a name="l00591"></a>00591         }
<a name="l00592"></a>00592         q_vector-&gt;eims_value = 1 &lt;&lt; msix_vector;
<a name="l00593"></a>00593         <span class="keywordflow">break</span>;
<a name="l00594"></a>00594     <span class="keywordflow">case</span> e1000_82580:
<a name="l00595"></a>00595     <span class="keywordflow">case</span> e1000_i350:
<a name="l00596"></a>00596         <span class="comment">/* 82580 uses the same table-based approach as 82576 but has fewer</span>
<a name="l00597"></a>00597 <span class="comment">           entries as a result we carry over for queues greater than 4. */</span>
<a name="l00598"></a>00598         <span class="keywordflow">if</span> (rx_queue &gt; IGB_N0_QUEUE) {
<a name="l00599"></a>00599             index = (rx_queue &gt;&gt; 1);
<a name="l00600"></a>00600             ivar = E1000_READ_REG_ARRAY(hw, E1000_IVAR0, index);
<a name="l00601"></a>00601             <span class="keywordflow">if</span> (rx_queue &amp; 0x1) {
<a name="l00602"></a>00602                 <span class="comment">/* vector goes into third byte of register */</span>
<a name="l00603"></a>00603                 ivar = ivar &amp; 0xFF00FFFF;
<a name="l00604"></a>00604                 ivar |= (msix_vector | E1000_IVAR_VALID) &lt;&lt; 16;
<a name="l00605"></a>00605             } <span class="keywordflow">else</span> {
<a name="l00606"></a>00606                 <span class="comment">/* vector goes into low byte of register */</span>
<a name="l00607"></a>00607                 ivar = ivar &amp; 0xFFFFFF00;
<a name="l00608"></a>00608                 ivar |= msix_vector | E1000_IVAR_VALID;
<a name="l00609"></a>00609             }
<a name="l00610"></a>00610             E1000_WRITE_REG_ARRAY(hw, E1000_IVAR0, index, ivar);
<a name="l00611"></a>00611         }
<a name="l00612"></a>00612         <span class="keywordflow">if</span> (tx_queue &gt; IGB_N0_QUEUE) {
<a name="l00613"></a>00613             index = (tx_queue &gt;&gt; 1);
<a name="l00614"></a>00614             ivar = E1000_READ_REG_ARRAY(hw, E1000_IVAR0, index);
<a name="l00615"></a>00615             <span class="keywordflow">if</span> (tx_queue &amp; 0x1) {
<a name="l00616"></a>00616                 <span class="comment">/* vector goes into high byte of register */</span>
<a name="l00617"></a>00617                 ivar = ivar &amp; 0x00FFFFFF;
<a name="l00618"></a>00618                 ivar |= (msix_vector | E1000_IVAR_VALID) &lt;&lt; 24;
<a name="l00619"></a>00619             } <span class="keywordflow">else</span> {
<a name="l00620"></a>00620                 <span class="comment">/* vector goes into second byte of register */</span>
<a name="l00621"></a>00621                 ivar = ivar &amp; 0xFFFF00FF;
<a name="l00622"></a>00622                 ivar |= (msix_vector | E1000_IVAR_VALID) &lt;&lt; 8;
<a name="l00623"></a>00623             }
<a name="l00624"></a>00624             E1000_WRITE_REG_ARRAY(hw, E1000_IVAR0, index, ivar);
<a name="l00625"></a>00625         }
<a name="l00626"></a>00626         q_vector-&gt;eims_value = 1 &lt;&lt; msix_vector;
<a name="l00627"></a>00627         <span class="keywordflow">break</span>;
<a name="l00628"></a>00628     <span class="keywordflow">default</span>:
<a name="l00629"></a>00629         BUG();
<a name="l00630"></a>00630         <span class="keywordflow">break</span>;
<a name="l00631"></a>00631     }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633     <span class="comment">/* add q_vector eims value to global eims_enable_mask */</span>
<a name="l00634"></a>00634     adapter-&gt;eims_enable_mask |= q_vector-&gt;eims_value;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636     <span class="comment">/* configure q_vector to set itr on first interrupt */</span>
<a name="l00637"></a>00637     q_vector-&gt;set_itr = 1;
<a name="l00638"></a>00638 }
<a name="l00639"></a>00639 
<a name="l00646"></a>00646 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_configure_msix(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648     u32 tmp;
<a name="l00649"></a>00649     <span class="keywordtype">int</span> i, vector = 0;
<a name="l00650"></a>00650     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652     adapter-&gt;eims_enable_mask = 0;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654     <span class="comment">/* set vector for other causes, i.e. link changes */</span>
<a name="l00655"></a>00655     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00656"></a>00656     <span class="keywordflow">case</span> e1000_82575:
<a name="l00657"></a>00657         tmp = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l00658"></a>00658         <span class="comment">/* enable MSI-X PBA support*/</span>
<a name="l00659"></a>00659         tmp |= E1000_CTRL_EXT_PBA_CLR;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661         <span class="comment">/* Auto-Mask interrupts upon ICR read. */</span>
<a name="l00662"></a>00662         tmp |= E1000_CTRL_EXT_EIAME;
<a name="l00663"></a>00663         tmp |= E1000_CTRL_EXT_IRCA;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665         E1000_WRITE_REG(hw, E1000_CTRL_EXT, tmp);
<a name="l00666"></a>00666 
<a name="l00667"></a>00667         <span class="comment">/* enable msix_other interrupt */</span>
<a name="l00668"></a>00668         E1000_WRITE_REG_ARRAY(hw, E1000_MSIXBM(0), vector++,
<a name="l00669"></a>00669                               E1000_EIMS_OTHER);
<a name="l00670"></a>00670         adapter-&gt;eims_other = E1000_EIMS_OTHER;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <span class="keywordflow">break</span>;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     <span class="keywordflow">case</span> e1000_82576:
<a name="l00675"></a>00675     <span class="keywordflow">case</span> e1000_82580:
<a name="l00676"></a>00676     <span class="keywordflow">case</span> e1000_i350:
<a name="l00677"></a>00677         <span class="comment">/* Turn on MSI-X capability first, or our settings</span>
<a name="l00678"></a>00678 <span class="comment">         * won&#39;t stick.  And it will take days to debug. */</span>
<a name="l00679"></a>00679         E1000_WRITE_REG(hw, E1000_GPIE, E1000_GPIE_MSIX_MODE |
<a name="l00680"></a>00680                         E1000_GPIE_PBA | E1000_GPIE_EIAME |
<a name="l00681"></a>00681                         E1000_GPIE_NSICR);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <span class="comment">/* enable msix_other interrupt */</span>
<a name="l00684"></a>00684         adapter-&gt;eims_other = 1 &lt;&lt; vector;
<a name="l00685"></a>00685         tmp = (vector++ | E1000_IVAR_VALID) &lt;&lt; 8;
<a name="l00686"></a>00686 
<a name="l00687"></a>00687         E1000_WRITE_REG(hw, E1000_IVAR_MISC, tmp);
<a name="l00688"></a>00688         <span class="keywordflow">break</span>;
<a name="l00689"></a>00689     <span class="keywordflow">default</span>:
<a name="l00690"></a>00690         <span class="comment">/* do nothing, since nothing else supports MSI-X */</span>
<a name="l00691"></a>00691         <span class="keywordflow">break</span>;
<a name="l00692"></a>00692     } <span class="comment">/* switch (hw-&gt;mac.type) */</span>
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     adapter-&gt;eims_enable_mask |= adapter-&gt;eims_other;
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)
<a name="l00697"></a>00697         igb_assign_vector(adapter-&gt;q_vector[i], vector++);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699     E1000_WRITE_FLUSH(hw);
<a name="l00700"></a>00700 }
<a name="l00701"></a>00701 
<a name="l00708"></a>00708 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_request_msix(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00709"></a>00709 {
<a name="l00710"></a>00710     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l00711"></a>00711     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00712"></a>00712     <span class="keywordtype">int</span> i, err = 0, vector = 0;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714     err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l00715"></a>00715                       &amp;igb_msix_other, 0, netdev-&gt;name, adapter);
<a name="l00716"></a>00716     <span class="keywordflow">if</span> (err)
<a name="l00717"></a>00717         <span class="keywordflow">goto</span> out;
<a name="l00718"></a>00718     vector++;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++) {
<a name="l00721"></a>00721         <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector = adapter-&gt;q_vector[i];
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         q_vector-&gt;itr_register = hw-&gt;hw_addr + E1000_EITR(vector);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         <span class="keywordflow">if</span> (q_vector-&gt;rx_ring &amp;&amp; q_vector-&gt;tx_ring)
<a name="l00726"></a>00726             sprintf(q_vector-&gt;name, <span class="stringliteral">&quot;%s-TxRx-%u&quot;</span>, netdev-&gt;name,
<a name="l00727"></a>00727                     q_vector-&gt;rx_ring-&gt;queue_index);
<a name="l00728"></a>00728         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (q_vector-&gt;tx_ring)
<a name="l00729"></a>00729             sprintf(q_vector-&gt;name, <span class="stringliteral">&quot;%s-tx-%u&quot;</span>, netdev-&gt;name,
<a name="l00730"></a>00730                     q_vector-&gt;tx_ring-&gt;queue_index);
<a name="l00731"></a>00731         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (q_vector-&gt;rx_ring)
<a name="l00732"></a>00732             sprintf(q_vector-&gt;name, <span class="stringliteral">&quot;%s-rx-%u&quot;</span>, netdev-&gt;name,
<a name="l00733"></a>00733                     q_vector-&gt;rx_ring-&gt;queue_index);
<a name="l00734"></a>00734         <span class="keywordflow">else</span>
<a name="l00735"></a>00735             sprintf(q_vector-&gt;name, <span class="stringliteral">&quot;%s-unused&quot;</span>, netdev-&gt;name);
<a name="l00736"></a>00736 
<a name="l00737"></a>00737         err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l00738"></a>00738                           igb_msix_ring, 0, q_vector-&gt;name,
<a name="l00739"></a>00739                           q_vector);
<a name="l00740"></a>00740         <span class="keywordflow">if</span> (err)
<a name="l00741"></a>00741             <span class="keywordflow">goto</span> out;
<a name="l00742"></a>00742         vector++;
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     igb_configure_msix(adapter);
<a name="l00746"></a>00746 out:
<a name="l00747"></a>00747     <span class="keywordflow">return</span> err;
<a name="l00748"></a>00748 }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_reset_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l00753"></a>00753         pci_disable_msix(adapter-&gt;pdev);
<a name="l00754"></a>00754         kfree(adapter-&gt;msix_entries);
<a name="l00755"></a>00755         adapter-&gt;msix_entries = NULL;
<a name="l00756"></a>00756     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_HAS_MSI) {
<a name="l00757"></a>00757         pci_disable_msi(adapter-&gt;pdev);
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759 }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l00762"></a>00762 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_lro_ring_exit(<span class="keyword">struct</span> igb_lro_list *lrolist)
<a name="l00763"></a>00763 {
<a name="l00764"></a>00764     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l00765"></a>00765     <span class="keyword">struct </span>igb_lro_desc *lrod;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;active,
<a name="l00768"></a>00768                               lro_node) {
<a name="l00769"></a>00769         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l00770"></a>00770         kfree(lrod);
<a name="l00771"></a>00771     }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;free,
<a name="l00774"></a>00774                               lro_node) {
<a name="l00775"></a>00775         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l00776"></a>00776         kfree(lrod);
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778 }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_lro_ring_init(<span class="keyword">struct</span> igb_lro_list *lrolist)
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782     <span class="keywordtype">int</span> j, bytes;
<a name="l00783"></a>00783     <span class="keyword">struct </span>igb_lro_desc *lrod;
<a name="l00784"></a>00784 
<a name="l00785"></a>00785     bytes = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>igb_lro_desc);
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     INIT_HLIST_HEAD(&amp;lrolist-&gt;free);
<a name="l00788"></a>00788     INIT_HLIST_HEAD(&amp;lrolist-&gt;active);
<a name="l00789"></a>00789 
<a name="l00790"></a>00790     <span class="keywordflow">for</span> (j = 0; j &lt; IGB_LRO_MAX; j++) {
<a name="l00791"></a>00791         lrod = kzalloc(bytes, GFP_KERNEL);
<a name="l00792"></a>00792         <span class="keywordflow">if</span> (lrod != NULL) {
<a name="l00793"></a>00793             INIT_HLIST_NODE(&amp;lrod-&gt;lro_node);
<a name="l00794"></a>00794             hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;free);
<a name="l00795"></a>00795         }
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797 }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799 <span class="preprocessor">#endif </span><span class="comment">/* IGB_LRO */</span>
<a name="l00800"></a>00800 
<a name="l00808"></a>00808 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_free_q_vectors(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00809"></a>00809 {
<a name="l00810"></a>00810     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector;
<a name="l00811"></a>00811     <span class="keywordtype">int</span> v_idx;
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; adapter-&gt;num_q_vectors; v_idx++) {
<a name="l00814"></a>00814         q_vector = adapter-&gt;q_vector[v_idx];
<a name="l00815"></a>00815         adapter-&gt;q_vector[v_idx] = NULL;
<a name="l00816"></a>00816         <span class="keywordflow">if</span> (!q_vector)
<a name="l00817"></a>00817             <span class="keywordflow">continue</span>;
<a name="l00818"></a>00818         netif_napi_del(&amp;q_vector-&gt;napi);
<a name="l00819"></a>00819 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l00820"></a>00820 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (q_vector-&gt;lrolist) {
<a name="l00821"></a>00821             igb_lro_ring_exit(q_vector-&gt;lrolist);
<a name="l00822"></a>00822             vfree(q_vector-&gt;lrolist);
<a name="l00823"></a>00823             q_vector-&gt;lrolist = NULL;
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825 <span class="preprocessor">#endif</span>
<a name="l00826"></a>00826 <span class="preprocessor"></span>        kfree(q_vector);
<a name="l00827"></a>00827     }
<a name="l00828"></a>00828     adapter-&gt;num_q_vectors = 0;
<a name="l00829"></a>00829 }
<a name="l00830"></a>00830 
<a name="l00837"></a>00837 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clear_interrupt_scheme(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00838"></a>00838 {
<a name="l00839"></a>00839     igb_free_queues(adapter);
<a name="l00840"></a>00840     igb_free_q_vectors(adapter);
<a name="l00841"></a>00841     igb_reset_interrupt_capability(adapter);
<a name="l00842"></a>00842 }
<a name="l00843"></a>00843 
<a name="l00850"></a>00850 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_reset_sriov_capability(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00851"></a>00851 {
<a name="l00852"></a>00852     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l00853"></a>00853     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     <span class="comment">/* reclaim resources allocated to VFs */</span>
<a name="l00856"></a>00856     <span class="keywordflow">if</span> (adapter-&gt;vf_data) {
<a name="l00857"></a>00857         <span class="comment">/* disable iov and allow time for transactions to clear */</span>
<a name="l00858"></a>00858         pci_disable_sriov(pdev);
<a name="l00859"></a>00859         msleep(500);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861         <span class="comment">/* free vf data storage */</span>
<a name="l00862"></a>00862         kfree(adapter-&gt;vf_data);
<a name="l00863"></a>00863         adapter-&gt;vf_data = NULL;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865         <span class="comment">/* switch rings back to PF ownership */</span>
<a name="l00866"></a>00866         E1000_WRITE_REG(hw, E1000_IOVCTL, E1000_IOVCTL_REUSE_VFQ);
<a name="l00867"></a>00867         msleep(100);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869         dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;IOV Disabled\n&quot;</span>);
<a name="l00870"></a>00870     }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     adapter-&gt;vfs_allocated_count = 0;
<a name="l00873"></a>00873 }
<a name="l00874"></a>00874 
<a name="l00881"></a>00881 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_sriov_capability(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00882"></a>00882 {
<a name="l00883"></a>00883     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l00884"></a>00884     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mac_addr[ETH_ALEN];
<a name="l00885"></a>00885     <span class="keywordtype">int</span> i;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     <span class="comment">/* no VFs requested, do nothing */</span>
<a name="l00888"></a>00888     <span class="keywordflow">if</span> (!adapter-&gt;vfs_allocated_count)
<a name="l00889"></a>00889         <span class="keywordflow">return</span>;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     <span class="comment">/* allocate vf data storage */</span>
<a name="l00892"></a>00892     adapter-&gt;vf_data = kcalloc(adapter-&gt;vfs_allocated_count,
<a name="l00893"></a>00893                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvf__data__storage.html">vf_data_storage</a>),
<a name="l00894"></a>00894                                GFP_KERNEL);
<a name="l00895"></a>00895 
<a name="l00896"></a>00896     <span class="keywordflow">if</span> (adapter-&gt;vf_data) {
<a name="l00897"></a>00897         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;vfs_allocated_count; i++) {
<a name="l00898"></a>00898             random_ether_addr(mac_addr);
<a name="l00899"></a>00899             igb_set_vf_mac(adapter, i, mac_addr);
<a name="l00900"></a>00900         }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902         <span class="keywordflow">if</span> (!pci_enable_sriov(pdev, adapter-&gt;vfs_allocated_count)) {
<a name="l00903"></a>00903             <span class="comment">/* DMA Coalescing is not supported in IOV mode. */</span>
<a name="l00904"></a>00904             <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_DMAC)
<a name="l00905"></a>00905                 adapter-&gt;flags &amp;= ~IGB_FLAG_DMAC;
<a name="l00906"></a>00906             <span class="keywordflow">return</span>;
<a name="l00907"></a>00907         }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909         kfree(adapter-&gt;vf_data);
<a name="l00910"></a>00910         adapter-&gt;vf_data = NULL;
<a name="l00911"></a>00911     }
<a name="l00912"></a>00912 
<a name="l00913"></a>00913     adapter-&gt;vfs_allocated_count = 0;
<a name="l00914"></a>00914     dev_warn(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Failed to initialize SR-IOV virtualization\n&quot;</span>);
<a name="l00915"></a>00915 }
<a name="l00916"></a>00916 
<a name="l00923"></a>00923 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l00924"></a>00924 {
<a name="l00925"></a>00925     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l00926"></a>00926     <span class="keywordtype">int</span> err;
<a name="l00927"></a>00927     <span class="keywordtype">int</span> numvecs, i;
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     <span class="comment">/* Number of supported queues. */</span>
<a name="l00930"></a>00930     adapter-&gt;num_rx_queues = adapter-&gt;rss_queues;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     <span class="keywordflow">if</span> (adapter-&gt;vmdq_pools &gt; 1)
<a name="l00933"></a>00933         adapter-&gt;num_rx_queues += adapter-&gt;vmdq_pools - 1;
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l00936"></a>00936 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;vmdq_pools)
<a name="l00937"></a>00937         adapter-&gt;num_tx_queues = adapter-&gt;vmdq_pools;
<a name="l00938"></a>00938     <span class="keywordflow">else</span>
<a name="l00939"></a>00939         adapter-&gt;num_tx_queues = adapter-&gt;num_rx_queues;
<a name="l00940"></a>00940 <span class="preprocessor">#else</span>
<a name="l00941"></a>00941 <span class="preprocessor"></span>    adapter-&gt;num_tx_queues = max_t(u32, 1, adapter-&gt;vmdq_pools);
<a name="l00942"></a>00942 <span class="preprocessor">#endif</span>
<a name="l00943"></a>00943 <span class="preprocessor"></span>
<a name="l00944"></a>00944     <span class="keywordflow">switch</span> (adapter-&gt;int_mode) {
<a name="l00945"></a>00945     <span class="keywordflow">case</span> IGB_INT_MODE_MSIX:
<a name="l00946"></a>00946         <span class="comment">/* start with one vector for every rx queue */</span>
<a name="l00947"></a>00947         numvecs = adapter-&gt;num_rx_queues;
<a name="l00948"></a>00948 
<a name="l00949"></a>00949         <span class="comment">/* if tx handler is seperate add 1 for every tx queue */</span>
<a name="l00950"></a>00950         <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IGB_FLAG_QUEUE_PAIRS))
<a name="l00951"></a>00951             numvecs += adapter-&gt;num_tx_queues;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         <span class="comment">/* store the number of vectors reserved for queues */</span>
<a name="l00954"></a>00954         adapter-&gt;num_q_vectors = numvecs;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956         <span class="comment">/* add 1 vector for link status interrupts */</span>
<a name="l00957"></a>00957         numvecs++;
<a name="l00958"></a>00958         adapter-&gt;msix_entries = kcalloc(numvecs,
<a name="l00959"></a>00959                                         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msix_entry),
<a name="l00960"></a>00960                                         GFP_KERNEL);
<a name="l00961"></a>00961         <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l00962"></a>00962             <span class="keywordflow">for</span> (i = 0; i &lt; numvecs; i++)
<a name="l00963"></a>00963                 adapter-&gt;msix_entries[i].entry = i;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965             err = pci_enable_msix(pdev,
<a name="l00966"></a>00966                                   adapter-&gt;msix_entries, numvecs);
<a name="l00967"></a>00967             <span class="keywordflow">if</span> (err == 0)
<a name="l00968"></a>00968                 <span class="keywordflow">break</span>;
<a name="l00969"></a>00969         }
<a name="l00970"></a>00970         <span class="comment">/* MSI-X failed, so fall through and try MSI */</span>
<a name="l00971"></a>00971         dev_warn(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Failed to initialize MSI-X interrupts. &quot;</span>
<a name="l00972"></a>00972                  <span class="stringliteral">&quot;Falling back to MSI interrupts.\n&quot;</span>);
<a name="l00973"></a>00973         igb_reset_interrupt_capability(adapter);
<a name="l00974"></a>00974     <span class="keywordflow">case</span> IGB_INT_MODE_MSI:
<a name="l00975"></a>00975         <span class="keywordflow">if</span> (!pci_enable_msi(pdev))
<a name="l00976"></a>00976             adapter-&gt;flags |= IGB_FLAG_HAS_MSI;
<a name="l00977"></a>00977         <span class="keywordflow">else</span>
<a name="l00978"></a>00978             dev_warn(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Failed to initialize MSI &quot;</span>
<a name="l00979"></a>00979                      <span class="stringliteral">&quot;interrupts.  Falling back to legacy &quot;</span>
<a name="l00980"></a>00980                      <span class="stringliteral">&quot;interrupts.\n&quot;</span>);
<a name="l00981"></a>00981         <span class="comment">/* Fall through */</span>
<a name="l00982"></a>00982     <span class="keywordflow">case</span> IGB_INT_MODE_LEGACY:
<a name="l00983"></a>00983         <span class="comment">/* disable advanced features and set number of queues to 1 */</span>
<a name="l00984"></a>00984         igb_reset_sriov_capability(adapter);
<a name="l00985"></a>00985         adapter-&gt;vmdq_pools = 0;
<a name="l00986"></a>00986         adapter-&gt;rss_queues = 1;
<a name="l00987"></a>00987         adapter-&gt;flags |= IGB_FLAG_QUEUE_PAIRS;
<a name="l00988"></a>00988         adapter-&gt;num_rx_queues = 1;
<a name="l00989"></a>00989         adapter-&gt;num_tx_queues = 1;
<a name="l00990"></a>00990         adapter-&gt;num_q_vectors = 1;
<a name="l00991"></a>00991         <span class="comment">/* Don&#39;t do anything; this is system default */</span>
<a name="l00992"></a>00992         <span class="keywordflow">break</span>;
<a name="l00993"></a>00993     }
<a name="l00994"></a>00994 
<a name="l00995"></a>00995 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span>    <span class="comment">/* Notify the stack of the (possibly) reduced Tx Queue count. */</span>
<a name="l00997"></a>00997 <span class="preprocessor">#ifdef CONFIG_NETDEVICES_MULTIQUEUE</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span>    adapter-&gt;netdev-&gt;egress_subqueue_count = adapter-&gt;num_tx_queues;
<a name="l00999"></a>00999 <span class="preprocessor">#else</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span>    adapter-&gt;netdev-&gt;real_num_tx_queues =
<a name="l01001"></a>01001             (adapter-&gt;vmdq_pools ? 1 : adapter-&gt;num_tx_queues);
<a name="l01002"></a>01002 <span class="preprocessor">#endif</span>
<a name="l01003"></a>01003 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>}
<a name="l01005"></a>01005 
<a name="l01013"></a>01013 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_alloc_q_vectors(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01014"></a>01014 {
<a name="l01015"></a>01015     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector;
<a name="l01016"></a>01016     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01017"></a>01017     <span class="keywordtype">int</span> v_idx;
<a name="l01018"></a>01018 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l01019"></a>01019 <span class="preprocessor"></span>    <span class="keywordtype">int</span> orig_node = adapter-&gt;node;
<a name="l01020"></a>01020 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l01021"></a>01021 
<a name="l01022"></a>01022     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; adapter-&gt;num_q_vectors; v_idx++) {
<a name="l01023"></a>01023 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l01024"></a>01024 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((adapter-&gt;num_q_vectors == (adapter-&gt;num_rx_queues + adapter-&gt;num_tx_queues)) &amp;&amp;
<a name="l01025"></a>01025             (adapter-&gt;num_rx_queues == v_idx))
<a name="l01026"></a>01026             adapter-&gt;node = orig_node;
<a name="l01027"></a>01027         <span class="keywordflow">if</span> (orig_node == -1) {
<a name="l01028"></a>01028             <span class="keywordtype">int</span> cur_node = next_online_node(adapter-&gt;node);
<a name="l01029"></a>01029             <span class="keywordflow">if</span> (cur_node == MAX_NUMNODES)
<a name="l01030"></a>01030                 cur_node = first_online_node;
<a name="l01031"></a>01031             adapter-&gt;node = cur_node;
<a name="l01032"></a>01032         }
<a name="l01033"></a>01033 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l01034"></a>01034         q_vector = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a>), GFP_KERNEL,
<a name="l01035"></a>01035                                 adapter-&gt;node);
<a name="l01036"></a>01036         <span class="keywordflow">if</span> (!q_vector)
<a name="l01037"></a>01037             q_vector = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a>), GFP_KERNEL);
<a name="l01038"></a>01038         <span class="keywordflow">if</span> (!q_vector)
<a name="l01039"></a>01039             <span class="keywordflow">goto</span> err_out;
<a name="l01040"></a>01040         q_vector-&gt;adapter = adapter;
<a name="l01041"></a>01041         q_vector-&gt;itr_register = hw-&gt;hw_addr + E1000_EITR(0);
<a name="l01042"></a>01042         q_vector-&gt;itr_val = IGB_START_ITR;
<a name="l01043"></a>01043         netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, igb_poll, 64);
<a name="l01044"></a>01044         adapter-&gt;q_vector[v_idx] = q_vector;
<a name="l01045"></a>01045 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l01046"></a>01046 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (v_idx &lt; adapter-&gt;num_rx_queues) {
<a name="l01047"></a>01047             <span class="keywordtype">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>igb_lro_list);
<a name="l01048"></a>01048             q_vector-&gt;lrolist = vzalloc_node(size, q_vector-&gt;numa_node);
<a name="l01049"></a>01049             <span class="keywordflow">if</span> (!q_vector-&gt;lrolist)
<a name="l01050"></a>01050                 q_vector-&gt;lrolist = vzalloc(size);
<a name="l01051"></a>01051             <span class="keywordflow">if</span> (!q_vector-&gt;lrolist)
<a name="l01052"></a>01052                 <span class="keywordflow">goto</span> err_out;
<a name="l01053"></a>01053             igb_lro_ring_init(q_vector-&gt;lrolist);
<a name="l01054"></a>01054         }
<a name="l01055"></a>01055 <span class="preprocessor">#endif</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span>    }
<a name="l01057"></a>01057 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l01058"></a>01058 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l01059"></a>01059     adapter-&gt;node = orig_node;
<a name="l01060"></a>01060 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l01061"></a>01061 
<a name="l01062"></a>01062     <span class="keywordflow">return</span> 0;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 err_out:
<a name="l01065"></a>01065 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l01066"></a>01066 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l01067"></a>01067     adapter-&gt;node = orig_node;
<a name="l01068"></a>01068 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l01069"></a>01069     igb_free_q_vectors(adapter);
<a name="l01070"></a>01070     <span class="keywordflow">return</span> -ENOMEM;
<a name="l01071"></a>01071 }
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_map_rx_ring_to_vector(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l01074"></a>01074                                       <span class="keywordtype">int</span> ring_idx, <span class="keywordtype">int</span> v_idx)
<a name="l01075"></a>01075 {
<a name="l01076"></a>01076     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector = adapter-&gt;q_vector[v_idx];
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     q_vector-&gt;rx_ring = adapter-&gt;rx_ring[ring_idx];
<a name="l01079"></a>01079     q_vector-&gt;rx_ring-&gt;q_vector = q_vector;
<a name="l01080"></a>01080     q_vector-&gt;itr_val = adapter-&gt;rx_itr_setting;
<a name="l01081"></a>01081     <span class="keywordflow">if</span> (q_vector-&gt;itr_val &amp;&amp; q_vector-&gt;itr_val &lt;= 3)
<a name="l01082"></a>01082         q_vector-&gt;itr_val = IGB_START_ITR;
<a name="l01083"></a>01083 }
<a name="l01084"></a>01084 
<a name="l01085"></a>01085 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_map_tx_ring_to_vector(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l01086"></a>01086                                       <span class="keywordtype">int</span> ring_idx, <span class="keywordtype">int</span> v_idx)
<a name="l01087"></a>01087 {
<a name="l01088"></a>01088     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector = adapter-&gt;q_vector[v_idx];
<a name="l01089"></a>01089 
<a name="l01090"></a>01090     q_vector-&gt;tx_ring = adapter-&gt;tx_ring[ring_idx];
<a name="l01091"></a>01091     q_vector-&gt;tx_ring-&gt;q_vector = q_vector;
<a name="l01092"></a>01092     q_vector-&gt;itr_val = adapter-&gt;tx_itr_setting;
<a name="l01093"></a>01093     <span class="keywordflow">if</span> (q_vector-&gt;itr_val &amp;&amp; q_vector-&gt;itr_val &lt;= 3)
<a name="l01094"></a>01094         q_vector-&gt;itr_val = IGB_START_ITR;
<a name="l01095"></a>01095 }
<a name="l01096"></a>01096 
<a name="l01102"></a>01102 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_map_ring_to_vector(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01103"></a>01103 {
<a name="l01104"></a>01104     <span class="keywordtype">int</span> i;
<a name="l01105"></a>01105     <span class="keywordtype">int</span> v_idx = 0;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107     <span class="keywordflow">if</span> ((adapter-&gt;num_q_vectors &lt; adapter-&gt;num_rx_queues) ||
<a name="l01108"></a>01108         (adapter-&gt;num_q_vectors &lt; adapter-&gt;num_tx_queues))
<a name="l01109"></a>01109         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     <span class="keywordflow">if</span> (adapter-&gt;num_q_vectors &gt;=
<a name="l01112"></a>01112         (adapter-&gt;num_rx_queues + adapter-&gt;num_tx_queues)) {
<a name="l01113"></a>01113         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l01114"></a>01114             igb_map_rx_ring_to_vector(adapter, i, v_idx++);
<a name="l01115"></a>01115         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l01116"></a>01116             igb_map_tx_ring_to_vector(adapter, i, v_idx++);
<a name="l01117"></a>01117     } <span class="keywordflow">else</span> {
<a name="l01118"></a>01118         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01119"></a>01119             <span class="keywordflow">if</span> (i &lt; adapter-&gt;num_tx_queues)
<a name="l01120"></a>01120                 igb_map_tx_ring_to_vector(adapter, i, v_idx);
<a name="l01121"></a>01121             igb_map_rx_ring_to_vector(adapter, i, v_idx++);
<a name="l01122"></a>01122         }
<a name="l01123"></a>01123         <span class="keywordflow">for</span> (; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l01124"></a>01124             igb_map_tx_ring_to_vector(adapter, i, v_idx++);
<a name="l01125"></a>01125     }
<a name="l01126"></a>01126     <span class="keywordflow">return</span> 0;
<a name="l01127"></a>01127 }
<a name="l01128"></a>01128 
<a name="l01134"></a>01134 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_init_interrupt_scheme(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01135"></a>01135 {
<a name="l01136"></a>01136     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01137"></a>01137     <span class="keywordtype">int</span> err;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139     igb_set_interrupt_capability(adapter);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     err = igb_alloc_q_vectors(adapter);
<a name="l01142"></a>01142     <span class="keywordflow">if</span> (err) {
<a name="l01143"></a>01143         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Unable to allocate memory for vectors\n&quot;</span>);
<a name="l01144"></a>01144         <span class="keywordflow">goto</span> err_alloc_q_vectors;
<a name="l01145"></a>01145     }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147     err = igb_alloc_queues(adapter);
<a name="l01148"></a>01148     <span class="keywordflow">if</span> (err) {
<a name="l01149"></a>01149         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Unable to allocate memory for queues\n&quot;</span>);
<a name="l01150"></a>01150         <span class="keywordflow">goto</span> err_alloc_queues;
<a name="l01151"></a>01151     }
<a name="l01152"></a>01152 
<a name="l01153"></a>01153     err = igb_map_ring_to_vector(adapter);
<a name="l01154"></a>01154     <span class="keywordflow">if</span> (err) {
<a name="l01155"></a>01155         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Invalid q_vector to ring mapping\n&quot;</span>);
<a name="l01156"></a>01156         <span class="keywordflow">goto</span> err_map_queues;
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     <span class="keywordflow">return</span> 0;
<a name="l01161"></a>01161 err_map_queues:
<a name="l01162"></a>01162     igb_free_queues(adapter);
<a name="l01163"></a>01163 err_alloc_queues:
<a name="l01164"></a>01164     igb_free_q_vectors(adapter);
<a name="l01165"></a>01165 err_alloc_q_vectors:
<a name="l01166"></a>01166     igb_reset_interrupt_capability(adapter);
<a name="l01167"></a>01167     <span class="keywordflow">return</span> err;
<a name="l01168"></a>01168 }
<a name="l01169"></a>01169 
<a name="l01176"></a>01176 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_request_irq(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01177"></a>01177 {
<a name="l01178"></a>01178     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01179"></a>01179     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01180"></a>01180     <span class="keywordtype">int</span> err = 0;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l01183"></a>01183         err = igb_request_msix(adapter);
<a name="l01184"></a>01184         <span class="keywordflow">if</span> (!err)
<a name="l01185"></a>01185             <span class="keywordflow">goto</span> request_done;
<a name="l01186"></a>01186         <span class="comment">/* fall back to MSI */</span>
<a name="l01187"></a>01187         igb_clear_interrupt_scheme(adapter);
<a name="l01188"></a>01188         igb_reset_sriov_capability(adapter);
<a name="l01189"></a>01189         <span class="keywordflow">if</span> (!pci_enable_msi(pdev))
<a name="l01190"></a>01190             adapter-&gt;flags |= IGB_FLAG_HAS_MSI;
<a name="l01191"></a>01191         igb_free_all_tx_resources(adapter);
<a name="l01192"></a>01192         igb_free_all_rx_resources(adapter);
<a name="l01193"></a>01193         adapter-&gt;num_tx_queues = 1;
<a name="l01194"></a>01194         adapter-&gt;num_rx_queues = 1;
<a name="l01195"></a>01195         adapter-&gt;num_q_vectors = 1;
<a name="l01196"></a>01196         err = igb_alloc_q_vectors(adapter);
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (err) {
<a name="l01198"></a>01198             dev_err(pci_dev_to_dev(pdev),
<a name="l01199"></a>01199                     <span class="stringliteral">&quot;Unable to allocate memory for vectors\n&quot;</span>);
<a name="l01200"></a>01200             <span class="keywordflow">goto</span> request_done;
<a name="l01201"></a>01201         }
<a name="l01202"></a>01202         err = igb_alloc_queues(adapter);
<a name="l01203"></a>01203         <span class="keywordflow">if</span> (err) {
<a name="l01204"></a>01204             dev_err(pci_dev_to_dev(pdev),
<a name="l01205"></a>01205                     <span class="stringliteral">&quot;Unable to allocate memory for queues\n&quot;</span>);
<a name="l01206"></a>01206             igb_free_q_vectors(adapter);
<a name="l01207"></a>01207             <span class="keywordflow">goto</span> request_done;
<a name="l01208"></a>01208         }
<a name="l01209"></a>01209         igb_setup_all_tx_resources(adapter);
<a name="l01210"></a>01210         igb_setup_all_rx_resources(adapter);
<a name="l01211"></a>01211     }
<a name="l01212"></a>01212 
<a name="l01213"></a>01213     igb_assign_vector(adapter-&gt;q_vector[0], 0);
<a name="l01214"></a>01214 
<a name="l01215"></a>01215     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_HAS_MSI) {
<a name="l01216"></a>01216         err = request_irq(pdev-&gt;irq, &amp;igb_intr_msi, 0,
<a name="l01217"></a>01217                   netdev-&gt;name, adapter);
<a name="l01218"></a>01218         <span class="keywordflow">if</span> (!err)
<a name="l01219"></a>01219             <span class="keywordflow">goto</span> request_done;
<a name="l01220"></a>01220 
<a name="l01221"></a>01221         <span class="comment">/* fall back to legacy interrupts */</span>
<a name="l01222"></a>01222         igb_reset_interrupt_capability(adapter);
<a name="l01223"></a>01223         adapter-&gt;flags &amp;= ~IGB_FLAG_HAS_MSI;
<a name="l01224"></a>01224     }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     err = request_irq(pdev-&gt;irq, &amp;igb_intr, IRQF_SHARED,
<a name="l01227"></a>01227               netdev-&gt;name, adapter);
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keywordflow">if</span> (err)
<a name="l01230"></a>01230         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Error %d getting interrupt\n&quot;</span>,
<a name="l01231"></a>01231             err);
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 request_done:
<a name="l01234"></a>01234     <span class="keywordflow">return</span> err;
<a name="l01235"></a>01235 }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_free_irq(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01238"></a>01238 {
<a name="l01239"></a>01239     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l01240"></a>01240         <span class="keywordtype">int</span> vector = 0, i;
<a name="l01241"></a>01241 
<a name="l01242"></a>01242         free_irq(adapter-&gt;msix_entries[vector++].vector, adapter);
<a name="l01243"></a>01243 
<a name="l01244"></a>01244         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)
<a name="l01245"></a>01245             free_irq(adapter-&gt;msix_entries[vector++].vector,
<a name="l01246"></a>01246                      adapter-&gt;q_vector[i]);
<a name="l01247"></a>01247     } <span class="keywordflow">else</span> {
<a name="l01248"></a>01248         free_irq(adapter-&gt;pdev-&gt;irq, adapter);
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250 }
<a name="l01251"></a>01251 
<a name="l01256"></a>01256 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_irq_disable(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01257"></a>01257 {
<a name="l01258"></a>01258     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01259"></a>01259 
<a name="l01260"></a>01260     <span class="comment">/*</span>
<a name="l01261"></a>01261 <span class="comment">     * we need to be careful when disabling interrupts.  The VFs are also</span>
<a name="l01262"></a>01262 <span class="comment">     * mapped into these registers and so clearing the bits can cause</span>
<a name="l01263"></a>01263 <span class="comment">     * issues on the VF drivers so we only need to clear what we set</span>
<a name="l01264"></a>01264 <span class="comment">     */</span>
<a name="l01265"></a>01265     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l01266"></a>01266         u32 regval = E1000_READ_REG(hw, E1000_EIAM);
<a name="l01267"></a>01267         E1000_WRITE_REG(hw, E1000_EIAM, regval &amp; ~adapter-&gt;eims_enable_mask);
<a name="l01268"></a>01268         E1000_WRITE_REG(hw, E1000_EIMC, adapter-&gt;eims_enable_mask);
<a name="l01269"></a>01269         regval = E1000_READ_REG(hw, E1000_EIAC);
<a name="l01270"></a>01270         E1000_WRITE_REG(hw, E1000_EIAC, regval &amp; ~adapter-&gt;eims_enable_mask);
<a name="l01271"></a>01271     }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     E1000_WRITE_REG(hw, E1000_IAM, 0);
<a name="l01274"></a>01274     E1000_WRITE_REG(hw, E1000_IMC, ~0);
<a name="l01275"></a>01275     E1000_WRITE_FLUSH(hw);
<a name="l01276"></a>01276     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l01277"></a>01277         <span class="keywordtype">int</span> i;
<a name="l01278"></a>01278         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)
<a name="l01279"></a>01279             synchronize_irq(adapter-&gt;msix_entries[i].vector);
<a name="l01280"></a>01280     } <span class="keywordflow">else</span> {
<a name="l01281"></a>01281         synchronize_irq(adapter-&gt;pdev-&gt;irq);
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283 }
<a name="l01284"></a>01284 
<a name="l01289"></a>01289 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_irq_enable(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01290"></a>01290 {
<a name="l01291"></a>01291     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l01294"></a>01294         u32 ims = E1000_IMS_LSC | E1000_IMS_DOUTSYNC | E1000_IMS_DRSTA;
<a name="l01295"></a>01295         u32 regval = E1000_READ_REG(hw, E1000_EIAC);
<a name="l01296"></a>01296         E1000_WRITE_REG(hw, E1000_EIAC, regval | adapter-&gt;eims_enable_mask);
<a name="l01297"></a>01297         regval = E1000_READ_REG(hw, E1000_EIAM);
<a name="l01298"></a>01298         E1000_WRITE_REG(hw, E1000_EIAM, regval | adapter-&gt;eims_enable_mask);
<a name="l01299"></a>01299         E1000_WRITE_REG(hw, E1000_EIMS, adapter-&gt;eims_enable_mask);
<a name="l01300"></a>01300         <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count) {
<a name="l01301"></a>01301             E1000_WRITE_REG(hw, E1000_MBVFIMR, 0xFF);
<a name="l01302"></a>01302             ims |= E1000_IMS_VMMB;
<a name="l01303"></a>01303         }
<a name="l01304"></a>01304         E1000_WRITE_REG(hw, E1000_IMS, ims);
<a name="l01305"></a>01305     } <span class="keywordflow">else</span> {
<a name="l01306"></a>01306         E1000_WRITE_REG(hw, E1000_IMS, IMS_ENABLE_MASK |
<a name="l01307"></a>01307                 E1000_IMS_DRSTA);
<a name="l01308"></a>01308         E1000_WRITE_REG(hw, E1000_IAM, IMS_ENABLE_MASK |
<a name="l01309"></a>01309                 E1000_IMS_DRSTA);
<a name="l01310"></a>01310     }
<a name="l01311"></a>01311 }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_update_mng_vlan(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01314"></a>01314 {
<a name="l01315"></a>01315     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01316"></a>01316     u16 vid = adapter-&gt;hw.mng_cookie.vlan_id;
<a name="l01317"></a>01317     u16 old_vid = adapter-&gt;mng_vlan_id;
<a name="l01318"></a>01318 
<a name="l01319"></a>01319     <span class="keywordflow">if</span> (hw-&gt;mng_cookie.status &amp; E1000_MNG_DHCP_COOKIE_STATUS_VLAN) {
<a name="l01320"></a>01320         <span class="comment">/* add VID to filter table */</span>
<a name="l01321"></a>01321         igb_vfta_set(hw, vid, TRUE);
<a name="l01322"></a>01322         adapter-&gt;mng_vlan_id = vid;
<a name="l01323"></a>01323     } <span class="keywordflow">else</span> {
<a name="l01324"></a>01324         adapter-&gt;mng_vlan_id = IGB_MNG_VLAN_NONE;
<a name="l01325"></a>01325     }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327     <span class="keywordflow">if</span> ((old_vid != (u16)IGB_MNG_VLAN_NONE) &amp;&amp;
<a name="l01328"></a>01328         (vid != old_vid) &amp;&amp;
<a name="l01329"></a>01329         !vlan_group_get_device(adapter-&gt;vlgrp, old_vid)) {
<a name="l01330"></a>01330         <span class="comment">/* remove VID from filter table */</span>
<a name="l01331"></a>01331         igb_vfta_set(hw, old_vid, FALSE);
<a name="l01332"></a>01332     }
<a name="l01333"></a>01333 }
<a name="l01334"></a>01334 
<a name="l01344"></a>01344 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_release_hw_control(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01345"></a>01345 {
<a name="l01346"></a>01346     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01347"></a>01347     u32 ctrl_ext;
<a name="l01348"></a>01348 
<a name="l01349"></a>01349     <span class="comment">/* Let firmware take over control of h/w */</span>
<a name="l01350"></a>01350     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l01351"></a>01351     E1000_WRITE_REG(hw, E1000_CTRL_EXT,
<a name="l01352"></a>01352             ctrl_ext &amp; ~E1000_CTRL_EXT_DRV_LOAD);
<a name="l01353"></a>01353 }
<a name="l01354"></a>01354 
<a name="l01364"></a>01364 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_get_hw_control(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01365"></a>01365 {
<a name="l01366"></a>01366     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01367"></a>01367     u32 ctrl_ext;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369     <span class="comment">/* Let firmware know the driver has taken over */</span>
<a name="l01370"></a>01370     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l01371"></a>01371     E1000_WRITE_REG(hw, E1000_CTRL_EXT,
<a name="l01372"></a>01372             ctrl_ext | E1000_CTRL_EXT_DRV_LOAD);
<a name="l01373"></a>01373 }
<a name="l01374"></a>01374 
<a name="l01379"></a>01379 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_configure(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01380"></a>01380 {
<a name="l01381"></a>01381     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01382"></a>01382     <span class="keywordtype">int</span> i;
<a name="l01383"></a>01383 
<a name="l01384"></a>01384     igb_get_hw_control(adapter);
<a name="l01385"></a>01385     igb_set_rx_mode(netdev);
<a name="l01386"></a>01386 
<a name="l01387"></a>01387     igb_restore_vlan(adapter);
<a name="l01388"></a>01388 
<a name="l01389"></a>01389     igb_setup_tctl(adapter);
<a name="l01390"></a>01390     igb_setup_mrqc(adapter);
<a name="l01391"></a>01391     igb_setup_rctl(adapter);
<a name="l01392"></a>01392 
<a name="l01393"></a>01393     igb_configure_tx(adapter);
<a name="l01394"></a>01394     igb_configure_rx(adapter);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396     e1000_rx_fifo_flush_82575(&amp;adapter-&gt;hw);
<a name="l01397"></a>01397 <span class="preprocessor">#ifdef CONFIG_NETDEVICES_MULTIQUEUE</span>
<a name="l01398"></a>01398 <span class="preprocessor"></span>
<a name="l01399"></a>01399     <span class="keywordflow">if</span> (adapter-&gt;num_tx_queues &gt; 1)
<a name="l01400"></a>01400         netdev-&gt;features |= NETIF_F_MULTI_QUEUE;
<a name="l01401"></a>01401     <span class="keywordflow">else</span>
<a name="l01402"></a>01402         netdev-&gt;features &amp;= ~NETIF_F_MULTI_QUEUE;
<a name="l01403"></a>01403 <span class="preprocessor">#endif</span>
<a name="l01404"></a>01404 <span class="preprocessor"></span>
<a name="l01405"></a>01405     <span class="comment">/* call igb_desc_unused which always leaves</span>
<a name="l01406"></a>01406 <span class="comment">     * at least 1 descriptor unused to make sure</span>
<a name="l01407"></a>01407 <span class="comment">     * next_to_use != next_to_clean */</span>
<a name="l01408"></a>01408     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01409"></a>01409         <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *ring = adapter-&gt;rx_ring[i];
<a name="l01410"></a>01410         igb_alloc_rx_buffers(ring, igb_desc_unused(ring));
<a name="l01411"></a>01411     }
<a name="l01412"></a>01412 }
<a name="l01413"></a>01413 
<a name="l01418"></a>01418 <span class="keywordtype">void</span> igb_power_up_link(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01419"></a>01419 {
<a name="l01420"></a>01420     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.media_type == e1000_media_type_copper)
<a name="l01421"></a>01421         e1000_power_up_phy(&amp;adapter-&gt;hw);
<a name="l01422"></a>01422     <span class="keywordflow">else</span>
<a name="l01423"></a>01423         e1000_power_up_fiber_serdes_link(&amp;adapter-&gt;hw);
<a name="l01424"></a>01424 }
<a name="l01425"></a>01425 
<a name="l01430"></a>01430 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_power_down_link(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01431"></a>01431 {
<a name="l01432"></a>01432     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.media_type == e1000_media_type_copper)
<a name="l01433"></a>01433         e1000_power_down_phy(&amp;adapter-&gt;hw);
<a name="l01434"></a>01434     <span class="keywordflow">else</span>
<a name="l01435"></a>01435         e1000_shutdown_fiber_serdes_link(&amp;adapter-&gt;hw);
<a name="l01436"></a>01436 }
<a name="l01437"></a>01437 
<a name="l01442"></a>01442 <span class="keywordtype">int</span> igb_up(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01443"></a>01443 {
<a name="l01444"></a>01444     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01445"></a>01445     <span class="keywordtype">int</span> i;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447     <span class="comment">/* hardware has been reset, we need to reload some things */</span>
<a name="l01448"></a>01448     igb_configure(adapter);
<a name="l01449"></a>01449 
<a name="l01450"></a>01450     clear_bit(__IGB_DOWN, &amp;adapter-&gt;state);
<a name="l01451"></a>01451 
<a name="l01452"></a>01452     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)
<a name="l01453"></a>01453         napi_enable(&amp;(adapter-&gt;q_vector[i]-&gt;napi));
<a name="l01454"></a>01454 
<a name="l01455"></a>01455     <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l01456"></a>01456         igb_configure_msix(adapter);
<a name="l01457"></a>01457     <span class="keywordflow">else</span>
<a name="l01458"></a>01458         igb_assign_vector(adapter-&gt;q_vector[0], 0);
<a name="l01459"></a>01459 
<a name="l01460"></a>01460     igb_configure_lli(adapter);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462     <span class="comment">/* Clear any pending interrupts. */</span>
<a name="l01463"></a>01463     E1000_READ_REG(hw, E1000_ICR);
<a name="l01464"></a>01464     igb_irq_enable(adapter);
<a name="l01465"></a>01465 
<a name="l01466"></a>01466     <span class="comment">/* notify VFs that reset has been completed */</span>
<a name="l01467"></a>01467     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count) {
<a name="l01468"></a>01468         u32 reg_data = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l01469"></a>01469         reg_data |= E1000_CTRL_EXT_PFRSTD;
<a name="l01470"></a>01470         E1000_WRITE_REG(hw, E1000_CTRL_EXT, reg_data);
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     netif_tx_start_all_queues(adapter-&gt;netdev);
<a name="l01474"></a>01474 
<a name="l01475"></a>01475     <span class="comment">/* start the watchdog. */</span>
<a name="l01476"></a>01476     hw-&gt;mac.get_link_status = 1;
<a name="l01477"></a>01477     schedule_work(&amp;adapter-&gt;watchdog_task);
<a name="l01478"></a>01478 
<a name="l01479"></a>01479     <span class="keywordflow">return</span> 0;
<a name="l01480"></a>01480 }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 <span class="keywordtype">void</span> igb_down(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01483"></a>01483 {
<a name="l01484"></a>01484     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01485"></a>01485     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01486"></a>01486     u32 tctl, rctl;
<a name="l01487"></a>01487     <span class="keywordtype">int</span> i;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489     <span class="comment">/* signal that we&#39;re down so the interrupt handler does not</span>
<a name="l01490"></a>01490 <span class="comment">     * reschedule our watchdog timer */</span>
<a name="l01491"></a>01491     set_bit(__IGB_DOWN, &amp;adapter-&gt;state);
<a name="l01492"></a>01492 
<a name="l01493"></a>01493     <span class="comment">/* disable receives in the hardware */</span>
<a name="l01494"></a>01494     rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l01495"></a>01495     E1000_WRITE_REG(hw, E1000_RCTL, rctl &amp; ~E1000_RCTL_EN);
<a name="l01496"></a>01496     <span class="comment">/* flush and sleep below */</span>
<a name="l01497"></a>01497 
<a name="l01498"></a>01498     netif_tx_stop_all_queues(netdev);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500     <span class="comment">/* disable transmits in the hardware */</span>
<a name="l01501"></a>01501     tctl = E1000_READ_REG(hw, E1000_TCTL);
<a name="l01502"></a>01502     tctl &amp;= ~E1000_TCTL_EN;
<a name="l01503"></a>01503     E1000_WRITE_REG(hw, E1000_TCTL, tctl);
<a name="l01504"></a>01504     <span class="comment">/* flush both disables and wait for them to finish */</span>
<a name="l01505"></a>01505     E1000_WRITE_FLUSH(hw);
<a name="l01506"></a>01506     msleep(10);
<a name="l01507"></a>01507 
<a name="l01508"></a>01508     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)
<a name="l01509"></a>01509         napi_disable(&amp;(adapter-&gt;q_vector[i]-&gt;napi));
<a name="l01510"></a>01510 
<a name="l01511"></a>01511     igb_irq_disable(adapter);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513     del_timer_sync(&amp;adapter-&gt;watchdog_timer);
<a name="l01514"></a>01514     del_timer_sync(&amp;adapter-&gt;phy_info_timer);
<a name="l01515"></a>01515 
<a name="l01516"></a>01516     netif_carrier_off(netdev);
<a name="l01517"></a>01517 
<a name="l01518"></a>01518     <span class="comment">/* record the stats before reset*/</span>
<a name="l01519"></a>01519     igb_update_stats(adapter);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521     adapter-&gt;link_speed = 0;
<a name="l01522"></a>01522     adapter-&gt;link_duplex = 0;
<a name="l01523"></a>01523 
<a name="l01524"></a>01524 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l01525"></a>01525 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!pci_channel_offline(adapter-&gt;pdev))
<a name="l01526"></a>01526         igb_reset(adapter);
<a name="l01527"></a>01527 <span class="preprocessor">#else</span>
<a name="l01528"></a>01528 <span class="preprocessor"></span>    igb_reset(adapter);
<a name="l01529"></a>01529 <span class="preprocessor">#endif</span>
<a name="l01530"></a>01530 <span class="preprocessor"></span>    igb_clean_all_tx_rings(adapter);
<a name="l01531"></a>01531     igb_clean_all_rx_rings(adapter);
<a name="l01532"></a>01532 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l01533"></a>01533 <span class="preprocessor"></span>
<a name="l01534"></a>01534     <span class="comment">/* since we reset the hardware DCA settings were cleared */</span>
<a name="l01535"></a>01535     igb_setup_dca(adapter);
<a name="l01536"></a>01536 <span class="preprocessor">#endif</span>
<a name="l01537"></a>01537 <span class="preprocessor"></span>}
<a name="l01538"></a>01538 
<a name="l01539"></a>01539 <span class="keywordtype">void</span> igb_reinit_locked(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01540"></a>01540 {
<a name="l01541"></a>01541     WARN_ON(in_interrupt());
<a name="l01542"></a>01542     <span class="keywordflow">while</span> (test_and_set_bit(__IGB_RESETTING, &amp;adapter-&gt;state))
<a name="l01543"></a>01543         msleep(1);
<a name="l01544"></a>01544     igb_down(adapter);
<a name="l01545"></a>01545     igb_up(adapter);
<a name="l01546"></a>01546     clear_bit(__IGB_RESETTING, &amp;adapter-&gt;state);
<a name="l01547"></a>01547 }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 <span class="keywordtype">void</span> igb_reset(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01550"></a>01550 {
<a name="l01551"></a>01551     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01552"></a>01552     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01553"></a>01553     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l01554"></a>01554     <span class="keyword">struct </span><a class="code" href="structe1000__fc__info.html">e1000_fc_info</a> *fc = &amp;hw-&gt;fc;
<a name="l01555"></a>01555     u32 pba = 0, tx_space, min_tx_space, min_rx_space;
<a name="l01556"></a>01556     u16 hwm;
<a name="l01557"></a>01557 
<a name="l01558"></a>01558     <span class="comment">/* Repartition Pba for greater than 9k mtu</span>
<a name="l01559"></a>01559 <span class="comment">     * To take effect CTRL.RST is required.</span>
<a name="l01560"></a>01560 <span class="comment">     */</span>
<a name="l01561"></a>01561     <span class="keywordflow">switch</span> (mac-&gt;type) {
<a name="l01562"></a>01562     <span class="keywordflow">case</span> e1000_i350:
<a name="l01563"></a>01563     <span class="keywordflow">case</span> e1000_82580:
<a name="l01564"></a>01564         pba = E1000_READ_REG(hw, E1000_RXPBS);
<a name="l01565"></a>01565         pba = e1000_rxpbs_adjust_82580(pba);
<a name="l01566"></a>01566         <span class="keywordflow">break</span>;
<a name="l01567"></a>01567     <span class="keywordflow">case</span> e1000_82576:
<a name="l01568"></a>01568         pba = E1000_READ_REG(hw, E1000_RXPBS);
<a name="l01569"></a>01569         pba &amp;= E1000_RXPBS_SIZE_MASK_82576;
<a name="l01570"></a>01570         <span class="keywordflow">break</span>;
<a name="l01571"></a>01571     <span class="keywordflow">case</span> e1000_82575:
<a name="l01572"></a>01572     <span class="keywordflow">default</span>:
<a name="l01573"></a>01573         pba = E1000_PBA_34K;
<a name="l01574"></a>01574         <span class="keywordflow">break</span>;
<a name="l01575"></a>01575     }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577     <span class="keywordflow">if</span> ((adapter-&gt;max_frame_size &gt; ETH_FRAME_LEN + ETH_FCS_LEN) &amp;&amp;
<a name="l01578"></a>01578         (mac-&gt;type &lt; e1000_82576)) {
<a name="l01579"></a>01579         <span class="comment">/* adjust PBA for jumbo frames */</span>
<a name="l01580"></a>01580         E1000_WRITE_REG(hw, E1000_PBA, pba);
<a name="l01581"></a>01581 
<a name="l01582"></a>01582         <span class="comment">/* To maintain wire speed transmits, the Tx FIFO should be</span>
<a name="l01583"></a>01583 <span class="comment">         * large enough to accommodate two full transmit packets,</span>
<a name="l01584"></a>01584 <span class="comment">         * rounded up to the next 1KB and expressed in KB.  Likewise,</span>
<a name="l01585"></a>01585 <span class="comment">         * the Rx FIFO should be large enough to accommodate at least</span>
<a name="l01586"></a>01586 <span class="comment">         * one full receive packet and is similarly rounded up and</span>
<a name="l01587"></a>01587 <span class="comment">         * expressed in KB. */</span>
<a name="l01588"></a>01588         pba = E1000_READ_REG(hw, E1000_PBA);
<a name="l01589"></a>01589         <span class="comment">/* upper 16 bits has Tx packet buffer allocation size in KB */</span>
<a name="l01590"></a>01590         tx_space = pba &gt;&gt; 16;
<a name="l01591"></a>01591         <span class="comment">/* lower 16 bits has Rx packet buffer allocation size in KB */</span>
<a name="l01592"></a>01592         pba &amp;= 0xffff;
<a name="l01593"></a>01593         <span class="comment">/* the tx fifo also stores 16 bytes of information about the tx</span>
<a name="l01594"></a>01594 <span class="comment">         * but don&#39;t include ethernet FCS because hardware appends it */</span>
<a name="l01595"></a>01595         min_tx_space = (adapter-&gt;max_frame_size +
<a name="l01596"></a>01596                 <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unione1000__adv__tx__desc.html">e1000_adv_tx_desc</a>) -
<a name="l01597"></a>01597                 ETH_FCS_LEN) * 2;
<a name="l01598"></a>01598         min_tx_space = ALIGN(min_tx_space, 1024);
<a name="l01599"></a>01599         min_tx_space &gt;&gt;= 10;
<a name="l01600"></a>01600         <span class="comment">/* software strips receive CRC, so leave room for it */</span>
<a name="l01601"></a>01601         min_rx_space = adapter-&gt;max_frame_size;
<a name="l01602"></a>01602         min_rx_space = ALIGN(min_rx_space, 1024);
<a name="l01603"></a>01603         min_rx_space &gt;&gt;= 10;
<a name="l01604"></a>01604 
<a name="l01605"></a>01605         <span class="comment">/* If current Tx allocation is less than the min Tx FIFO size,</span>
<a name="l01606"></a>01606 <span class="comment">         * and the min Tx FIFO size is less than the current Rx FIFO</span>
<a name="l01607"></a>01607 <span class="comment">         * allocation, take space away from current Rx allocation */</span>
<a name="l01608"></a>01608         <span class="keywordflow">if</span> (tx_space &lt; min_tx_space &amp;&amp;
<a name="l01609"></a>01609             ((min_tx_space - tx_space) &lt; pba)) {
<a name="l01610"></a>01610             pba = pba - (min_tx_space - tx_space);
<a name="l01611"></a>01611 
<a name="l01612"></a>01612             <span class="comment">/* if short on rx space, rx wins and must trump tx</span>
<a name="l01613"></a>01613 <span class="comment">             * adjustment */</span>
<a name="l01614"></a>01614             <span class="keywordflow">if</span> (pba &lt; min_rx_space)
<a name="l01615"></a>01615                 pba = min_rx_space;
<a name="l01616"></a>01616         }
<a name="l01617"></a>01617         E1000_WRITE_REG(hw, E1000_PBA, pba);
<a name="l01618"></a>01618     }
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     <span class="comment">/* flow control settings */</span>
<a name="l01621"></a>01621     <span class="comment">/* The high water mark must be low enough to fit one full frame</span>
<a name="l01622"></a>01622 <span class="comment">     * (or the size used for early receive) above it in the Rx FIFO.</span>
<a name="l01623"></a>01623 <span class="comment">     * Set it to the lower of:</span>
<a name="l01624"></a>01624 <span class="comment">     * - 90% of the Rx FIFO size, or</span>
<a name="l01625"></a>01625 <span class="comment">     * - the full Rx FIFO size minus one full frame */</span>
<a name="l01626"></a>01626     hwm = min(((pba &lt;&lt; 10) * 9 / 10),
<a name="l01627"></a>01627             ((pba &lt;&lt; 10) - 2 * adapter-&gt;max_frame_size));
<a name="l01628"></a>01628 
<a name="l01629"></a>01629     fc-&gt;high_water = hwm &amp; 0xFFF0;  <span class="comment">/* 16-byte granularity */</span>
<a name="l01630"></a>01630     fc-&gt;low_water = fc-&gt;high_water - 16;
<a name="l01631"></a>01631     fc-&gt;pause_time = 0xFFFF;
<a name="l01632"></a>01632     fc-&gt;send_xon = 1;
<a name="l01633"></a>01633     fc-&gt;current_mode = fc-&gt;requested_mode;
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     <span class="comment">/* disable receive for all VFs and wait one second */</span>
<a name="l01636"></a>01636     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count) {
<a name="l01637"></a>01637         <span class="keywordtype">int</span> i;
<a name="l01638"></a>01638         <span class="comment">/*</span>
<a name="l01639"></a>01639 <span class="comment">         * Clear all flags except indication that the PF has set</span>
<a name="l01640"></a>01640 <span class="comment">         * the VF MAC addresses administratively</span>
<a name="l01641"></a>01641 <span class="comment">         */</span>
<a name="l01642"></a>01642         <span class="keywordflow">for</span> (i = 0 ; i &lt; adapter-&gt;vfs_allocated_count; i++)
<a name="l01643"></a>01643             adapter-&gt;vf_data[i].flags &amp;= IGB_VF_FLAG_PF_SET_MAC;
<a name="l01644"></a>01644 
<a name="l01645"></a>01645         <span class="comment">/* ping all the active vfs to let them know we are going down */</span>
<a name="l01646"></a>01646         igb_ping_all_vfs(adapter);
<a name="l01647"></a>01647 
<a name="l01648"></a>01648         <span class="comment">/* disable transmits and receives */</span>
<a name="l01649"></a>01649         E1000_WRITE_REG(hw, E1000_VFRE, 0);
<a name="l01650"></a>01650         E1000_WRITE_REG(hw, E1000_VFTE, 0);
<a name="l01651"></a>01651     }
<a name="l01652"></a>01652 
<a name="l01653"></a>01653     <span class="comment">/* Allow time for pending master requests to run */</span>
<a name="l01654"></a>01654     e1000_reset_hw(hw);
<a name="l01655"></a>01655     E1000_WRITE_REG(hw, E1000_WUC, 0);
<a name="l01656"></a>01656 
<a name="l01657"></a>01657     <span class="keywordflow">if</span> (e1000_init_hw(hw))
<a name="l01658"></a>01658         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Hardware Error\n&quot;</span>);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660     <span class="keywordflow">if</span> (hw-&gt;mac.type &gt; e1000_82580) {
<a name="l01661"></a>01661         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_DMAC) {
<a name="l01662"></a>01662             u32 reg;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664             <span class="comment">/*</span>
<a name="l01665"></a>01665 <span class="comment">             * DMA Coalescing high water mark needs to be higher than the</span>
<a name="l01666"></a>01666 <span class="comment">             * RX threshold.  The RX threshold is currently pba - 6, so we</span>
<a name="l01667"></a>01667 <span class="comment">             * should use a high water mark of pba - 4.</span>
<a name="l01668"></a>01668 <span class="comment">             */</span>
<a name="l01669"></a>01669             hwm = (pba - 4) &lt;&lt; 10;
<a name="l01670"></a>01670 
<a name="l01671"></a>01671             reg = (((pba-6) &lt;&lt; E1000_DMACR_DMACTHR_SHIFT)
<a name="l01672"></a>01672                    &amp; E1000_DMACR_DMACTHR_MASK);
<a name="l01673"></a>01673 
<a name="l01674"></a>01674             <span class="comment">/* transition to L0x or L1 if available..*/</span>
<a name="l01675"></a>01675             reg |= (E1000_DMACR_DMAC_EN | E1000_DMACR_DMAC_LX_MASK);
<a name="l01676"></a>01676 
<a name="l01677"></a>01677             <span class="comment">/* watchdog timer= +-1000 usec in 32usec intervals */</span>
<a name="l01678"></a>01678             reg |= (1000 &gt;&gt; 5);
<a name="l01679"></a>01679             E1000_WRITE_REG(hw, E1000_DMACR, reg);
<a name="l01680"></a>01680 
<a name="l01681"></a>01681             <span class="comment">/* no lower threshold to disable coalescing(smart fifb)-UTRESH=0*/</span>
<a name="l01682"></a>01682             E1000_WRITE_REG(hw, E1000_DMCRTRH, 0);
<a name="l01683"></a>01683 
<a name="l01684"></a>01684             <span class="comment">/* set hwm to PBA -  2 * max frame size */</span>
<a name="l01685"></a>01685             E1000_WRITE_REG(hw, E1000_FCRTC, hwm);
<a name="l01686"></a>01686 
<a name="l01687"></a>01687             <span class="comment">/*</span>
<a name="l01688"></a>01688 <span class="comment">             * This sets the time to wait before requesting transition to</span>
<a name="l01689"></a>01689 <span class="comment">             * low power state to number of usecs needed to receive 1 512</span>
<a name="l01690"></a>01690 <span class="comment">             * byte frame at gigabit line rate</span>
<a name="l01691"></a>01691 <span class="comment">             */</span>
<a name="l01692"></a>01692             reg = E1000_READ_REG(hw, E1000_DMCTLX);
<a name="l01693"></a>01693             reg |= IGB_DMCTLX_DCFLUSH_DIS;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695             
<a name="l01696"></a>01696             <span class="comment">/* Delay 255 usec before entering Lx state. */</span>
<a name="l01697"></a>01697             reg |= 0xFF;
<a name="l01698"></a>01698             E1000_WRITE_REG(hw, E1000_DMCTLX, reg);
<a name="l01699"></a>01699 
<a name="l01700"></a>01700             <span class="comment">/* free space in tx packet buffer to wake from DMA coal */</span>
<a name="l01701"></a>01701             E1000_WRITE_REG(hw, E1000_DMCTXTH,
<a name="l01702"></a>01702                         (IGB_MIN_TXPBSIZE -
<a name="l01703"></a>01703                 (IGB_TX_BUF_4096 + adapter-&gt;max_frame_size)) &gt;&gt; 6);
<a name="l01704"></a>01704 
<a name="l01705"></a>01705             <span class="comment">/* make low power state decision controlled by DMA coal */</span>
<a name="l01706"></a>01706             reg = E1000_READ_REG(hw, E1000_PCIEMISC);
<a name="l01707"></a>01707             reg |= E1000_PCIEMISC_LX_DECISION;
<a name="l01708"></a>01708             E1000_WRITE_REG(hw, E1000_PCIEMISC, reg);
<a name="l01709"></a>01709         } <span class="comment">/* end if IGB_FLAG_DMAC set */</span>
<a name="l01710"></a>01710     }
<a name="l01711"></a>01711     <span class="keywordflow">if</span> (!netif_running(adapter-&gt;netdev))
<a name="l01712"></a>01712         igb_power_down_link(adapter);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714     igb_update_mng_vlan(adapter);
<a name="l01715"></a>01715 
<a name="l01716"></a>01716     <span class="comment">/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */</span>
<a name="l01717"></a>01717     E1000_WRITE_REG(hw, E1000_VET, ETHERNET_IEEE_VLAN_TYPE);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719     e1000_get_phy_info(hw);
<a name="l01720"></a>01720 }
<a name="l01721"></a>01721 
<a name="l01722"></a>01722 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l01723"></a>01723 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>net_device_ops igb_netdev_ops = {
<a name="l01724"></a>01724     .ndo_open       = igb_open,
<a name="l01725"></a>01725     .ndo_stop       = igb_close,
<a name="l01726"></a>01726     .ndo_start_xmit     = igb_xmit_frame,
<a name="l01727"></a>01727     .ndo_get_stats      = igb_get_stats,
<a name="l01728"></a>01728     .ndo_set_rx_mode    = igb_set_rx_mode,
<a name="l01729"></a>01729     .ndo_set_multicast_list = igb_set_rx_mode,
<a name="l01730"></a>01730     .ndo_set_mac_address    = igb_set_mac,
<a name="l01731"></a>01731     .ndo_change_mtu     = igb_change_mtu,
<a name="l01732"></a>01732     .ndo_do_ioctl       = igb_ioctl,
<a name="l01733"></a>01733     .ndo_tx_timeout     = igb_tx_timeout,
<a name="l01734"></a>01734     .ndo_validate_addr  = eth_validate_addr,
<a name="l01735"></a>01735     .ndo_vlan_rx_register   = igb_vlan_rx_register,
<a name="l01736"></a>01736     .ndo_vlan_rx_add_vid    = igb_vlan_rx_add_vid,
<a name="l01737"></a>01737     .ndo_vlan_rx_kill_vid   = igb_vlan_rx_kill_vid,
<a name="l01738"></a>01738 <span class="preprocessor">#ifdef IFLA_VF_MAX</span>
<a name="l01739"></a>01739 <span class="preprocessor"></span>    .ndo_set_vf_mac     = igb_ndo_set_vf_mac,
<a name="l01740"></a>01740     .ndo_set_vf_vlan    = igb_ndo_set_vf_vlan,
<a name="l01741"></a>01741     .ndo_set_vf_tx_rate = igb_ndo_set_vf_bw,
<a name="l01742"></a>01742     .ndo_get_vf_config  = igb_ndo_get_vf_config,
<a name="l01743"></a>01743 <span class="preprocessor">#endif</span>
<a name="l01744"></a>01744 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l01745"></a>01745 <span class="preprocessor"></span>    .ndo_poll_controller    = igb_netpoll,
<a name="l01746"></a>01746 <span class="preprocessor">#endif</span>
<a name="l01747"></a>01747 <span class="preprocessor"></span>};
<a name="l01748"></a>01748 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l01749"></a>01749 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>net_device_ops igb_vmdq_ops = {
<a name="l01750"></a>01750     .ndo_open       = &amp;igb_vmdq_open,
<a name="l01751"></a>01751     .ndo_stop       = &amp;igb_vmdq_close,
<a name="l01752"></a>01752     .ndo_start_xmit     = &amp;igb_vmdq_xmit_frame,
<a name="l01753"></a>01753     .ndo_get_stats      = &amp;igb_vmdq_get_stats,
<a name="l01754"></a>01754     .ndo_set_rx_mode    = &amp;igb_vmdq_set_rx_mode,
<a name="l01755"></a>01755     .ndo_set_multicast_list = &amp;igb_vmdq_set_rx_mode,
<a name="l01756"></a>01756     .ndo_validate_addr  = eth_validate_addr,
<a name="l01757"></a>01757     .ndo_set_mac_address    = &amp;igb_vmdq_set_mac,
<a name="l01758"></a>01758     .ndo_change_mtu     = &amp;igb_vmdq_change_mtu,
<a name="l01759"></a>01759     .ndo_tx_timeout     = &amp;igb_vmdq_tx_timeout,
<a name="l01760"></a>01760     .ndo_vlan_rx_register   = &amp;igb_vmdq_vlan_rx_register,
<a name="l01761"></a>01761     .ndo_vlan_rx_add_vid    = &amp;igb_vmdq_vlan_rx_add_vid,
<a name="l01762"></a>01762     .ndo_vlan_rx_kill_vid   = &amp;igb_vmdq_vlan_rx_kill_vid,
<a name="l01763"></a>01763 };
<a name="l01764"></a>01764 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IGB_VMDQ_NETDEV */</span>
<a name="l01765"></a>01765 
<a name="l01766"></a>01766 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l01767"></a>01767 
<a name="l01768"></a>01768 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l01769"></a>01769 <span class="preprocessor"></span><span class="keywordtype">void</span> igb_assign_vmdq_netdev_ops(<span class="keyword">struct</span> net_device *vnetdev)
<a name="l01770"></a>01770 {
<a name="l01771"></a>01771 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l01772"></a>01772 <span class="preprocessor"></span>    vnetdev-&gt;netdev_ops = &amp;igb_vmdq_ops;
<a name="l01773"></a>01773 <span class="preprocessor">#else</span>
<a name="l01774"></a>01774 <span class="preprocessor"></span>    dev-&gt;open = &amp;igb_vmdq_open;
<a name="l01775"></a>01775     dev-&gt;stop = &amp;igb_vmdq_close;
<a name="l01776"></a>01776     dev-&gt;hard_start_xmit = &amp;igb_vmdq_xmit_frame;
<a name="l01777"></a>01777     dev-&gt;get_stats = &amp;igb_vmdq_get_stats;
<a name="l01778"></a>01778 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l01779"></a>01779 <span class="preprocessor"></span>    dev-&gt;set_rx_mode = &amp;igb_vmdq_set_rx_mode;
<a name="l01780"></a>01780 <span class="preprocessor">#endif</span>
<a name="l01781"></a>01781 <span class="preprocessor"></span>    dev-&gt;set_multicast_list = &amp;igb_vmdq_set_rx_mode;
<a name="l01782"></a>01782     dev-&gt;set_mac_address = &amp;igb_vmdq_set_mac;
<a name="l01783"></a>01783     dev-&gt;change_mtu = &amp;igb_vmdq_change_mtu;
<a name="l01784"></a>01784 <span class="preprocessor">#ifdef HAVE_TX_TIMEOUT</span>
<a name="l01785"></a>01785 <span class="preprocessor"></span>    dev-&gt;tx_timeout = &amp;igb_vmdq_tx_timeout;
<a name="l01786"></a>01786 <span class="preprocessor">#endif</span>
<a name="l01787"></a>01787 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l01788"></a>01788 <span class="preprocessor"></span>    dev-&gt;vlan_rx_register = &amp;igb_vmdq_vlan_rx_register;
<a name="l01789"></a>01789     dev-&gt;vlan_rx_add_vid = &amp;igb_vmdq_vlan_rx_add_vid;
<a name="l01790"></a>01790     dev-&gt;vlan_rx_kill_vid = &amp;igb_vmdq_vlan_rx_kill_vid;
<a name="l01791"></a>01791 <span class="preprocessor">#endif</span>
<a name="l01792"></a>01792 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01793"></a>01793 <span class="preprocessor"></span>    igb_vmdq_set_ethtool_ops(vnetdev);
<a name="l01794"></a>01794     vnetdev-&gt;watchdog_timeo = 5 * HZ;
<a name="l01795"></a>01795 
<a name="l01796"></a>01796 }
<a name="l01797"></a>01797 
<a name="l01798"></a>01798 <span class="keywordtype">int</span> igb_init_vmdq_netdevs(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01799"></a>01799 {
<a name="l01800"></a>01800     <span class="keywordtype">int</span> pool, err = 0, base_queue;
<a name="l01801"></a>01801     <span class="keyword">struct </span>net_device *vnetdev;
<a name="l01802"></a>01802     <span class="keyword">struct </span>igb_vmdq_adapter *vmdq_adapter;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     <span class="keywordflow">for</span> (pool = 1; pool &lt; adapter-&gt;vmdq_pools; pool++) {
<a name="l01805"></a>01805         <span class="keywordtype">int</span> qpp = (!adapter-&gt;rss_queues ? 1 : adapter-&gt;rss_queues);
<a name="l01806"></a>01806         base_queue = pool * qpp;
<a name="l01807"></a>01807         vnetdev = alloc_etherdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> igb_vmdq_adapter));
<a name="l01808"></a>01808         <span class="keywordflow">if</span> (!vnetdev) {
<a name="l01809"></a>01809             err = -ENOMEM;
<a name="l01810"></a>01810             <span class="keywordflow">break</span>;
<a name="l01811"></a>01811         }
<a name="l01812"></a>01812         vmdq_adapter = netdev_priv(vnetdev);
<a name="l01813"></a>01813         vmdq_adapter-&gt;vnetdev = vnetdev;
<a name="l01814"></a>01814         vmdq_adapter-&gt;real_adapter = adapter;
<a name="l01815"></a>01815         vmdq_adapter-&gt;rx_ring = adapter-&gt;rx_ring[base_queue];
<a name="l01816"></a>01816         vmdq_adapter-&gt;tx_ring = adapter-&gt;tx_ring[base_queue];
<a name="l01817"></a>01817         igb_assign_vmdq_netdev_ops(vnetdev);
<a name="l01818"></a>01818         snprintf(vnetdev-&gt;name, IFNAMSIZ, <span class="stringliteral">&quot;%sv%d&quot;</span>,
<a name="l01819"></a>01819              adapter-&gt;netdev-&gt;name, pool);
<a name="l01820"></a>01820         vnetdev-&gt;features = adapter-&gt;netdev-&gt;features;
<a name="l01821"></a>01821 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l01822"></a>01822 <span class="preprocessor"></span>        vnetdev-&gt;vlan_features = adapter-&gt;netdev-&gt;vlan_features;
<a name="l01823"></a>01823 <span class="preprocessor">#endif</span>
<a name="l01824"></a>01824 <span class="preprocessor"></span>        adapter-&gt;vmdq_netdev[pool-1] = vnetdev;
<a name="l01825"></a>01825         err = register_netdev(vnetdev);
<a name="l01826"></a>01826         <span class="keywordflow">if</span> (err)
<a name="l01827"></a>01827             <span class="keywordflow">break</span>;
<a name="l01828"></a>01828     }
<a name="l01829"></a>01829     <span class="keywordflow">return</span> err;
<a name="l01830"></a>01830 }
<a name="l01831"></a>01831 
<a name="l01832"></a>01832 <span class="keywordtype">int</span> igb_remove_vmdq_netdevs(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l01833"></a>01833 {
<a name="l01834"></a>01834     <span class="keywordtype">int</span> pool, err = 0;
<a name="l01835"></a>01835 
<a name="l01836"></a>01836     <span class="keywordflow">for</span> (pool = 1; pool &lt; adapter-&gt;vmdq_pools; pool++) {
<a name="l01837"></a>01837         unregister_netdev(adapter-&gt;vmdq_netdev[pool-1]);
<a name="l01838"></a>01838         free_netdev(adapter-&gt;vmdq_netdev[pool-1]);
<a name="l01839"></a>01839         adapter-&gt;vmdq_netdev[pool-1] = NULL;
<a name="l01840"></a>01840     }
<a name="l01841"></a>01841     <span class="keywordflow">return</span> err;
<a name="l01842"></a>01842 }
<a name="l01843"></a>01843 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IGB_VMDQ_NETDEV */</span>
<a name="l01844"></a>01844 
<a name="l01856"></a>01856 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit igb_probe(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l01857"></a>01857                    <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *ent)
<a name="l01858"></a>01858 {
<a name="l01859"></a>01859     <span class="keyword">struct </span>net_device *netdev;
<a name="l01860"></a>01860     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter;
<a name="l01861"></a>01861     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw;
<a name="l01862"></a>01862     u16 eeprom_data = 0;
<a name="l01863"></a>01863     u8 pba_str[E1000_PBANUM_LENGTH];
<a name="l01864"></a>01864     s32 ret_val;
<a name="l01865"></a>01865     <span class="keyword">static</span> <span class="keywordtype">int</span> global_quad_port_a; <span class="comment">/* global quad port a indication */</span>
<a name="l01866"></a>01866     <span class="keywordtype">int</span> i, err, pci_using_dac;
<a name="l01867"></a>01867     <span class="keyword">static</span> <span class="keywordtype">int</span> cards_found;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869     err = pci_enable_device_mem(pdev);
<a name="l01870"></a>01870     <span class="keywordflow">if</span> (err)
<a name="l01871"></a>01871         <span class="keywordflow">return</span> err;
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     pci_using_dac = 0;
<a name="l01874"></a>01874     err = dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64));
<a name="l01875"></a>01875     <span class="keywordflow">if</span> (!err) {
<a name="l01876"></a>01876         err = dma_set_coherent_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64));
<a name="l01877"></a>01877         <span class="keywordflow">if</span> (!err)
<a name="l01878"></a>01878             pci_using_dac = 1;
<a name="l01879"></a>01879     } <span class="keywordflow">else</span> {
<a name="l01880"></a>01880         err = dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(32));
<a name="l01881"></a>01881         <span class="keywordflow">if</span> (err) {
<a name="l01882"></a>01882             err = dma_set_coherent_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(32));
<a name="l01883"></a>01883             <span class="keywordflow">if</span> (err) {
<a name="l01884"></a>01884                 IGB_ERR(<span class="stringliteral">&quot;No usable DMA configuration, &quot;</span>
<a name="l01885"></a>01885                         <span class="stringliteral">&quot;aborting\n&quot;</span>);
<a name="l01886"></a>01886                 <span class="keywordflow">goto</span> err_dma;
<a name="l01887"></a>01887             }
<a name="l01888"></a>01888         }
<a name="l01889"></a>01889     }
<a name="l01890"></a>01890 
<a name="l01891"></a>01891 <span class="preprocessor">#ifndef HAVE_ASPM_QUIRKS</span>
<a name="l01892"></a>01892 <span class="preprocessor"></span>    <span class="comment">/* 82575 requires that the pci-e link partner disable the L0s state */</span>
<a name="l01893"></a>01893     <span class="keywordflow">switch</span> (pdev-&gt;device) {
<a name="l01894"></a>01894     <span class="keywordflow">case</span> E1000_DEV_ID_82575EB_COPPER:
<a name="l01895"></a>01895     <span class="keywordflow">case</span> E1000_DEV_ID_82575EB_FIBER_SERDES:
<a name="l01896"></a>01896     <span class="keywordflow">case</span> E1000_DEV_ID_82575GB_QUAD_COPPER:
<a name="l01897"></a>01897         pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S);
<a name="l01898"></a>01898     <span class="keywordflow">default</span>:
<a name="l01899"></a>01899         <span class="keywordflow">break</span>;
<a name="l01900"></a>01900     }
<a name="l01901"></a>01901 
<a name="l01902"></a>01902 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ASPM_QUIRKS */</span>
<a name="l01903"></a>01903     err = pci_request_selected_regions(pdev,
<a name="l01904"></a>01904                                        pci_select_bars(pdev,
<a name="l01905"></a>01905                                                            IORESOURCE_MEM),
<a name="l01906"></a>01906                                        igb_driver_name);
<a name="l01907"></a>01907     <span class="keywordflow">if</span> (err)
<a name="l01908"></a>01908         <span class="keywordflow">goto</span> err_pci_reg;
<a name="l01909"></a>01909 
<a name="l01910"></a>01910     pci_enable_pcie_error_reporting(pdev);
<a name="l01911"></a>01911 
<a name="l01912"></a>01912     pci_set_master(pdev);
<a name="l01913"></a>01913 
<a name="l01914"></a>01914     err = -ENOMEM;
<a name="l01915"></a>01915 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l01916"></a>01916 <span class="preprocessor"></span>    netdev = alloc_etherdev_mq(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a>),
<a name="l01917"></a>01917                                IGB_MAX_TX_QUEUES);
<a name="l01918"></a>01918 <span class="preprocessor">#else</span>
<a name="l01919"></a>01919 <span class="preprocessor"></span>    netdev = alloc_etherdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a>));
<a name="l01920"></a>01920 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l01921"></a>01921     <span class="keywordflow">if</span> (!netdev)
<a name="l01922"></a>01922         <span class="keywordflow">goto</span> err_alloc_etherdev;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924     SET_MODULE_OWNER(netdev);
<a name="l01925"></a>01925     SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);
<a name="l01926"></a>01926 
<a name="l01927"></a>01927     pci_set_drvdata(pdev, netdev);
<a name="l01928"></a>01928     adapter = netdev_priv(netdev);
<a name="l01929"></a>01929     adapter-&gt;netdev = netdev;
<a name="l01930"></a>01930     adapter-&gt;pdev = pdev;
<a name="l01931"></a>01931     hw = &amp;adapter-&gt;hw;
<a name="l01932"></a>01932     hw-&gt;back = adapter;
<a name="l01933"></a>01933     adapter-&gt;msg_enable = (1 &lt;&lt; debug) - 1;
<a name="l01934"></a>01934 
<a name="l01935"></a>01935 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l01936"></a>01936 <span class="preprocessor"></span>    err = pci_save_state(pdev);
<a name="l01937"></a>01937     <span class="keywordflow">if</span> (err)
<a name="l01938"></a>01938         <span class="keywordflow">goto</span> err_ioremap;
<a name="l01939"></a>01939 <span class="preprocessor">#endif</span>
<a name="l01940"></a>01940 <span class="preprocessor"></span>    err = -EIO;
<a name="l01941"></a>01941     hw-&gt;hw_addr = ioremap(pci_resource_start(pdev, 0),
<a name="l01942"></a>01942                           pci_resource_len(pdev, 0));
<a name="l01943"></a>01943     <span class="keywordflow">if</span> (!hw-&gt;hw_addr)
<a name="l01944"></a>01944         <span class="keywordflow">goto</span> err_ioremap;
<a name="l01945"></a>01945 
<a name="l01946"></a>01946 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l01947"></a>01947 <span class="preprocessor"></span>    netdev-&gt;netdev_ops = &amp;igb_netdev_ops;
<a name="l01948"></a>01948 <span class="preprocessor">#else </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l01949"></a>01949     netdev-&gt;open = &amp;igb_open;
<a name="l01950"></a>01950     netdev-&gt;stop = &amp;igb_close;
<a name="l01951"></a>01951     netdev-&gt;get_stats = &amp;igb_get_stats;
<a name="l01952"></a>01952 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l01953"></a>01953 <span class="preprocessor"></span>    netdev-&gt;set_rx_mode = &amp;igb_set_rx_mode;
<a name="l01954"></a>01954 <span class="preprocessor">#endif</span>
<a name="l01955"></a>01955 <span class="preprocessor"></span>    netdev-&gt;set_multicast_list = &amp;igb_set_rx_mode;
<a name="l01956"></a>01956     netdev-&gt;set_mac_address = &amp;igb_set_mac;
<a name="l01957"></a>01957     netdev-&gt;change_mtu = &amp;igb_change_mtu;
<a name="l01958"></a>01958     netdev-&gt;do_ioctl = &amp;igb_ioctl;
<a name="l01959"></a>01959 <span class="preprocessor">#ifdef HAVE_TX_TIMEOUT</span>
<a name="l01960"></a>01960 <span class="preprocessor"></span>    netdev-&gt;tx_timeout = &amp;igb_tx_timeout;
<a name="l01961"></a>01961 <span class="preprocessor">#endif</span>
<a name="l01962"></a>01962 <span class="preprocessor"></span>    netdev-&gt;vlan_rx_register = igb_vlan_rx_register;
<a name="l01963"></a>01963     netdev-&gt;vlan_rx_add_vid = igb_vlan_rx_add_vid;
<a name="l01964"></a>01964     netdev-&gt;vlan_rx_kill_vid = igb_vlan_rx_kill_vid;
<a name="l01965"></a>01965 <span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l01966"></a>01966 <span class="preprocessor"></span>    netdev-&gt;poll_controller = igb_netpoll;
<a name="l01967"></a>01967 <span class="preprocessor">#endif</span>
<a name="l01968"></a>01968 <span class="preprocessor"></span>    netdev-&gt;hard_start_xmit = &amp;igb_xmit_frame;
<a name="l01969"></a>01969 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l01970"></a>01970     igb_set_ethtool_ops(netdev);
<a name="l01971"></a>01971 <span class="preprocessor">#ifdef HAVE_TX_TIMEOUT</span>
<a name="l01972"></a>01972 <span class="preprocessor"></span>    netdev-&gt;watchdog_timeo = 5 * HZ;
<a name="l01973"></a>01973 <span class="preprocessor">#endif</span>
<a name="l01974"></a>01974 <span class="preprocessor"></span>
<a name="l01975"></a>01975     strncpy(netdev-&gt;name, pci_name(pdev), <span class="keyword">sizeof</span>(netdev-&gt;name) - 1);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977     adapter-&gt;bd_number = cards_found;
<a name="l01978"></a>01978 
<a name="l01979"></a>01979     <span class="comment">/* setup the private structure */</span>
<a name="l01980"></a>01980     err = igb_sw_init(adapter);
<a name="l01981"></a>01981     <span class="keywordflow">if</span> (err)
<a name="l01982"></a>01982         <span class="keywordflow">goto</span> err_sw_init;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984     e1000_get_bus_info(hw);
<a name="l01985"></a>01985 
<a name="l01986"></a>01986     hw-&gt;phy.autoneg_wait_to_complete = FALSE;
<a name="l01987"></a>01987     hw-&gt;mac.adaptive_ifs = FALSE;
<a name="l01988"></a>01988 
<a name="l01989"></a>01989     <span class="comment">/* Copper options */</span>
<a name="l01990"></a>01990     <span class="keywordflow">if</span> (hw-&gt;phy.media_type == e1000_media_type_copper) {
<a name="l01991"></a>01991 <span class="preprocessor">#ifdef ETH_TP_MDI_X</span>
<a name="l01992"></a>01992 <span class="preprocessor"></span>        hw-&gt;phy.mdix = ETH_TP_MDI_INVALID;
<a name="l01993"></a>01993 <span class="preprocessor">#else</span>
<a name="l01994"></a>01994 <span class="preprocessor"></span>        hw-&gt;phy.mdix = AUTO_ALL_MODES;
<a name="l01995"></a>01995 <span class="preprocessor">#endif </span><span class="comment">/* ETH_TP_MDI_X */</span>
<a name="l01996"></a>01996         hw-&gt;phy.disable_polarity_correction = FALSE;
<a name="l01997"></a>01997         hw-&gt;phy.ms_type = e1000_ms_hw_default;
<a name="l01998"></a>01998     }
<a name="l01999"></a>01999 
<a name="l02000"></a>02000     <span class="keywordflow">if</span> (e1000_check_reset_block(hw))
<a name="l02001"></a>02001         dev_info(pci_dev_to_dev(pdev),
<a name="l02002"></a>02002             <span class="stringliteral">&quot;PHY reset is blocked due to SOL/IDER session.\n&quot;</span>);
<a name="l02003"></a>02003 
<a name="l02004"></a>02004     netdev-&gt;features = NETIF_F_SG |
<a name="l02005"></a>02005                NETIF_F_IP_CSUM |
<a name="l02006"></a>02006                NETIF_F_HW_VLAN_TX |
<a name="l02007"></a>02007                NETIF_F_HW_VLAN_RX |
<a name="l02008"></a>02008                NETIF_F_HW_VLAN_FILTER;
<a name="l02009"></a>02009 
<a name="l02010"></a>02010 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l02011"></a>02011 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_IPV6_CSUM;
<a name="l02012"></a>02012 <span class="preprocessor">#endif</span>
<a name="l02013"></a>02013 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l02014"></a>02014 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO;
<a name="l02015"></a>02015 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l02016"></a>02016 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO6;
<a name="l02017"></a>02017 <span class="preprocessor">#endif</span>
<a name="l02018"></a>02018 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l02019"></a>02019 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l02020"></a>02020 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_LRO;
<a name="l02021"></a>02021 
<a name="l02022"></a>02022 <span class="preprocessor">#endif</span>
<a name="l02023"></a>02023 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_GRO</span>
<a name="l02024"></a>02024 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_GRO;
<a name="l02025"></a>02025 <span class="preprocessor">#endif</span>
<a name="l02026"></a>02026 <span class="preprocessor"></span>
<a name="l02027"></a>02027 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l02028"></a>02028 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_TSO;
<a name="l02029"></a>02029     netdev-&gt;vlan_features |= NETIF_F_TSO6;
<a name="l02030"></a>02030     netdev-&gt;vlan_features |= NETIF_F_IP_CSUM;
<a name="l02031"></a>02031     netdev-&gt;vlan_features |= NETIF_F_IPV6_CSUM;
<a name="l02032"></a>02032     netdev-&gt;vlan_features |= NETIF_F_SG;
<a name="l02033"></a>02033 
<a name="l02034"></a>02034 <span class="preprocessor">#endif</span>
<a name="l02035"></a>02035 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (pci_using_dac)
<a name="l02036"></a>02036         netdev-&gt;features |= NETIF_F_HIGHDMA;
<a name="l02037"></a>02037 
<a name="l02038"></a>02038     <span class="keywordflow">if</span> (hw-&gt;mac.type &gt;= e1000_82576)
<a name="l02039"></a>02039         netdev-&gt;features |= NETIF_F_SCTP_CSUM;
<a name="l02040"></a>02040 
<a name="l02041"></a>02041     adapter-&gt;en_mng_pt = e1000_enable_mng_pass_thru(hw);
<a name="l02042"></a>02042 
<a name="l02043"></a>02043     <span class="comment">/* before reading the NVM, reset the controller to put the device in a</span>
<a name="l02044"></a>02044 <span class="comment">     * known good starting state */</span>
<a name="l02045"></a>02045     e1000_reset_hw(hw);
<a name="l02046"></a>02046 
<a name="l02047"></a>02047     <span class="comment">/* make sure the NVM is good */</span>
<a name="l02048"></a>02048     <span class="keywordflow">if</span> (e1000_validate_nvm_checksum(hw) &lt; 0) {
<a name="l02049"></a>02049         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;The NVM Checksum Is Not&quot;</span>
<a name="l02050"></a>02050                 <span class="stringliteral">&quot; Valid\n&quot;</span>);
<a name="l02051"></a>02051         err = -EIO;
<a name="l02052"></a>02052         <span class="keywordflow">goto</span> err_eeprom;
<a name="l02053"></a>02053     }
<a name="l02054"></a>02054 
<a name="l02055"></a>02055     <span class="comment">/* copy the MAC address out of the NVM */</span>
<a name="l02056"></a>02056     <span class="keywordflow">if</span> (e1000_read_mac_addr(hw))
<a name="l02057"></a>02057         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;NVM Read Error\n&quot;</span>);
<a name="l02058"></a>02058     memcpy(netdev-&gt;dev_addr, hw-&gt;mac.addr, netdev-&gt;addr_len);
<a name="l02059"></a>02059 <span class="preprocessor">#ifdef ETHTOOL_GPERMADDR</span>
<a name="l02060"></a>02060 <span class="preprocessor"></span>    memcpy(netdev-&gt;perm_addr, hw-&gt;mac.addr, netdev-&gt;addr_len);
<a name="l02061"></a>02061 
<a name="l02062"></a>02062     <span class="keywordflow">if</span> (!is_valid_ether_addr(netdev-&gt;perm_addr)) {
<a name="l02063"></a>02063 <span class="preprocessor">#else</span>
<a name="l02064"></a>02064 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!is_valid_ether_addr(netdev-&gt;dev_addr)) {
<a name="l02065"></a>02065 <span class="preprocessor">#endif</span>
<a name="l02066"></a>02066 <span class="preprocessor"></span>        dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Invalid MAC Address\n&quot;</span>);
<a name="l02067"></a>02067         err = -EIO;
<a name="l02068"></a>02068         <span class="keywordflow">goto</span> err_eeprom;
<a name="l02069"></a>02069     }
<a name="l02070"></a>02070 
<a name="l02071"></a>02071     memcpy(&amp;adapter-&gt;mac_table[0].addr, hw-&gt;mac.addr, netdev-&gt;addr_len);
<a name="l02072"></a>02072     adapter-&gt;mac_table[0].queue = adapter-&gt;vfs_allocated_count;
<a name="l02073"></a>02073     adapter-&gt;mac_table[0].state = (IGB_MAC_STATE_DEFAULT | IGB_MAC_STATE_IN_USE);
<a name="l02074"></a>02074     igb_rar_set(adapter, 0);
<a name="l02075"></a>02075 
<a name="l02076"></a>02076     <span class="comment">/* get firmware version for ethtool -i */</span>
<a name="l02077"></a>02077     e1000_read_nvm(&amp;adapter-&gt;hw, 5, 1, &amp;adapter-&gt;fw_version);
<a name="l02078"></a>02078     setup_timer(&amp;adapter-&gt;watchdog_timer, &amp;igb_watchdog,
<a name="l02079"></a>02079                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) adapter);
<a name="l02080"></a>02080     setup_timer(&amp;adapter-&gt;phy_info_timer, &amp;igb_update_phy_info,
<a name="l02081"></a>02081                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) adapter);
<a name="l02082"></a>02082 
<a name="l02083"></a>02083     INIT_WORK(&amp;adapter-&gt;reset_task, igb_reset_task);
<a name="l02084"></a>02084     INIT_WORK(&amp;adapter-&gt;watchdog_task, igb_watchdog_task);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086     <span class="comment">/* Initialize link properties that are user-changeable */</span>
<a name="l02087"></a>02087     adapter-&gt;fc_autoneg = <span class="keyword">true</span>;
<a name="l02088"></a>02088     hw-&gt;mac.autoneg = <span class="keyword">true</span>;
<a name="l02089"></a>02089     hw-&gt;phy.autoneg_advertised = 0x2f;
<a name="l02090"></a>02090 
<a name="l02091"></a>02091     hw-&gt;fc.requested_mode = e1000_fc_default;
<a name="l02092"></a>02092     hw-&gt;fc.current_mode = e1000_fc_default;
<a name="l02093"></a>02093 
<a name="l02094"></a>02094     e1000_validate_mdi_setting(hw);
<a name="l02095"></a>02095 
<a name="l02096"></a>02096     <span class="comment">/* Initial Wake on LAN setting If APM wake is enabled in the EEPROM,</span>
<a name="l02097"></a>02097 <span class="comment">     * enable the ACPI Magic Packet filter</span>
<a name="l02098"></a>02098 <span class="comment">     */</span>
<a name="l02099"></a>02099 
<a name="l02100"></a>02100     <span class="keywordflow">if</span> (hw-&gt;bus.func == 0)
<a name="l02101"></a>02101         e1000_read_nvm(hw, NVM_INIT_CONTROL3_PORT_A, 1, &amp;eeprom_data);
<a name="l02102"></a>02102     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;mac.type &gt;= e1000_82580)
<a name="l02103"></a>02103         hw-&gt;nvm.ops.read(hw, NVM_INIT_CONTROL3_PORT_A +
<a name="l02104"></a>02104                          NVM_82580_LAN_FUNC_OFFSET(hw-&gt;bus.func), 1,
<a name="l02105"></a>02105                          &amp;eeprom_data);
<a name="l02106"></a>02106     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;bus.func == 1)
<a name="l02107"></a>02107         e1000_read_nvm(hw, NVM_INIT_CONTROL3_PORT_B, 1, &amp;eeprom_data);
<a name="l02108"></a>02108 
<a name="l02109"></a>02109     <span class="keywordflow">if</span> (eeprom_data &amp; IGB_EEPROM_APME)
<a name="l02110"></a>02110         adapter-&gt;eeprom_wol |= E1000_WUFC_MAG;
<a name="l02111"></a>02111 
<a name="l02112"></a>02112     <span class="comment">/* now that we have the eeprom settings, apply the special cases where</span>
<a name="l02113"></a>02113 <span class="comment">     * the eeprom may be wrong or the board simply won&#39;t support wake on</span>
<a name="l02114"></a>02114 <span class="comment">     * lan on a particular port */</span>
<a name="l02115"></a>02115     <span class="keywordflow">switch</span> (pdev-&gt;device) {
<a name="l02116"></a>02116     <span class="keywordflow">case</span> E1000_DEV_ID_82575GB_QUAD_COPPER:
<a name="l02117"></a>02117         adapter-&gt;eeprom_wol = 0;
<a name="l02118"></a>02118         <span class="keywordflow">break</span>;
<a name="l02119"></a>02119     <span class="keywordflow">case</span> E1000_DEV_ID_82575EB_FIBER_SERDES:
<a name="l02120"></a>02120     <span class="keywordflow">case</span> E1000_DEV_ID_82576_FIBER:
<a name="l02121"></a>02121     <span class="keywordflow">case</span> E1000_DEV_ID_82576_SERDES:
<a name="l02122"></a>02122         <span class="comment">/* Wake events only supported on port A for dual fiber</span>
<a name="l02123"></a>02123 <span class="comment">         * regardless of eeprom setting */</span>
<a name="l02124"></a>02124         <span class="keywordflow">if</span> (E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STATUS_FUNC_1)
<a name="l02125"></a>02125             adapter-&gt;eeprom_wol = 0;
<a name="l02126"></a>02126         <span class="keywordflow">break</span>;
<a name="l02127"></a>02127     <span class="keywordflow">case</span> E1000_DEV_ID_82576_QUAD_COPPER:
<a name="l02128"></a>02128     <span class="keywordflow">case</span> E1000_DEV_ID_82576_QUAD_COPPER_ET2:
<a name="l02129"></a>02129         <span class="comment">/* if quad port adapter, disable WoL on all but port A */</span>
<a name="l02130"></a>02130         <span class="keywordflow">if</span> (global_quad_port_a != 0)
<a name="l02131"></a>02131             adapter-&gt;eeprom_wol = 0;
<a name="l02132"></a>02132         <span class="keywordflow">else</span>
<a name="l02133"></a>02133             adapter-&gt;flags |= IGB_FLAG_QUAD_PORT_A;
<a name="l02134"></a>02134         <span class="comment">/* Reset for multiple quad port adapters */</span>
<a name="l02135"></a>02135         <span class="keywordflow">if</span> (++global_quad_port_a == 4)
<a name="l02136"></a>02136             global_quad_port_a = 0;
<a name="l02137"></a>02137         <span class="keywordflow">break</span>;
<a name="l02138"></a>02138     }
<a name="l02139"></a>02139 
<a name="l02140"></a>02140     <span class="comment">/* initialize the wol settings based on the eeprom settings */</span>
<a name="l02141"></a>02141     adapter-&gt;wol = adapter-&gt;eeprom_wol;
<a name="l02142"></a>02142     device_set_wakeup_enable(pci_dev_to_dev(adapter-&gt;pdev), adapter-&gt;wol);
<a name="l02143"></a>02143 
<a name="l02144"></a>02144     <span class="comment">/* reset the hardware with the new settings */</span>
<a name="l02145"></a>02145     igb_reset(adapter);
<a name="l02146"></a>02146 
<a name="l02147"></a>02147     <span class="comment">/* let the f/w know that the h/w is now under the control of the</span>
<a name="l02148"></a>02148 <span class="comment">     * driver. */</span>
<a name="l02149"></a>02149     igb_get_hw_control(adapter);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151     strncpy(netdev-&gt;name, <span class="stringliteral">&quot;eth%d&quot;</span>, IFNAMSIZ);
<a name="l02152"></a>02152     err = register_netdev(netdev);
<a name="l02153"></a>02153     <span class="keywordflow">if</span> (err)
<a name="l02154"></a>02154         <span class="keywordflow">goto</span> err_register;
<a name="l02155"></a>02155 
<a name="l02156"></a>02156 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l02157"></a>02157 <span class="preprocessor"></span>    err = igb_init_vmdq_netdevs(adapter);
<a name="l02158"></a>02158     <span class="keywordflow">if</span> (err)
<a name="l02159"></a>02159         <span class="keywordflow">goto</span> err_register;
<a name="l02160"></a>02160 <span class="preprocessor">#endif</span>
<a name="l02161"></a>02161 <span class="preprocessor"></span>    <span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span>
<a name="l02162"></a>02162     netif_carrier_off(netdev);
<a name="l02163"></a>02163 
<a name="l02164"></a>02164 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l02165"></a>02165 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (dca_add_requester(&amp;pdev-&gt;dev) == E1000_SUCCESS) {
<a name="l02166"></a>02166         adapter-&gt;flags |= IGB_FLAG_DCA_ENABLED;
<a name="l02167"></a>02167         dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;DCA enabled\n&quot;</span>);
<a name="l02168"></a>02168         igb_setup_dca(adapter);
<a name="l02169"></a>02169     }
<a name="l02170"></a>02170 
<a name="l02171"></a>02171 <span class="preprocessor">#endif</span>
<a name="l02172"></a>02172 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l02173"></a>02173 <span class="preprocessor"></span>    <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02174"></a>02174     <span class="keywordflow">case</span> e1000_i350:
<a name="l02175"></a>02175     <span class="keywordflow">case</span> e1000_82580:
<a name="l02176"></a>02176         memset(&amp;adapter-&gt;cycles, 0, <span class="keyword">sizeof</span>(adapter-&gt;cycles));
<a name="l02177"></a>02177         adapter-&gt;cycles.read = igb_read_clock;
<a name="l02178"></a>02178         adapter-&gt;cycles.mask = CLOCKSOURCE_MASK(64);
<a name="l02179"></a>02179         adapter-&gt;cycles.mult = 1;
<a name="l02180"></a>02180         <span class="comment">/*</span>
<a name="l02181"></a>02181 <span class="comment">         * The 82580 timesync updates the system timer every 8ns by 8ns</span>
<a name="l02182"></a>02182 <span class="comment">         * and the value cannot be shifted.  Instead we need to shift</span>
<a name="l02183"></a>02183 <span class="comment">         * the registers to generate a 64bit timer value.  As a result</span>
<a name="l02184"></a>02184 <span class="comment">         * SYSTIMR/L/H, TXSTMPL/H, RXSTMPL/H all have to be shifted by</span>
<a name="l02185"></a>02185 <span class="comment">         * 24 in order to generate a larger value for synchronization.</span>
<a name="l02186"></a>02186 <span class="comment">         */</span>
<a name="l02187"></a>02187         adapter-&gt;cycles.shift = IGB_82580_TSYNC_SHIFT;
<a name="l02188"></a>02188         <span class="comment">/* disable system timer temporarily by setting bit 31 */</span>
<a name="l02189"></a>02189         E1000_WRITE_REG(hw, E1000_TSAUXC, 0x80000000);
<a name="l02190"></a>02190         E1000_WRITE_FLUSH(hw);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192         <span class="comment">/* Set registers so that rollover occurs soon to test this. */</span>
<a name="l02193"></a>02193         E1000_WRITE_REG(hw, E1000_SYSTIMR, 0x00000000);
<a name="l02194"></a>02194         E1000_WRITE_REG(hw, E1000_SYSTIML, 0x80000000);
<a name="l02195"></a>02195         E1000_WRITE_REG(hw, E1000_SYSTIMH, 0x000000FF);
<a name="l02196"></a>02196         E1000_WRITE_FLUSH(hw);
<a name="l02197"></a>02197 
<a name="l02198"></a>02198         <span class="comment">/* enable system timer by clearing bit 31 */</span>
<a name="l02199"></a>02199         E1000_WRITE_REG(hw, E1000_TSAUXC, 0x0);
<a name="l02200"></a>02200         E1000_WRITE_FLUSH(hw);
<a name="l02201"></a>02201 
<a name="l02202"></a>02202         timecounter_init(&amp;adapter-&gt;clock,
<a name="l02203"></a>02203                  &amp;adapter-&gt;cycles,
<a name="l02204"></a>02204                  ktime_to_ns(ktime_get_real()));
<a name="l02205"></a>02205         <span class="comment">/*</span>
<a name="l02206"></a>02206 <span class="comment">         * Synchronize our NIC clock against system wall clock. NIC</span>
<a name="l02207"></a>02207 <span class="comment">         * time stamp reading requires ~3us per sample, each sample</span>
<a name="l02208"></a>02208 <span class="comment">         * was pretty stable even under load =&gt; only require 10</span>
<a name="l02209"></a>02209 <span class="comment">         * samples for each offset comparison.</span>
<a name="l02210"></a>02210 <span class="comment">         */</span>
<a name="l02211"></a>02211         memset(&amp;adapter-&gt;compare, 0, <span class="keyword">sizeof</span>(adapter-&gt;compare));
<a name="l02212"></a>02212         adapter-&gt;compare.source = &amp;adapter-&gt;clock;
<a name="l02213"></a>02213         adapter-&gt;compare.target = ktime_get_real;
<a name="l02214"></a>02214         adapter-&gt;compare.num_samples = 10;
<a name="l02215"></a>02215         timecompare_update(&amp;adapter-&gt;compare, 0);
<a name="l02216"></a>02216         <span class="keywordflow">break</span>;
<a name="l02217"></a>02217     <span class="keywordflow">case</span> e1000_82576:
<a name="l02218"></a>02218         <span class="comment">/*</span>
<a name="l02219"></a>02219 <span class="comment">         * Initialize hardware timer: we keep it running just in case</span>
<a name="l02220"></a>02220 <span class="comment">         * that some program needs it later on.</span>
<a name="l02221"></a>02221 <span class="comment">         */</span>
<a name="l02222"></a>02222         memset(&amp;adapter-&gt;cycles, 0, <span class="keyword">sizeof</span>(adapter-&gt;cycles));
<a name="l02223"></a>02223         adapter-&gt;cycles.read = igb_read_clock;
<a name="l02224"></a>02224         adapter-&gt;cycles.mask = CLOCKSOURCE_MASK(64);
<a name="l02225"></a>02225         adapter-&gt;cycles.mult = 1;
<a name="l02235"></a>02235         adapter-&gt;cycles.shift = IGB_82576_TSYNC_SHIFT;
<a name="l02236"></a>02236         E1000_WRITE_REG(hw, E1000_TIMINCA,
<a name="l02237"></a>02237                         (1 &lt;&lt; E1000_TIMINCA_16NS_SHIFT) |
<a name="l02238"></a>02238                         (16 &lt;&lt; IGB_82576_TSYNC_SHIFT));
<a name="l02239"></a>02239 
<a name="l02240"></a>02240         <span class="comment">/* Set registers so that rollover occurs soon to test this. */</span>
<a name="l02241"></a>02241         E1000_WRITE_REG(hw, E1000_SYSTIML, 0x00000000);
<a name="l02242"></a>02242         E1000_WRITE_REG(hw, E1000_SYSTIMH, 0xFF800000);
<a name="l02243"></a>02243         E1000_WRITE_FLUSH(hw);
<a name="l02244"></a>02244 
<a name="l02245"></a>02245         timecounter_init(&amp;adapter-&gt;clock,
<a name="l02246"></a>02246                  &amp;adapter-&gt;cycles,
<a name="l02247"></a>02247                  ktime_to_ns(ktime_get_real()));
<a name="l02248"></a>02248         <span class="comment">/*</span>
<a name="l02249"></a>02249 <span class="comment">         * Synchronize our NIC clock against system wall clock. NIC</span>
<a name="l02250"></a>02250 <span class="comment">         * time stamp reading requires ~3us per sample, each sample</span>
<a name="l02251"></a>02251 <span class="comment">         * was pretty stable even under load =&gt; only require 10</span>
<a name="l02252"></a>02252 <span class="comment">         * samples for each offset comparison.</span>
<a name="l02253"></a>02253 <span class="comment">         */</span>
<a name="l02254"></a>02254         memset(&amp;adapter-&gt;compare, 0, <span class="keyword">sizeof</span>(adapter-&gt;compare));
<a name="l02255"></a>02255         adapter-&gt;compare.source = &amp;adapter-&gt;clock;
<a name="l02256"></a>02256         adapter-&gt;compare.target = ktime_get_real;
<a name="l02257"></a>02257         adapter-&gt;compare.num_samples = 10;
<a name="l02258"></a>02258         timecompare_update(&amp;adapter-&gt;compare, 0);
<a name="l02259"></a>02259         <span class="keywordflow">break</span>;
<a name="l02260"></a>02260     <span class="keywordflow">case</span> e1000_82575:
<a name="l02261"></a>02261         <span class="comment">/* 82575 does not support timesync */</span>
<a name="l02262"></a>02262     <span class="keywordflow">default</span>:
<a name="l02263"></a>02263         <span class="keywordflow">break</span>;
<a name="l02264"></a>02264     }
<a name="l02265"></a>02265 
<a name="l02266"></a>02266 <span class="preprocessor">#endif </span><span class="comment">/* SIOCSHWTSTAMP */</span>
<a name="l02267"></a>02267     dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Intel(R) Gigabit Ethernet Network Connection\n&quot;</span>);
<a name="l02268"></a>02268     <span class="comment">/* print bus type/speed/width info */</span>
<a name="l02269"></a>02269     dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;%s: (PCIe:%s:%s) &quot;</span>,
<a name="l02270"></a>02270              netdev-&gt;name,
<a name="l02271"></a>02271              ((hw-&gt;bus.speed == e1000_bus_speed_2500) ? <span class="stringliteral">&quot;2.5GT/s&quot;</span> :
<a name="l02272"></a>02272               (hw-&gt;bus.speed == e1000_bus_speed_5000) ? <span class="stringliteral">&quot;5.0GT/s&quot;</span> :
<a name="l02273"></a>02273                                                         <span class="stringliteral">&quot;unknown&quot;</span>),
<a name="l02274"></a>02274              ((hw-&gt;bus.width == e1000_bus_width_pcie_x4) ? <span class="stringliteral">&quot;Width x4&quot;</span> :
<a name="l02275"></a>02275               (hw-&gt;bus.width == e1000_bus_width_pcie_x2) ? <span class="stringliteral">&quot;Width x2&quot;</span> :
<a name="l02276"></a>02276               (hw-&gt;bus.width == e1000_bus_width_pcie_x1) ? <span class="stringliteral">&quot;Width x1&quot;</span> :
<a name="l02277"></a>02277                <span class="stringliteral">&quot;unknown&quot;</span>));
<a name="l02278"></a>02278 
<a name="l02279"></a>02279     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++)
<a name="l02280"></a>02280         printk(<span class="stringliteral">&quot;%2.2x%c&quot;</span>, netdev-&gt;dev_addr[i], i == 5 ? <span class="charliteral">&#39;\n&#39;</span> : <span class="charliteral">&#39;:&#39;</span>);
<a name="l02281"></a>02281 
<a name="l02282"></a>02282     ret_val = e1000_read_pba_string(hw, pba_str, E1000_PBANUM_LENGTH);
<a name="l02283"></a>02283     <span class="keywordflow">if</span> (ret_val)
<a name="l02284"></a>02284         strcpy(pba_str, <span class="stringliteral">&quot;Unknown&quot;</span>);
<a name="l02285"></a>02285     dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;%s: PBA No: %s\n&quot;</span>, netdev-&gt;name,
<a name="l02286"></a>02286          pba_str);
<a name="l02287"></a>02287 
<a name="l02288"></a>02288 
<a name="l02289"></a>02289     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02290"></a>02290     <span class="keywordflow">case</span> e1000_i350:
<a name="l02291"></a>02291         <span class="comment">/* Enable EEE */</span>
<a name="l02292"></a>02292         e1000_set_eee_i350(hw);
<a name="l02293"></a>02293 
<a name="l02294"></a>02294         <span class="comment">/* send driver version info to firmware */</span>
<a name="l02295"></a>02295         igb_init_fw(adapter);
<a name="l02296"></a>02296         <span class="keywordflow">break</span>;
<a name="l02297"></a>02297     <span class="keywordflow">default</span>:
<a name="l02298"></a>02298         <span class="keywordflow">break</span>;
<a name="l02299"></a>02299     }
<a name="l02300"></a>02300 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l02301"></a>02301 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (test_bit(IGB_RING_FLAG_RX_LRO, &amp;adapter-&gt;rx_ring[0]-&gt;flags))
<a name="l02302"></a>02302         dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Internal LRO is enabled \n&quot;</span>);
<a name="l02303"></a>02303     <span class="keywordflow">else</span>
<a name="l02304"></a>02304         dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;LRO is disabled \n&quot;</span>);
<a name="l02305"></a>02305 <span class="preprocessor">#endif</span>
<a name="l02306"></a>02306 <span class="preprocessor"></span>    dev_info(pci_dev_to_dev(pdev),
<a name="l02307"></a>02307              <span class="stringliteral">&quot;Using %s interrupts. %d rx queue(s), %d tx queue(s)\n&quot;</span>,
<a name="l02308"></a>02308              adapter-&gt;msix_entries ? <span class="stringliteral">&quot;MSI-X&quot;</span> :
<a name="l02309"></a>02309              (adapter-&gt;flags &amp; IGB_FLAG_HAS_MSI) ? <span class="stringliteral">&quot;MSI&quot;</span> : <span class="stringliteral">&quot;legacy&quot;</span>,
<a name="l02310"></a>02310              adapter-&gt;num_rx_queues, adapter-&gt;num_tx_queues);
<a name="l02311"></a>02311 
<a name="l02312"></a>02312     cards_found++;
<a name="l02313"></a>02313     <span class="keywordflow">return</span> 0;
<a name="l02314"></a>02314 
<a name="l02315"></a>02315 err_register:
<a name="l02316"></a>02316     igb_release_hw_control(adapter);
<a name="l02317"></a>02317 err_eeprom:
<a name="l02318"></a>02318     <span class="keywordflow">if</span> (!e1000_check_reset_block(hw))
<a name="l02319"></a>02319         e1000_phy_hw_reset(hw);
<a name="l02320"></a>02320 
<a name="l02321"></a>02321     <span class="keywordflow">if</span> (hw-&gt;flash_address)
<a name="l02322"></a>02322         iounmap(hw-&gt;flash_address);
<a name="l02323"></a>02323 err_sw_init:
<a name="l02324"></a>02324     igb_clear_interrupt_scheme(adapter);
<a name="l02325"></a>02325     igb_reset_sriov_capability(adapter);
<a name="l02326"></a>02326     iounmap(hw-&gt;hw_addr);
<a name="l02327"></a>02327 err_ioremap:
<a name="l02328"></a>02328     free_netdev(netdev);
<a name="l02329"></a>02329 err_alloc_etherdev:
<a name="l02330"></a>02330     pci_release_selected_regions(pdev,
<a name="l02331"></a>02331                                  pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l02332"></a>02332 err_pci_reg:
<a name="l02333"></a>02333 err_dma:
<a name="l02334"></a>02334     pci_disable_device(pdev);
<a name="l02335"></a>02335     <span class="keywordflow">return</span> err;
<a name="l02336"></a>02336 }
<a name="l02337"></a>02337 
<a name="l02347"></a>02347 <span class="keyword">static</span> <span class="keywordtype">void</span> __devexit igb_remove(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l02348"></a>02348 {
<a name="l02349"></a>02349     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l02350"></a>02350     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02351"></a>02351     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02352"></a>02352 
<a name="l02353"></a>02353     <span class="comment">/* flush_scheduled work may reschedule our watchdog task, so</span>
<a name="l02354"></a>02354 <span class="comment">     * explicitly disable watchdog tasks from being rescheduled  */</span>
<a name="l02355"></a>02355     set_bit(__IGB_DOWN, &amp;adapter-&gt;state);
<a name="l02356"></a>02356     del_timer_sync(&amp;adapter-&gt;watchdog_timer);
<a name="l02357"></a>02357     del_timer_sync(&amp;adapter-&gt;phy_info_timer);
<a name="l02358"></a>02358 
<a name="l02359"></a>02359     flush_scheduled_work();
<a name="l02360"></a>02360 
<a name="l02361"></a>02361 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l02362"></a>02362 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_DCA_ENABLED) {
<a name="l02363"></a>02363         dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;DCA disabled\n&quot;</span>);
<a name="l02364"></a>02364         dca_remove_requester(&amp;pdev-&gt;dev);
<a name="l02365"></a>02365         adapter-&gt;flags &amp;= ~IGB_FLAG_DCA_ENABLED;
<a name="l02366"></a>02366         E1000_WRITE_REG(hw, E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_DISABLE);
<a name="l02367"></a>02367     }
<a name="l02368"></a>02368 <span class="preprocessor">#endif</span>
<a name="l02369"></a>02369 <span class="preprocessor"></span>
<a name="l02370"></a>02370     <span class="comment">/* Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<a name="l02371"></a>02371 <span class="comment">     * would have already happened in close and is redundant. */</span>
<a name="l02372"></a>02372     igb_release_hw_control(adapter);
<a name="l02373"></a>02373 
<a name="l02374"></a>02374     unregister_netdev(netdev);
<a name="l02375"></a>02375 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l02376"></a>02376 <span class="preprocessor"></span>    igb_remove_vmdq_netdevs(adapter);
<a name="l02377"></a>02377 <span class="preprocessor">#endif</span>
<a name="l02378"></a>02378 <span class="preprocessor"></span>
<a name="l02379"></a>02379     igb_clear_interrupt_scheme(adapter);
<a name="l02380"></a>02380     igb_reset_sriov_capability(adapter);
<a name="l02381"></a>02381 
<a name="l02382"></a>02382     iounmap(hw-&gt;hw_addr);
<a name="l02383"></a>02383     <span class="keywordflow">if</span> (hw-&gt;flash_address)
<a name="l02384"></a>02384         iounmap(hw-&gt;flash_address);
<a name="l02385"></a>02385     pci_release_selected_regions(pdev,
<a name="l02386"></a>02386                                  pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l02387"></a>02387 
<a name="l02388"></a>02388     kfree(adapter-&gt;mac_table);
<a name="l02389"></a>02389     free_netdev(netdev);
<a name="l02390"></a>02390 
<a name="l02391"></a>02391     pci_disable_pcie_error_reporting(pdev);
<a name="l02392"></a>02392 
<a name="l02393"></a>02393     pci_disable_device(pdev);
<a name="l02394"></a>02394 }
<a name="l02395"></a>02395 
<a name="l02404"></a>02404 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit igb_sw_init(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02405"></a>02405 {
<a name="l02406"></a>02406     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02407"></a>02407     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02408"></a>02408     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l02409"></a>02409 
<a name="l02410"></a>02410     <span class="comment">/* PCI config space info */</span>
<a name="l02411"></a>02411 
<a name="l02412"></a>02412     hw-&gt;vendor_id = pdev-&gt;vendor;
<a name="l02413"></a>02413     hw-&gt;device_id = pdev-&gt;device;
<a name="l02414"></a>02414     hw-&gt;subsystem_vendor_id = pdev-&gt;subsystem_vendor;
<a name="l02415"></a>02415     hw-&gt;subsystem_device_id = pdev-&gt;subsystem_device;
<a name="l02416"></a>02416 
<a name="l02417"></a>02417     pci_read_config_byte(pdev, PCI_REVISION_ID, &amp;hw-&gt;revision_id);
<a name="l02418"></a>02418 
<a name="l02419"></a>02419     pci_read_config_word(pdev, PCI_COMMAND, &amp;hw-&gt;bus.pci_cmd_word);
<a name="l02420"></a>02420 
<a name="l02421"></a>02421     adapter-&gt;tx_ring_count = IGB_DEFAULT_TXD;
<a name="l02422"></a>02422     adapter-&gt;rx_ring_count = IGB_DEFAULT_RXD;
<a name="l02423"></a>02423     adapter-&gt;max_frame_size = netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN +
<a name="l02424"></a>02424                           VLAN_TAG_SIZE;
<a name="l02425"></a>02425 
<a name="l02426"></a>02426     <span class="comment">/* Initialize the hardware-specific values */</span>
<a name="l02427"></a>02427     <span class="keywordflow">if</span> (e1000_setup_init_funcs(hw, TRUE)) {
<a name="l02428"></a>02428         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Hardware Initialization Failure\n&quot;</span>);
<a name="l02429"></a>02429         <span class="keywordflow">return</span> -EIO;
<a name="l02430"></a>02430     }
<a name="l02431"></a>02431 
<a name="l02432"></a>02432     igb_check_options(adapter);
<a name="l02433"></a>02433 
<a name="l02434"></a>02434     adapter-&gt;mac_table = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__mac__addr.html">igb_mac_addr</a>) *
<a name="l02435"></a>02435                      hw-&gt;mac.rar_entry_count, 
<a name="l02436"></a>02436                      GFP_ATOMIC);
<a name="l02437"></a>02437 
<a name="l02438"></a>02438     <span class="comment">/* These calls may decrease the number of queues */</span>
<a name="l02439"></a>02439     igb_set_sriov_capability(adapter);
<a name="l02440"></a>02440 
<a name="l02441"></a>02441     <span class="keywordflow">if</span> (igb_init_interrupt_scheme(adapter)) {
<a name="l02442"></a>02442         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Unable to allocate memory for queues\n&quot;</span>);
<a name="l02443"></a>02443         <span class="keywordflow">return</span> -ENOMEM;
<a name="l02444"></a>02444     }
<a name="l02445"></a>02445 
<a name="l02446"></a>02446     <span class="comment">/* Explicitly disable IRQ since the NIC can be in any state. */</span>
<a name="l02447"></a>02447     igb_irq_disable(adapter);
<a name="l02448"></a>02448 
<a name="l02449"></a>02449     set_bit(__IGB_DOWN, &amp;adapter-&gt;state);
<a name="l02450"></a>02450     <span class="keywordflow">return</span> 0;
<a name="l02451"></a>02451 }
<a name="l02452"></a>02452 
<a name="l02465"></a>02465 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_open(<span class="keyword">struct</span> net_device *netdev)
<a name="l02466"></a>02466 {
<a name="l02467"></a>02467     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02468"></a>02468     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02469"></a>02469     <span class="keywordtype">int</span> err;
<a name="l02470"></a>02470     <span class="keywordtype">int</span> i;
<a name="l02471"></a>02471 
<a name="l02472"></a>02472     <span class="comment">/* disallow open during test */</span>
<a name="l02473"></a>02473     <span class="keywordflow">if</span> (test_bit(__IGB_TESTING, &amp;adapter-&gt;state))
<a name="l02474"></a>02474         <span class="keywordflow">return</span> -EBUSY;
<a name="l02475"></a>02475 
<a name="l02476"></a>02476     netif_carrier_off(netdev);
<a name="l02477"></a>02477 
<a name="l02478"></a>02478     <span class="comment">/* allocate transmit descriptors */</span>
<a name="l02479"></a>02479     err = igb_setup_all_tx_resources(adapter);
<a name="l02480"></a>02480     <span class="keywordflow">if</span> (err)
<a name="l02481"></a>02481         <span class="keywordflow">goto</span> err_setup_tx;
<a name="l02482"></a>02482 
<a name="l02483"></a>02483     <span class="comment">/* allocate receive descriptors */</span>
<a name="l02484"></a>02484     err = igb_setup_all_rx_resources(adapter);
<a name="l02485"></a>02485     <span class="keywordflow">if</span> (err)
<a name="l02486"></a>02486         <span class="keywordflow">goto</span> err_setup_rx;
<a name="l02487"></a>02487 
<a name="l02488"></a>02488     igb_power_up_link(adapter);
<a name="l02489"></a>02489 
<a name="l02490"></a>02490     <span class="comment">/* before we allocate an interrupt, we must be ready to handle it.</span>
<a name="l02491"></a>02491 <span class="comment">     * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span>
<a name="l02492"></a>02492 <span class="comment">     * as soon as we call pci_request_irq, so we have to setup our</span>
<a name="l02493"></a>02493 <span class="comment">     * clean_rx handler before we do so.  */</span>
<a name="l02494"></a>02494     igb_configure(adapter);
<a name="l02495"></a>02495 
<a name="l02496"></a>02496     err = igb_request_irq(adapter);
<a name="l02497"></a>02497     <span class="keywordflow">if</span> (err)
<a name="l02498"></a>02498         <span class="keywordflow">goto</span> err_req_irq;
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     <span class="comment">/* From here on the code is the same as igb_up() */</span>
<a name="l02501"></a>02501     clear_bit(__IGB_DOWN, &amp;adapter-&gt;state);
<a name="l02502"></a>02502 
<a name="l02503"></a>02503     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)
<a name="l02504"></a>02504         napi_enable(&amp;(adapter-&gt;q_vector[i]-&gt;napi));
<a name="l02505"></a>02505     igb_configure_lli(adapter);
<a name="l02506"></a>02506 
<a name="l02507"></a>02507     <span class="comment">/* Clear any pending interrupts. */</span>
<a name="l02508"></a>02508     E1000_READ_REG(hw, E1000_ICR);
<a name="l02509"></a>02509 
<a name="l02510"></a>02510     igb_irq_enable(adapter);
<a name="l02511"></a>02511 
<a name="l02512"></a>02512     <span class="comment">/* notify VFs that reset has been completed */</span>
<a name="l02513"></a>02513     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count) {
<a name="l02514"></a>02514         u32 reg_data = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l02515"></a>02515         reg_data |= E1000_CTRL_EXT_PFRSTD;
<a name="l02516"></a>02516         E1000_WRITE_REG(hw, E1000_CTRL_EXT, reg_data);
<a name="l02517"></a>02517     }
<a name="l02518"></a>02518 
<a name="l02519"></a>02519     netif_tx_start_all_queues(netdev);
<a name="l02520"></a>02520 
<a name="l02521"></a>02521     <span class="comment">/* start the watchdog. */</span>
<a name="l02522"></a>02522     hw-&gt;mac.get_link_status = 1;
<a name="l02523"></a>02523     schedule_work(&amp;adapter-&gt;watchdog_task);
<a name="l02524"></a>02524 
<a name="l02525"></a>02525     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l02526"></a>02526 
<a name="l02527"></a>02527 err_req_irq:
<a name="l02528"></a>02528     igb_release_hw_control(adapter);
<a name="l02529"></a>02529     igb_power_down_link(adapter);
<a name="l02530"></a>02530     igb_free_all_rx_resources(adapter);
<a name="l02531"></a>02531 err_setup_rx:
<a name="l02532"></a>02532     igb_free_all_tx_resources(adapter);
<a name="l02533"></a>02533 err_setup_tx:
<a name="l02534"></a>02534     igb_reset(adapter);
<a name="l02535"></a>02535 
<a name="l02536"></a>02536     <span class="keywordflow">return</span> err;
<a name="l02537"></a>02537 }
<a name="l02538"></a>02538 
<a name="l02550"></a>02550 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_close(<span class="keyword">struct</span> net_device *netdev)
<a name="l02551"></a>02551 {
<a name="l02552"></a>02552     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02553"></a>02553 
<a name="l02554"></a>02554     WARN_ON(test_bit(__IGB_RESETTING, &amp;adapter-&gt;state));
<a name="l02555"></a>02555     igb_down(adapter);
<a name="l02556"></a>02556 
<a name="l02557"></a>02557     igb_free_irq(adapter);
<a name="l02558"></a>02558 
<a name="l02559"></a>02559     igb_free_all_tx_resources(adapter);
<a name="l02560"></a>02560     igb_free_all_rx_resources(adapter);
<a name="l02561"></a>02561 
<a name="l02562"></a>02562     <span class="keywordflow">return</span> 0;
<a name="l02563"></a>02563 }
<a name="l02564"></a>02564 
<a name="l02571"></a>02571 <span class="keywordtype">int</span> igb_setup_tx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring)
<a name="l02572"></a>02572 {
<a name="l02573"></a>02573     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = tx_ring-&gt;dev;
<a name="l02574"></a>02574     <span class="keywordtype">int</span> orig_node = dev_to_node(dev);
<a name="l02575"></a>02575     <span class="keywordtype">int</span> size;
<a name="l02576"></a>02576 
<a name="l02577"></a>02577     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a>) * tx_ring-&gt;count;
<a name="l02578"></a>02578     tx_ring-&gt;buffer_info = vzalloc_node(size, tx_ring-&gt;numa_node);
<a name="l02579"></a>02579     <span class="keywordflow">if</span> (!tx_ring-&gt;buffer_info)
<a name="l02580"></a>02580         tx_ring-&gt;buffer_info = vzalloc(size);
<a name="l02581"></a>02581     <span class="keywordflow">if</span> (!tx_ring-&gt;buffer_info)
<a name="l02582"></a>02582         <span class="keywordflow">goto</span> err;
<a name="l02583"></a>02583 
<a name="l02584"></a>02584     <span class="comment">/* round up to nearest 4K */</span>
<a name="l02585"></a>02585     tx_ring-&gt;size = tx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unione1000__adv__tx__desc.html">e1000_adv_tx_desc</a>);
<a name="l02586"></a>02586     tx_ring-&gt;size = ALIGN(tx_ring-&gt;size, 4096);
<a name="l02587"></a>02587 
<a name="l02588"></a>02588     set_dev_node(dev, tx_ring-&gt;numa_node);
<a name="l02589"></a>02589     tx_ring-&gt;desc = dma_alloc_coherent(dev,
<a name="l02590"></a>02590                        tx_ring-&gt;size,
<a name="l02591"></a>02591                        &amp;tx_ring-&gt;dma,
<a name="l02592"></a>02592                        GFP_KERNEL);
<a name="l02593"></a>02593     set_dev_node(dev, orig_node);
<a name="l02594"></a>02594     <span class="keywordflow">if</span> (!tx_ring-&gt;desc)
<a name="l02595"></a>02595         tx_ring-&gt;desc = dma_alloc_coherent(dev,
<a name="l02596"></a>02596                            tx_ring-&gt;size,
<a name="l02597"></a>02597                            &amp;tx_ring-&gt;dma,
<a name="l02598"></a>02598                            GFP_KERNEL);
<a name="l02599"></a>02599 
<a name="l02600"></a>02600     <span class="keywordflow">if</span> (!tx_ring-&gt;desc)
<a name="l02601"></a>02601         <span class="keywordflow">goto</span> err;
<a name="l02602"></a>02602 
<a name="l02603"></a>02603     tx_ring-&gt;next_to_use = 0;
<a name="l02604"></a>02604     tx_ring-&gt;next_to_clean = 0;
<a name="l02605"></a>02605 
<a name="l02606"></a>02606     <span class="keywordflow">return</span> 0;
<a name="l02607"></a>02607 
<a name="l02608"></a>02608 err:
<a name="l02609"></a>02609     vfree(tx_ring-&gt;buffer_info);
<a name="l02610"></a>02610     dev_err(dev,
<a name="l02611"></a>02611         <span class="stringliteral">&quot;Unable to allocate memory for the transmit descriptor ring\n&quot;</span>);
<a name="l02612"></a>02612     <span class="keywordflow">return</span> -ENOMEM;
<a name="l02613"></a>02613 }
<a name="l02614"></a>02614 
<a name="l02622"></a>02622 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_setup_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02623"></a>02623 {
<a name="l02624"></a>02624     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l02625"></a>02625     <span class="keywordtype">int</span> i, err = 0;
<a name="l02626"></a>02626 
<a name="l02627"></a>02627     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l02628"></a>02628         err = igb_setup_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l02629"></a>02629         <span class="keywordflow">if</span> (err) {
<a name="l02630"></a>02630             dev_err(pci_dev_to_dev(pdev),
<a name="l02631"></a>02631                 <span class="stringliteral">&quot;Allocation for Tx Queue %u failed\n&quot;</span>, i);
<a name="l02632"></a>02632             <span class="keywordflow">for</span> (i--; i &gt;= 0; i--)
<a name="l02633"></a>02633                 igb_free_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l02634"></a>02634             <span class="keywordflow">break</span>;
<a name="l02635"></a>02635         }
<a name="l02636"></a>02636     }
<a name="l02637"></a>02637 
<a name="l02638"></a>02638     <span class="keywordflow">return</span> err;
<a name="l02639"></a>02639 }
<a name="l02640"></a>02640 
<a name="l02645"></a>02645 <span class="keywordtype">void</span> igb_setup_tctl(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02646"></a>02646 {
<a name="l02647"></a>02647     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02648"></a>02648     u32 tctl;
<a name="l02649"></a>02649 
<a name="l02650"></a>02650     <span class="comment">/* disable queue 0 which is enabled by default on 82575 and 82576 */</span>
<a name="l02651"></a>02651     E1000_WRITE_REG(hw, E1000_TXDCTL(0), 0);
<a name="l02652"></a>02652 
<a name="l02653"></a>02653     <span class="comment">/* Program the Transmit Control Register */</span>
<a name="l02654"></a>02654     tctl = E1000_READ_REG(hw, E1000_TCTL);
<a name="l02655"></a>02655     tctl &amp;= ~E1000_TCTL_CT;
<a name="l02656"></a>02656     tctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |
<a name="l02657"></a>02657         (E1000_COLLISION_THRESHOLD &lt;&lt; E1000_CT_SHIFT);
<a name="l02658"></a>02658 
<a name="l02659"></a>02659     e1000_config_collision_dist(hw);
<a name="l02660"></a>02660 
<a name="l02661"></a>02661     <span class="comment">/* Enable transmits */</span>
<a name="l02662"></a>02662     tctl |= E1000_TCTL_EN;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664     E1000_WRITE_REG(hw, E1000_TCTL, tctl);
<a name="l02665"></a>02665 }
<a name="l02666"></a>02666 
<a name="l02674"></a>02674 <span class="keywordtype">void</span> igb_configure_tx_ring(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l02675"></a>02675                            <span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *ring)
<a name="l02676"></a>02676 {
<a name="l02677"></a>02677     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02678"></a>02678     u32 txdctl = 0;
<a name="l02679"></a>02679     u64 tdba = ring-&gt;dma;
<a name="l02680"></a>02680     <span class="keywordtype">int</span> reg_idx = ring-&gt;reg_idx;
<a name="l02681"></a>02681 
<a name="l02682"></a>02682     <span class="comment">/* disable the queue */</span>
<a name="l02683"></a>02683     E1000_WRITE_REG(hw, E1000_TXDCTL(reg_idx), 0);
<a name="l02684"></a>02684     E1000_WRITE_FLUSH(hw);
<a name="l02685"></a>02685     mdelay(10);
<a name="l02686"></a>02686 
<a name="l02687"></a>02687     E1000_WRITE_REG(hw, E1000_TDLEN(reg_idx),
<a name="l02688"></a>02688                     ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unione1000__adv__tx__desc.html">e1000_adv_tx_desc</a>));
<a name="l02689"></a>02689     E1000_WRITE_REG(hw, E1000_TDBAL(reg_idx),
<a name="l02690"></a>02690                     tdba &amp; 0x00000000ffffffffULL);
<a name="l02691"></a>02691     E1000_WRITE_REG(hw, E1000_TDBAH(reg_idx), tdba &gt;&gt; 32);
<a name="l02692"></a>02692 
<a name="l02693"></a>02693     ring-&gt;tail = hw-&gt;hw_addr + E1000_TDT(reg_idx);
<a name="l02694"></a>02694     E1000_WRITE_REG(hw, E1000_TDH(reg_idx), 0);
<a name="l02695"></a>02695     writel(0, ring-&gt;tail);
<a name="l02696"></a>02696 
<a name="l02697"></a>02697     txdctl |= IGB_TX_PTHRESH;
<a name="l02698"></a>02698     txdctl |= IGB_TX_HTHRESH &lt;&lt; 8;
<a name="l02699"></a>02699     txdctl |= IGB_TX_WTHRESH &lt;&lt; 16;
<a name="l02700"></a>02700 
<a name="l02701"></a>02701     txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
<a name="l02702"></a>02702     E1000_WRITE_REG(hw, E1000_TXDCTL(reg_idx), txdctl);
<a name="l02703"></a>02703 }
<a name="l02704"></a>02704 
<a name="l02711"></a>02711 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_configure_tx(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02712"></a>02712 {
<a name="l02713"></a>02713     <span class="keywordtype">int</span> i;
<a name="l02714"></a>02714 
<a name="l02715"></a>02715     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l02716"></a>02716         igb_configure_tx_ring(adapter, adapter-&gt;tx_ring[i]);
<a name="l02717"></a>02717 }
<a name="l02718"></a>02718 
<a name="l02725"></a>02725 <span class="keywordtype">int</span> igb_setup_rx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *rx_ring)
<a name="l02726"></a>02726 {
<a name="l02727"></a>02727     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = rx_ring-&gt;dev;
<a name="l02728"></a>02728     <span class="keywordtype">int</span> orig_node = dev_to_node(dev);
<a name="l02729"></a>02729     <span class="keywordtype">int</span> size, desc_len;
<a name="l02730"></a>02730 
<a name="l02731"></a>02731     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a>) * rx_ring-&gt;count;
<a name="l02732"></a>02732     rx_ring-&gt;buffer_info = vzalloc_node(size, rx_ring-&gt;numa_node);
<a name="l02733"></a>02733     <span class="keywordflow">if</span> (!rx_ring-&gt;buffer_info)
<a name="l02734"></a>02734         rx_ring-&gt;buffer_info = vzalloc(size);
<a name="l02735"></a>02735     <span class="keywordflow">if</span> (!rx_ring-&gt;buffer_info)
<a name="l02736"></a>02736         <span class="keywordflow">goto</span> err;
<a name="l02737"></a>02737 
<a name="l02738"></a>02738     desc_len = <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unione1000__adv__rx__desc.html">e1000_adv_rx_desc</a>);
<a name="l02739"></a>02739 
<a name="l02740"></a>02740     <span class="comment">/* Round up to nearest 4K */</span>
<a name="l02741"></a>02741     rx_ring-&gt;size = rx_ring-&gt;count * desc_len;
<a name="l02742"></a>02742     rx_ring-&gt;size = ALIGN(rx_ring-&gt;size, 4096);
<a name="l02743"></a>02743 
<a name="l02744"></a>02744     set_dev_node(dev, rx_ring-&gt;numa_node);
<a name="l02745"></a>02745     rx_ring-&gt;desc = dma_alloc_coherent(dev,
<a name="l02746"></a>02746                        rx_ring-&gt;size,
<a name="l02747"></a>02747                        &amp;rx_ring-&gt;dma,
<a name="l02748"></a>02748                        GFP_KERNEL);
<a name="l02749"></a>02749     set_dev_node(dev, orig_node);
<a name="l02750"></a>02750     <span class="keywordflow">if</span> (!rx_ring-&gt;desc)
<a name="l02751"></a>02751         rx_ring-&gt;desc = dma_alloc_coherent(dev,
<a name="l02752"></a>02752                            rx_ring-&gt;size,
<a name="l02753"></a>02753                            &amp;rx_ring-&gt;dma,
<a name="l02754"></a>02754                            GFP_KERNEL);
<a name="l02755"></a>02755 
<a name="l02756"></a>02756     <span class="keywordflow">if</span> (!rx_ring-&gt;desc)
<a name="l02757"></a>02757         <span class="keywordflow">goto</span> err;
<a name="l02758"></a>02758 
<a name="l02759"></a>02759     rx_ring-&gt;next_to_clean = 0;
<a name="l02760"></a>02760     rx_ring-&gt;next_to_use = 0;
<a name="l02761"></a>02761 
<a name="l02762"></a>02762     <span class="keywordflow">return</span> 0;
<a name="l02763"></a>02763 
<a name="l02764"></a>02764 err:
<a name="l02765"></a>02765     vfree(rx_ring-&gt;buffer_info);
<a name="l02766"></a>02766     rx_ring-&gt;buffer_info = NULL;
<a name="l02767"></a>02767     dev_err(dev, <span class="stringliteral">&quot;Unable to allocate memory for the receive descriptor&quot;</span>
<a name="l02768"></a>02768         <span class="stringliteral">&quot; ring\n&quot;</span>);
<a name="l02769"></a>02769     <span class="keywordflow">return</span> -ENOMEM;
<a name="l02770"></a>02770 }
<a name="l02771"></a>02771 
<a name="l02779"></a>02779 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_setup_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02780"></a>02780 {
<a name="l02781"></a>02781     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l02782"></a>02782     <span class="keywordtype">int</span> i, err = 0;
<a name="l02783"></a>02783 
<a name="l02784"></a>02784     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l02785"></a>02785         err = igb_setup_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l02786"></a>02786         <span class="keywordflow">if</span> (err) {
<a name="l02787"></a>02787             dev_err(pci_dev_to_dev(pdev),
<a name="l02788"></a>02788                 <span class="stringliteral">&quot;Allocation for Rx Queue %u failed\n&quot;</span>, i);
<a name="l02789"></a>02789             <span class="keywordflow">for</span> (i--; i &gt;= 0; i--)
<a name="l02790"></a>02790                 igb_free_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l02791"></a>02791             <span class="keywordflow">break</span>;
<a name="l02792"></a>02792         }
<a name="l02793"></a>02793     }
<a name="l02794"></a>02794 
<a name="l02795"></a>02795     <span class="keywordflow">return</span> err;
<a name="l02796"></a>02796 }
<a name="l02797"></a>02797 
<a name="l02802"></a>02802 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_setup_mrqc(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02803"></a>02803 {
<a name="l02804"></a>02804     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02805"></a>02805     u32 mrqc, rxcsum;
<a name="l02806"></a>02806     u32 j, num_rx_queues, shift = 0, shift2 = 0;
<a name="l02807"></a>02807     <span class="keyword">union </span>e1000_reta {
<a name="l02808"></a>02808         u32 dword;
<a name="l02809"></a>02809         u8  bytes[4];
<a name="l02810"></a>02810     } reta;
<a name="l02811"></a>02811     <span class="keyword">static</span> <span class="keyword">const</span> u8 rsshash[40] = {
<a name="l02812"></a>02812         0x6d, 0x5a, 0x56, 0xda, 0x25, 0x5b, 0x0e, 0xc2, 0x41, 0x67,
<a name="l02813"></a>02813         0x25, 0x3d, 0x43, 0xa3, 0x8f, 0xb0, 0xd0, 0xca, 0x2b, 0xcb,
<a name="l02814"></a>02814         0xae, 0x7b, 0x30, 0xb4, 0x77, 0xcb, 0x2d, 0xa3, 0x80, 0x30,
<a name="l02815"></a>02815         0xf2, 0x0c, 0x6a, 0x42, 0xb7, 0x3b, 0xbe, 0xac, 0x01, 0xfa };
<a name="l02816"></a>02816 
<a name="l02817"></a>02817     <span class="comment">/* Fill out hash function seeds */</span>
<a name="l02818"></a>02818     <span class="keywordflow">for</span> (j = 0; j &lt; 10; j++) {
<a name="l02819"></a>02819         u32 rsskey = rsshash[(j * 4)];
<a name="l02820"></a>02820         rsskey |= rsshash[(j * 4) + 1] &lt;&lt; 8;
<a name="l02821"></a>02821         rsskey |= rsshash[(j * 4) + 2] &lt;&lt; 16;
<a name="l02822"></a>02822         rsskey |= rsshash[(j * 4) + 3] &lt;&lt; 24;
<a name="l02823"></a>02823         E1000_WRITE_REG_ARRAY(hw, E1000_RSSRK(0), j, rsskey);
<a name="l02824"></a>02824     }
<a name="l02825"></a>02825 
<a name="l02826"></a>02826     num_rx_queues = adapter-&gt;rss_queues;
<a name="l02827"></a>02827 
<a name="l02828"></a>02828     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count || adapter-&gt;vmdq_pools) {
<a name="l02829"></a>02829         <span class="comment">/* 82575 and 82576 supports 2 RSS queues for VMDq */</span>
<a name="l02830"></a>02830         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02831"></a>02831         <span class="keywordflow">case</span> e1000_i350:
<a name="l02832"></a>02832         <span class="keywordflow">case</span> e1000_82580:
<a name="l02833"></a>02833             num_rx_queues = 1;
<a name="l02834"></a>02834             shift = 0;
<a name="l02835"></a>02835             <span class="keywordflow">break</span>;
<a name="l02836"></a>02836         <span class="keywordflow">case</span> e1000_82576:
<a name="l02837"></a>02837             shift = 3;
<a name="l02838"></a>02838             num_rx_queues = 2;
<a name="l02839"></a>02839             <span class="keywordflow">break</span>;
<a name="l02840"></a>02840         <span class="keywordflow">case</span> e1000_82575:
<a name="l02841"></a>02841             shift = 2;
<a name="l02842"></a>02842             shift2 = 6;
<a name="l02843"></a>02843         <span class="keywordflow">default</span>:
<a name="l02844"></a>02844             <span class="keywordflow">break</span>;
<a name="l02845"></a>02845         }
<a name="l02846"></a>02846     } <span class="keywordflow">else</span> {
<a name="l02847"></a>02847         <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82575)
<a name="l02848"></a>02848             shift = 6;
<a name="l02849"></a>02849     }
<a name="l02850"></a>02850 
<a name="l02851"></a>02851     <span class="keywordflow">for</span> (j = 0; j &lt; (32 * 4); j++) {
<a name="l02852"></a>02852         reta.bytes[j &amp; 3] = (j % num_rx_queues) &lt;&lt; shift;
<a name="l02853"></a>02853         <span class="keywordflow">if</span> (shift2)
<a name="l02854"></a>02854             reta.bytes[j &amp; 3] |= num_rx_queues &lt;&lt; shift2;
<a name="l02855"></a>02855         <span class="keywordflow">if</span> ((j &amp; 3) == 3)
<a name="l02856"></a>02856             E1000_WRITE_REG(hw, E1000_RETA(j &gt;&gt; 2), reta.dword);
<a name="l02857"></a>02857     }
<a name="l02858"></a>02858 
<a name="l02859"></a>02859     <span class="comment">/*</span>
<a name="l02860"></a>02860 <span class="comment">     * Disable raw packet checksumming so that RSS hash is placed in</span>
<a name="l02861"></a>02861 <span class="comment">     * descriptor on writeback.  No need to enable TCP/UDP/IP checksum</span>
<a name="l02862"></a>02862 <span class="comment">     * offloads as they are enabled by default</span>
<a name="l02863"></a>02863 <span class="comment">     */</span>
<a name="l02864"></a>02864     rxcsum = E1000_READ_REG(hw, E1000_RXCSUM);
<a name="l02865"></a>02865     rxcsum |= E1000_RXCSUM_PCSD;
<a name="l02866"></a>02866 
<a name="l02867"></a>02867     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type &gt;= e1000_82576)
<a name="l02868"></a>02868         <span class="comment">/* Enable Receive Checksum Offload for SCTP */</span>
<a name="l02869"></a>02869         rxcsum |= E1000_RXCSUM_CRCOFL;
<a name="l02870"></a>02870 
<a name="l02871"></a>02871     <span class="comment">/* Don&#39;t need to set TUOFL or IPOFL, they default to 1 */</span>
<a name="l02872"></a>02872     E1000_WRITE_REG(hw, E1000_RXCSUM, rxcsum);
<a name="l02873"></a>02873 
<a name="l02874"></a>02874     <span class="comment">/* If VMDq is enabled then we set the appropriate mode for that, else</span>
<a name="l02875"></a>02875 <span class="comment">     * we default to RSS so that an RSS hash is calculated per packet even</span>
<a name="l02876"></a>02876 <span class="comment">     * if we are only using one queue */</span>
<a name="l02877"></a>02877     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count || adapter-&gt;vmdq_pools) {
<a name="l02878"></a>02878         <span class="keywordflow">if</span> (hw-&gt;mac.type &gt; e1000_82575) {
<a name="l02879"></a>02879             <span class="comment">/* Set the default pool for the PF&#39;s first queue */</span>
<a name="l02880"></a>02880             u32 vtctl = E1000_READ_REG(hw, E1000_VT_CTL);
<a name="l02881"></a>02881             vtctl &amp;= ~(E1000_VT_CTL_DEFAULT_POOL_MASK |
<a name="l02882"></a>02882                    E1000_VT_CTL_DISABLE_DEF_POOL);
<a name="l02883"></a>02883             vtctl |= adapter-&gt;vfs_allocated_count &lt;&lt;
<a name="l02884"></a>02884                 E1000_VT_CTL_DEFAULT_POOL_SHIFT;
<a name="l02885"></a>02885             E1000_WRITE_REG(hw, E1000_VT_CTL, vtctl);
<a name="l02886"></a>02886         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;rss_queues &gt; 1) {
<a name="l02887"></a>02887             <span class="comment">/* set default queue for pool 1 to queue 2 */</span>
<a name="l02888"></a>02888             E1000_WRITE_REG(hw, E1000_VT_CTL,
<a name="l02889"></a>02889                         adapter-&gt;rss_queues &lt;&lt; 7);
<a name="l02890"></a>02890         }
<a name="l02891"></a>02891         <span class="keywordflow">if</span> (adapter-&gt;rss_queues &gt; 1)
<a name="l02892"></a>02892             mrqc = E1000_MRQC_ENABLE_VMDQ_RSS_2Q;
<a name="l02893"></a>02893         <span class="keywordflow">else</span>
<a name="l02894"></a>02894             mrqc = E1000_MRQC_ENABLE_VMDQ;
<a name="l02895"></a>02895     } <span class="keywordflow">else</span> {
<a name="l02896"></a>02896         mrqc = E1000_MRQC_ENABLE_RSS_4Q;
<a name="l02897"></a>02897     }
<a name="l02898"></a>02898 
<a name="l02899"></a>02899     igb_vmm_control(adapter);
<a name="l02900"></a>02900 
<a name="l02901"></a>02901     <span class="comment">/*</span>
<a name="l02902"></a>02902 <span class="comment">     * Generate RSS hash based on TCP port numbers and/or</span>
<a name="l02903"></a>02903 <span class="comment">     * IPv4/v6 src and dst addresses since UDP cannot be</span>
<a name="l02904"></a>02904 <span class="comment">     * hashed reliably due to IP fragmentation</span>
<a name="l02905"></a>02905 <span class="comment">     */</span>
<a name="l02906"></a>02906     mrqc |= E1000_MRQC_RSS_FIELD_IPV4 |
<a name="l02907"></a>02907         E1000_MRQC_RSS_FIELD_IPV4_TCP |
<a name="l02908"></a>02908         E1000_MRQC_RSS_FIELD_IPV6 |
<a name="l02909"></a>02909         E1000_MRQC_RSS_FIELD_IPV6_TCP |
<a name="l02910"></a>02910         E1000_MRQC_RSS_FIELD_IPV6_TCP_EX;
<a name="l02911"></a>02911 
<a name="l02912"></a>02912     E1000_WRITE_REG(hw, E1000_MRQC, mrqc);
<a name="l02913"></a>02913 }
<a name="l02914"></a>02914 
<a name="l02919"></a>02919 <span class="keywordtype">void</span> igb_setup_rctl(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02920"></a>02920 {
<a name="l02921"></a>02921     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02922"></a>02922     u32 rctl;
<a name="l02923"></a>02923 
<a name="l02924"></a>02924     rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l02925"></a>02925 
<a name="l02926"></a>02926     rctl &amp;= ~(3 &lt;&lt; E1000_RCTL_MO_SHIFT);
<a name="l02927"></a>02927     rctl &amp;= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);
<a name="l02928"></a>02928 
<a name="l02929"></a>02929     rctl |= E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_RDMTS_HALF |
<a name="l02930"></a>02930         (hw-&gt;mac.mc_filter_type &lt;&lt; E1000_RCTL_MO_SHIFT);
<a name="l02931"></a>02931 
<a name="l02932"></a>02932     <span class="comment">/*</span>
<a name="l02933"></a>02933 <span class="comment">     * enable stripping of CRC. It&#39;s unlikely this will break BMC</span>
<a name="l02934"></a>02934 <span class="comment">     * redirection as it did with e1000. Newer features require</span>
<a name="l02935"></a>02935 <span class="comment">     * that the HW strips the CRC.</span>
<a name="l02936"></a>02936 <span class="comment">     */</span>
<a name="l02937"></a>02937     rctl |= E1000_RCTL_SECRC;
<a name="l02938"></a>02938 
<a name="l02939"></a>02939     <span class="comment">/* disable store bad packets and clear size bits. */</span>
<a name="l02940"></a>02940     rctl &amp;= ~(E1000_RCTL_SBP | E1000_RCTL_SZ_256);
<a name="l02941"></a>02941 
<a name="l02942"></a>02942     <span class="comment">/* enable LPE to prevent packets larger than max_frame_size */</span>
<a name="l02943"></a>02943     rctl |= E1000_RCTL_LPE;
<a name="l02944"></a>02944 
<a name="l02945"></a>02945     <span class="comment">/* disable queue 0 to prevent tail write w/o re-config */</span>
<a name="l02946"></a>02946     E1000_WRITE_REG(hw, E1000_RXDCTL(0), 0);
<a name="l02947"></a>02947 
<a name="l02948"></a>02948     <span class="comment">/* Attention!!!  For SR-IOV PF driver operations you must enable</span>
<a name="l02949"></a>02949 <span class="comment">     * queue drop for all VF and PF queues to prevent head of line blocking</span>
<a name="l02950"></a>02950 <span class="comment">     * if an un-trusted VF does not provide descriptors to hardware.</span>
<a name="l02951"></a>02951 <span class="comment">     */</span>
<a name="l02952"></a>02952     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count) {
<a name="l02953"></a>02953         <span class="comment">/* set all queue drop enable bits */</span>
<a name="l02954"></a>02954         E1000_WRITE_REG(hw, E1000_QDE, ALL_QUEUES);
<a name="l02955"></a>02955     }
<a name="l02956"></a>02956 
<a name="l02957"></a>02957     E1000_WRITE_REG(hw, E1000_RCTL, rctl);
<a name="l02958"></a>02958 }
<a name="l02959"></a>02959 
<a name="l02960"></a>02960 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> igb_set_vf_rlpml(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, <span class="keywordtype">int</span> size,
<a name="l02961"></a>02961                                    <span class="keywordtype">int</span> vfn)
<a name="l02962"></a>02962 {
<a name="l02963"></a>02963     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02964"></a>02964     u32 vmolr;
<a name="l02965"></a>02965 
<a name="l02966"></a>02966     <span class="comment">/* if it isn&#39;t the PF check to see if VFs are enabled and</span>
<a name="l02967"></a>02967 <span class="comment">     * increase the size to support vlan tags */</span>
<a name="l02968"></a>02968     <span class="keywordflow">if</span> (vfn &lt; adapter-&gt;vfs_allocated_count &amp;&amp;
<a name="l02969"></a>02969         adapter-&gt;vf_data[vfn].vlans_enabled)
<a name="l02970"></a>02970         size += VLAN_TAG_SIZE;
<a name="l02971"></a>02971 
<a name="l02972"></a>02972 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l02973"></a>02973 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (vfn &gt;= adapter-&gt;vfs_allocated_count) {
<a name="l02974"></a>02974         <span class="keywordtype">int</span> queue = vfn - adapter-&gt;vfs_allocated_count;
<a name="l02975"></a>02975         <span class="keyword">struct </span>igb_vmdq_adapter *vadapter;
<a name="l02976"></a>02976 
<a name="l02977"></a>02977         vadapter = netdev_priv(adapter-&gt;vmdq_netdev[queue-1]);
<a name="l02978"></a>02978         <span class="keywordflow">if</span> (vadapter-&gt;vlgrp)
<a name="l02979"></a>02979             size += VLAN_TAG_SIZE;
<a name="l02980"></a>02980     }
<a name="l02981"></a>02981 <span class="preprocessor">#endif</span>
<a name="l02982"></a>02982 <span class="preprocessor"></span>    vmolr = E1000_READ_REG(hw, E1000_VMOLR(vfn));
<a name="l02983"></a>02983     vmolr &amp;= ~E1000_VMOLR_RLPML_MASK;
<a name="l02984"></a>02984     vmolr |= size | E1000_VMOLR_LPE;
<a name="l02985"></a>02985     E1000_WRITE_REG(hw, E1000_VMOLR(vfn), vmolr);
<a name="l02986"></a>02986 
<a name="l02987"></a>02987     <span class="keywordflow">return</span> 0;
<a name="l02988"></a>02988 }
<a name="l02989"></a>02989 
<a name="l02996"></a>02996 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_rlpml_set(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l02997"></a>02997 {
<a name="l02998"></a>02998     u32 max_frame_size = adapter-&gt;max_frame_size;
<a name="l02999"></a>02999     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03000"></a>03000     u16 pf_id = adapter-&gt;vfs_allocated_count;
<a name="l03001"></a>03001 
<a name="l03002"></a>03002     <span class="keywordflow">if</span> (adapter-&gt;vmdq_pools &amp;&amp; hw-&gt;mac.type != e1000_82575) {
<a name="l03003"></a>03003         <span class="keywordtype">int</span> i;
<a name="l03004"></a>03004         <span class="keywordflow">for</span> (i = 1; i &lt; adapter-&gt;vmdq_pools; i++)
<a name="l03005"></a>03005             igb_set_vf_rlpml(adapter, max_frame_size, pf_id + i);
<a name="l03006"></a>03006         <span class="comment">/*</span>
<a name="l03007"></a>03007 <span class="comment">         * If we&#39;re in VMDQ or SR-IOV mode, then set global RLPML</span>
<a name="l03008"></a>03008 <span class="comment">         * to our max jumbo frame size, in case we need to enable</span>
<a name="l03009"></a>03009 <span class="comment">         * jumbo frames on one of the rings later.</span>
<a name="l03010"></a>03010 <span class="comment">         * This will not pass over-length frames into the default</span>
<a name="l03011"></a>03011 <span class="comment">         * queue because it&#39;s gated by the VMOLR.RLPML.</span>
<a name="l03012"></a>03012 <span class="comment">         */</span>
<a name="l03013"></a>03013         max_frame_size = MAX_JUMBO_FRAME_SIZE;
<a name="l03014"></a>03014     }
<a name="l03015"></a>03015     <span class="comment">/* Set VF RLPML for the PF device. */</span>
<a name="l03016"></a>03016     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count)
<a name="l03017"></a>03017         igb_set_vf_rlpml(adapter, max_frame_size, pf_id);
<a name="l03018"></a>03018 
<a name="l03019"></a>03019     E1000_WRITE_REG(hw, E1000_RLPML, max_frame_size);
<a name="l03020"></a>03020 }
<a name="l03021"></a>03021 
<a name="l03022"></a>03022 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> igb_set_vf_vlan_strip(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l03023"></a>03023                     <span class="keywordtype">int</span> vfn, <span class="keywordtype">bool</span> enable)
<a name="l03024"></a>03024 {
<a name="l03025"></a>03025     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03026"></a>03026     u32 val;
<a name="l03027"></a>03027     <span class="keywordtype">void</span> __iomem *reg;
<a name="l03028"></a>03028 
<a name="l03029"></a>03029     <span class="keywordflow">if</span> (hw-&gt;mac.type &lt; e1000_82576)
<a name="l03030"></a>03030         <span class="keywordflow">return</span>;
<a name="l03031"></a>03031 
<a name="l03032"></a>03032         <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_i350)
<a name="l03033"></a>03033         reg = hw-&gt;hw_addr + E1000_DVMOLR(vfn);
<a name="l03034"></a>03034     <span class="keywordflow">else</span>
<a name="l03035"></a>03035         reg = hw-&gt;hw_addr + E1000_VMOLR(vfn);
<a name="l03036"></a>03036 
<a name="l03037"></a>03037     val = readl(reg);
<a name="l03038"></a>03038     <span class="keywordflow">if</span> (enable)
<a name="l03039"></a>03039         val |= E1000_VMOLR_STRVLAN;
<a name="l03040"></a>03040     <span class="keywordflow">else</span>
<a name="l03041"></a>03041         val &amp;= ~(E1000_VMOLR_STRVLAN);
<a name="l03042"></a>03042     writel(val, reg);
<a name="l03043"></a>03043 }
<a name="l03044"></a>03044 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> igb_set_vmolr(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l03045"></a>03045                  <span class="keywordtype">int</span> vfn, <span class="keywordtype">bool</span> aupe)
<a name="l03046"></a>03046 {
<a name="l03047"></a>03047     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03048"></a>03048     u32 vmolr;
<a name="l03049"></a>03049 
<a name="l03050"></a>03050     <span class="comment">/*</span>
<a name="l03051"></a>03051 <span class="comment">     * This register exists only on 82576 and newer so if we are older then</span>
<a name="l03052"></a>03052 <span class="comment">     * we should exit and do nothing</span>
<a name="l03053"></a>03053 <span class="comment">     */</span>
<a name="l03054"></a>03054     <span class="keywordflow">if</span> (hw-&gt;mac.type &lt; e1000_82576)
<a name="l03055"></a>03055         <span class="keywordflow">return</span>;
<a name="l03056"></a>03056 
<a name="l03057"></a>03057     vmolr = E1000_READ_REG(hw, E1000_VMOLR(vfn));
<a name="l03058"></a>03058 
<a name="l03059"></a>03059     <span class="keywordflow">if</span> (aupe)
<a name="l03060"></a>03060         vmolr |= E1000_VMOLR_AUPE;        <span class="comment">/* Accept untagged packets */</span>
<a name="l03061"></a>03061     <span class="keywordflow">else</span>
<a name="l03062"></a>03062         vmolr &amp;= ~(E1000_VMOLR_AUPE); <span class="comment">/* Tagged packets ONLY */</span>
<a name="l03063"></a>03063 
<a name="l03064"></a>03064     <span class="comment">/* clear all bits that might not be set */</span>
<a name="l03065"></a>03065     vmolr &amp;= ~E1000_VMOLR_RSSE;
<a name="l03066"></a>03066 
<a name="l03067"></a>03067     <span class="keywordflow">if</span> (adapter-&gt;rss_queues &gt; 1 &amp;&amp; vfn == adapter-&gt;vfs_allocated_count)
<a name="l03068"></a>03068         vmolr |= E1000_VMOLR_RSSE; <span class="comment">/* enable RSS */</span>
<a name="l03069"></a>03069 
<a name="l03070"></a>03070     vmolr |= E1000_VMOLR_BAM;      <span class="comment">/* Accept broadcast */</span>
<a name="l03071"></a>03071     vmolr |= E1000_VMOLR_LPE;      <span class="comment">/* Accept long packets */</span>
<a name="l03072"></a>03072 
<a name="l03073"></a>03073     E1000_WRITE_REG(hw, E1000_VMOLR(vfn), vmolr);
<a name="l03074"></a>03074 }
<a name="l03075"></a>03075 
<a name="l03083"></a>03083 <span class="keywordtype">void</span> igb_configure_rx_ring(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l03084"></a>03084                            <span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *ring)
<a name="l03085"></a>03085 {
<a name="l03086"></a>03086     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03087"></a>03087     u64 rdba = ring-&gt;dma;
<a name="l03088"></a>03088     <span class="keywordtype">int</span> reg_idx = ring-&gt;reg_idx;
<a name="l03089"></a>03089     u32 srrctl = 0, rxdctl = 0;
<a name="l03090"></a>03090 
<a name="l03091"></a>03091     <span class="comment">/* disable the queue */</span>
<a name="l03092"></a>03092     E1000_WRITE_REG(hw, E1000_RXDCTL(reg_idx), 0);
<a name="l03093"></a>03093 
<a name="l03094"></a>03094     <span class="comment">/* Set DMA base address registers */</span>
<a name="l03095"></a>03095     E1000_WRITE_REG(hw, E1000_RDBAL(reg_idx),
<a name="l03096"></a>03096                     rdba &amp; 0x00000000ffffffffULL);
<a name="l03097"></a>03097     E1000_WRITE_REG(hw, E1000_RDBAH(reg_idx), rdba &gt;&gt; 32);
<a name="l03098"></a>03098     E1000_WRITE_REG(hw, E1000_RDLEN(reg_idx),
<a name="l03099"></a>03099                    ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unione1000__adv__rx__desc.html">e1000_adv_rx_desc</a>));
<a name="l03100"></a>03100 
<a name="l03101"></a>03101     <span class="comment">/* initialize head and tail */</span>
<a name="l03102"></a>03102     ring-&gt;tail = hw-&gt;hw_addr + E1000_RDT(reg_idx);
<a name="l03103"></a>03103     E1000_WRITE_REG(hw, E1000_RDH(reg_idx), 0);
<a name="l03104"></a>03104     writel(0, ring-&gt;tail);
<a name="l03105"></a>03105 
<a name="l03106"></a>03106     <span class="comment">/* set descriptor configuration */</span>
<a name="l03107"></a>03107 <span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l03108"></a>03108 <span class="preprocessor"></span>    srrctl = IGB_RX_HDR_LEN &lt;&lt; E1000_SRRCTL_BSIZEHDRSIZE_SHIFT;
<a name="l03109"></a>03109 <span class="preprocessor">#if (PAGE_SIZE / 2) &gt; IGB_RXBUFFER_16384</span>
<a name="l03110"></a>03110 <span class="preprocessor"></span>    srrctl |= IGB_RXBUFFER_16384 &gt;&gt; E1000_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03111"></a>03111 <span class="preprocessor">#else</span>
<a name="l03112"></a>03112 <span class="preprocessor"></span>    srrctl |= (PAGE_SIZE / 2) &gt;&gt; E1000_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03113"></a>03113 <span class="preprocessor">#endif</span>
<a name="l03114"></a>03114 <span class="preprocessor"></span>    srrctl |= E1000_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS;
<a name="l03115"></a>03115 <span class="preprocessor">#else </span><span class="comment">/* CONFIG_IGB_DISABLE_PACKET_SPLIT */</span>
<a name="l03116"></a>03116     srrctl = ALIGN(ring-&gt;rx_buffer_len, 1024) &gt;&gt;
<a name="l03117"></a>03117              E1000_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03118"></a>03118     srrctl |= E1000_SRRCTL_DESCTYPE_ADV_ONEBUF;
<a name="l03119"></a>03119 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IGB_DISABLE_PACKET_SPLIT */</span>
<a name="l03120"></a>03120 <span class="preprocessor">#ifdef IGB_PER_PKT_TIMESTAMP</span>
<a name="l03121"></a>03121 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (hw-&gt;mac.type &gt;= e1000_82580)
<a name="l03122"></a>03122         srrctl |= E1000_SRRCTL_TIMESTAMP;
<a name="l03123"></a>03123 <span class="preprocessor">#endif</span>
<a name="l03124"></a>03124 <span class="preprocessor"></span>    <span class="comment">/* Set Drop Enable if we are supporting SR-IOV */</span>
<a name="l03125"></a>03125     <span class="keywordflow">if</span> (adapter-&gt;vfs_allocated_count)
<a name="l03126"></a>03126         srrctl |= E1000_SRRCTL_DROP_EN;
<a name="l03127"></a>03127 
<a name="l03128"></a>03128     E1000_WRITE_REG(hw, E1000_SRRCTL(reg_idx), srrctl);
<a name="l03129"></a>03129 
<a name="l03130"></a>03130     <span class="comment">/* set filtering for VMDQ pools */</span>
<a name="l03131"></a>03131     igb_set_vmolr(adapter, reg_idx &amp; 0x7, <span class="keyword">true</span>);
<a name="l03132"></a>03132 
<a name="l03133"></a>03133     rxdctl |= IGB_RX_PTHRESH;
<a name="l03134"></a>03134     rxdctl |= IGB_RX_HTHRESH &lt;&lt; 8;
<a name="l03135"></a>03135     rxdctl |= IGB_RX_WTHRESH &lt;&lt; 16;
<a name="l03136"></a>03136 
<a name="l03137"></a>03137     <span class="comment">/* enable receive descriptor fetching */</span>
<a name="l03138"></a>03138     rxdctl |= E1000_RXDCTL_QUEUE_ENABLE;
<a name="l03139"></a>03139     E1000_WRITE_REG(hw, E1000_RXDCTL(reg_idx), rxdctl);
<a name="l03140"></a>03140 }
<a name="l03141"></a>03141 
<a name="l03148"></a>03148 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_configure_rx(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03149"></a>03149 {
<a name="l03150"></a>03150     <span class="keywordtype">int</span> i;
<a name="l03151"></a>03151 
<a name="l03152"></a>03152     <span class="comment">/* set UTA to appropriate mode */</span>
<a name="l03153"></a>03153     igb_set_uta(adapter);
<a name="l03154"></a>03154 
<a name="l03155"></a>03155     igb_full_sync_mac_table(adapter);
<a name="l03156"></a>03156     <span class="comment">/* Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<a name="l03157"></a>03157 <span class="comment">     * the Base and Length of the Rx Descriptor Ring */</span>
<a name="l03158"></a>03158     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l03159"></a>03159         igb_configure_rx_ring(adapter, adapter-&gt;rx_ring[i]);
<a name="l03160"></a>03160 }
<a name="l03161"></a>03161 
<a name="l03168"></a>03168 <span class="keywordtype">void</span> igb_free_tx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring)
<a name="l03169"></a>03169 {
<a name="l03170"></a>03170     igb_clean_tx_ring(tx_ring);
<a name="l03171"></a>03171 
<a name="l03172"></a>03172     vfree(tx_ring-&gt;buffer_info);
<a name="l03173"></a>03173     tx_ring-&gt;buffer_info = NULL;
<a name="l03174"></a>03174 
<a name="l03175"></a>03175     <span class="comment">/* if not set, then don&#39;t free */</span>
<a name="l03176"></a>03176     <span class="keywordflow">if</span> (!tx_ring-&gt;desc)
<a name="l03177"></a>03177         <span class="keywordflow">return</span>;
<a name="l03178"></a>03178 
<a name="l03179"></a>03179     dma_free_coherent(tx_ring-&gt;dev, tx_ring-&gt;size,
<a name="l03180"></a>03180               tx_ring-&gt;desc, tx_ring-&gt;dma);
<a name="l03181"></a>03181 
<a name="l03182"></a>03182     tx_ring-&gt;desc = NULL;
<a name="l03183"></a>03183 }
<a name="l03184"></a>03184 
<a name="l03191"></a>03191 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_free_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03192"></a>03192 {
<a name="l03193"></a>03193     <span class="keywordtype">int</span> i;
<a name="l03194"></a>03194 
<a name="l03195"></a>03195     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l03196"></a>03196         igb_free_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l03197"></a>03197 }
<a name="l03198"></a>03198 
<a name="l03199"></a>03199 <span class="keywordtype">void</span> igb_unmap_and_free_tx_resource(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring,
<a name="l03200"></a>03200                     <span class="keyword">struct</span> <a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info)
<a name="l03201"></a>03201 {
<a name="l03202"></a>03202     <span class="keywordflow">if</span> (buffer_info-&gt;dma) {
<a name="l03203"></a>03203         <span class="keywordflow">if</span> (buffer_info-&gt;mapped_as_page)
<a name="l03204"></a>03204             dma_unmap_page(tx_ring-&gt;dev,
<a name="l03205"></a>03205                     buffer_info-&gt;dma,
<a name="l03206"></a>03206                     buffer_info-&gt;length,
<a name="l03207"></a>03207                     DMA_TO_DEVICE);
<a name="l03208"></a>03208         <span class="keywordflow">else</span>
<a name="l03209"></a>03209             dma_unmap_single(tx_ring-&gt;dev,
<a name="l03210"></a>03210                     buffer_info-&gt;dma,
<a name="l03211"></a>03211                     buffer_info-&gt;length,
<a name="l03212"></a>03212                     DMA_TO_DEVICE);
<a name="l03213"></a>03213     }
<a name="l03214"></a>03214     <span class="keywordflow">if</span> (buffer_info-&gt;skb)
<a name="l03215"></a>03215         dev_kfree_skb_any(buffer_info-&gt;skb);
<a name="l03216"></a>03216     <span class="comment">/* buffer_info must be completely set up in the transmit path */</span>
<a name="l03217"></a>03217     memset(buffer_info, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__buffer.html">igb_buffer</a>));
<a name="l03218"></a>03218 }
<a name="l03219"></a>03219 
<a name="l03224"></a>03224 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_tx_ring(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring)
<a name="l03225"></a>03225 {
<a name="l03226"></a>03226     <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info;
<a name="l03227"></a>03227     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
<a name="l03228"></a>03228     u16 i;
<a name="l03229"></a>03229 
<a name="l03230"></a>03230     <span class="keywordflow">if</span> (!tx_ring-&gt;buffer_info)
<a name="l03231"></a>03231         <span class="keywordflow">return</span>;
<a name="l03232"></a>03232     <span class="comment">/* Free all the Tx ring sk_buffs */</span>
<a name="l03233"></a>03233 
<a name="l03234"></a>03234     <span class="keywordflow">for</span> (i = 0; i &lt; tx_ring-&gt;count; i++) {
<a name="l03235"></a>03235         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l03236"></a>03236         igb_unmap_and_free_tx_resource(tx_ring, buffer_info);
<a name="l03237"></a>03237     }
<a name="l03238"></a>03238 
<a name="l03239"></a>03239     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a>) * tx_ring-&gt;count;
<a name="l03240"></a>03240     memset(tx_ring-&gt;buffer_info, 0, size);
<a name="l03241"></a>03241 
<a name="l03242"></a>03242     <span class="comment">/* Zero out the descriptor ring */</span>
<a name="l03243"></a>03243     memset(tx_ring-&gt;desc, 0, tx_ring-&gt;size);
<a name="l03244"></a>03244 
<a name="l03245"></a>03245     tx_ring-&gt;next_to_use = 0;
<a name="l03246"></a>03246     tx_ring-&gt;next_to_clean = 0;
<a name="l03247"></a>03247 }
<a name="l03248"></a>03248 
<a name="l03253"></a>03253 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_all_tx_rings(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03254"></a>03254 {
<a name="l03255"></a>03255     <span class="keywordtype">int</span> i;
<a name="l03256"></a>03256 
<a name="l03257"></a>03257     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l03258"></a>03258         igb_clean_tx_ring(adapter-&gt;tx_ring[i]);
<a name="l03259"></a>03259 }
<a name="l03260"></a>03260 
<a name="l03267"></a>03267 <span class="keywordtype">void</span> igb_free_rx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *rx_ring)
<a name="l03268"></a>03268 {
<a name="l03269"></a>03269     igb_clean_rx_ring(rx_ring);
<a name="l03270"></a>03270 
<a name="l03271"></a>03271     vfree(rx_ring-&gt;buffer_info);
<a name="l03272"></a>03272     rx_ring-&gt;buffer_info = NULL;
<a name="l03273"></a>03273 
<a name="l03274"></a>03274     <span class="comment">/* if not set, then don&#39;t free */</span>
<a name="l03275"></a>03275     <span class="keywordflow">if</span> (!rx_ring-&gt;desc)
<a name="l03276"></a>03276         <span class="keywordflow">return</span>;
<a name="l03277"></a>03277 
<a name="l03278"></a>03278     dma_free_coherent(rx_ring-&gt;dev, rx_ring-&gt;size,
<a name="l03279"></a>03279               rx_ring-&gt;desc, rx_ring-&gt;dma);
<a name="l03280"></a>03280 
<a name="l03281"></a>03281     rx_ring-&gt;desc = NULL;
<a name="l03282"></a>03282 }
<a name="l03283"></a>03283 
<a name="l03290"></a>03290 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_free_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03291"></a>03291 {
<a name="l03292"></a>03292     <span class="keywordtype">int</span> i;
<a name="l03293"></a>03293 
<a name="l03294"></a>03294     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l03295"></a>03295         igb_free_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l03296"></a>03296 }
<a name="l03297"></a>03297 
<a name="l03302"></a>03302 <span class="keywordtype">void</span> igb_clean_rx_ring(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *rx_ring)
<a name="l03303"></a>03303 {
<a name="l03304"></a>03304     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
<a name="l03305"></a>03305 <span class="preprocessor">#ifdef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l03306"></a>03306 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> bufsz = rx_ring-&gt;rx_buffer_len;
<a name="l03307"></a>03307 <span class="preprocessor">#else</span>
<a name="l03308"></a>03308 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> bufsz = IGB_RX_HDR_LEN;
<a name="l03309"></a>03309 <span class="preprocessor">#endif</span>
<a name="l03310"></a>03310 <span class="preprocessor"></span>    u16 i;
<a name="l03311"></a>03311 
<a name="l03312"></a>03312     <span class="keywordflow">if</span> (!rx_ring-&gt;buffer_info)
<a name="l03313"></a>03313         <span class="keywordflow">return</span>;
<a name="l03314"></a>03314 
<a name="l03315"></a>03315     <span class="comment">/* Free all the Rx ring sk_buffs */</span>
<a name="l03316"></a>03316     <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++) {
<a name="l03317"></a>03317         <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l03318"></a>03318         <span class="keywordflow">if</span> (buffer_info-&gt;dma) {
<a name="l03319"></a>03319             dma_unmap_single(rx_ring-&gt;dev,
<a name="l03320"></a>03320                              buffer_info-&gt;dma,
<a name="l03321"></a>03321                      bufsz,
<a name="l03322"></a>03322                      DMA_FROM_DEVICE);
<a name="l03323"></a>03323             buffer_info-&gt;dma = 0;
<a name="l03324"></a>03324         }
<a name="l03325"></a>03325 
<a name="l03326"></a>03326         <span class="keywordflow">if</span> (buffer_info-&gt;skb) {
<a name="l03327"></a>03327             dev_kfree_skb(buffer_info-&gt;skb);
<a name="l03328"></a>03328             buffer_info-&gt;skb = NULL;
<a name="l03329"></a>03329         }
<a name="l03330"></a>03330 <span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l03331"></a>03331 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (buffer_info-&gt;page_dma) {
<a name="l03332"></a>03332             dma_unmap_page(rx_ring-&gt;dev,
<a name="l03333"></a>03333                            buffer_info-&gt;page_dma,
<a name="l03334"></a>03334                        PAGE_SIZE / 2,
<a name="l03335"></a>03335                        DMA_FROM_DEVICE);
<a name="l03336"></a>03336             buffer_info-&gt;page_dma = 0;
<a name="l03337"></a>03337         }
<a name="l03338"></a>03338         <span class="keywordflow">if</span> (buffer_info-&gt;page) {
<a name="l03339"></a>03339             put_page(buffer_info-&gt;page);
<a name="l03340"></a>03340             buffer_info-&gt;page = NULL;
<a name="l03341"></a>03341             buffer_info-&gt;page_offset = 0;
<a name="l03342"></a>03342         }
<a name="l03343"></a>03343 <span class="preprocessor">#endif</span>
<a name="l03344"></a>03344 <span class="preprocessor"></span>    }
<a name="l03345"></a>03345 
<a name="l03346"></a>03346     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a>) * rx_ring-&gt;count;
<a name="l03347"></a>03347     memset(rx_ring-&gt;buffer_info, 0, size);
<a name="l03348"></a>03348 
<a name="l03349"></a>03349     <span class="comment">/* Zero out the descriptor ring */</span>
<a name="l03350"></a>03350     memset(rx_ring-&gt;desc, 0, rx_ring-&gt;size);
<a name="l03351"></a>03351 
<a name="l03352"></a>03352     rx_ring-&gt;next_to_clean = 0;
<a name="l03353"></a>03353     rx_ring-&gt;next_to_use = 0;
<a name="l03354"></a>03354 }
<a name="l03355"></a>03355 
<a name="l03360"></a>03360 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_all_rx_rings(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03361"></a>03361 {
<a name="l03362"></a>03362     <span class="keywordtype">int</span> i;
<a name="l03363"></a>03363 
<a name="l03364"></a>03364     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l03365"></a>03365         igb_clean_rx_ring(adapter-&gt;rx_ring[i]);
<a name="l03366"></a>03366 }
<a name="l03367"></a>03367 
<a name="l03375"></a>03375 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_mac(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">void</span> *p)
<a name="l03376"></a>03376 {
<a name="l03377"></a>03377     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03378"></a>03378     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03379"></a>03379     <span class="keyword">struct </span>sockaddr *addr = p;
<a name="l03380"></a>03380 
<a name="l03381"></a>03381     <span class="keywordflow">if</span> (!is_valid_ether_addr(addr-&gt;sa_data))
<a name="l03382"></a>03382         <span class="keywordflow">return</span> -EADDRNOTAVAIL;
<a name="l03383"></a>03383 
<a name="l03384"></a>03384     igb_del_mac_filter(adapter, hw-&gt;mac.addr,
<a name="l03385"></a>03385                adapter-&gt;vfs_allocated_count);
<a name="l03386"></a>03386     memcpy(netdev-&gt;dev_addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l03387"></a>03387     memcpy(hw-&gt;mac.addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l03388"></a>03388 
<a name="l03389"></a>03389     <span class="comment">/* set the correct pool for the new PF MAC address in entry 0 */</span>
<a name="l03390"></a>03390     <span class="keywordflow">return</span> igb_add_mac_filter(adapter, hw-&gt;mac.addr,
<a name="l03391"></a>03391                        adapter-&gt;vfs_allocated_count);
<a name="l03392"></a>03392 }
<a name="l03393"></a>03393 
<a name="l03403"></a>03403 <span class="keywordtype">int</span> igb_write_mc_addr_list(<span class="keyword">struct</span> net_device *netdev)
<a name="l03404"></a>03404 {
<a name="l03405"></a>03405     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03406"></a>03406     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03407"></a>03407 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03408"></a>03408 <span class="preprocessor"></span>    <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03409"></a>03409 <span class="preprocessor">#else</span>
<a name="l03410"></a>03410 <span class="preprocessor"></span>    <span class="keyword">struct </span>dev_mc_list *ha;
<a name="l03411"></a>03411 <span class="preprocessor">#endif</span>
<a name="l03412"></a>03412 <span class="preprocessor"></span>    u8  *mta_list;
<a name="l03413"></a>03413     <span class="keywordtype">int</span> i, count;
<a name="l03414"></a>03414 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l03415"></a>03415 <span class="preprocessor"></span>    <span class="keywordtype">int</span> vm;
<a name="l03416"></a>03416 <span class="preprocessor">#endif</span>
<a name="l03417"></a>03417 <span class="preprocessor"></span>    count = netdev_mc_count(netdev);
<a name="l03418"></a>03418 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l03419"></a>03419 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (vm = 1; vm &lt; adapter-&gt;vmdq_pools; vm++) {
<a name="l03420"></a>03420         <span class="keywordflow">if</span> (!adapter-&gt;vmdq_netdev[vm])
<a name="l03421"></a>03421             <span class="keywordflow">break</span>;
<a name="l03422"></a>03422         <span class="keywordflow">if</span> (!netif_running(adapter-&gt;vmdq_netdev[vm]))
<a name="l03423"></a>03423             <span class="keywordflow">continue</span>;
<a name="l03424"></a>03424         count += netdev_mc_count(adapter-&gt;vmdq_netdev[vm]);
<a name="l03425"></a>03425     }
<a name="l03426"></a>03426 <span class="preprocessor">#endif</span>
<a name="l03427"></a>03427 <span class="preprocessor"></span>
<a name="l03428"></a>03428     <span class="keywordflow">if</span> (!count) {
<a name="l03429"></a>03429         e1000_update_mc_addr_list(hw, NULL, 0);
<a name="l03430"></a>03430         <span class="keywordflow">return</span> 0;
<a name="l03431"></a>03431     }
<a name="l03432"></a>03432     mta_list = kzalloc(count * 6, GFP_ATOMIC);
<a name="l03433"></a>03433     <span class="keywordflow">if</span> (!mta_list)
<a name="l03434"></a>03434         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03435"></a>03435 
<a name="l03436"></a>03436     <span class="comment">/* The shared function expects a packed array of only addresses. */</span>
<a name="l03437"></a>03437     i = 0;
<a name="l03438"></a>03438     netdev_for_each_mc_addr(ha, netdev)
<a name="l03439"></a>03439 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03440"></a>03440 <span class="preprocessor"></span>        memcpy(mta_list + (i++ * ETH_ALEN), ha-&gt;addr, ETH_ALEN);
<a name="l03441"></a>03441 <span class="preprocessor">#else</span>
<a name="l03442"></a>03442 <span class="preprocessor"></span>        memcpy(mta_list + (i++ * ETH_ALEN), ha-&gt;dmi_addr, ETH_ALEN);
<a name="l03443"></a>03443 <span class="preprocessor">#endif</span>
<a name="l03444"></a>03444 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l03445"></a>03445 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (vm = 1; vm &lt; adapter-&gt;vmdq_pools; vm++) {
<a name="l03446"></a>03446         <span class="keywordflow">if</span> (!adapter-&gt;vmdq_netdev[vm])
<a name="l03447"></a>03447             <span class="keywordflow">break</span>;
<a name="l03448"></a>03448         <span class="keywordflow">if</span> (!netif_running(adapter-&gt;vmdq_netdev[vm]) ||
<a name="l03449"></a>03449             !netdev_mc_count(adapter-&gt;vmdq_netdev[vm]))
<a name="l03450"></a>03450             <span class="keywordflow">continue</span>;
<a name="l03451"></a>03451         netdev_for_each_mc_addr(ha, adapter-&gt;vmdq_netdev[vm])
<a name="l03452"></a>03452 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03453"></a>03453 <span class="preprocessor"></span>            memcpy(mta_list + (i++ * ETH_ALEN),
<a name="l03454"></a>03454                    ha-&gt;addr, ETH_ALEN);
<a name="l03455"></a>03455 <span class="preprocessor">#else</span>
<a name="l03456"></a>03456 <span class="preprocessor"></span>            memcpy(mta_list + (i++ * ETH_ALEN),
<a name="l03457"></a>03457                    ha-&gt;dmi_addr, ETH_ALEN);
<a name="l03458"></a>03458 <span class="preprocessor">#endif</span>
<a name="l03459"></a>03459 <span class="preprocessor"></span>    }
<a name="l03460"></a>03460 <span class="preprocessor">#endif</span>
<a name="l03461"></a>03461 <span class="preprocessor"></span>    e1000_update_mc_addr_list(hw, mta_list, i);
<a name="l03462"></a>03462     kfree(mta_list);
<a name="l03463"></a>03463 
<a name="l03464"></a>03464     <span class="keywordflow">return</span> count;
<a name="l03465"></a>03465 }
<a name="l03466"></a>03466 
<a name="l03467"></a>03467 <span class="keywordtype">void</span> igb_rar_set(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 index)
<a name="l03468"></a>03468 {
<a name="l03469"></a>03469     u32 rar_low, rar_high;
<a name="l03470"></a>03470     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03471"></a>03471     u8 *addr = adapter-&gt;mac_table[index].addr;
<a name="l03472"></a>03472     <span class="comment">/* HW expects these in little endian so we reverse the byte order</span>
<a name="l03473"></a>03473 <span class="comment">     * from network order (big endian) to little endian</span>
<a name="l03474"></a>03474 <span class="comment">     */</span>
<a name="l03475"></a>03475     rar_low = ((u32) addr[0] | ((u32) addr[1] &lt;&lt; 8) |
<a name="l03476"></a>03476               ((u32) addr[2] &lt;&lt; 16) | ((u32) addr[3] &lt;&lt; 24));
<a name="l03477"></a>03477     rar_high = ((u32) addr[4] | ((u32) addr[5] &lt;&lt; 8));
<a name="l03478"></a>03478 
<a name="l03479"></a>03479     <span class="comment">/* Indicate to hardware the Address is Valid. */</span>
<a name="l03480"></a>03480     <span class="keywordflow">if</span> (adapter-&gt;mac_table[index].state &amp; IGB_MAC_STATE_IN_USE)
<a name="l03481"></a>03481         rar_high |= E1000_RAH_AV;
<a name="l03482"></a>03482 
<a name="l03483"></a>03483     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82575)
<a name="l03484"></a>03484         rar_high |= E1000_RAH_POOL_1 * adapter-&gt;mac_table[index].queue;
<a name="l03485"></a>03485     <span class="keywordflow">else</span>
<a name="l03486"></a>03486         rar_high |= E1000_RAH_POOL_1 &lt;&lt; adapter-&gt;mac_table[index].queue;
<a name="l03487"></a>03487 
<a name="l03488"></a>03488     E1000_WRITE_REG(hw, E1000_RAL(index), rar_low);
<a name="l03489"></a>03489     E1000_WRITE_FLUSH(hw);
<a name="l03490"></a>03490     E1000_WRITE_REG(hw, E1000_RAH(index), rar_high);
<a name="l03491"></a>03491     E1000_WRITE_FLUSH(hw);
<a name="l03492"></a>03492 }
<a name="l03493"></a>03493 
<a name="l03494"></a>03494 <span class="keywordtype">void</span> igb_full_sync_mac_table(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03495"></a>03495 {
<a name="l03496"></a>03496     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03497"></a>03497     <span class="keywordtype">int</span> i;
<a name="l03498"></a>03498     <span class="keywordflow">for</span> (i = 0; i &lt; hw-&gt;mac.rar_entry_count; i++) {
<a name="l03499"></a>03499             igb_rar_set(adapter, i);
<a name="l03500"></a>03500     }
<a name="l03501"></a>03501 }
<a name="l03502"></a>03502 
<a name="l03503"></a>03503 <span class="keywordtype">void</span> igb_sync_mac_table(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03504"></a>03504 {
<a name="l03505"></a>03505     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03506"></a>03506     <span class="keywordtype">int</span> i;
<a name="l03507"></a>03507     <span class="keywordflow">for</span> (i = 0; i &lt; hw-&gt;mac.rar_entry_count; i++) {
<a name="l03508"></a>03508         <span class="keywordflow">if</span> (adapter-&gt;mac_table[i].state &amp; IGB_MAC_STATE_MODIFIED)
<a name="l03509"></a>03509             igb_rar_set(adapter, i);
<a name="l03510"></a>03510         adapter-&gt;mac_table[i].state &amp;= ~(IGB_MAC_STATE_MODIFIED);
<a name="l03511"></a>03511     }
<a name="l03512"></a>03512 }
<a name="l03513"></a>03513 
<a name="l03514"></a>03514 <span class="keywordtype">int</span> igb_available_rars(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03515"></a>03515 {
<a name="l03516"></a>03516     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03517"></a>03517     <span class="keywordtype">int</span> i, count = 0;
<a name="l03518"></a>03518 
<a name="l03519"></a>03519     <span class="keywordflow">for</span> (i = 0; i &lt; hw-&gt;mac.rar_entry_count; i++) {
<a name="l03520"></a>03520         <span class="keywordflow">if</span> (adapter-&gt;mac_table[i].state == 0)
<a name="l03521"></a>03521             count++;
<a name="l03522"></a>03522     }
<a name="l03523"></a>03523     <span class="keywordflow">return</span> count;
<a name="l03524"></a>03524 }
<a name="l03525"></a>03525 
<a name="l03526"></a>03526 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l03527"></a>03527 <span class="preprocessor"></span>
<a name="l03536"></a>03536 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_write_uc_addr_list(<span class="keyword">struct</span> net_device *netdev)
<a name="l03537"></a>03537 {
<a name="l03538"></a>03538     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03539"></a>03539     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vfn = adapter-&gt;vfs_allocated_count;
<a name="l03540"></a>03540     <span class="keywordtype">int</span> count = 0;
<a name="l03541"></a>03541 
<a name="l03542"></a>03542     <span class="comment">/* return ENOMEM indicating insufficient memory for addresses */</span>
<a name="l03543"></a>03543     <span class="keywordflow">if</span> (netdev_uc_count(netdev) &gt; igb_available_rars(adapter))
<a name="l03544"></a>03544         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03545"></a>03545     <span class="keywordflow">if</span> (!netdev_uc_empty(netdev)) {
<a name="l03546"></a>03546 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_UNICAST</span>
<a name="l03547"></a>03547 <span class="preprocessor"></span>        <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03548"></a>03548 <span class="preprocessor">#else</span>
<a name="l03549"></a>03549 <span class="preprocessor"></span>        <span class="keyword">struct </span>dev_mc_list *ha;
<a name="l03550"></a>03550 <span class="preprocessor">#endif</span>
<a name="l03551"></a>03551 <span class="preprocessor"></span>        netdev_for_each_uc_addr(ha, netdev) {
<a name="l03552"></a>03552 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_UNICAST</span>
<a name="l03553"></a>03553 <span class="preprocessor"></span>            igb_del_mac_filter(adapter, ha-&gt;addr, vfn);
<a name="l03554"></a>03554             igb_add_mac_filter(adapter, ha-&gt;addr, vfn);
<a name="l03555"></a>03555 <span class="preprocessor">#else</span>
<a name="l03556"></a>03556 <span class="preprocessor"></span>            igb_del_mac_filter(adapter, ha-&gt;da_addr, vfn);
<a name="l03557"></a>03557             igb_add_mac_filter(adapter, ha-&gt;da_addr, vfn);
<a name="l03558"></a>03558 <span class="preprocessor">#endif</span>
<a name="l03559"></a>03559 <span class="preprocessor"></span>            count++;
<a name="l03560"></a>03560         }
<a name="l03561"></a>03561     }
<a name="l03562"></a>03562     <span class="keywordflow">return</span> count;
<a name="l03563"></a>03563 }
<a name="l03564"></a>03564 
<a name="l03565"></a>03565 <span class="preprocessor">#endif</span>
<a name="l03566"></a>03566 <span class="preprocessor"></span>
<a name="l03575"></a>03575 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_rx_mode(<span class="keyword">struct</span> net_device *netdev)
<a name="l03576"></a>03576 {
<a name="l03577"></a>03577     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03578"></a>03578     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03579"></a>03579     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vfn = adapter-&gt;vfs_allocated_count;
<a name="l03580"></a>03580     u32 rctl, vmolr = 0;
<a name="l03581"></a>03581     <span class="keywordtype">int</span> count;
<a name="l03582"></a>03582 
<a name="l03583"></a>03583     <span class="comment">/* Check for Promiscuous and All Multicast modes */</span>
<a name="l03584"></a>03584     rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l03585"></a>03585 
<a name="l03586"></a>03586     <span class="comment">/* clear the effected bits */</span>
<a name="l03587"></a>03587     rctl &amp;= ~(E1000_RCTL_UPE | E1000_RCTL_MPE | E1000_RCTL_VFE);
<a name="l03588"></a>03588 
<a name="l03589"></a>03589     <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_PROMISC) {
<a name="l03590"></a>03590         rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
<a name="l03591"></a>03591         vmolr |= (E1000_VMOLR_ROPE | E1000_VMOLR_MPME);
<a name="l03592"></a>03592     } <span class="keywordflow">else</span> {
<a name="l03593"></a>03593         <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_ALLMULTI) {
<a name="l03594"></a>03594             rctl |= E1000_RCTL_MPE;
<a name="l03595"></a>03595             vmolr |= E1000_VMOLR_MPME;
<a name="l03596"></a>03596         } <span class="keywordflow">else</span> {
<a name="l03597"></a>03597             <span class="comment">/*</span>
<a name="l03598"></a>03598 <span class="comment">             * Write addresses to the MTA, if the attempt fails</span>
<a name="l03599"></a>03599 <span class="comment">             * then we should just turn on promiscous mode so</span>
<a name="l03600"></a>03600 <span class="comment">             * that we can at least receive multicast traffic</span>
<a name="l03601"></a>03601 <span class="comment">             */</span>
<a name="l03602"></a>03602             count = igb_write_mc_addr_list(netdev);
<a name="l03603"></a>03603             <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l03604"></a>03604                 rctl |= E1000_RCTL_MPE;
<a name="l03605"></a>03605                 vmolr |= E1000_VMOLR_MPME;
<a name="l03606"></a>03606             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count) {
<a name="l03607"></a>03607                 vmolr |= E1000_VMOLR_ROMPE;
<a name="l03608"></a>03608             }
<a name="l03609"></a>03609         }
<a name="l03610"></a>03610 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l03611"></a>03611 <span class="preprocessor"></span>        <span class="comment">/*</span>
<a name="l03612"></a>03612 <span class="comment">         * Write addresses to available RAR registers, if there is not</span>
<a name="l03613"></a>03613 <span class="comment">         * sufficient space to store all the addresses then enable</span>
<a name="l03614"></a>03614 <span class="comment">         * unicast promiscous mode</span>
<a name="l03615"></a>03615 <span class="comment">         */</span>
<a name="l03616"></a>03616         count = igb_write_uc_addr_list(netdev);
<a name="l03617"></a>03617         <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l03618"></a>03618             rctl |= E1000_RCTL_UPE;
<a name="l03619"></a>03619             vmolr |= E1000_VMOLR_ROPE;
<a name="l03620"></a>03620         }
<a name="l03621"></a>03621 <span class="preprocessor">#endif</span>
<a name="l03622"></a>03622 <span class="preprocessor"></span>        rctl |= E1000_RCTL_VFE;
<a name="l03623"></a>03623     }
<a name="l03624"></a>03624     E1000_WRITE_REG(hw, E1000_RCTL, rctl);
<a name="l03625"></a>03625 
<a name="l03626"></a>03626     <span class="comment">/*</span>
<a name="l03627"></a>03627 <span class="comment">     * In order to support SR-IOV and eventually VMDq it is necessary to set</span>
<a name="l03628"></a>03628 <span class="comment">     * the VMOLR to enable the appropriate modes.  Without this workaround</span>
<a name="l03629"></a>03629 <span class="comment">     * we will have issues with VLAN tag stripping not being done for frames</span>
<a name="l03630"></a>03630 <span class="comment">     * that are only arriving because we are the default pool</span>
<a name="l03631"></a>03631 <span class="comment">     */</span>
<a name="l03632"></a>03632     <span class="keywordflow">if</span> (hw-&gt;mac.type &lt; e1000_82576)
<a name="l03633"></a>03633         <span class="keywordflow">return</span>;
<a name="l03634"></a>03634 
<a name="l03635"></a>03635     vmolr |= E1000_READ_REG(hw, E1000_VMOLR(vfn)) &amp;
<a name="l03636"></a>03636              ~(E1000_VMOLR_ROPE | E1000_VMOLR_MPME | E1000_VMOLR_ROMPE);
<a name="l03637"></a>03637     E1000_WRITE_REG(hw, E1000_VMOLR(vfn), vmolr);
<a name="l03638"></a>03638     igb_restore_vf_multicasts(adapter);
<a name="l03639"></a>03639 }
<a name="l03640"></a>03640 
<a name="l03641"></a>03641 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_check_wvbr(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03642"></a>03642 {
<a name="l03643"></a>03643     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03644"></a>03644     u32 wvbr = 0;
<a name="l03645"></a>03645 
<a name="l03646"></a>03646     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03647"></a>03647     <span class="keywordflow">case</span> e1000_82576:
<a name="l03648"></a>03648     <span class="keywordflow">case</span> e1000_i350:
<a name="l03649"></a>03649         <span class="keywordflow">if</span> (!(wvbr = E1000_READ_REG(hw, E1000_WVBR)))
<a name="l03650"></a>03650             <span class="keywordflow">return</span>;
<a name="l03651"></a>03651         <span class="keywordflow">break</span>;
<a name="l03652"></a>03652     <span class="keywordflow">default</span>:
<a name="l03653"></a>03653         <span class="keywordflow">break</span>;
<a name="l03654"></a>03654     }
<a name="l03655"></a>03655 
<a name="l03656"></a>03656     adapter-&gt;wvbr |= wvbr;
<a name="l03657"></a>03657 }
<a name="l03658"></a>03658 
<a name="l03659"></a>03659 <span class="preprocessor">#define IGB_STAGGERED_QUEUE_OFFSET 8</span>
<a name="l03660"></a>03660 <span class="preprocessor"></span>
<a name="l03661"></a>03661 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_spoof_check(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03662"></a>03662 {
<a name="l03663"></a>03663     <span class="keywordtype">int</span> j;
<a name="l03664"></a>03664 
<a name="l03665"></a>03665     <span class="keywordflow">if</span> (!adapter-&gt;wvbr)
<a name="l03666"></a>03666         <span class="keywordflow">return</span>;
<a name="l03667"></a>03667 
<a name="l03668"></a>03668     <span class="keywordflow">for</span>(j = 0; j &lt; adapter-&gt;vfs_allocated_count; j++) {
<a name="l03669"></a>03669         <span class="keywordflow">if</span> (adapter-&gt;wvbr &amp; (1 &lt;&lt; j) ||
<a name="l03670"></a>03670             adapter-&gt;wvbr &amp; (1 &lt;&lt; (j + IGB_STAGGERED_QUEUE_OFFSET))) {
<a name="l03671"></a>03671             DPRINTK(DRV, WARNING,
<a name="l03672"></a>03672                 <span class="stringliteral">&quot;Spoof event(s) detected on VF %d\n&quot;</span>, j);
<a name="l03673"></a>03673             adapter-&gt;wvbr &amp;=
<a name="l03674"></a>03674                 ~((1 &lt;&lt; j) |
<a name="l03675"></a>03675                   (1 &lt;&lt; (j + IGB_STAGGERED_QUEUE_OFFSET)));
<a name="l03676"></a>03676         }
<a name="l03677"></a>03677     }
<a name="l03678"></a>03678 }
<a name="l03679"></a>03679 
<a name="l03680"></a>03680 <span class="comment">/* Need to wait a few seconds after link up to get diagnostic information from</span>
<a name="l03681"></a>03681 <span class="comment"> * the phy */</span>
<a name="l03682"></a>03682 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_update_phy_info(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l03683"></a>03683 {
<a name="l03684"></a>03684     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = (<span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *) data;
<a name="l03685"></a>03685     e1000_get_phy_info(&amp;adapter-&gt;hw);
<a name="l03686"></a>03686 }
<a name="l03687"></a>03687 
<a name="l03692"></a>03692 <span class="keywordtype">bool</span> igb_has_link(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l03693"></a>03693 {
<a name="l03694"></a>03694     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03695"></a>03695     <span class="keywordtype">bool</span> link_active = FALSE;
<a name="l03696"></a>03696 
<a name="l03697"></a>03697     <span class="comment">/* get_link_status is set on LSC (link status) interrupt or</span>
<a name="l03698"></a>03698 <span class="comment">     * rx sequence error interrupt.  get_link_status will stay</span>
<a name="l03699"></a>03699 <span class="comment">     * false until the e1000_check_for_link establishes link</span>
<a name="l03700"></a>03700 <span class="comment">     * for copper adapters ONLY</span>
<a name="l03701"></a>03701 <span class="comment">     */</span>
<a name="l03702"></a>03702     <span class="keywordflow">switch</span> (hw-&gt;phy.media_type) {
<a name="l03703"></a>03703     <span class="keywordflow">case</span> e1000_media_type_copper:
<a name="l03704"></a>03704         <span class="keywordflow">if</span> (!hw-&gt;mac.get_link_status)
<a name="l03705"></a>03705             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03706"></a>03706     <span class="keywordflow">case</span> e1000_media_type_internal_serdes:
<a name="l03707"></a>03707         e1000_check_for_link(hw);
<a name="l03708"></a>03708         link_active = !hw-&gt;mac.get_link_status;
<a name="l03709"></a>03709         <span class="keywordflow">break</span>;
<a name="l03710"></a>03710     <span class="keywordflow">case</span> e1000_media_type_unknown:
<a name="l03711"></a>03711     <span class="keywordflow">default</span>:
<a name="l03712"></a>03712         <span class="keywordflow">break</span>;
<a name="l03713"></a>03713     }
<a name="l03714"></a>03714 
<a name="l03715"></a>03715     <span class="keywordflow">return</span> link_active;
<a name="l03716"></a>03716 }
<a name="l03717"></a>03717 
<a name="l03722"></a>03722 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_watchdog(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l03723"></a>03723 {
<a name="l03724"></a>03724     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = (<span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *)data;
<a name="l03725"></a>03725     <span class="comment">/* Do the rest outside of interrupt context */</span>
<a name="l03726"></a>03726     schedule_work(&amp;adapter-&gt;watchdog_task);
<a name="l03727"></a>03727 }
<a name="l03728"></a>03728 
<a name="l03729"></a>03729 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_watchdog_task(<span class="keyword">struct</span> work_struct *work)
<a name="l03730"></a>03730 {
<a name="l03731"></a>03731     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = container_of(work,
<a name="l03732"></a>03732                                                <span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a>,
<a name="l03733"></a>03733                                                    watchdog_task);
<a name="l03734"></a>03734     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03735"></a>03735     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l03736"></a>03736     u32 link;
<a name="l03737"></a>03737     <span class="keywordtype">int</span> i;
<a name="l03738"></a>03738     u32 thstat, ctrl_ext;
<a name="l03739"></a>03739 
<a name="l03740"></a>03740 
<a name="l03741"></a>03741     link = igb_has_link(adapter);
<a name="l03742"></a>03742     <span class="keywordflow">if</span> (link) {
<a name="l03743"></a>03743         <span class="keywordflow">if</span> (!netif_carrier_ok(netdev)) {
<a name="l03744"></a>03744             u32 ctrl;
<a name="l03745"></a>03745             e1000_get_speed_and_duplex(hw,
<a name="l03746"></a>03746                                        &amp;adapter-&gt;link_speed,
<a name="l03747"></a>03747                                        &amp;adapter-&gt;link_duplex);
<a name="l03748"></a>03748 
<a name="l03749"></a>03749             ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l03750"></a>03750             <span class="comment">/* Links status message must follow this format */</span>
<a name="l03751"></a>03751             printk(KERN_INFO <span class="stringliteral">&quot;igb: %s NIC Link is Up %d Mbps %s, &quot;</span>
<a name="l03752"></a>03752                  <span class="stringliteral">&quot;Flow Control: %s\n&quot;</span>,
<a name="l03753"></a>03753                    netdev-&gt;name,
<a name="l03754"></a>03754                    adapter-&gt;link_speed,
<a name="l03755"></a>03755                    adapter-&gt;link_duplex == FULL_DUPLEX ?
<a name="l03756"></a>03756                  <span class="stringliteral">&quot;Full Duplex&quot;</span> : <span class="stringliteral">&quot;Half Duplex&quot;</span>,
<a name="l03757"></a>03757                    ((ctrl &amp; E1000_CTRL_TFCE) &amp;&amp;
<a name="l03758"></a>03758                     (ctrl &amp; E1000_CTRL_RFCE)) ? <span class="stringliteral">&quot;RX/TX&quot;</span>:
<a name="l03759"></a>03759                    ((ctrl &amp; E1000_CTRL_RFCE) ?  <span class="stringliteral">&quot;RX&quot;</span> :
<a name="l03760"></a>03760                    ((ctrl &amp; E1000_CTRL_TFCE) ?  <span class="stringliteral">&quot;TX&quot;</span> : <span class="stringliteral">&quot;None&quot;</span>)));
<a name="l03761"></a>03761             <span class="comment">/* adjust timeout factor according to speed/duplex */</span>
<a name="l03762"></a>03762             adapter-&gt;tx_timeout_factor = 1;
<a name="l03763"></a>03763             <span class="keywordflow">switch</span> (adapter-&gt;link_speed) {
<a name="l03764"></a>03764             <span class="keywordflow">case</span> SPEED_10:
<a name="l03765"></a>03765                 adapter-&gt;tx_timeout_factor = 14;
<a name="l03766"></a>03766                 <span class="keywordflow">break</span>;
<a name="l03767"></a>03767             <span class="keywordflow">case</span> SPEED_100:
<a name="l03768"></a>03768                 <span class="comment">/* maybe add some timeout factor ? */</span>
<a name="l03769"></a>03769                 <span class="keywordflow">break</span>;
<a name="l03770"></a>03770             }
<a name="l03771"></a>03771 
<a name="l03772"></a>03772             netif_carrier_on(netdev);
<a name="l03773"></a>03773             netif_tx_wake_all_queues(netdev);
<a name="l03774"></a>03774 
<a name="l03775"></a>03775             igb_ping_all_vfs(adapter);
<a name="l03776"></a>03776 <span class="preprocessor">#ifdef IFLA_VF_MAX</span>
<a name="l03777"></a>03777 <span class="preprocessor"></span>            igb_check_vf_rate_limit(adapter);
<a name="l03778"></a>03778 <span class="preprocessor">#endif </span><span class="comment">/* IFLA_VF_MAX */</span>
<a name="l03779"></a>03779 
<a name="l03780"></a>03780             <span class="comment">/* link state has changed, schedule phy info update */</span>
<a name="l03781"></a>03781             <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l03782"></a>03782                 mod_timer(&amp;adapter-&gt;phy_info_timer,
<a name="l03783"></a>03783                       round_jiffies(jiffies + 2 * HZ));
<a name="l03784"></a>03784         }
<a name="l03785"></a>03785     } <span class="keywordflow">else</span> {
<a name="l03786"></a>03786         <span class="keywordflow">if</span> (netif_carrier_ok(netdev)) {
<a name="l03787"></a>03787             adapter-&gt;link_speed = 0;
<a name="l03788"></a>03788             adapter-&gt;link_duplex = 0;
<a name="l03789"></a>03789             <span class="comment">/* check for thermal sensor event on i350 */</span>
<a name="l03790"></a>03790             <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_i350) {
<a name="l03791"></a>03791                 thstat = E1000_READ_REG(hw, E1000_THSTAT);
<a name="l03792"></a>03792                 ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l03793"></a>03793                 <span class="keywordflow">if</span> ((hw-&gt;phy.media_type ==
<a name="l03794"></a>03794                     e1000_media_type_copper) &amp;&amp;
<a name="l03795"></a>03795                     !(ctrl_ext &amp;
<a name="l03796"></a>03796                     E1000_CTRL_EXT_LINK_MODE_SGMII)) {
<a name="l03797"></a>03797                     <span class="keywordflow">if</span> (thstat &amp; E1000_THSTAT_PWR_DOWN) {
<a name="l03798"></a>03798                         printk(KERN_ERR <span class="stringliteral">&quot;igb: %s The &quot;</span>
<a name="l03799"></a>03799                         <span class="stringliteral">&quot;network adapter was stopped &quot;</span>
<a name="l03800"></a>03800                         <span class="stringliteral">&quot;because it overheated.\n&quot;</span>,
<a name="l03801"></a>03801                         netdev-&gt;name);
<a name="l03802"></a>03802                     }
<a name="l03803"></a>03803                     <span class="keywordflow">if</span> (thstat &amp; E1000_THSTAT_LINK_THROTTLE) {
<a name="l03804"></a>03804                         printk(KERN_INFO 
<a name="l03805"></a>03805                             <span class="stringliteral">&quot;igb: %s The network &quot;</span>
<a name="l03806"></a>03806                             <span class="stringliteral">&quot;adapter supported &quot;</span>
<a name="l03807"></a>03807                             <span class="stringliteral">&quot;link speed &quot;</span>
<a name="l03808"></a>03808                             <span class="stringliteral">&quot;was downshifted &quot;</span>
<a name="l03809"></a>03809                             <span class="stringliteral">&quot;because it &quot;</span>
<a name="l03810"></a>03810                             <span class="stringliteral">&quot;overheated.\n&quot;</span>,
<a name="l03811"></a>03811                             netdev-&gt;name);
<a name="l03812"></a>03812                     }
<a name="l03813"></a>03813                 }
<a name="l03814"></a>03814             }
<a name="l03815"></a>03815 
<a name="l03816"></a>03816             <span class="comment">/* Links status message must follow this format */</span>
<a name="l03817"></a>03817             printk(KERN_INFO <span class="stringliteral">&quot;igb: %s NIC Link is Down\n&quot;</span>,
<a name="l03818"></a>03818                    netdev-&gt;name);
<a name="l03819"></a>03819             netif_carrier_off(netdev);
<a name="l03820"></a>03820             netif_tx_stop_all_queues(netdev);
<a name="l03821"></a>03821 
<a name="l03822"></a>03822             igb_ping_all_vfs(adapter);
<a name="l03823"></a>03823 
<a name="l03824"></a>03824             <span class="comment">/* link state has changed, schedule phy info update */</span>
<a name="l03825"></a>03825             <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l03826"></a>03826                 mod_timer(&amp;adapter-&gt;phy_info_timer,
<a name="l03827"></a>03827                       round_jiffies(jiffies + 2 * HZ));
<a name="l03828"></a>03828         }
<a name="l03829"></a>03829     }
<a name="l03830"></a>03830 
<a name="l03831"></a>03831     igb_update_stats(adapter);
<a name="l03832"></a>03832 
<a name="l03833"></a>03833     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l03834"></a>03834         <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l03835"></a>03835         <span class="keywordflow">if</span> (!netif_carrier_ok(netdev)) {
<a name="l03836"></a>03836             <span class="comment">/* We&#39;ve lost link, so the controller stops DMA,</span>
<a name="l03837"></a>03837 <span class="comment">             * but we&#39;ve got queued Tx work that&#39;s never going</span>
<a name="l03838"></a>03838 <span class="comment">             * to get done, so reset controller to flush Tx.</span>
<a name="l03839"></a>03839 <span class="comment">             * (Do the reset outside of interrupt context). */</span>
<a name="l03840"></a>03840             <span class="keywordflow">if</span> (igb_desc_unused(tx_ring) + 1 &lt; tx_ring-&gt;count) {
<a name="l03841"></a>03841                 adapter-&gt;tx_timeout_count++;
<a name="l03842"></a>03842                 schedule_work(&amp;adapter-&gt;reset_task);
<a name="l03843"></a>03843                 <span class="comment">/* return immediately since reset is imminent */</span>
<a name="l03844"></a>03844                 <span class="keywordflow">return</span>;
<a name="l03845"></a>03845             }
<a name="l03846"></a>03846         }
<a name="l03847"></a>03847 
<a name="l03848"></a>03848         <span class="comment">/* Force detection of hung controller every watchdog period */</span>
<a name="l03849"></a>03849         set_bit(IGB_RING_FLAG_TX_DETECT_HANG, &amp;tx_ring-&gt;flags);
<a name="l03850"></a>03850     }
<a name="l03851"></a>03851 
<a name="l03852"></a>03852     <span class="comment">/* Cause software interrupt to ensure rx ring is cleaned */</span>
<a name="l03853"></a>03853     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l03854"></a>03854         u32 eics = 0;
<a name="l03855"></a>03855         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)
<a name="l03856"></a>03856             eics |= adapter-&gt;q_vector[i]-&gt;eims_value;
<a name="l03857"></a>03857         E1000_WRITE_REG(hw, E1000_EICS, eics);
<a name="l03858"></a>03858     } <span class="keywordflow">else</span> {
<a name="l03859"></a>03859         E1000_WRITE_REG(hw, E1000_ICS, E1000_ICS_RXDMT0);
<a name="l03860"></a>03860     }
<a name="l03861"></a>03861 
<a name="l03862"></a>03862     igb_spoof_check(adapter);
<a name="l03863"></a>03863 
<a name="l03864"></a>03864     <span class="comment">/* Reset the timer */</span>
<a name="l03865"></a>03865     <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l03866"></a>03866         mod_timer(&amp;adapter-&gt;watchdog_timer,
<a name="l03867"></a>03867               round_jiffies(jiffies + 2 * HZ));
<a name="l03868"></a>03868 }
<a name="l03869"></a>03869 
<a name="l03870"></a>03870 <span class="keyword">enum</span> latency_range {
<a name="l03871"></a>03871     lowest_latency = 0,
<a name="l03872"></a>03872     low_latency = 1,
<a name="l03873"></a>03873     bulk_latency = 2,
<a name="l03874"></a>03874     latency_invalid = 255
<a name="l03875"></a>03875 };
<a name="l03876"></a>03876 
<a name="l03893"></a>03893 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_update_ring_itr(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector)
<a name="l03894"></a>03894 {
<a name="l03895"></a>03895     <span class="keywordtype">int</span> new_val = q_vector-&gt;itr_val;
<a name="l03896"></a>03896     <span class="keywordtype">int</span> avg_wire_size = 0;
<a name="l03897"></a>03897     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l03898"></a>03898 
<a name="l03899"></a>03899     <span class="comment">/* For non-gigabit speeds, just fix the interrupt rate at 4000</span>
<a name="l03900"></a>03900 <span class="comment">     * ints/sec - ITR timer value of 120 ticks.</span>
<a name="l03901"></a>03901 <span class="comment">     */</span>
<a name="l03902"></a>03902     <span class="keywordflow">if</span> (adapter-&gt;link_speed != SPEED_1000) {
<a name="l03903"></a>03903         new_val = IGB_4K_ITR;
<a name="l03904"></a>03904         <span class="keywordflow">goto</span> set_itr_val;
<a name="l03905"></a>03905     }
<a name="l03906"></a>03906 
<a name="l03907"></a>03907     <span class="keywordflow">if</span> (q_vector-&gt;rx_ring &amp;&amp; q_vector-&gt;rx_ring-&gt;total_packets) {
<a name="l03908"></a>03908         <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *ring = q_vector-&gt;rx_ring;
<a name="l03909"></a>03909         avg_wire_size = ring-&gt;total_bytes / ring-&gt;total_packets;
<a name="l03910"></a>03910     }
<a name="l03911"></a>03911 
<a name="l03912"></a>03912     <span class="keywordflow">if</span> (q_vector-&gt;tx_ring &amp;&amp; q_vector-&gt;tx_ring-&gt;total_packets) {
<a name="l03913"></a>03913         <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *ring = q_vector-&gt;tx_ring;
<a name="l03914"></a>03914         avg_wire_size = max_t(u32, avg_wire_size,
<a name="l03915"></a>03915                               (ring-&gt;total_bytes /
<a name="l03916"></a>03916                                ring-&gt;total_packets));
<a name="l03917"></a>03917     }
<a name="l03918"></a>03918 
<a name="l03919"></a>03919     <span class="comment">/* if avg_wire_size isn&#39;t set no work was done */</span>
<a name="l03920"></a>03920     <span class="keywordflow">if</span> (!avg_wire_size)
<a name="l03921"></a>03921         <span class="keywordflow">goto</span> clear_counts;
<a name="l03922"></a>03922 
<a name="l03923"></a>03923     <span class="comment">/* Add 24 bytes to size to account for CRC, preamble, and gap */</span>
<a name="l03924"></a>03924     avg_wire_size += 24;
<a name="l03925"></a>03925 
<a name="l03926"></a>03926     <span class="comment">/* Don&#39;t starve jumbo frames */</span>
<a name="l03927"></a>03927     avg_wire_size = min(avg_wire_size, 3000);
<a name="l03928"></a>03928 
<a name="l03929"></a>03929     <span class="comment">/* Give a little boost to mid-size frames */</span>
<a name="l03930"></a>03930     <span class="keywordflow">if</span> ((avg_wire_size &gt; 300) &amp;&amp; (avg_wire_size &lt; 1200))
<a name="l03931"></a>03931         new_val = avg_wire_size / 3;
<a name="l03932"></a>03932     <span class="keywordflow">else</span>
<a name="l03933"></a>03933         new_val = avg_wire_size / 2;
<a name="l03934"></a>03934 
<a name="l03935"></a>03935     <span class="comment">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
<a name="l03936"></a>03936     <span class="keywordflow">if</span> (new_val &lt; IGB_20K_ITR &amp;&amp;
<a name="l03937"></a>03937         ((q_vector-&gt;rx_ring &amp;&amp; adapter-&gt;rx_itr_setting == 3) ||
<a name="l03938"></a>03938          (!q_vector-&gt;rx_ring &amp;&amp; adapter-&gt;tx_itr_setting == 3)))
<a name="l03939"></a>03939         new_val = IGB_20K_ITR;
<a name="l03940"></a>03940 
<a name="l03941"></a>03941 set_itr_val:
<a name="l03942"></a>03942     <span class="keywordflow">if</span> (new_val != q_vector-&gt;itr_val) {
<a name="l03943"></a>03943         q_vector-&gt;itr_val = new_val;
<a name="l03944"></a>03944         q_vector-&gt;set_itr = 1;
<a name="l03945"></a>03945     }
<a name="l03946"></a>03946 clear_counts:
<a name="l03947"></a>03947     <span class="keywordflow">if</span> (q_vector-&gt;rx_ring) {
<a name="l03948"></a>03948         q_vector-&gt;rx_ring-&gt;total_bytes = 0;
<a name="l03949"></a>03949         q_vector-&gt;rx_ring-&gt;total_packets = 0;
<a name="l03950"></a>03950     }
<a name="l03951"></a>03951     <span class="keywordflow">if</span> (q_vector-&gt;tx_ring) {
<a name="l03952"></a>03952         q_vector-&gt;tx_ring-&gt;total_bytes = 0;
<a name="l03953"></a>03953         q_vector-&gt;tx_ring-&gt;total_packets = 0;
<a name="l03954"></a>03954     }
<a name="l03955"></a>03955 }
<a name="l03956"></a>03956 
<a name="l03972"></a>03972 <span class="keyword">static</span> u16 igb_update_itr(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *ring)
<a name="l03973"></a>03973 {
<a name="l03974"></a>03974     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packets = ring-&gt;total_packets;
<a name="l03975"></a>03975     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes = ring-&gt;total_bytes;
<a name="l03976"></a>03976     u16 itrval = ring-&gt;itr;
<a name="l03977"></a>03977 
<a name="l03978"></a>03978     <span class="comment">/* no packets, exit with status unchanged */</span>
<a name="l03979"></a>03979     <span class="keywordflow">if</span> (packets == 0)
<a name="l03980"></a>03980         <span class="keywordflow">return</span> itrval;
<a name="l03981"></a>03981 
<a name="l03982"></a>03982     <span class="keywordflow">switch</span> (itrval) {
<a name="l03983"></a>03983     <span class="keywordflow">case</span> lowest_latency:
<a name="l03984"></a>03984         <span class="comment">/* handle TSO and jumbo frames */</span>
<a name="l03985"></a>03985         <span class="keywordflow">if</span> (bytes/packets &gt; 8000)
<a name="l03986"></a>03986             itrval = bulk_latency;
<a name="l03987"></a>03987         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((packets &lt; 5) &amp;&amp; (bytes &gt; 512))
<a name="l03988"></a>03988             itrval = low_latency;
<a name="l03989"></a>03989         <span class="keywordflow">break</span>;
<a name="l03990"></a>03990     <span class="keywordflow">case</span> low_latency:  <span class="comment">/* 50 usec aka 20000 ints/s */</span>
<a name="l03991"></a>03991         <span class="keywordflow">if</span> (bytes &gt; 10000) {
<a name="l03992"></a>03992             <span class="comment">/* this if handles the TSO accounting */</span>
<a name="l03993"></a>03993             <span class="keywordflow">if</span> (bytes/packets &gt; 8000) {
<a name="l03994"></a>03994                 itrval = bulk_latency;
<a name="l03995"></a>03995             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((packets &lt; 10) || ((bytes/packets) &gt; 1200)) {
<a name="l03996"></a>03996                 itrval = bulk_latency;
<a name="l03997"></a>03997             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((packets &gt; 35)) {
<a name="l03998"></a>03998                 itrval = lowest_latency;
<a name="l03999"></a>03999             }
<a name="l04000"></a>04000         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes/packets &gt; 2000) {
<a name="l04001"></a>04001             itrval = bulk_latency;
<a name="l04002"></a>04002         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (packets &lt;= 2 &amp;&amp; bytes &lt; 512) {
<a name="l04003"></a>04003             itrval = lowest_latency;
<a name="l04004"></a>04004         }
<a name="l04005"></a>04005         <span class="keywordflow">break</span>;
<a name="l04006"></a>04006     <span class="keywordflow">case</span> bulk_latency: <span class="comment">/* 250 usec aka 4000 ints/s */</span>
<a name="l04007"></a>04007         <span class="keywordflow">if</span> (bytes &gt; 25000) {
<a name="l04008"></a>04008             <span class="keywordflow">if</span> (packets &gt; 35)
<a name="l04009"></a>04009                 itrval = low_latency;
<a name="l04010"></a>04010         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes &lt; 1500) {
<a name="l04011"></a>04011             itrval = low_latency;
<a name="l04012"></a>04012         }
<a name="l04013"></a>04013         <span class="keywordflow">break</span>;
<a name="l04014"></a>04014     }
<a name="l04015"></a>04015 
<a name="l04016"></a>04016     ring-&gt;total_bytes = 0;
<a name="l04017"></a>04017     ring-&gt;total_packets = 0;
<a name="l04018"></a>04018     ring-&gt;itr = itrval;
<a name="l04019"></a>04019     <span class="keywordflow">return</span> itrval;
<a name="l04020"></a>04020 }
<a name="l04021"></a>04021 
<a name="l04022"></a>04022 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_itr(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector)
<a name="l04023"></a>04023 {
<a name="l04024"></a>04024     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l04025"></a>04025     u16 current_itr = 0;
<a name="l04026"></a>04026     u32 new_itr = q_vector-&gt;itr_val;
<a name="l04027"></a>04027 
<a name="l04028"></a>04028     <span class="comment">/* for non-gigabit speeds, just fix the interrupt rate at 4000 */</span>
<a name="l04029"></a>04029     <span class="keywordflow">if</span> (adapter-&gt;link_speed != SPEED_1000) {
<a name="l04030"></a>04030         current_itr = 0;
<a name="l04031"></a>04031         new_itr = IGB_4K_ITR;
<a name="l04032"></a>04032         <span class="keywordflow">goto</span> set_itr_now;
<a name="l04033"></a>04033     }
<a name="l04034"></a>04034 
<a name="l04035"></a>04035     <span class="keywordflow">if</span> (q_vector-&gt;rx_ring) 
<a name="l04036"></a>04036         current_itr = igb_update_itr(q_vector-&gt;rx_ring);
<a name="l04037"></a>04037     <span class="keywordflow">if</span> (q_vector-&gt;tx_ring) {
<a name="l04038"></a>04038         igb_update_itr(q_vector-&gt;tx_ring);
<a name="l04039"></a>04039         current_itr = max(current_itr, q_vector-&gt;tx_ring-&gt;itr);
<a name="l04040"></a>04040     }
<a name="l04041"></a>04041 
<a name="l04042"></a>04042     <span class="comment">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
<a name="l04043"></a>04043     <span class="keywordflow">if</span> (current_itr == lowest_latency &amp;&amp;
<a name="l04044"></a>04044         ((q_vector-&gt;rx_ring &amp;&amp; adapter-&gt;rx_itr_setting == 3) ||
<a name="l04045"></a>04045          (!q_vector-&gt;rx_ring &amp;&amp; adapter-&gt;tx_itr_setting == 3)))
<a name="l04046"></a>04046         current_itr = low_latency;
<a name="l04047"></a>04047 
<a name="l04048"></a>04048     <span class="keywordflow">switch</span> (current_itr) {
<a name="l04049"></a>04049     <span class="comment">/* counts and packets in update_itr are dependent on these numbers */</span>
<a name="l04050"></a>04050     <span class="keywordflow">case</span> lowest_latency:
<a name="l04051"></a>04051         new_itr = IGB_70K_ITR; <span class="comment">/* 70,000 ints/sec */</span>
<a name="l04052"></a>04052         <span class="keywordflow">break</span>;
<a name="l04053"></a>04053     <span class="keywordflow">case</span> low_latency:
<a name="l04054"></a>04054         new_itr = IGB_20K_ITR; <span class="comment">/* 20,000 ints/sec */</span>
<a name="l04055"></a>04055         <span class="keywordflow">break</span>;
<a name="l04056"></a>04056     <span class="keywordflow">case</span> bulk_latency:
<a name="l04057"></a>04057         new_itr = IGB_4K_ITR;  <span class="comment">/* 4,000 ints/sec */</span>
<a name="l04058"></a>04058         <span class="keywordflow">break</span>;
<a name="l04059"></a>04059     <span class="keywordflow">default</span>:
<a name="l04060"></a>04060         <span class="keywordflow">break</span>;
<a name="l04061"></a>04061     }
<a name="l04062"></a>04062 
<a name="l04063"></a>04063 set_itr_now:
<a name="l04064"></a>04064     <span class="keywordflow">if</span> (new_itr != q_vector-&gt;itr_val) {
<a name="l04065"></a>04065         <span class="comment">/* this attempts to bias the interrupt rate towards Bulk</span>
<a name="l04066"></a>04066 <span class="comment">         * by adding intermediate steps when interrupt rate is</span>
<a name="l04067"></a>04067 <span class="comment">         * increasing */</span>
<a name="l04068"></a>04068         new_itr = new_itr &gt; q_vector-&gt;itr_val ?
<a name="l04069"></a>04069                      max((new_itr * q_vector-&gt;itr_val) /
<a name="l04070"></a>04070                          (new_itr + (q_vector-&gt;itr_val &gt;&gt; 2)),
<a name="l04071"></a>04071                  new_itr) :
<a name="l04072"></a>04072                  new_itr;
<a name="l04073"></a>04073         <span class="comment">/* Don&#39;t write the value here; it resets the adapter&#39;s</span>
<a name="l04074"></a>04074 <span class="comment">         * internal timer, and causes us to delay far longer than</span>
<a name="l04075"></a>04075 <span class="comment">         * we should between interrupts.  Instead, we write the ITR</span>
<a name="l04076"></a>04076 <span class="comment">         * value at the beginning of the next interrupt so the timing</span>
<a name="l04077"></a>04077 <span class="comment">         * ends up being correct.</span>
<a name="l04078"></a>04078 <span class="comment">         */</span>
<a name="l04079"></a>04079         q_vector-&gt;itr_val = new_itr;
<a name="l04080"></a>04080         q_vector-&gt;set_itr = 1;
<a name="l04081"></a>04081     }
<a name="l04082"></a>04082 }
<a name="l04083"></a>04083 
<a name="l04084"></a>04084 <span class="preprocessor">#define IGB_TX_FLAGS_CSUM       0x00000001</span>
<a name="l04085"></a>04085 <span class="preprocessor"></span><span class="preprocessor">#define IGB_TX_FLAGS_VLAN       0x00000002</span>
<a name="l04086"></a>04086 <span class="preprocessor"></span><span class="preprocessor">#define IGB_TX_FLAGS_TSO        0x00000004</span>
<a name="l04087"></a>04087 <span class="preprocessor"></span><span class="preprocessor">#define IGB_TX_FLAGS_IPV4       0x00000008</span>
<a name="l04088"></a>04088 <span class="preprocessor"></span><span class="preprocessor">#define IGB_TX_FLAGS_TSTAMP     0x00000010</span>
<a name="l04089"></a>04089 <span class="preprocessor"></span><span class="preprocessor">#define IGB_TX_FLAGS_VLAN_MASK      0xffff0000</span>
<a name="l04090"></a>04090 <span class="preprocessor"></span><span class="preprocessor">#define IGB_TX_FLAGS_VLAN_SHIFT             16</span>
<a name="l04091"></a>04091 <span class="preprocessor"></span>
<a name="l04092"></a>04092 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structe1000__adv__tx__context__desc.html">e1000_adv_tx_context_desc</a> *igb_tx_ctxtdesc(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring)
<a name="l04093"></a>04093 {
<a name="l04094"></a>04094     <span class="keyword">struct </span><a class="code" href="structe1000__adv__tx__context__desc.html">e1000_adv_tx_context_desc</a> *context_desc;
<a name="l04095"></a>04095     <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info;
<a name="l04096"></a>04096     u16 i = tx_ring-&gt;next_to_use;
<a name="l04097"></a>04097 
<a name="l04098"></a>04098     buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l04099"></a>04099     buffer_info-&gt;time_stamp = jiffies;
<a name="l04100"></a>04100     buffer_info-&gt;next_to_watch = i;
<a name="l04101"></a>04101 
<a name="l04102"></a>04102     context_desc = IGB_TX_CTXTDESC(tx_ring, i);
<a name="l04103"></a>04103 
<a name="l04104"></a>04104     i++;
<a name="l04105"></a>04105     <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l04106"></a>04106         tx_ring-&gt;next_to_use = 0;
<a name="l04107"></a>04107     <span class="keywordflow">else</span>
<a name="l04108"></a>04108         tx_ring-&gt;next_to_use = i;
<a name="l04109"></a>04109 
<a name="l04110"></a>04110     <span class="keywordflow">return</span> context_desc;
<a name="l04111"></a>04111 }
<a name="l04112"></a>04112 
<a name="l04113"></a>04113 
<a name="l04114"></a>04114 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> igb_tso(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring,
<a name="l04115"></a>04115                           <span class="keyword">struct</span> sk_buff *skb, u32 tx_flags, u8 *hdr_len)
<a name="l04116"></a>04116 {
<a name="l04117"></a>04117 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l04118"></a>04118 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structe1000__adv__tx__context__desc.html">e1000_adv_tx_context_desc</a> *context_desc;
<a name="l04119"></a>04119     <span class="keywordtype">int</span> err;
<a name="l04120"></a>04120     u32 info = 0, tu_cmd = 0;
<a name="l04121"></a>04121     u32 mss_l4len_idx;
<a name="l04122"></a>04122     u8 l4len;
<a name="l04123"></a>04123 
<a name="l04124"></a>04124     <span class="keywordflow">if</span> (skb_header_cloned(skb)) {
<a name="l04125"></a>04125         err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
<a name="l04126"></a>04126         <span class="keywordflow">if</span> (err)
<a name="l04127"></a>04127             <span class="keywordflow">return</span> err;
<a name="l04128"></a>04128     }
<a name="l04129"></a>04129 
<a name="l04130"></a>04130     context_desc = igb_tx_ctxtdesc(tx_ring);
<a name="l04131"></a>04131     l4len = tcp_hdrlen(skb);
<a name="l04132"></a>04132     *hdr_len += l4len;
<a name="l04133"></a>04133 
<a name="l04134"></a>04134     <span class="keywordflow">if</span> (skb-&gt;protocol == htons(ETH_P_IP)) {
<a name="l04135"></a>04135         <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = ip_hdr(skb);
<a name="l04136"></a>04136         iph-&gt;tot_len = 0;
<a name="l04137"></a>04137         iph-&gt;check = 0;
<a name="l04138"></a>04138         tcp_hdr(skb)-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr,
<a name="l04139"></a>04139                              iph-&gt;daddr, 0,
<a name="l04140"></a>04140                              IPPROTO_TCP,
<a name="l04141"></a>04141                              0);
<a name="l04142"></a>04142 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l04143"></a>04143 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (skb_is_gso_v6(skb)) {
<a name="l04144"></a>04144         ipv6_hdr(skb)-&gt;payload_len = 0;
<a name="l04145"></a>04145         tcp_hdr(skb)-&gt;check = ~csum_ipv6_magic(&amp;ipv6_hdr(skb)-&gt;saddr,
<a name="l04146"></a>04146                                &amp;ipv6_hdr(skb)-&gt;daddr,
<a name="l04147"></a>04147                                0, IPPROTO_TCP, 0);
<a name="l04148"></a>04148 <span class="preprocessor">#endif</span>
<a name="l04149"></a>04149 <span class="preprocessor"></span>    }
<a name="l04150"></a>04150 
<a name="l04151"></a>04151     <span class="comment">/* VLAN MACLEN IPLEN */</span>
<a name="l04152"></a>04152     <span class="keywordflow">if</span> (tx_flags &amp; IGB_TX_FLAGS_VLAN)
<a name="l04153"></a>04153         info |= (tx_flags &amp; IGB_TX_FLAGS_VLAN_MASK);
<a name="l04154"></a>04154     info |= (skb_network_offset(skb) &lt;&lt; E1000_ADVTXD_MACLEN_SHIFT);
<a name="l04155"></a>04155     *hdr_len += skb_network_offset(skb);
<a name="l04156"></a>04156     info |= skb_network_header_len(skb);
<a name="l04157"></a>04157     *hdr_len += skb_network_header_len(skb);
<a name="l04158"></a>04158     context_desc-&gt;vlan_macip_lens = cpu_to_le32(info);
<a name="l04159"></a>04159 
<a name="l04160"></a>04160     <span class="comment">/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */</span>
<a name="l04161"></a>04161     tu_cmd |= (E1000_TXD_CMD_DEXT | E1000_ADVTXD_DTYP_CTXT);
<a name="l04162"></a>04162 
<a name="l04163"></a>04163     <span class="keywordflow">if</span> (skb-&gt;protocol == htons(ETH_P_IP))
<a name="l04164"></a>04164         tu_cmd |= E1000_ADVTXD_TUCMD_IPV4;
<a name="l04165"></a>04165     tu_cmd |= E1000_ADVTXD_TUCMD_L4T_TCP;
<a name="l04166"></a>04166 
<a name="l04167"></a>04167     context_desc-&gt;type_tucmd_mlhl = cpu_to_le32(tu_cmd);
<a name="l04168"></a>04168 
<a name="l04169"></a>04169     <span class="comment">/* MSS L4LEN IDX */</span>
<a name="l04170"></a>04170     mss_l4len_idx = (skb_shinfo(skb)-&gt;gso_size &lt;&lt; E1000_ADVTXD_MSS_SHIFT);
<a name="l04171"></a>04171     mss_l4len_idx |= (l4len &lt;&lt; E1000_ADVTXD_L4LEN_SHIFT);
<a name="l04172"></a>04172 
<a name="l04173"></a>04173     <span class="comment">/* For 82575, context index must be unique per ring. */</span>
<a name="l04174"></a>04174     <span class="keywordflow">if</span> (test_bit(IGB_RING_FLAG_TX_CTX_IDX, &amp;tx_ring-&gt;flags))
<a name="l04175"></a>04175         mss_l4len_idx |= tx_ring-&gt;reg_idx &lt;&lt; 4;
<a name="l04176"></a>04176 
<a name="l04177"></a>04177     context_desc-&gt;mss_l4len_idx = cpu_to_le32(mss_l4len_idx);
<a name="l04178"></a>04178     context_desc-&gt;seqnum_seed = 0;
<a name="l04179"></a>04179 
<a name="l04180"></a>04180     <span class="keywordflow">return</span> TRUE;
<a name="l04181"></a>04181 <span class="preprocessor">#else</span>
<a name="l04182"></a>04182 <span class="preprocessor"></span>    <span class="keywordflow">return</span> FALSE;
<a name="l04183"></a>04183 <span class="preprocessor">#endif  </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l04184"></a>04184 }
<a name="l04185"></a>04185 
<a name="l04186"></a>04186 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> igb_tx_csum(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring,
<a name="l04187"></a>04187                    <span class="keyword">struct</span> sk_buff *skb, u32 tx_flags)
<a name="l04188"></a>04188 {
<a name="l04189"></a>04189     <span class="keywordflow">if</span> ((skb-&gt;ip_summed == CHECKSUM_PARTIAL) ||
<a name="l04190"></a>04190         (tx_flags &amp; IGB_TX_FLAGS_VLAN)) {
<a name="l04191"></a>04191         <span class="keyword">struct </span><a class="code" href="structe1000__adv__tx__context__desc.html">e1000_adv_tx_context_desc</a> *context_desc;
<a name="l04192"></a>04192         u32 info = 0, tu_cmd = 0;
<a name="l04193"></a>04193 
<a name="l04194"></a>04194         context_desc = igb_tx_ctxtdesc(tx_ring);
<a name="l04195"></a>04195 
<a name="l04196"></a>04196         <span class="keywordflow">if</span> (tx_flags &amp; IGB_TX_FLAGS_VLAN)
<a name="l04197"></a>04197             info |= (tx_flags &amp; IGB_TX_FLAGS_VLAN_MASK);
<a name="l04198"></a>04198 
<a name="l04199"></a>04199         info |= (skb_network_offset(skb) &lt;&lt; E1000_ADVTXD_MACLEN_SHIFT);
<a name="l04200"></a>04200         <span class="keywordflow">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL)
<a name="l04201"></a>04201             info |= skb_network_header_len(skb);
<a name="l04202"></a>04202 
<a name="l04203"></a>04203         context_desc-&gt;vlan_macip_lens = cpu_to_le32(info);
<a name="l04204"></a>04204 
<a name="l04205"></a>04205         tu_cmd |= (E1000_TXD_CMD_DEXT | E1000_ADVTXD_DTYP_CTXT);
<a name="l04206"></a>04206 
<a name="l04207"></a>04207         <span class="keywordflow">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {
<a name="l04208"></a>04208             __be16 protocol;
<a name="l04209"></a>04209 
<a name="l04210"></a>04210             <span class="keywordflow">if</span> (skb-&gt;protocol == cpu_to_be16(ETH_P_8021Q)) {
<a name="l04211"></a>04211                 <span class="keyword">const</span> <span class="keyword">struct </span>vlan_ethhdr *vhdr =
<a name="l04212"></a>04212                           (<span class="keyword">const</span> <span class="keyword">struct </span>vlan_ethhdr*)skb-&gt;data;
<a name="l04213"></a>04213 
<a name="l04214"></a>04214                 protocol = vhdr-&gt;h_vlan_encapsulated_proto;
<a name="l04215"></a>04215             } <span class="keywordflow">else</span> {
<a name="l04216"></a>04216                 protocol = skb-&gt;protocol;
<a name="l04217"></a>04217             }
<a name="l04218"></a>04218 
<a name="l04219"></a>04219             <span class="keywordflow">switch</span> (protocol) {
<a name="l04220"></a>04220             <span class="keywordflow">case</span> __constant_htons(ETH_P_IP):
<a name="l04221"></a>04221                 tu_cmd |= E1000_ADVTXD_TUCMD_IPV4;
<a name="l04222"></a>04222                 <span class="keywordflow">if</span> (ip_hdr(skb)-&gt;protocol == IPPROTO_TCP)
<a name="l04223"></a>04223                     tu_cmd |= E1000_ADVTXD_TUCMD_L4T_TCP;
<a name="l04224"></a>04224                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ip_hdr(skb)-&gt;protocol == IPPROTO_SCTP)
<a name="l04225"></a>04225                     tu_cmd |= E1000_ADVTXD_TUCMD_L4T_SCTP;
<a name="l04226"></a>04226                 <span class="keywordflow">break</span>;
<a name="l04227"></a>04227 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l04228"></a>04228 <span class="preprocessor"></span>            <span class="keywordflow">case</span> __constant_htons(ETH_P_IPV6):
<a name="l04229"></a>04229                 <span class="comment">/* XXX what about other V6 headers?? */</span>
<a name="l04230"></a>04230                 if (ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_TCP)
<a name="l04231"></a>04231                     tu_cmd |= E1000_ADVTXD_TUCMD_L4T_TCP;
<a name="l04232"></a>04232                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_SCTP)
<a name="l04233"></a>04233                     tu_cmd |= E1000_ADVTXD_TUCMD_L4T_SCTP;
<a name="l04234"></a>04234                 <span class="keywordflow">break</span>;
<a name="l04235"></a>04235 <span class="preprocessor">#endif</span>
<a name="l04236"></a>04236 <span class="preprocessor"></span>            <span class="keywordflow">default</span>:
<a name="l04237"></a>04237                 <span class="keywordflow">if</span> (unlikely(net_ratelimit()))
<a name="l04238"></a>04238                     dev_warn(tx_ring-&gt;dev,
<a name="l04239"></a>04239                         <span class="stringliteral">&quot;partial checksum but proto=%x!\n&quot;</span>,
<a name="l04240"></a>04240                         skb-&gt;protocol);
<a name="l04241"></a>04241                 <span class="keywordflow">break</span>;
<a name="l04242"></a>04242             }
<a name="l04243"></a>04243         }
<a name="l04244"></a>04244 
<a name="l04245"></a>04245         context_desc-&gt;type_tucmd_mlhl = cpu_to_le32(tu_cmd);
<a name="l04246"></a>04246         context_desc-&gt;seqnum_seed = 0;
<a name="l04247"></a>04247         <span class="keywordflow">if</span> (test_bit(IGB_RING_FLAG_TX_CTX_IDX, &amp;tx_ring-&gt;flags))
<a name="l04248"></a>04248             context_desc-&gt;mss_l4len_idx =
<a name="l04249"></a>04249                 cpu_to_le32(tx_ring-&gt;reg_idx &lt;&lt; 4);
<a name="l04250"></a>04250 
<a name="l04251"></a>04251         <span class="keywordflow">return</span> TRUE;
<a name="l04252"></a>04252     }
<a name="l04253"></a>04253     <span class="keywordflow">return</span> FALSE;
<a name="l04254"></a>04254 }
<a name="l04255"></a>04255 
<a name="l04256"></a>04256 <span class="preprocessor">#define IGB_MAX_TXD_PWR 16</span>
<a name="l04257"></a>04257 <span class="preprocessor"></span><span class="preprocessor">#define IGB_MAX_DATA_PER_TXD    (1&lt;&lt;IGB_MAX_TXD_PWR)</span>
<a name="l04258"></a>04258 <span class="preprocessor"></span>
<a name="l04259"></a>04259 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> igb_tx_map(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring, <span class="keyword">struct</span> sk_buff *skb,
<a name="l04260"></a>04260                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first)
<a name="l04261"></a>04261 {
<a name="l04262"></a>04262     <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info;
<a name="l04263"></a>04263     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hlen = skb_headlen(skb);
<a name="l04264"></a>04264     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f;
<a name="l04265"></a>04265     <span class="keywordtype">int</span> count = 0;
<a name="l04266"></a>04266     u16 i = tx_ring-&gt;next_to_use;
<a name="l04267"></a>04267 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l04268"></a>04268 <span class="preprocessor"></span>    u16 gso_segs = skb_shinfo(skb)-&gt;gso_segs ?: 1;
<a name="l04269"></a>04269 <span class="preprocessor">#endif</span>
<a name="l04270"></a>04270 <span class="preprocessor"></span>
<a name="l04271"></a>04271     buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l04272"></a>04272     buffer_info-&gt;length = hlen;
<a name="l04273"></a>04273     <span class="comment">/* set time_stamp *before* dma to help avoid a possible race */</span>
<a name="l04274"></a>04274     buffer_info-&gt;time_stamp = jiffies;
<a name="l04275"></a>04275     buffer_info-&gt;next_to_watch = i;
<a name="l04276"></a>04276     buffer_info-&gt;dma = dma_map_single(tx_ring-&gt;dev, skb-&gt;data, hlen,
<a name="l04277"></a>04277                       DMA_TO_DEVICE);
<a name="l04278"></a>04278     <span class="keywordflow">if</span> (dma_mapping_error(tx_ring-&gt;dev, buffer_info-&gt;dma))
<a name="l04279"></a>04279         <span class="keywordflow">goto</span> dma_error;
<a name="l04280"></a>04280 
<a name="l04281"></a>04281     <span class="keywordflow">for</span> (f = 0; f &lt; skb_shinfo(skb)-&gt;nr_frags; f++) {
<a name="l04282"></a>04282         <span class="keyword">struct </span>skb_frag_struct *frag = &amp;skb_shinfo(skb)-&gt;frags[f];
<a name="l04283"></a>04283         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = frag-&gt;size;
<a name="l04284"></a>04284 
<a name="l04285"></a>04285         count++;
<a name="l04286"></a>04286         i++;
<a name="l04287"></a>04287         <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l04288"></a>04288             i = 0;
<a name="l04289"></a>04289 
<a name="l04290"></a>04290         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l04291"></a>04291         buffer_info-&gt;length = len;
<a name="l04292"></a>04292         buffer_info-&gt;time_stamp = jiffies;
<a name="l04293"></a>04293         buffer_info-&gt;next_to_watch = i;
<a name="l04294"></a>04294         buffer_info-&gt;mapped_as_page = <span class="keyword">true</span>;
<a name="l04295"></a>04295         buffer_info-&gt;dma = dma_map_page(tx_ring-&gt;dev,
<a name="l04296"></a>04296                         frag-&gt;page,
<a name="l04297"></a>04297                         frag-&gt;page_offset,
<a name="l04298"></a>04298                         len,
<a name="l04299"></a>04299                         DMA_TO_DEVICE);
<a name="l04300"></a>04300         <span class="keywordflow">if</span> (dma_mapping_error(tx_ring-&gt;dev, buffer_info-&gt;dma))
<a name="l04301"></a>04301             <span class="keywordflow">goto</span> dma_error;
<a name="l04302"></a>04302     }
<a name="l04303"></a>04303 
<a name="l04304"></a>04304     tx_ring-&gt;buffer_info[i].skb = skb;
<a name="l04305"></a>04305 <span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l04306"></a>04306 <span class="preprocessor"></span><span class="preprocessor">#ifdef SKB_SHARED_TX_IS_UNION</span>
<a name="l04307"></a>04307 <span class="preprocessor"></span>    tx_ring-&gt;buffer_info[i].shtx = skb_shinfo(skb)-&gt;tx_flags.flags;
<a name="l04308"></a>04308 <span class="preprocessor">#else</span>
<a name="l04309"></a>04309 <span class="preprocessor"></span>    tx_ring-&gt;buffer_info[i].shtx = skb_shinfo(skb)-&gt;tx_flags;
<a name="l04310"></a>04310 <span class="preprocessor">#endif</span>
<a name="l04311"></a>04311 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04312"></a>04312 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l04313"></a>04313 <span class="preprocessor"></span>    <span class="comment">/* multiply data chunks by size of headers */</span>
<a name="l04314"></a>04314     tx_ring-&gt;buffer_info[i].bytecount = ((gso_segs - 1) * hlen) + skb-&gt;len;
<a name="l04315"></a>04315     tx_ring-&gt;buffer_info[i].gso_segs = gso_segs;
<a name="l04316"></a>04316 <span class="preprocessor">#else</span>
<a name="l04317"></a>04317 <span class="preprocessor"></span>    tx_ring-&gt;buffer_info[i].bytecount = skb-&gt;len;
<a name="l04318"></a>04318 <span class="preprocessor">#endif</span>
<a name="l04319"></a>04319 <span class="preprocessor"></span>    tx_ring-&gt;buffer_info[first].next_to_watch = i;
<a name="l04320"></a>04320 
<a name="l04321"></a>04321     <span class="keywordflow">return</span> ++count;
<a name="l04322"></a>04322 
<a name="l04323"></a>04323 dma_error:
<a name="l04324"></a>04324     dev_err(tx_ring-&gt;dev, <span class="stringliteral">&quot;TX DMA map failed\n&quot;</span>);
<a name="l04325"></a>04325 
<a name="l04326"></a>04326     <span class="comment">/* clear timestamp and dma mappings for failed buffer_info mapping */</span>
<a name="l04327"></a>04327     memset(buffer_info, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structigb__buffer.html">igb_buffer</a>));
<a name="l04328"></a>04328 
<a name="l04329"></a>04329     <span class="comment">/* clear timestamp and dma mappings for remaining portion of packet */</span>
<a name="l04330"></a>04330     <span class="keywordflow">while</span> (count--) {
<a name="l04331"></a>04331         <span class="keywordflow">if</span> (i == 0)
<a name="l04332"></a>04332             i = tx_ring-&gt;count;
<a name="l04333"></a>04333         i--;
<a name="l04334"></a>04334         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l04335"></a>04335         igb_unmap_and_free_tx_resource(tx_ring, buffer_info);
<a name="l04336"></a>04336     }
<a name="l04337"></a>04337 
<a name="l04338"></a>04338     <span class="keywordflow">return</span> 0;
<a name="l04339"></a>04339 }
<a name="l04340"></a>04340 
<a name="l04341"></a>04341 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> igb_tx_queue(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring,
<a name="l04342"></a>04342                 u32 tx_flags, <span class="keywordtype">int</span> count, u32 paylen,
<a name="l04343"></a>04343                 u8 hdr_len)
<a name="l04344"></a>04344 {
<a name="l04345"></a>04345     <span class="keyword">union </span><a class="code" href="unione1000__adv__tx__desc.html">e1000_adv_tx_desc</a> *tx_desc;
<a name="l04346"></a>04346     u32 olinfo_status = 0, cmd_type_len;
<a name="l04347"></a>04347     u16 i;
<a name="l04348"></a>04348 
<a name="l04349"></a>04349     cmd_type_len = (E1000_ADVTXD_DTYP_DATA | E1000_ADVTXD_DCMD_IFCS |
<a name="l04350"></a>04350             E1000_ADVTXD_DCMD_DEXT);
<a name="l04351"></a>04351 
<a name="l04352"></a>04352     <span class="keywordflow">if</span> (tx_flags &amp; IGB_TX_FLAGS_VLAN)
<a name="l04353"></a>04353         cmd_type_len |= E1000_ADVTXD_DCMD_VLE;
<a name="l04354"></a>04354 
<a name="l04355"></a>04355     <span class="keywordflow">if</span> (tx_flags &amp; IGB_TX_FLAGS_TSTAMP)
<a name="l04356"></a>04356         cmd_type_len |= E1000_ADVTXD_MAC_TSTAMP;
<a name="l04357"></a>04357 
<a name="l04358"></a>04358     <span class="keywordflow">if</span> (tx_flags &amp; IGB_TX_FLAGS_TSO) {
<a name="l04359"></a>04359         cmd_type_len |= E1000_ADVTXD_DCMD_TSE;
<a name="l04360"></a>04360 
<a name="l04361"></a>04361         <span class="comment">/* insert tcp checksum */</span>
<a name="l04362"></a>04362         olinfo_status |= E1000_TXD_POPTS_TXSM &lt;&lt; 8;
<a name="l04363"></a>04363 
<a name="l04364"></a>04364         <span class="comment">/* insert ip checksum */</span>
<a name="l04365"></a>04365         <span class="keywordflow">if</span> (tx_flags &amp; IGB_TX_FLAGS_IPV4)
<a name="l04366"></a>04366             olinfo_status |= E1000_TXD_POPTS_IXSM &lt;&lt; 8;
<a name="l04367"></a>04367 
<a name="l04368"></a>04368     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tx_flags &amp; IGB_TX_FLAGS_CSUM) {
<a name="l04369"></a>04369         olinfo_status |= E1000_TXD_POPTS_TXSM &lt;&lt; 8;
<a name="l04370"></a>04370     }
<a name="l04371"></a>04371 
<a name="l04372"></a>04372     <span class="keywordflow">if</span> (test_bit(IGB_RING_FLAG_TX_CTX_IDX, &amp;tx_ring-&gt;flags) &amp;&amp;
<a name="l04373"></a>04373         (tx_flags &amp; (IGB_TX_FLAGS_CSUM |
<a name="l04374"></a>04374                      IGB_TX_FLAGS_TSO |
<a name="l04375"></a>04375              IGB_TX_FLAGS_VLAN)))
<a name="l04376"></a>04376         olinfo_status |= tx_ring-&gt;reg_idx &lt;&lt; 4;
<a name="l04377"></a>04377 
<a name="l04378"></a>04378     olinfo_status |= ((paylen - hdr_len) &lt;&lt; E1000_ADVTXD_PAYLEN_SHIFT);
<a name="l04379"></a>04379 
<a name="l04380"></a>04380     i = tx_ring-&gt;next_to_use;
<a name="l04381"></a>04381     <span class="keywordflow">do</span> {
<a name="l04382"></a>04382         <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l04383"></a>04383         tx_desc = IGB_TX_DESC(tx_ring, i);
<a name="l04384"></a>04384         tx_desc-&gt;read.buffer_addr = cpu_to_le64(buffer_info-&gt;dma);
<a name="l04385"></a>04385         tx_desc-&gt;read.cmd_type_len =
<a name="l04386"></a>04386             cpu_to_le32(cmd_type_len | buffer_info-&gt;length);
<a name="l04387"></a>04387         tx_desc-&gt;read.olinfo_status = cpu_to_le32(olinfo_status);
<a name="l04388"></a>04388         count--;
<a name="l04389"></a>04389         i++;
<a name="l04390"></a>04390         <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l04391"></a>04391             i = 0;
<a name="l04392"></a>04392     } <span class="keywordflow">while</span> (count &gt; 0);
<a name="l04393"></a>04393     tx_ring-&gt;next_to_use = i;
<a name="l04394"></a>04394 
<a name="l04395"></a>04395     tx_desc-&gt;read.cmd_type_len |= cpu_to_le32(IGB_TXD_DCMD);
<a name="l04396"></a>04396     <span class="comment">/* Force memory writes to complete before letting h/w</span>
<a name="l04397"></a>04397 <span class="comment">     * know there are new descriptors to fetch.  (Only</span>
<a name="l04398"></a>04398 <span class="comment">     * applicable for weak-ordered memory model archs,</span>
<a name="l04399"></a>04399 <span class="comment">     * such as IA-64). */</span>
<a name="l04400"></a>04400     wmb();
<a name="l04401"></a>04401 
<a name="l04402"></a>04402     writel(i, tx_ring-&gt;tail);
<a name="l04403"></a>04403     <span class="comment">/* we need this if more than one processor can write to our tail</span>
<a name="l04404"></a>04404 <span class="comment">     * at a time, it syncronizes IO on IA64/Altix systems */</span>
<a name="l04405"></a>04405     mmiowb();
<a name="l04406"></a>04406 }
<a name="l04407"></a>04407 
<a name="l04408"></a>04408 <span class="keyword">static</span> <span class="keywordtype">int</span> __igb_maybe_stop_tx(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring, <span class="keyword">const</span> u16 size)
<a name="l04409"></a>04409 {
<a name="l04410"></a>04410     <span class="keyword">struct </span>net_device *netdev = netdev_ring(tx_ring);
<a name="l04411"></a>04411 
<a name="l04412"></a>04412     <span class="keywordflow">if</span> (netif_is_multiqueue(netdev))
<a name="l04413"></a>04413         netif_stop_subqueue(netdev, ring_queue_index(tx_ring));
<a name="l04414"></a>04414     <span class="keywordflow">else</span>
<a name="l04415"></a>04415         netif_stop_queue(netdev);
<a name="l04416"></a>04416 
<a name="l04417"></a>04417     <span class="comment">/* Herbert&#39;s original patch had:</span>
<a name="l04418"></a>04418 <span class="comment">     *  smp_mb__after_netif_stop_queue();</span>
<a name="l04419"></a>04419 <span class="comment">     * but since that doesn&#39;t exist yet, just open code it. */</span>
<a name="l04420"></a>04420     smp_mb();
<a name="l04421"></a>04421 
<a name="l04422"></a>04422     <span class="comment">/* We need to check again in a case another CPU has just</span>
<a name="l04423"></a>04423 <span class="comment">     * made room available. */</span>
<a name="l04424"></a>04424     <span class="keywordflow">if</span> (igb_desc_unused(tx_ring) &lt; size)
<a name="l04425"></a>04425         <span class="keywordflow">return</span> -EBUSY;
<a name="l04426"></a>04426 
<a name="l04427"></a>04427     <span class="comment">/* A reprieve! */</span>
<a name="l04428"></a>04428     <span class="keywordflow">if</span> (netif_is_multiqueue(netdev))
<a name="l04429"></a>04429         netif_wake_subqueue(netdev, ring_queue_index(tx_ring));
<a name="l04430"></a>04430     <span class="keywordflow">else</span>
<a name="l04431"></a>04431         netif_wake_queue(netdev);
<a name="l04432"></a>04432 
<a name="l04433"></a>04433     tx_ring-&gt;tx_stats.restart_queue++;
<a name="l04434"></a>04434 
<a name="l04435"></a>04435     <span class="keywordflow">return</span> 0;
<a name="l04436"></a>04436 }
<a name="l04437"></a>04437 
<a name="l04438"></a>04438 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> igb_maybe_stop_tx(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring, <span class="keyword">const</span> u16 size)
<a name="l04439"></a>04439 {
<a name="l04440"></a>04440     <span class="keywordflow">if</span> (igb_desc_unused(tx_ring) &gt;= size)
<a name="l04441"></a>04441         <span class="keywordflow">return</span> 0;
<a name="l04442"></a>04442     <span class="keywordflow">return</span> __igb_maybe_stop_tx(tx_ring, size);
<a name="l04443"></a>04443 }
<a name="l04444"></a>04444 
<a name="l04445"></a>04445 netdev_tx_t igb_xmit_frame_ring(<span class="keyword">struct</span> sk_buff *skb,
<a name="l04446"></a>04446                 <span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring)
<a name="l04447"></a>04447 {
<a name="l04448"></a>04448     <span class="keywordtype">int</span> tso = 0, count;
<a name="l04449"></a>04449     u32 tx_flags = 0;
<a name="l04450"></a>04450     u16 first;
<a name="l04451"></a>04451     u8 hdr_len = 0;
<a name="l04452"></a>04452 
<a name="l04453"></a>04453     <span class="comment">/* need: 1 descriptor per page,</span>
<a name="l04454"></a>04454 <span class="comment">     *       + 2 desc gap to keep tail from touching head,</span>
<a name="l04455"></a>04455 <span class="comment">     *       + 1 desc for skb-&gt;data,</span>
<a name="l04456"></a>04456 <span class="comment">     *       + 1 desc for context descriptor,</span>
<a name="l04457"></a>04457 <span class="comment">     * otherwise try next time */</span>
<a name="l04458"></a>04458     <span class="keywordflow">if</span> (igb_maybe_stop_tx(tx_ring, skb_shinfo(skb)-&gt;nr_frags + 4)) {
<a name="l04459"></a>04459         <span class="comment">/* this is a hard error */</span>
<a name="l04460"></a>04460         <span class="keywordflow">return</span> NETDEV_TX_BUSY;
<a name="l04461"></a>04461     }
<a name="l04462"></a>04462 
<a name="l04463"></a>04463 <span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l04464"></a>04464 <span class="preprocessor"></span><span class="preprocessor">#ifdef SKB_SHARED_TX_IS_UNION</span>
<a name="l04465"></a>04465 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (unlikely(skb_shinfo(skb)-&gt;tx_flags.flags &amp; SKBTX_HW_TSTAMP)) {
<a name="l04466"></a>04466         skb_shinfo(skb)-&gt;tx_flags.flags |= SKBTX_IN_PROGRESS;
<a name="l04467"></a>04467         tx_flags |= IGB_TX_FLAGS_TSTAMP;
<a name="l04468"></a>04468     }
<a name="l04469"></a>04469 <span class="preprocessor">#else</span>
<a name="l04470"></a>04470 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (unlikely(skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_HW_TSTAMP)) {
<a name="l04471"></a>04471         skb_shinfo(skb)-&gt;tx_flags |= SKBTX_IN_PROGRESS;
<a name="l04472"></a>04472         tx_flags |= IGB_TX_FLAGS_TSTAMP;
<a name="l04473"></a>04473     }
<a name="l04474"></a>04474 <span class="preprocessor">#endif</span>
<a name="l04475"></a>04475 <span class="preprocessor"></span>
<a name="l04476"></a>04476 <span class="preprocessor">#endif</span>
<a name="l04477"></a>04477 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (vlan_tx_tag_present(skb)) {
<a name="l04478"></a>04478         tx_flags |= IGB_TX_FLAGS_VLAN;
<a name="l04479"></a>04479         tx_flags |= (vlan_tx_tag_get(skb) &lt;&lt; IGB_TX_FLAGS_VLAN_SHIFT);
<a name="l04480"></a>04480     }
<a name="l04481"></a>04481 
<a name="l04482"></a>04482     <span class="keywordflow">if</span> (skb-&gt;protocol == htons(ETH_P_IP))
<a name="l04483"></a>04483         tx_flags |= IGB_TX_FLAGS_IPV4;
<a name="l04484"></a>04484 
<a name="l04485"></a>04485     first = tx_ring-&gt;next_to_use;
<a name="l04486"></a>04486 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l04487"></a>04487 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (skb_is_gso(skb)) {
<a name="l04488"></a>04488         tso = igb_tso(tx_ring, skb, tx_flags, &amp;hdr_len);
<a name="l04489"></a>04489 
<a name="l04490"></a>04490         <span class="keywordflow">if</span> (tso &lt; 0) {
<a name="l04491"></a>04491             dev_kfree_skb_any(skb);
<a name="l04492"></a>04492             <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l04493"></a>04493         }
<a name="l04494"></a>04494     }
<a name="l04495"></a>04495 
<a name="l04496"></a>04496 <span class="preprocessor">#endif</span>
<a name="l04497"></a>04497 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (tso)
<a name="l04498"></a>04498         tx_flags |= IGB_TX_FLAGS_TSO;
<a name="l04499"></a>04499     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (igb_tx_csum(tx_ring, skb, tx_flags) &amp;&amp;
<a name="l04500"></a>04500              (skb-&gt;ip_summed == CHECKSUM_PARTIAL))
<a name="l04501"></a>04501         tx_flags |= IGB_TX_FLAGS_CSUM;
<a name="l04502"></a>04502 
<a name="l04503"></a>04503     <span class="comment">/*</span>
<a name="l04504"></a>04504 <span class="comment">     * count reflects descriptors mapped, if 0 or less then mapping error</span>
<a name="l04505"></a>04505 <span class="comment">     * has occured and we need to rewind the descriptor queue</span>
<a name="l04506"></a>04506 <span class="comment">     */</span>
<a name="l04507"></a>04507     count = igb_tx_map(tx_ring, skb, first);
<a name="l04508"></a>04508     <span class="keywordflow">if</span> (!count) {
<a name="l04509"></a>04509         dev_kfree_skb_any(skb);
<a name="l04510"></a>04510         tx_ring-&gt;buffer_info[first].time_stamp = 0;
<a name="l04511"></a>04511         tx_ring-&gt;next_to_use = first;
<a name="l04512"></a>04512         <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l04513"></a>04513     }
<a name="l04514"></a>04514 
<a name="l04515"></a>04515     igb_tx_queue(tx_ring, tx_flags, count, skb-&gt;len, hdr_len);
<a name="l04516"></a>04516 
<a name="l04517"></a>04517 <span class="preprocessor">#ifndef HAVE_TRANS_START_IN_QUEUE</span>
<a name="l04518"></a>04518 <span class="preprocessor"></span>    netdev_ring(tx_ring)-&gt;trans_start = jiffies;
<a name="l04519"></a>04519 
<a name="l04520"></a>04520 <span class="preprocessor">#endif</span>
<a name="l04521"></a>04521 <span class="preprocessor"></span>    <span class="comment">/* Make sure there is space in the ring for the next send. */</span>
<a name="l04522"></a>04522     igb_maybe_stop_tx(tx_ring, MAX_SKB_FRAGS + 4);
<a name="l04523"></a>04523 
<a name="l04524"></a>04524     <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l04525"></a>04525 }
<a name="l04526"></a>04526 
<a name="l04527"></a>04527 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l04528"></a>04528 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *igb_tx_queue_mapping(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l04529"></a>04529                                                     <span class="keyword">struct</span> sk_buff *skb)
<a name="l04530"></a>04530 {
<a name="l04531"></a>04531     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r_idx = skb-&gt;queue_mapping &amp; (IGB_MAX_TX_QUEUES - 1);
<a name="l04532"></a>04532 
<a name="l04533"></a>04533     <span class="keywordflow">if</span> (r_idx &gt;= adapter-&gt;num_tx_queues)
<a name="l04534"></a>04534         r_idx = r_idx % adapter-&gt;num_tx_queues;
<a name="l04535"></a>04535 
<a name="l04536"></a>04536     <span class="keywordflow">return</span> adapter-&gt;tx_ring[r_idx];
<a name="l04537"></a>04537 }
<a name="l04538"></a>04538 <span class="preprocessor">#else</span>
<a name="l04539"></a>04539 <span class="preprocessor"></span><span class="preprocessor">#define igb_tx_queue_mapping(_adapter, _skb) (_adapter)-&gt;tx_ring[0]</span>
<a name="l04540"></a>04540 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l04541"></a>04541 <span class="preprocessor"></span>
<a name="l04542"></a>04542 <span class="keyword">static</span> netdev_tx_t igb_xmit_frame(<span class="keyword">struct</span> sk_buff *skb,
<a name="l04543"></a>04543                                       <span class="keyword">struct</span> net_device *netdev)
<a name="l04544"></a>04544 {
<a name="l04545"></a>04545     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04546"></a>04546 
<a name="l04547"></a>04547     <span class="keywordflow">if</span> (test_bit(__IGB_DOWN, &amp;adapter-&gt;state)) {
<a name="l04548"></a>04548         dev_kfree_skb_any(skb);
<a name="l04549"></a>04549         <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l04550"></a>04550     }
<a name="l04551"></a>04551 
<a name="l04552"></a>04552     <span class="keywordflow">if</span> (skb-&gt;len &lt;= 0) {
<a name="l04553"></a>04553         dev_kfree_skb_any(skb);
<a name="l04554"></a>04554         <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l04555"></a>04555     }
<a name="l04556"></a>04556 
<a name="l04557"></a>04557     <span class="comment">/*</span>
<a name="l04558"></a>04558 <span class="comment">     * The minimum packet size with TCTL.PSP set is 17 so pad the skb</span>
<a name="l04559"></a>04559 <span class="comment">     * in order to meet this minimum size requirement.</span>
<a name="l04560"></a>04560 <span class="comment">     */</span>
<a name="l04561"></a>04561     <span class="keywordflow">if</span> (skb-&gt;len &lt; 17) {
<a name="l04562"></a>04562         <span class="keywordflow">if</span> (skb_padto(skb, 17))
<a name="l04563"></a>04563             <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l04564"></a>04564         skb-&gt;len = 17;
<a name="l04565"></a>04565     }
<a name="l04566"></a>04566 
<a name="l04567"></a>04567     <span class="comment">/* This goes back to the question of how to logically map a tx queue</span>
<a name="l04568"></a>04568 <span class="comment">     * to a flow.  Right now, performance is impacted slightly negatively</span>
<a name="l04569"></a>04569 <span class="comment">     * if using multiple tx queues.  If the stack breaks away from a</span>
<a name="l04570"></a>04570 <span class="comment">     * single qdisc implementation, we can look at this again. */</span>
<a name="l04571"></a>04571     <span class="keywordflow">return</span> igb_xmit_frame_ring(skb, igb_tx_queue_mapping(adapter, skb));
<a name="l04572"></a>04572 }
<a name="l04573"></a>04573 
<a name="l04578"></a>04578 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_tx_timeout(<span class="keyword">struct</span> net_device *netdev)
<a name="l04579"></a>04579 {
<a name="l04580"></a>04580     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04581"></a>04581     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04582"></a>04582 
<a name="l04583"></a>04583     <span class="comment">/* Do the reset outside of interrupt context */</span>
<a name="l04584"></a>04584     adapter-&gt;tx_timeout_count++;
<a name="l04585"></a>04585 
<a name="l04586"></a>04586     <span class="keywordflow">if</span> (hw-&gt;mac.type &gt;= e1000_82580)
<a name="l04587"></a>04587         hw-&gt;dev_spec._82575.global_device_reset = <span class="keyword">true</span>;
<a name="l04588"></a>04588 
<a name="l04589"></a>04589     schedule_work(&amp;adapter-&gt;reset_task);
<a name="l04590"></a>04590     E1000_WRITE_REG(hw, E1000_EICS,
<a name="l04591"></a>04591             (adapter-&gt;eims_enable_mask &amp; ~adapter-&gt;eims_other));
<a name="l04592"></a>04592 }
<a name="l04593"></a>04593 
<a name="l04594"></a>04594 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_reset_task(<span class="keyword">struct</span> work_struct *work)
<a name="l04595"></a>04595 {
<a name="l04596"></a>04596     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter;
<a name="l04597"></a>04597     adapter = container_of(work, <span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a>, reset_task);
<a name="l04598"></a>04598 
<a name="l04599"></a>04599     igb_reinit_locked(adapter);
<a name="l04600"></a>04600 }
<a name="l04601"></a>04601 
<a name="l04609"></a>04609 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *igb_get_stats(<span class="keyword">struct</span> net_device *netdev)
<a name="l04610"></a>04610 {
<a name="l04611"></a>04611 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l04612"></a>04612 <span class="preprocessor"></span>    <span class="comment">/* only return the current stats */</span>
<a name="l04613"></a>04613     <span class="keywordflow">return</span> &amp;netdev-&gt;stats;
<a name="l04614"></a>04614 <span class="preprocessor">#else</span>
<a name="l04615"></a>04615 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04616"></a>04616 
<a name="l04617"></a>04617     <span class="comment">/* only return the current stats */</span>
<a name="l04618"></a>04618     <span class="keywordflow">return</span> &amp;adapter-&gt;net_stats;
<a name="l04619"></a>04619 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_STATS_IN_NETDEV */</span>
<a name="l04620"></a>04620 }
<a name="l04621"></a>04621 
<a name="l04629"></a>04629 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_change_mtu(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> new_mtu)
<a name="l04630"></a>04630 {
<a name="l04631"></a>04631     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04632"></a>04632     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l04633"></a>04633     <span class="keywordtype">int</span> max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_TAG_SIZE;
<a name="l04634"></a>04634 <span class="preprocessor">#ifdef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l04635"></a>04635 <span class="preprocessor"></span>    u32 rx_buffer_len, i;
<a name="l04636"></a>04636 <span class="preprocessor">#endif</span>
<a name="l04637"></a>04637 <span class="preprocessor"></span>
<a name="l04638"></a>04638     <span class="keywordflow">if</span> ((new_mtu &lt; 68) || (max_frame &gt; MAX_JUMBO_FRAME_SIZE)) {
<a name="l04639"></a>04639         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Invalid MTU setting\n&quot;</span>);
<a name="l04640"></a>04640         <span class="keywordflow">return</span> -EINVAL;
<a name="l04641"></a>04641     }
<a name="l04642"></a>04642 
<a name="l04643"></a>04643 <span class="preprocessor">#define MAX_STD_JUMBO_FRAME_SIZE 9238</span>
<a name="l04644"></a>04644 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (max_frame &gt; MAX_STD_JUMBO_FRAME_SIZE) {
<a name="l04645"></a>04645         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;MTU &gt; 9216 not supported.\n&quot;</span>);
<a name="l04646"></a>04646         <span class="keywordflow">return</span> -EINVAL;
<a name="l04647"></a>04647     }
<a name="l04648"></a>04648 
<a name="l04649"></a>04649     <span class="keywordflow">while</span> (test_and_set_bit(__IGB_RESETTING, &amp;adapter-&gt;state))
<a name="l04650"></a>04650         msleep(1);
<a name="l04651"></a>04651 
<a name="l04652"></a>04652     <span class="comment">/* igb_down has a dependency on max_frame_size */</span>
<a name="l04653"></a>04653     adapter-&gt;max_frame_size = max_frame;
<a name="l04654"></a>04654 
<a name="l04655"></a>04655 <span class="preprocessor">#ifdef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l04656"></a>04656 <span class="preprocessor"></span><span class="preprocessor">#ifdef IGB_PER_PKT_TIMESTAMP</span>
<a name="l04657"></a>04657 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type &gt;= e1000_82580)
<a name="l04658"></a>04658         max_frame += IGB_TS_HDR_LEN;
<a name="l04659"></a>04659 
<a name="l04660"></a>04660 <span class="preprocessor">#endif</span>
<a name="l04661"></a>04661 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l04662"></a>04662 <span class="comment">     * RLPML prevents us from receiving a frame larger than max_frame so</span>
<a name="l04663"></a>04663 <span class="comment">     * it is safe to just set the rx_buffer_len to max_frame without the</span>
<a name="l04664"></a>04664 <span class="comment">     * risk of an skb over panic.</span>
<a name="l04665"></a>04665 <span class="comment">     */</span>
<a name="l04666"></a>04666     <span class="keywordflow">if</span> (max_frame &lt;= MAXIMUM_ETHERNET_VLAN_SIZE)
<a name="l04667"></a>04667         rx_buffer_len = MAXIMUM_ETHERNET_VLAN_SIZE;
<a name="l04668"></a>04668     <span class="keywordflow">else</span>
<a name="l04669"></a>04669         rx_buffer_len = max_frame;
<a name="l04670"></a>04670 
<a name="l04671"></a>04671 <span class="preprocessor">#endif</span>
<a name="l04672"></a>04672 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l04673"></a>04673         igb_down(adapter);
<a name="l04674"></a>04674 
<a name="l04675"></a>04675     dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;changing MTU from %d to %d\n&quot;</span>,
<a name="l04676"></a>04676             netdev-&gt;mtu, new_mtu);
<a name="l04677"></a>04677     netdev-&gt;mtu = new_mtu;
<a name="l04678"></a>04678 
<a name="l04679"></a>04679 <span class="preprocessor">#ifdef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l04680"></a>04680 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l04681"></a>04681         adapter-&gt;rx_ring[i]-&gt;rx_buffer_len = rx_buffer_len;
<a name="l04682"></a>04682 
<a name="l04683"></a>04683 #endif
<a name="l04684"></a>04684     if (netif_running(netdev))
<a name="l04685"></a>04685         igb_up(adapter);
<a name="l04686"></a>04686     <span class="keywordflow">else</span>
<a name="l04687"></a>04687         igb_reset(adapter);
<a name="l04688"></a>04688 
<a name="l04689"></a>04689     clear_bit(__IGB_RESETTING, &amp;adapter-&gt;state);
<a name="l04690"></a>04690 
<a name="l04691"></a>04691     <span class="keywordflow">return</span> 0;
<a name="l04692"></a>04692 }
<a name="l04693"></a>04693 
<a name="l04699"></a>04699 <span class="keywordtype">void</span> igb_update_stats(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l04700"></a>04700 {
<a name="l04701"></a>04701     <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *net_stats = igb_get_stats(adapter-&gt;netdev);
<a name="l04702"></a>04702     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04703"></a>04703 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l04704"></a>04704 <span class="preprocessor"></span>    <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l04705"></a>04705 <span class="preprocessor">#endif</span>
<a name="l04706"></a>04706 <span class="preprocessor"></span>    u32 reg, mpc;
<a name="l04707"></a>04707     u16 phy_tmp;
<a name="l04708"></a>04708     <span class="keywordtype">int</span> i;
<a name="l04709"></a>04709     u64 bytes, packets;
<a name="l04710"></a>04710 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l04711"></a>04711 <span class="preprocessor"></span>    u32 flushed = 0, coal = 0, recycled = 0;
<a name="l04712"></a>04712     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector;
<a name="l04713"></a>04713 <span class="preprocessor">#endif</span>
<a name="l04714"></a>04714 <span class="preprocessor"></span>
<a name="l04715"></a>04715 <span class="preprocessor">#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF</span>
<a name="l04716"></a>04716 <span class="preprocessor"></span>
<a name="l04717"></a>04717     <span class="comment">/*</span>
<a name="l04718"></a>04718 <span class="comment">     * Prevent stats update while adapter is being reset, or if the pci</span>
<a name="l04719"></a>04719 <span class="comment">     * connection is down.</span>
<a name="l04720"></a>04720 <span class="comment">     */</span>
<a name="l04721"></a>04721     <span class="keywordflow">if</span> (adapter-&gt;link_speed == 0)
<a name="l04722"></a>04722         <span class="keywordflow">return</span>;
<a name="l04723"></a>04723 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l04724"></a>04724 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (pci_channel_offline(pdev))
<a name="l04725"></a>04725         <span class="keywordflow">return</span>;
<a name="l04726"></a>04726 
<a name="l04727"></a>04727 <span class="preprocessor">#endif</span>
<a name="l04728"></a>04728 <span class="preprocessor"></span><span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l04729"></a>04729 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++) {
<a name="l04730"></a>04730         q_vector = adapter-&gt;q_vector[i];
<a name="l04731"></a>04731         <span class="keywordflow">if</span> (!q_vector || !q_vector-&gt;lrolist)
<a name="l04732"></a>04732             <span class="keywordflow">continue</span>;
<a name="l04733"></a>04733         flushed += q_vector-&gt;lrolist-&gt;stats.flushed;
<a name="l04734"></a>04734         coal += q_vector-&gt;lrolist-&gt;stats.coal;
<a name="l04735"></a>04735         recycled += q_vector-&gt;lrolist-&gt;stats.recycled;
<a name="l04736"></a>04736     }
<a name="l04737"></a>04737     adapter-&gt;lro_stats.flushed = flushed;
<a name="l04738"></a>04738     adapter-&gt;lro_stats.coal = coal;
<a name="l04739"></a>04739     adapter-&gt;lro_stats.recycled = recycled;
<a name="l04740"></a>04740 
<a name="l04741"></a>04741 <span class="preprocessor">#endif</span>
<a name="l04742"></a>04742 <span class="preprocessor"></span>    bytes = 0;
<a name="l04743"></a>04743     packets = 0;
<a name="l04744"></a>04744     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l04745"></a>04745         u32 rqdpc_tmp = E1000_READ_REG(hw, E1000_RQDPC(i)) &amp; 0x0FFF;
<a name="l04746"></a>04746         <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *ring = adapter-&gt;rx_ring[i];
<a name="l04747"></a>04747         ring-&gt;rx_stats.drops += rqdpc_tmp;
<a name="l04748"></a>04748         net_stats-&gt;rx_fifo_errors += rqdpc_tmp;
<a name="l04749"></a>04749 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l04750"></a>04750 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!ring-&gt;vmdq_netdev) {
<a name="l04751"></a>04751             bytes += ring-&gt;rx_stats.bytes;
<a name="l04752"></a>04752             packets += ring-&gt;rx_stats.packets;
<a name="l04753"></a>04753         }
<a name="l04754"></a>04754 <span class="preprocessor">#else</span>
<a name="l04755"></a>04755 <span class="preprocessor"></span>        bytes += ring-&gt;rx_stats.bytes;
<a name="l04756"></a>04756         packets += ring-&gt;rx_stats.packets;
<a name="l04757"></a>04757 <span class="preprocessor">#endif</span>
<a name="l04758"></a>04758 <span class="preprocessor"></span>    }
<a name="l04759"></a>04759 
<a name="l04760"></a>04760     net_stats-&gt;rx_bytes = bytes;
<a name="l04761"></a>04761     net_stats-&gt;rx_packets = packets;
<a name="l04762"></a>04762 
<a name="l04763"></a>04763     bytes = 0;
<a name="l04764"></a>04764     packets = 0;
<a name="l04765"></a>04765     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l04766"></a>04766         <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *ring = adapter-&gt;tx_ring[i];
<a name="l04767"></a>04767 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l04768"></a>04768 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!ring-&gt;vmdq_netdev) {
<a name="l04769"></a>04769             bytes += ring-&gt;tx_stats.bytes;
<a name="l04770"></a>04770             packets += ring-&gt;tx_stats.packets;
<a name="l04771"></a>04771         }
<a name="l04772"></a>04772 <span class="preprocessor">#else</span>
<a name="l04773"></a>04773 <span class="preprocessor"></span>        bytes += ring-&gt;tx_stats.bytes;
<a name="l04774"></a>04774         packets += ring-&gt;tx_stats.packets;
<a name="l04775"></a>04775 <span class="preprocessor">#endif</span>
<a name="l04776"></a>04776 <span class="preprocessor"></span>    }
<a name="l04777"></a>04777     net_stats-&gt;tx_bytes = bytes;
<a name="l04778"></a>04778     net_stats-&gt;tx_packets = packets;
<a name="l04779"></a>04779 
<a name="l04780"></a>04780     <span class="comment">/* read stats registers */</span>
<a name="l04781"></a>04781     adapter-&gt;stats.crcerrs += E1000_READ_REG(hw, E1000_CRCERRS);
<a name="l04782"></a>04782     adapter-&gt;stats.gprc += E1000_READ_REG(hw, E1000_GPRC);
<a name="l04783"></a>04783     adapter-&gt;stats.gorc += E1000_READ_REG(hw, E1000_GORCL);
<a name="l04784"></a>04784     E1000_READ_REG(hw, E1000_GORCH); <span class="comment">/* clear GORCL */</span>
<a name="l04785"></a>04785     adapter-&gt;stats.bprc += E1000_READ_REG(hw, E1000_BPRC);
<a name="l04786"></a>04786     adapter-&gt;stats.mprc += E1000_READ_REG(hw, E1000_MPRC);
<a name="l04787"></a>04787     adapter-&gt;stats.roc += E1000_READ_REG(hw, E1000_ROC);
<a name="l04788"></a>04788 
<a name="l04789"></a>04789     adapter-&gt;stats.prc64 += E1000_READ_REG(hw, E1000_PRC64);
<a name="l04790"></a>04790     adapter-&gt;stats.prc127 += E1000_READ_REG(hw, E1000_PRC127);
<a name="l04791"></a>04791     adapter-&gt;stats.prc255 += E1000_READ_REG(hw, E1000_PRC255);
<a name="l04792"></a>04792     adapter-&gt;stats.prc511 += E1000_READ_REG(hw, E1000_PRC511);
<a name="l04793"></a>04793     adapter-&gt;stats.prc1023 += E1000_READ_REG(hw, E1000_PRC1023);
<a name="l04794"></a>04794     adapter-&gt;stats.prc1522 += E1000_READ_REG(hw, E1000_PRC1522);
<a name="l04795"></a>04795     adapter-&gt;stats.symerrs += E1000_READ_REG(hw, E1000_SYMERRS);
<a name="l04796"></a>04796     adapter-&gt;stats.sec += E1000_READ_REG(hw, E1000_SEC);
<a name="l04797"></a>04797 
<a name="l04798"></a>04798     mpc = E1000_READ_REG(hw, E1000_MPC);
<a name="l04799"></a>04799     adapter-&gt;stats.mpc += mpc;
<a name="l04800"></a>04800     net_stats-&gt;rx_fifo_errors += mpc;
<a name="l04801"></a>04801     adapter-&gt;stats.scc += E1000_READ_REG(hw, E1000_SCC);
<a name="l04802"></a>04802     adapter-&gt;stats.ecol += E1000_READ_REG(hw, E1000_ECOL);
<a name="l04803"></a>04803     adapter-&gt;stats.mcc += E1000_READ_REG(hw, E1000_MCC);
<a name="l04804"></a>04804     adapter-&gt;stats.latecol += E1000_READ_REG(hw, E1000_LATECOL);
<a name="l04805"></a>04805     adapter-&gt;stats.dc += E1000_READ_REG(hw, E1000_DC);
<a name="l04806"></a>04806     adapter-&gt;stats.rlec += E1000_READ_REG(hw, E1000_RLEC);
<a name="l04807"></a>04807     adapter-&gt;stats.xonrxc += E1000_READ_REG(hw, E1000_XONRXC);
<a name="l04808"></a>04808     adapter-&gt;stats.xontxc += E1000_READ_REG(hw, E1000_XONTXC);
<a name="l04809"></a>04809     adapter-&gt;stats.xoffrxc += E1000_READ_REG(hw, E1000_XOFFRXC);
<a name="l04810"></a>04810     adapter-&gt;stats.xofftxc += E1000_READ_REG(hw, E1000_XOFFTXC);
<a name="l04811"></a>04811     adapter-&gt;stats.fcruc += E1000_READ_REG(hw, E1000_FCRUC);
<a name="l04812"></a>04812     adapter-&gt;stats.gptc += E1000_READ_REG(hw, E1000_GPTC);
<a name="l04813"></a>04813     adapter-&gt;stats.gotc += E1000_READ_REG(hw, E1000_GOTCL);
<a name="l04814"></a>04814     E1000_READ_REG(hw, E1000_GOTCH); <span class="comment">/* clear GOTCL */</span>
<a name="l04815"></a>04815     adapter-&gt;stats.rnbc += E1000_READ_REG(hw, E1000_RNBC);
<a name="l04816"></a>04816     adapter-&gt;stats.ruc += E1000_READ_REG(hw, E1000_RUC);
<a name="l04817"></a>04817     adapter-&gt;stats.rfc += E1000_READ_REG(hw, E1000_RFC);
<a name="l04818"></a>04818     adapter-&gt;stats.rjc += E1000_READ_REG(hw, E1000_RJC);
<a name="l04819"></a>04819     adapter-&gt;stats.tor += E1000_READ_REG(hw, E1000_TORH);
<a name="l04820"></a>04820     adapter-&gt;stats.tot += E1000_READ_REG(hw, E1000_TOTH);
<a name="l04821"></a>04821     adapter-&gt;stats.tpr += E1000_READ_REG(hw, E1000_TPR);
<a name="l04822"></a>04822 
<a name="l04823"></a>04823     adapter-&gt;stats.ptc64 += E1000_READ_REG(hw, E1000_PTC64);
<a name="l04824"></a>04824     adapter-&gt;stats.ptc127 += E1000_READ_REG(hw, E1000_PTC127);
<a name="l04825"></a>04825     adapter-&gt;stats.ptc255 += E1000_READ_REG(hw, E1000_PTC255);
<a name="l04826"></a>04826     adapter-&gt;stats.ptc511 += E1000_READ_REG(hw, E1000_PTC511);
<a name="l04827"></a>04827     adapter-&gt;stats.ptc1023 += E1000_READ_REG(hw, E1000_PTC1023);
<a name="l04828"></a>04828     adapter-&gt;stats.ptc1522 += E1000_READ_REG(hw, E1000_PTC1522);
<a name="l04829"></a>04829 
<a name="l04830"></a>04830     adapter-&gt;stats.mptc += E1000_READ_REG(hw, E1000_MPTC);
<a name="l04831"></a>04831     adapter-&gt;stats.bptc += E1000_READ_REG(hw, E1000_BPTC);
<a name="l04832"></a>04832 
<a name="l04833"></a>04833     adapter-&gt;stats.tpt += E1000_READ_REG(hw, E1000_TPT);
<a name="l04834"></a>04834     adapter-&gt;stats.colc += E1000_READ_REG(hw, E1000_COLC);
<a name="l04835"></a>04835 
<a name="l04836"></a>04836     adapter-&gt;stats.algnerrc += E1000_READ_REG(hw, E1000_ALGNERRC);
<a name="l04837"></a>04837     <span class="comment">/* read internal phy sepecific stats */</span>
<a name="l04838"></a>04838     reg = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l04839"></a>04839     <span class="keywordflow">if</span> (!(reg &amp; E1000_CTRL_EXT_LINK_MODE_MASK)) {
<a name="l04840"></a>04840         adapter-&gt;stats.rxerrc += E1000_READ_REG(hw, E1000_RXERRC);
<a name="l04841"></a>04841         adapter-&gt;stats.tncrs += E1000_READ_REG(hw, E1000_TNCRS);
<a name="l04842"></a>04842     }
<a name="l04843"></a>04843 
<a name="l04844"></a>04844     adapter-&gt;stats.tsctc += E1000_READ_REG(hw, E1000_TSCTC);
<a name="l04845"></a>04845     adapter-&gt;stats.tsctfc += E1000_READ_REG(hw, E1000_TSCTFC);
<a name="l04846"></a>04846 
<a name="l04847"></a>04847     adapter-&gt;stats.iac += E1000_READ_REG(hw, E1000_IAC);
<a name="l04848"></a>04848     adapter-&gt;stats.icrxoc += E1000_READ_REG(hw, E1000_ICRXOC);
<a name="l04849"></a>04849     adapter-&gt;stats.icrxptc += E1000_READ_REG(hw, E1000_ICRXPTC);
<a name="l04850"></a>04850     adapter-&gt;stats.icrxatc += E1000_READ_REG(hw, E1000_ICRXATC);
<a name="l04851"></a>04851     adapter-&gt;stats.ictxptc += E1000_READ_REG(hw, E1000_ICTXPTC);
<a name="l04852"></a>04852     adapter-&gt;stats.ictxatc += E1000_READ_REG(hw, E1000_ICTXATC);
<a name="l04853"></a>04853     adapter-&gt;stats.ictxqec += E1000_READ_REG(hw, E1000_ICTXQEC);
<a name="l04854"></a>04854     adapter-&gt;stats.ictxqmtc += E1000_READ_REG(hw, E1000_ICTXQMTC);
<a name="l04855"></a>04855     adapter-&gt;stats.icrxdmtc += E1000_READ_REG(hw, E1000_ICRXDMTC);
<a name="l04856"></a>04856 
<a name="l04857"></a>04857     <span class="comment">/* Fill out the OS statistics structure */</span>
<a name="l04858"></a>04858     net_stats-&gt;multicast = adapter-&gt;stats.mprc;
<a name="l04859"></a>04859     net_stats-&gt;collisions = adapter-&gt;stats.colc;
<a name="l04860"></a>04860 
<a name="l04861"></a>04861     <span class="comment">/* Rx Errors */</span>
<a name="l04862"></a>04862 
<a name="l04863"></a>04863     <span class="comment">/* RLEC on some newer hardware can be incorrect so build</span>
<a name="l04864"></a>04864 <span class="comment">     * our own version based on RUC and ROC */</span>
<a name="l04865"></a>04865     net_stats-&gt;rx_errors = adapter-&gt;stats.rxerrc +
<a name="l04866"></a>04866         adapter-&gt;stats.crcerrs + adapter-&gt;stats.algnerrc +
<a name="l04867"></a>04867         adapter-&gt;stats.ruc + adapter-&gt;stats.roc +
<a name="l04868"></a>04868         adapter-&gt;stats.cexterr;
<a name="l04869"></a>04869     net_stats-&gt;rx_length_errors = adapter-&gt;stats.ruc +
<a name="l04870"></a>04870                       adapter-&gt;stats.roc;
<a name="l04871"></a>04871     net_stats-&gt;rx_crc_errors = adapter-&gt;stats.crcerrs;
<a name="l04872"></a>04872     net_stats-&gt;rx_frame_errors = adapter-&gt;stats.algnerrc;
<a name="l04873"></a>04873     net_stats-&gt;rx_missed_errors = adapter-&gt;stats.mpc;
<a name="l04874"></a>04874 
<a name="l04875"></a>04875     <span class="comment">/* Tx Errors */</span>
<a name="l04876"></a>04876     net_stats-&gt;tx_errors = adapter-&gt;stats.ecol +
<a name="l04877"></a>04877                    adapter-&gt;stats.latecol;
<a name="l04878"></a>04878     net_stats-&gt;tx_aborted_errors = adapter-&gt;stats.ecol;
<a name="l04879"></a>04879     net_stats-&gt;tx_window_errors = adapter-&gt;stats.latecol;
<a name="l04880"></a>04880     net_stats-&gt;tx_carrier_errors = adapter-&gt;stats.tncrs;
<a name="l04881"></a>04881 
<a name="l04882"></a>04882     <span class="comment">/* Tx Dropped needs to be maintained elsewhere */</span>
<a name="l04883"></a>04883 
<a name="l04884"></a>04884     <span class="comment">/* Phy Stats */</span>
<a name="l04885"></a>04885     <span class="keywordflow">if</span> (hw-&gt;phy.media_type == e1000_media_type_copper) {
<a name="l04886"></a>04886         <span class="keywordflow">if</span> ((adapter-&gt;link_speed == SPEED_1000) &amp;&amp;
<a name="l04887"></a>04887            (!e1000_read_phy_reg(hw, PHY_1000T_STATUS, &amp;phy_tmp))) {
<a name="l04888"></a>04888             phy_tmp &amp;= PHY_IDLE_ERROR_COUNT_MASK;
<a name="l04889"></a>04889             adapter-&gt;phy_stats.idle_errors += phy_tmp;
<a name="l04890"></a>04890         }
<a name="l04891"></a>04891     }
<a name="l04892"></a>04892 
<a name="l04893"></a>04893     <span class="comment">/* Management Stats */</span>
<a name="l04894"></a>04894     adapter-&gt;stats.mgptc += E1000_READ_REG(hw, E1000_MGTPTC);
<a name="l04895"></a>04895     adapter-&gt;stats.mgprc += E1000_READ_REG(hw, E1000_MGTPRC);
<a name="l04896"></a>04896     adapter-&gt;stats.mgpdc += E1000_READ_REG(hw, E1000_MGTPDC);
<a name="l04897"></a>04897     adapter-&gt;stats.o2bgptc += E1000_READ_REG(hw, E1000_O2BGPTC);
<a name="l04898"></a>04898     adapter-&gt;stats.o2bspc += E1000_READ_REG(hw, E1000_O2BSPC);
<a name="l04899"></a>04899     adapter-&gt;stats.b2ospc += E1000_READ_REG(hw, E1000_B2OSPC);
<a name="l04900"></a>04900     adapter-&gt;stats.b2ogprc += E1000_READ_REG(hw, E1000_B2OGPRC);
<a name="l04901"></a>04901 }
<a name="l04902"></a>04902 
<a name="l04903"></a>04903 <span class="keyword">static</span> irqreturn_t igb_msix_other(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l04904"></a>04904 {
<a name="l04905"></a>04905     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = data;
<a name="l04906"></a>04906     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04907"></a>04907     u32 icr = E1000_READ_REG(hw, E1000_ICR);
<a name="l04908"></a>04908     <span class="comment">/* reading ICR causes bit 31 of EICR to be cleared */</span>
<a name="l04909"></a>04909 
<a name="l04910"></a>04910     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_DRSTA)
<a name="l04911"></a>04911         schedule_work(&amp;adapter-&gt;reset_task);
<a name="l04912"></a>04912 
<a name="l04913"></a>04913     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_DOUTSYNC) {
<a name="l04914"></a>04914         <span class="comment">/* HW is reporting DMA is out of sync */</span>
<a name="l04915"></a>04915         adapter-&gt;stats.doosync++;
<a name="l04916"></a>04916         <span class="comment">/* The DMA Out of Sync is also indication of a spoof event</span>
<a name="l04917"></a>04917 <span class="comment">         * in IOV mode. Check the Wrong VM Behavior register to</span>
<a name="l04918"></a>04918 <span class="comment">         * see if it is really a spoof event. */</span>
<a name="l04919"></a>04919         igb_check_wvbr(adapter);
<a name="l04920"></a>04920     }
<a name="l04921"></a>04921 
<a name="l04922"></a>04922     <span class="comment">/* Check for a mailbox event */</span>
<a name="l04923"></a>04923     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_VMMB)
<a name="l04924"></a>04924         igb_msg_task(adapter);
<a name="l04925"></a>04925 
<a name="l04926"></a>04926     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_LSC) {
<a name="l04927"></a>04927         hw-&gt;mac.get_link_status = 1;
<a name="l04928"></a>04928         <span class="comment">/* guard against interrupt when we&#39;re going down */</span>
<a name="l04929"></a>04929         <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l04930"></a>04930             mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);
<a name="l04931"></a>04931     }
<a name="l04932"></a>04932 
<a name="l04933"></a>04933     E1000_WRITE_REG(hw, E1000_EIMS, adapter-&gt;eims_other);
<a name="l04934"></a>04934 
<a name="l04935"></a>04935     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l04936"></a>04936 }
<a name="l04937"></a>04937 
<a name="l04938"></a>04938 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_write_itr(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector)
<a name="l04939"></a>04939 {
<a name="l04940"></a>04940     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l04941"></a>04941     u32 itr_val = q_vector-&gt;itr_val &amp; 0x7FFC;
<a name="l04942"></a>04942 
<a name="l04943"></a>04943     <span class="keywordflow">if</span> (!q_vector-&gt;set_itr)
<a name="l04944"></a>04944         <span class="keywordflow">return</span>;
<a name="l04945"></a>04945 
<a name="l04946"></a>04946     <span class="keywordflow">if</span> (!itr_val)
<a name="l04947"></a>04947         itr_val = 0x4;
<a name="l04948"></a>04948 
<a name="l04949"></a>04949     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == e1000_82575)
<a name="l04950"></a>04950         itr_val |= itr_val &lt;&lt; 16;
<a name="l04951"></a>04951     <span class="keywordflow">else</span>
<a name="l04952"></a>04952         itr_val |= E1000_EITR_CNT_IGNR;
<a name="l04953"></a>04953 
<a name="l04954"></a>04954     writel(itr_val, q_vector-&gt;itr_register);
<a name="l04955"></a>04955     q_vector-&gt;set_itr = 0;
<a name="l04956"></a>04956 }
<a name="l04957"></a>04957 
<a name="l04958"></a>04958 <span class="keyword">static</span> irqreturn_t igb_msix_ring(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l04959"></a>04959 {
<a name="l04960"></a>04960     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector = data;
<a name="l04961"></a>04961 
<a name="l04962"></a>04962     <span class="comment">/* Write the ITR value calculated from the previous interrupt. */</span>
<a name="l04963"></a>04963     igb_write_itr(q_vector);
<a name="l04964"></a>04964 
<a name="l04965"></a>04965     napi_schedule(&amp;q_vector-&gt;napi);
<a name="l04966"></a>04966 
<a name="l04967"></a>04967     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l04968"></a>04968 }
<a name="l04969"></a>04969 
<a name="l04970"></a>04970 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l04971"></a>04971 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_update_dca(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector)
<a name="l04972"></a>04972 {
<a name="l04973"></a>04973     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l04974"></a>04974     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04975"></a>04975     <span class="keywordtype">int</span> cpu = get_cpu();
<a name="l04976"></a>04976 
<a name="l04977"></a>04977     <span class="keywordflow">if</span> (q_vector-&gt;cpu == cpu)
<a name="l04978"></a>04978         <span class="keywordflow">goto</span> out_no_update;
<a name="l04979"></a>04979 
<a name="l04980"></a>04980     <span class="keywordflow">if</span> (q_vector-&gt;tx_ring) {
<a name="l04981"></a>04981         <span class="keywordtype">int</span> q = q_vector-&gt;tx_ring-&gt;reg_idx;
<a name="l04982"></a>04982         u32 dca_txctrl = E1000_READ_REG(hw, E1000_DCA_TXCTRL(q));
<a name="l04983"></a>04983         <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82575) {
<a name="l04984"></a>04984             dca_txctrl &amp;= ~E1000_DCA_TXCTRL_CPUID_MASK;
<a name="l04985"></a>04985             dca_txctrl |= dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu);
<a name="l04986"></a>04986         } <span class="keywordflow">else</span> {
<a name="l04987"></a>04987             dca_txctrl &amp;= ~E1000_DCA_TXCTRL_CPUID_MASK_82576;
<a name="l04988"></a>04988             dca_txctrl |= dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu) &lt;&lt;
<a name="l04989"></a>04989                           E1000_DCA_TXCTRL_CPUID_SHIFT_82576;
<a name="l04990"></a>04990         }
<a name="l04991"></a>04991         dca_txctrl |= E1000_DCA_TXCTRL_DESC_DCA_EN;
<a name="l04992"></a>04992         E1000_WRITE_REG(hw, E1000_DCA_TXCTRL(q), dca_txctrl);
<a name="l04993"></a>04993     }
<a name="l04994"></a>04994     <span class="keywordflow">if</span> (q_vector-&gt;rx_ring) {
<a name="l04995"></a>04995         <span class="keywordtype">int</span> q = q_vector-&gt;rx_ring-&gt;reg_idx;
<a name="l04996"></a>04996         u32 dca_rxctrl = E1000_READ_REG(hw, E1000_DCA_RXCTRL(q));
<a name="l04997"></a>04997         <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82575) {
<a name="l04998"></a>04998             dca_rxctrl &amp;= ~E1000_DCA_RXCTRL_CPUID_MASK;
<a name="l04999"></a>04999             dca_rxctrl |= dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu);
<a name="l05000"></a>05000         } <span class="keywordflow">else</span> {
<a name="l05001"></a>05001             dca_rxctrl &amp;= ~E1000_DCA_RXCTRL_CPUID_MASK_82576;
<a name="l05002"></a>05002             dca_rxctrl |= dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu) &lt;&lt;
<a name="l05003"></a>05003                           E1000_DCA_RXCTRL_CPUID_SHIFT_82576;
<a name="l05004"></a>05004         }
<a name="l05005"></a>05005         dca_rxctrl |= E1000_DCA_RXCTRL_DESC_DCA_EN;
<a name="l05006"></a>05006         dca_rxctrl |= E1000_DCA_RXCTRL_HEAD_DCA_EN;
<a name="l05007"></a>05007         dca_rxctrl |= E1000_DCA_RXCTRL_DATA_DCA_EN;
<a name="l05008"></a>05008         E1000_WRITE_REG(hw, E1000_DCA_RXCTRL(q), dca_rxctrl);
<a name="l05009"></a>05009     }
<a name="l05010"></a>05010     q_vector-&gt;cpu = cpu;
<a name="l05011"></a>05011 out_no_update:
<a name="l05012"></a>05012     put_cpu();
<a name="l05013"></a>05013 }
<a name="l05014"></a>05014 
<a name="l05015"></a>05015 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_setup_dca(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l05016"></a>05016 {
<a name="l05017"></a>05017     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05018"></a>05018     <span class="keywordtype">int</span> i;
<a name="l05019"></a>05019 
<a name="l05020"></a>05020     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IGB_FLAG_DCA_ENABLED))
<a name="l05021"></a>05021         <span class="keywordflow">return</span>;
<a name="l05022"></a>05022 
<a name="l05023"></a>05023     <span class="comment">/* Always use CB2 mode, difference is masked in the CB driver. */</span>
<a name="l05024"></a>05024     E1000_WRITE_REG(hw, E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_CB2);
<a name="l05025"></a>05025 
<a name="l05026"></a>05026     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++) {
<a name="l05027"></a>05027         adapter-&gt;q_vector[i]-&gt;cpu = -1;
<a name="l05028"></a>05028         igb_update_dca(adapter-&gt;q_vector[i]);
<a name="l05029"></a>05029     }
<a name="l05030"></a>05030 }
<a name="l05031"></a>05031 
<a name="l05032"></a>05032 <span class="keyword">static</span> <span class="keywordtype">int</span> __igb_notify_dca(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev, <span class="keywordtype">void</span> *data)
<a name="l05033"></a>05033 {
<a name="l05034"></a>05034     <span class="keyword">struct </span>net_device *netdev = dev_get_drvdata(dev);
<a name="l05035"></a>05035     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05036"></a>05036     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l05037"></a>05037     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05038"></a>05038     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keyword">event</span> = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)data;
<a name="l05039"></a>05039 
<a name="l05040"></a>05040     <span class="keywordflow">switch</span> (event) {
<a name="l05041"></a>05041     <span class="keywordflow">case</span> DCA_PROVIDER_ADD:
<a name="l05042"></a>05042         <span class="comment">/* if already enabled, don&#39;t do it again */</span>
<a name="l05043"></a>05043         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_DCA_ENABLED)
<a name="l05044"></a>05044             <span class="keywordflow">break</span>;
<a name="l05045"></a>05045         <span class="keywordflow">if</span> (dca_add_requester(dev) == E1000_SUCCESS) {
<a name="l05046"></a>05046             adapter-&gt;flags |= IGB_FLAG_DCA_ENABLED;
<a name="l05047"></a>05047             dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;DCA enabled\n&quot;</span>);
<a name="l05048"></a>05048             igb_setup_dca(adapter);
<a name="l05049"></a>05049             <span class="keywordflow">break</span>;
<a name="l05050"></a>05050         }
<a name="l05051"></a>05051         <span class="comment">/* Fall Through since DCA is disabled. */</span>
<a name="l05052"></a>05052     <span class="keywordflow">case</span> DCA_PROVIDER_REMOVE:
<a name="l05053"></a>05053         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IGB_FLAG_DCA_ENABLED) {
<a name="l05054"></a>05054             <span class="comment">/* without this a class_device is left</span>
<a name="l05055"></a>05055 <span class="comment">             * hanging around in the sysfs model */</span>
<a name="l05056"></a>05056             dca_remove_requester(dev);
<a name="l05057"></a>05057             dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;DCA disabled\n&quot;</span>);
<a name="l05058"></a>05058             adapter-&gt;flags &amp;= ~IGB_FLAG_DCA_ENABLED;
<a name="l05059"></a>05059             E1000_WRITE_REG(hw, E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_DISABLE);
<a name="l05060"></a>05060         }
<a name="l05061"></a>05061         <span class="keywordflow">break</span>;
<a name="l05062"></a>05062     }
<a name="l05063"></a>05063 
<a name="l05064"></a>05064     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l05065"></a>05065 }
<a name="l05066"></a>05066 
<a name="l05067"></a>05067 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_notify_dca(<span class="keyword">struct</span> notifier_block *nb, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l05068"></a>05068                           <span class="keywordtype">void</span> *p)
<a name="l05069"></a>05069 {
<a name="l05070"></a>05070     <span class="keywordtype">int</span> ret_val;
<a name="l05071"></a>05071 
<a name="l05072"></a>05072     ret_val = driver_for_each_device(&amp;igb_driver.driver, NULL, &amp;event,
<a name="l05073"></a>05073                                      __igb_notify_dca);
<a name="l05074"></a>05074 
<a name="l05075"></a>05075     <span class="keywordflow">return</span> ret_val ? NOTIFY_BAD : NOTIFY_DONE;
<a name="l05076"></a>05076 }
<a name="l05077"></a>05077 <span class="preprocessor">#endif </span><span class="comment">/* IGB_DCA */</span>
<a name="l05078"></a>05078 
<a name="l05079"></a>05079 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_ping_all_vfs(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l05080"></a>05080 {
<a name="l05081"></a>05081     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05082"></a>05082     u32 ping;
<a name="l05083"></a>05083     <span class="keywordtype">int</span> i;
<a name="l05084"></a>05084 
<a name="l05085"></a>05085     <span class="keywordflow">for</span> (i = 0 ; i &lt; adapter-&gt;vfs_allocated_count; i++) {
<a name="l05086"></a>05086         ping = E1000_PF_CONTROL_MSG;
<a name="l05087"></a>05087         <span class="keywordflow">if</span> (adapter-&gt;vf_data[i].flags &amp; IGB_VF_FLAG_CTS)
<a name="l05088"></a>05088             ping |= E1000_VT_MSGTYPE_CTS;
<a name="l05089"></a>05089         e1000_write_mbx(hw, &amp;ping, 1, i);
<a name="l05090"></a>05090     }
<a name="l05091"></a>05091 }
<a name="l05092"></a>05092 
<a name="l05103"></a>05103 <span class="keywordtype">void</span> igb_mta_set(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 hash_value)
<a name="l05104"></a>05104 {
<a name="l05105"></a>05105     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05106"></a>05106     u32 hash_bit, hash_reg, mta;
<a name="l05107"></a>05107 
<a name="l05108"></a>05108     <span class="comment">/*</span>
<a name="l05109"></a>05109 <span class="comment">     * The MTA is a register array of 32-bit registers. It is</span>
<a name="l05110"></a>05110 <span class="comment">     * treated like an array of (32*mta_reg_count) bits.  We want to</span>
<a name="l05111"></a>05111 <span class="comment">     * set bit BitArray[hash_value]. So we figure out what register</span>
<a name="l05112"></a>05112 <span class="comment">     * the bit is in, read it, OR in the new bit, then write</span>
<a name="l05113"></a>05113 <span class="comment">     * back the new value.  The (hw-&gt;mac.mta_reg_count - 1) serves as a</span>
<a name="l05114"></a>05114 <span class="comment">     * mask to bits 31:5 of the hash value which gives us the</span>
<a name="l05115"></a>05115 <span class="comment">     * register we&#39;re modifying.  The hash bit within that register</span>
<a name="l05116"></a>05116 <span class="comment">     * is determined by the lower 5 bits of the hash value.</span>
<a name="l05117"></a>05117 <span class="comment">     */</span>
<a name="l05118"></a>05118     hash_reg = (hash_value &gt;&gt; 5) &amp; (hw-&gt;mac.mta_reg_count - 1);
<a name="l05119"></a>05119     hash_bit = hash_value &amp; 0x1F;
<a name="l05120"></a>05120 
<a name="l05121"></a>05121     mta = E1000_READ_REG_ARRAY(hw, E1000_MTA, hash_reg);
<a name="l05122"></a>05122 
<a name="l05123"></a>05123     mta |= (1 &lt;&lt; hash_bit);
<a name="l05124"></a>05124 
<a name="l05125"></a>05125     E1000_WRITE_REG_ARRAY(hw, E1000_MTA, hash_reg, mta);
<a name="l05126"></a>05126     E1000_WRITE_FLUSH(hw);
<a name="l05127"></a>05127 }
<a name="l05128"></a>05128 
<a name="l05129"></a>05129 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_vf_promisc(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 *msgbuf, u32 vf)
<a name="l05130"></a>05130 {
<a name="l05131"></a>05131 
<a name="l05132"></a>05132     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05133"></a>05133     u32 vmolr = E1000_READ_REG(hw, E1000_VMOLR(vf));
<a name="l05134"></a>05134     <span class="keyword">struct </span><a class="code" href="structvf__data__storage.html">vf_data_storage</a> *vf_data = &amp;adapter-&gt;vf_data[vf];
<a name="l05135"></a>05135 
<a name="l05136"></a>05136     vf_data-&gt;flags &amp;= ~(IGB_VF_FLAG_UNI_PROMISC |
<a name="l05137"></a>05137                         IGB_VF_FLAG_MULTI_PROMISC);
<a name="l05138"></a>05138     vmolr &amp;= ~(E1000_VMOLR_ROPE | E1000_VMOLR_ROMPE | E1000_VMOLR_MPME);
<a name="l05139"></a>05139 
<a name="l05140"></a>05140 <span class="preprocessor">#ifdef IGB_ENABLE_VF_PROMISC</span>
<a name="l05141"></a>05141 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (*msgbuf &amp; E1000_VF_SET_PROMISC_UNICAST) {
<a name="l05142"></a>05142         vmolr |= E1000_VMOLR_ROPE;
<a name="l05143"></a>05143         vf_data-&gt;flags |= IGB_VF_FLAG_UNI_PROMISC;
<a name="l05144"></a>05144         *msgbuf &amp;= ~E1000_VF_SET_PROMISC_UNICAST;
<a name="l05145"></a>05145     }
<a name="l05146"></a>05146 <span class="preprocessor">#endif</span>
<a name="l05147"></a>05147 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (*msgbuf &amp; E1000_VF_SET_PROMISC_MULTICAST) {
<a name="l05148"></a>05148         vmolr |= E1000_VMOLR_MPME;
<a name="l05149"></a>05149         vf_data-&gt;flags |= IGB_VF_FLAG_MULTI_PROMISC;
<a name="l05150"></a>05150         *msgbuf &amp;= ~E1000_VF_SET_PROMISC_MULTICAST;
<a name="l05151"></a>05151     } <span class="keywordflow">else</span> {
<a name="l05152"></a>05152         <span class="comment">/*</span>
<a name="l05153"></a>05153 <span class="comment">         * if we have hashes and we are clearing a multicast promisc</span>
<a name="l05154"></a>05154 <span class="comment">         * flag we need to write the hashes to the MTA as this step</span>
<a name="l05155"></a>05155 <span class="comment">         * was previously skipped</span>
<a name="l05156"></a>05156 <span class="comment">         */</span>
<a name="l05157"></a>05157         <span class="keywordflow">if</span> (vf_data-&gt;num_vf_mc_hashes &gt; 30) {
<a name="l05158"></a>05158             vmolr |= E1000_VMOLR_MPME;
<a name="l05159"></a>05159         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vf_data-&gt;num_vf_mc_hashes) {
<a name="l05160"></a>05160             <span class="keywordtype">int</span> j;
<a name="l05161"></a>05161             vmolr |= E1000_VMOLR_ROMPE;
<a name="l05162"></a>05162             <span class="keywordflow">for</span> (j = 0; j &lt; vf_data-&gt;num_vf_mc_hashes; j++)
<a name="l05163"></a>05163                 igb_mta_set(adapter, vf_data-&gt;vf_mc_hashes[j]);
<a name="l05164"></a>05164         }
<a name="l05165"></a>05165     }
<a name="l05166"></a>05166 
<a name="l05167"></a>05167     E1000_WRITE_REG(hw, E1000_VMOLR(vf), vmolr);
<a name="l05168"></a>05168 
<a name="l05169"></a>05169     <span class="comment">/* there are flags left unprocessed, likely not supported */</span>
<a name="l05170"></a>05170     <span class="keywordflow">if</span> (*msgbuf &amp; E1000_VT_MSGINFO_MASK)
<a name="l05171"></a>05171         <span class="keywordflow">return</span> -EINVAL;
<a name="l05172"></a>05172 
<a name="l05173"></a>05173     <span class="keywordflow">return</span> 0;
<a name="l05174"></a>05174 
<a name="l05175"></a>05175 }
<a name="l05176"></a>05176 
<a name="l05177"></a>05177 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_vf_multicasts(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l05178"></a>05178                   u32 *msgbuf, u32 vf)
<a name="l05179"></a>05179 {
<a name="l05180"></a>05180     <span class="keywordtype">int</span> n = (msgbuf[0] &amp; E1000_VT_MSGINFO_MASK) &gt;&gt; E1000_VT_MSGINFO_SHIFT;
<a name="l05181"></a>05181     u16 *hash_list = (u16 *)&amp;msgbuf[1];
<a name="l05182"></a>05182     <span class="keyword">struct </span><a class="code" href="structvf__data__storage.html">vf_data_storage</a> *vf_data = &amp;adapter-&gt;vf_data[vf];
<a name="l05183"></a>05183     <span class="keywordtype">int</span> i;
<a name="l05184"></a>05184 
<a name="l05185"></a>05185     <span class="comment">/* salt away the number of multicast addresses assigned</span>
<a name="l05186"></a>05186 <span class="comment">     * to this VF for later use to restore when the PF multi cast</span>
<a name="l05187"></a>05187 <span class="comment">     * list changes</span>
<a name="l05188"></a>05188 <span class="comment">     */</span>
<a name="l05189"></a>05189     vf_data-&gt;num_vf_mc_hashes = n;
<a name="l05190"></a>05190 
<a name="l05191"></a>05191     <span class="comment">/* only up to 30 hash values supported */</span>
<a name="l05192"></a>05192     <span class="keywordflow">if</span> (n &gt; 30)
<a name="l05193"></a>05193         n = 30;
<a name="l05194"></a>05194 
<a name="l05195"></a>05195     <span class="comment">/* store the hashes for later use */</span>
<a name="l05196"></a>05196     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l05197"></a>05197         vf_data-&gt;vf_mc_hashes[i] = hash_list[i];
<a name="l05198"></a>05198 
<a name="l05199"></a>05199     <span class="comment">/* Flush and reset the mta with the new values */</span>
<a name="l05200"></a>05200     igb_set_rx_mode(adapter-&gt;netdev);
<a name="l05201"></a>05201 
<a name="l05202"></a>05202     <span class="keywordflow">return</span> 0;
<a name="l05203"></a>05203 }
<a name="l05204"></a>05204 
<a name="l05205"></a>05205 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_restore_vf_multicasts(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l05206"></a>05206 {
<a name="l05207"></a>05207     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05208"></a>05208     <span class="keyword">struct </span><a class="code" href="structvf__data__storage.html">vf_data_storage</a> *vf_data;
<a name="l05209"></a>05209     <span class="keywordtype">int</span> i, j;
<a name="l05210"></a>05210 
<a name="l05211"></a>05211     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;vfs_allocated_count; i++) {
<a name="l05212"></a>05212         u32 vmolr = E1000_READ_REG(hw, E1000_VMOLR(i));
<a name="l05213"></a>05213         vmolr &amp;= ~(E1000_VMOLR_ROMPE | E1000_VMOLR_MPME);
<a name="l05214"></a>05214 
<a name="l05215"></a>05215         vf_data = &amp;adapter-&gt;vf_data[i];
<a name="l05216"></a>05216 
<a name="l05217"></a>05217         <span class="keywordflow">if</span> ((vf_data-&gt;num_vf_mc_hashes &gt; 30) ||
<a name="l05218"></a>05218             (vf_data-&gt;flags &amp; IGB_VF_FLAG_MULTI_PROMISC)) {
<a name="l05219"></a>05219             vmolr |= E1000_VMOLR_MPME;
<a name="l05220"></a>05220         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vf_data-&gt;num_vf_mc_hashes) {
<a name="l05221"></a>05221             vmolr |= E1000_VMOLR_ROMPE;
<a name="l05222"></a>05222             <span class="keywordflow">for</span> (j = 0; j &lt; vf_data-&gt;num_vf_mc_hashes; j++)
<a name="l05223"></a>05223                 igb_mta_set(adapter, vf_data-&gt;vf_mc_hashes[j]);
<a name="l05224"></a>05224         }
<a name="l05225"></a>05225         E1000_WRITE_REG(hw, E1000_VMOLR(i), vmolr);
<a name="l05226"></a>05226     }
<a name="l05227"></a>05227 }
<a name="l05228"></a>05228 
<a name="l05229"></a>05229 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clear_vf_vfta(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vf)
<a name="l05230"></a>05230 {
<a name="l05231"></a>05231     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05232"></a>05232     u32 pool_mask, reg, vid;
<a name="l05233"></a>05233     u16 vlan_default;
<a name="l05234"></a>05234     <span class="keywordtype">int</span> i;
<a name="l05235"></a>05235 
<a name="l05236"></a>05236     pool_mask = 1 &lt;&lt; (E1000_VLVF_POOLSEL_SHIFT + vf);
<a name="l05237"></a>05237 
<a name="l05238"></a>05238     <span class="comment">/* Find the vlan filter for this id */</span>
<a name="l05239"></a>05239     <span class="keywordflow">for</span> (i = 0; i &lt; E1000_VLVF_ARRAY_SIZE; i++) {
<a name="l05240"></a>05240         reg = E1000_READ_REG(hw, E1000_VLVF(i));
<a name="l05241"></a>05241 
<a name="l05242"></a>05242         <span class="comment">/* remove the vf from the pool */</span>
<a name="l05243"></a>05243         reg &amp;= ~pool_mask;
<a name="l05244"></a>05244 
<a name="l05245"></a>05245         <span class="comment">/* if pool is empty then remove entry from vfta */</span>
<a name="l05246"></a>05246         <span class="keywordflow">if</span> (!(reg &amp; E1000_VLVF_POOLSEL_MASK) &amp;&amp;
<a name="l05247"></a>05247             (reg &amp; E1000_VLVF_VLANID_ENABLE)) {
<a name="l05248"></a>05248             reg = 0;
<a name="l05249"></a>05249             vid = reg &amp; E1000_VLVF_VLANID_MASK;
<a name="l05250"></a>05250             igb_vfta_set(hw, vid, FALSE);
<a name="l05251"></a>05251         }
<a name="l05252"></a>05252 
<a name="l05253"></a>05253         E1000_WRITE_REG(hw, E1000_VLVF(i), reg);
<a name="l05254"></a>05254     }
<a name="l05255"></a>05255 
<a name="l05256"></a>05256     adapter-&gt;vf_data[vf].vlans_enabled = 0;
<a name="l05257"></a>05257 
<a name="l05258"></a>05258     vlan_default = adapter-&gt;vf_data[vf].default_vf_vlan_id;
<a name="l05259"></a>05259     <span class="keywordflow">if</span> (vlan_default)
<a name="l05260"></a>05260         igb_vlvf_set(adapter, vlan_default, <span class="keyword">true</span>, vf);
<a name="l05261"></a>05261 }
<a name="l05262"></a>05262 
<a name="l05263"></a>05263 s32 igb_vlvf_set(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vid, <span class="keywordtype">bool</span> add, u32 vf)
<a name="l05264"></a>05264 {
<a name="l05265"></a>05265     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05266"></a>05266     u32 reg, i;
<a name="l05267"></a>05267 
<a name="l05268"></a>05268     <span class="comment">/* The vlvf table only exists on 82576 hardware and newer */</span>
<a name="l05269"></a>05269     <span class="keywordflow">if</span> (hw-&gt;mac.type &lt; e1000_82576)
<a name="l05270"></a>05270         <span class="keywordflow">return</span> -1;
<a name="l05271"></a>05271 
<a name="l05272"></a>05272     <span class="comment">/* we only need to do this if VMDq is enabled */</span>
<a name="l05273"></a>05273     <span class="keywordflow">if</span> (!adapter-&gt;vmdq_pools)
<a name="l05274"></a>05274         <span class="keywordflow">return</span> -1;
<a name="l05275"></a>05275 
<a name="l05276"></a>05276     <span class="comment">/* Find the vlan filter for this id */</span>
<a name="l05277"></a>05277     <span class="keywordflow">for</span> (i = 0; i &lt; E1000_VLVF_ARRAY_SIZE; i++) {
<a name="l05278"></a>05278         reg = E1000_READ_REG(hw, E1000_VLVF(i));
<a name="l05279"></a>05279         <span class="keywordflow">if</span> ((reg &amp; E1000_VLVF_VLANID_ENABLE) &amp;&amp;
<a name="l05280"></a>05280             vid == (reg &amp; E1000_VLVF_VLANID_MASK))
<a name="l05281"></a>05281             <span class="keywordflow">break</span>;
<a name="l05282"></a>05282     }
<a name="l05283"></a>05283 
<a name="l05284"></a>05284     <span class="keywordflow">if</span> (add) {
<a name="l05285"></a>05285         <span class="keywordflow">if</span> (i == E1000_VLVF_ARRAY_SIZE) {
<a name="l05286"></a>05286             <span class="comment">/* Did not find a matching VLAN ID entry that was</span>
<a name="l05287"></a>05287 <span class="comment">             * enabled.  Search for a free filter entry, i.e.</span>
<a name="l05288"></a>05288 <span class="comment">             * one without the enable bit set</span>
<a name="l05289"></a>05289 <span class="comment">             */</span>
<a name="l05290"></a>05290             <span class="keywordflow">for</span> (i = 0; i &lt; E1000_VLVF_ARRAY_SIZE; i++) {
<a name="l05291"></a>05291                 reg = E1000_READ_REG(hw, E1000_VLVF(i));
<a name="l05292"></a>05292                 <span class="keywordflow">if</span> (!(reg &amp; E1000_VLVF_VLANID_ENABLE))
<a name="l05293"></a>05293                     <span class="keywordflow">break</span>;
<a name="l05294"></a>05294             }
<a name="l05295"></a>05295         }
<a name="l05296"></a>05296         <span class="keywordflow">if</span> (i &lt; E1000_VLVF_ARRAY_SIZE) {
<a name="l05297"></a>05297             <span class="comment">/* Found an enabled/available entry */</span>
<a name="l05298"></a>05298             reg |= 1 &lt;&lt; (E1000_VLVF_POOLSEL_SHIFT + vf);
<a name="l05299"></a>05299 
<a name="l05300"></a>05300             <span class="comment">/* if !enabled we need to set this up in vfta */</span>
<a name="l05301"></a>05301             <span class="keywordflow">if</span> (!(reg &amp; E1000_VLVF_VLANID_ENABLE)) {
<a name="l05302"></a>05302                 <span class="comment">/* add VID to filter table */</span>
<a name="l05303"></a>05303                 igb_vfta_set(hw, vid, TRUE);
<a name="l05304"></a>05304                 reg |= E1000_VLVF_VLANID_ENABLE;
<a name="l05305"></a>05305             }
<a name="l05306"></a>05306             reg &amp;= ~E1000_VLVF_VLANID_MASK;
<a name="l05307"></a>05307             reg |= vid;
<a name="l05308"></a>05308             E1000_WRITE_REG(hw, E1000_VLVF(i), reg);
<a name="l05309"></a>05309 
<a name="l05310"></a>05310             <span class="comment">/* do not modify RLPML for PF devices */</span>
<a name="l05311"></a>05311             <span class="keywordflow">if</span> (vf &gt;= adapter-&gt;vfs_allocated_count)
<a name="l05312"></a>05312                 <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l05313"></a>05313 
<a name="l05314"></a>05314             <span class="keywordflow">if</span> (!adapter-&gt;vf_data[vf].vlans_enabled) {
<a name="l05315"></a>05315                 u32 size;
<a name="l05316"></a>05316                 reg = E1000_READ_REG(hw, E1000_VMOLR(vf));
<a name="l05317"></a>05317                 size = reg &amp; E1000_VMOLR_RLPML_MASK;
<a name="l05318"></a>05318                 size += 4;
<a name="l05319"></a>05319                 reg &amp;= ~E1000_VMOLR_RLPML_MASK;
<a name="l05320"></a>05320                 reg |= size;
<a name="l05321"></a>05321                 E1000_WRITE_REG(hw, E1000_VMOLR(vf), reg);
<a name="l05322"></a>05322             }
<a name="l05323"></a>05323 
<a name="l05324"></a>05324             adapter-&gt;vf_data[vf].vlans_enabled++;
<a name="l05325"></a>05325             <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l05326"></a>05326         }
<a name="l05327"></a>05327     } <span class="keywordflow">else</span> {
<a name="l05328"></a>05328         <span class="keywordflow">if</span> (i &lt; E1000_VLVF_ARRAY_SIZE) {
<a name="l05329"></a>05329             <span class="comment">/* remove vf from the pool */</span>
<a name="l05330"></a>05330             reg &amp;= ~(1 &lt;&lt; (E1000_VLVF_POOLSEL_SHIFT + vf));
<a name="l05331"></a>05331             <span class="comment">/* if pool is empty then remove entry from vfta */</span>
<a name="l05332"></a>05332             <span class="keywordflow">if</span> (!(reg &amp; E1000_VLVF_POOLSEL_MASK)) {
<a name="l05333"></a>05333                 reg = 0;
<a name="l05334"></a>05334                 igb_vfta_set(hw, vid, FALSE);
<a name="l05335"></a>05335             }
<a name="l05336"></a>05336             E1000_WRITE_REG(hw, E1000_VLVF(i), reg);
<a name="l05337"></a>05337 
<a name="l05338"></a>05338             <span class="comment">/* do not modify RLPML for PF devices */</span>
<a name="l05339"></a>05339             <span class="keywordflow">if</span> (vf &gt;= adapter-&gt;vfs_allocated_count)
<a name="l05340"></a>05340                 <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l05341"></a>05341 
<a name="l05342"></a>05342             adapter-&gt;vf_data[vf].vlans_enabled--;
<a name="l05343"></a>05343             <span class="keywordflow">if</span> (!adapter-&gt;vf_data[vf].vlans_enabled) {
<a name="l05344"></a>05344                 u32 size;
<a name="l05345"></a>05345                 reg = E1000_READ_REG(hw, E1000_VMOLR(vf));
<a name="l05346"></a>05346                 size = reg &amp; E1000_VMOLR_RLPML_MASK;
<a name="l05347"></a>05347                 size -= 4;
<a name="l05348"></a>05348                 reg &amp;= ~E1000_VMOLR_RLPML_MASK;
<a name="l05349"></a>05349                 reg |= size;
<a name="l05350"></a>05350                 E1000_WRITE_REG(hw, E1000_VMOLR(vf), reg);
<a name="l05351"></a>05351             }
<a name="l05352"></a>05352             <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l05353"></a>05353         }
<a name="l05354"></a>05354     }
<a name="l05355"></a>05355     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l05356"></a>05356 }
<a name="l05357"></a>05357 
<a name="l05358"></a>05358 <span class="preprocessor">#ifdef IFLA_VF_MAX</span>
<a name="l05359"></a>05359 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_vmvir(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vid, u32 vf)
<a name="l05360"></a>05360 {
<a name="l05361"></a>05361     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05362"></a>05362 
<a name="l05363"></a>05363     <span class="keywordflow">if</span> (vid)
<a name="l05364"></a>05364         E1000_WRITE_REG(hw, E1000_VMVIR(vf), (vid | E1000_VMVIR_VLANA_DEFAULT));
<a name="l05365"></a>05365     <span class="keywordflow">else</span>
<a name="l05366"></a>05366         E1000_WRITE_REG(hw, E1000_VMVIR(vf), 0);
<a name="l05367"></a>05367 }
<a name="l05368"></a>05368 
<a name="l05369"></a>05369 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_set_vf_vlan(<span class="keyword">struct</span> net_device *netdev,
<a name="l05370"></a>05370                    <span class="keywordtype">int</span> vf, u16 vlan, u8 qos)
<a name="l05371"></a>05371 {
<a name="l05372"></a>05372     <span class="keywordtype">int</span> err = 0;
<a name="l05373"></a>05373     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05374"></a>05374 
<a name="l05375"></a>05375     <span class="comment">/* VLAN IDs accepted range 0-4094 */</span>
<a name="l05376"></a>05376     <span class="keywordflow">if</span> ((vf &gt;= adapter-&gt;vfs_allocated_count) || (vlan &gt; VLAN_VID_MASK-1) || (qos &gt; 7))
<a name="l05377"></a>05377         <span class="keywordflow">return</span> -EINVAL;
<a name="l05378"></a>05378     <span class="keywordflow">if</span> (vlan || qos) {
<a name="l05379"></a>05379         err = igb_vlvf_set(adapter, vlan, !!vlan, vf);
<a name="l05380"></a>05380         <span class="keywordflow">if</span> (err)
<a name="l05381"></a>05381             <span class="keywordflow">goto</span> out;
<a name="l05382"></a>05382         igb_set_vmvir(adapter, vlan | (qos &lt;&lt; VLAN_PRIO_SHIFT), vf);
<a name="l05383"></a>05383         igb_set_vmolr(adapter, vf, !vlan);
<a name="l05384"></a>05384         adapter-&gt;vf_data[vf].pf_vlan = vlan;
<a name="l05385"></a>05385         adapter-&gt;vf_data[vf].pf_qos = qos;
<a name="l05386"></a>05386         igb_set_vf_vlan_strip(adapter, vf, <span class="keyword">true</span>); 
<a name="l05387"></a>05387         dev_info(&amp;adapter-&gt;pdev-&gt;dev,
<a name="l05388"></a>05388              <span class="stringliteral">&quot;Setting VLAN %d, QOS 0x%x on VF %d\n&quot;</span>, vlan, qos, vf);
<a name="l05389"></a>05389         <span class="keywordflow">if</span> (test_bit(__IGB_DOWN, &amp;adapter-&gt;state)) {
<a name="l05390"></a>05390             dev_warn(&amp;adapter-&gt;pdev-&gt;dev,
<a name="l05391"></a>05391                  <span class="stringliteral">&quot;The VF VLAN has been set,&quot;</span>
<a name="l05392"></a>05392                  <span class="stringliteral">&quot; but the PF device is not up.\n&quot;</span>);
<a name="l05393"></a>05393             dev_warn(&amp;adapter-&gt;pdev-&gt;dev,
<a name="l05394"></a>05394                  <span class="stringliteral">&quot;Bring the PF device up before&quot;</span>
<a name="l05395"></a>05395                  <span class="stringliteral">&quot; attempting to use the VF device.\n&quot;</span>);
<a name="l05396"></a>05396         }
<a name="l05397"></a>05397     } <span class="keywordflow">else</span> {
<a name="l05398"></a>05398         igb_vlvf_set(adapter, adapter-&gt;vf_data[vf].pf_vlan,
<a name="l05399"></a>05399                    <span class="keyword">false</span>, vf);
<a name="l05400"></a>05400         igb_set_vmvir(adapter, vlan, vf);
<a name="l05401"></a>05401         igb_set_vmolr(adapter, vf, <span class="keyword">true</span>);
<a name="l05402"></a>05402         igb_set_vf_vlan_strip(adapter, vf, <span class="keyword">false</span>); 
<a name="l05403"></a>05403         adapter-&gt;vf_data[vf].pf_vlan = 0;
<a name="l05404"></a>05404         adapter-&gt;vf_data[vf].pf_qos = 0;
<a name="l05405"></a>05405        }
<a name="l05406"></a>05406 out:
<a name="l05407"></a>05407        <span class="keywordflow">return</span> err;
<a name="l05408"></a>05408 }
<a name="l05409"></a>05409 <span class="preprocessor">#endif</span>
<a name="l05410"></a>05410 <span class="preprocessor"></span>
<a name="l05411"></a>05411 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_vf_vlan(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 *msgbuf, u32 vf)
<a name="l05412"></a>05412 {
<a name="l05413"></a>05413     <span class="keywordtype">int</span> add = (msgbuf[0] &amp; E1000_VT_MSGINFO_MASK) &gt;&gt; E1000_VT_MSGINFO_SHIFT;
<a name="l05414"></a>05414     <span class="keywordtype">int</span> vid = (msgbuf[1] &amp; E1000_VLVF_VLANID_MASK);
<a name="l05415"></a>05415     
<a name="l05416"></a>05416     <span class="keywordflow">if</span> (vid)
<a name="l05417"></a>05417         igb_set_vf_vlan_strip(adapter, vf, <span class="keyword">true</span>); 
<a name="l05418"></a>05418     <span class="keywordflow">else</span>
<a name="l05419"></a>05419         igb_set_vf_vlan_strip(adapter, vf, <span class="keyword">false</span>); 
<a name="l05420"></a>05420     <span class="keywordflow">return</span> igb_vlvf_set(adapter, vid, add, vf);
<a name="l05421"></a>05421 }
<a name="l05422"></a>05422 
<a name="l05423"></a>05423 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> igb_vf_reset(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vf)
<a name="l05424"></a>05424 {
<a name="l05425"></a>05425     <span class="comment">/* clear flags except flag that the PF has set the MAC */</span>
<a name="l05426"></a>05426     adapter-&gt;vf_data[vf].flags &amp;= IGB_VF_FLAG_PF_SET_MAC;
<a name="l05427"></a>05427     adapter-&gt;vf_data[vf].last_nack = jiffies;
<a name="l05428"></a>05428 
<a name="l05429"></a>05429     <span class="comment">/* reset offloads to defaults */</span>
<a name="l05430"></a>05430     igb_set_vmolr(adapter, vf, <span class="keyword">true</span>);
<a name="l05431"></a>05431 
<a name="l05432"></a>05432     <span class="comment">/* reset vlans for device */</span>
<a name="l05433"></a>05433     igb_clear_vf_vfta(adapter, vf);
<a name="l05434"></a>05434 <span class="preprocessor">#ifdef IFLA_VF_MAX</span>
<a name="l05435"></a>05435 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;vf_data[vf].pf_vlan)
<a name="l05436"></a>05436         igb_ndo_set_vf_vlan(adapter-&gt;netdev, vf,
<a name="l05437"></a>05437                     adapter-&gt;vf_data[vf].pf_vlan,
<a name="l05438"></a>05438                     adapter-&gt;vf_data[vf].pf_qos);
<a name="l05439"></a>05439     <span class="keywordflow">else</span>
<a name="l05440"></a>05440         igb_clear_vf_vfta(adapter, vf);
<a name="l05441"></a>05441 <span class="preprocessor">#endif</span>
<a name="l05442"></a>05442 <span class="preprocessor"></span>
<a name="l05443"></a>05443     <span class="comment">/* reset multicast table array for vf */</span>
<a name="l05444"></a>05444     adapter-&gt;vf_data[vf].num_vf_mc_hashes = 0;
<a name="l05445"></a>05445 
<a name="l05446"></a>05446     <span class="comment">/* Flush and reset the mta with the new values */</span>
<a name="l05447"></a>05447     igb_set_rx_mode(adapter-&gt;netdev);
<a name="l05448"></a>05448 }
<a name="l05449"></a>05449 
<a name="l05450"></a>05450 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vf_reset_event(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vf)
<a name="l05451"></a>05451 {
<a name="l05452"></a>05452     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *vf_mac = adapter-&gt;vf_data[vf].vf_mac_addresses;
<a name="l05453"></a>05453 
<a name="l05454"></a>05454     <span class="comment">/* generate a new mac address as we were hotplug removed/added */</span>
<a name="l05455"></a>05455     <span class="keywordflow">if</span> (!(adapter-&gt;vf_data[vf].flags &amp; IGB_VF_FLAG_PF_SET_MAC))
<a name="l05456"></a>05456         random_ether_addr(vf_mac);
<a name="l05457"></a>05457 
<a name="l05458"></a>05458     <span class="comment">/* process remaining reset events */</span>
<a name="l05459"></a>05459     igb_vf_reset(adapter, vf);
<a name="l05460"></a>05460 }
<a name="l05461"></a>05461 
<a name="l05462"></a>05462 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vf_reset_msg(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vf)
<a name="l05463"></a>05463 {
<a name="l05464"></a>05464     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05465"></a>05465     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *vf_mac = adapter-&gt;vf_data[vf].vf_mac_addresses;
<a name="l05466"></a>05466     u32 reg, msgbuf[3];
<a name="l05467"></a>05467     u8 *addr = (u8 *)(&amp;msgbuf[1]);
<a name="l05468"></a>05468 
<a name="l05469"></a>05469     <span class="comment">/* process all the same items cleared in a function level reset */</span>
<a name="l05470"></a>05470     igb_vf_reset(adapter, vf);
<a name="l05471"></a>05471 
<a name="l05472"></a>05472     <span class="comment">/* set vf mac address */</span>
<a name="l05473"></a>05473     igb_del_mac_filter(adapter, vf_mac, vf);
<a name="l05474"></a>05474     igb_add_mac_filter(adapter, vf_mac, vf);
<a name="l05475"></a>05475 
<a name="l05476"></a>05476     <span class="comment">/* enable transmit and receive for vf */</span>
<a name="l05477"></a>05477     reg = E1000_READ_REG(hw, E1000_VFTE);
<a name="l05478"></a>05478     E1000_WRITE_REG(hw, E1000_VFTE, reg | (1 &lt;&lt; vf));
<a name="l05479"></a>05479     reg = E1000_READ_REG(hw, E1000_VFRE);
<a name="l05480"></a>05480     E1000_WRITE_REG(hw, E1000_VFRE, reg | (1 &lt;&lt; vf));
<a name="l05481"></a>05481 
<a name="l05482"></a>05482     adapter-&gt;vf_data[vf].flags |= IGB_VF_FLAG_CTS;
<a name="l05483"></a>05483 
<a name="l05484"></a>05484     <span class="comment">/* reply to reset with ack and vf mac address */</span>
<a name="l05485"></a>05485     msgbuf[0] = E1000_VF_RESET | E1000_VT_MSGTYPE_ACK;
<a name="l05486"></a>05486     memcpy(addr, vf_mac, 6);
<a name="l05487"></a>05487     e1000_write_mbx(hw, msgbuf, 3, vf);
<a name="l05488"></a>05488 }
<a name="l05489"></a>05489 
<a name="l05490"></a>05490 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_vf_mac_addr(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 *msg, <span class="keywordtype">int</span> vf)
<a name="l05491"></a>05491 {
<a name="l05492"></a>05492     <span class="comment">/*</span>
<a name="l05493"></a>05493 <span class="comment">     * The VF MAC Address is stored in a packed array of bytes</span>
<a name="l05494"></a>05494 <span class="comment">     * starting at the second 32 bit word of the msg array</span>
<a name="l05495"></a>05495 <span class="comment">     */</span>
<a name="l05496"></a>05496     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;msg[1];
<a name="l05497"></a>05497     <span class="keywordtype">int</span> err = -1;
<a name="l05498"></a>05498 
<a name="l05499"></a>05499     <span class="keywordflow">if</span> (is_valid_ether_addr(addr))
<a name="l05500"></a>05500         err = igb_set_vf_mac(adapter, vf, addr);
<a name="l05501"></a>05501 
<a name="l05502"></a>05502     <span class="keywordflow">return</span> err;
<a name="l05503"></a>05503 }
<a name="l05504"></a>05504 
<a name="l05505"></a>05505 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_rcv_ack_from_vf(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vf)
<a name="l05506"></a>05506 {
<a name="l05507"></a>05507     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05508"></a>05508     <span class="keyword">struct </span><a class="code" href="structvf__data__storage.html">vf_data_storage</a> *vf_data = &amp;adapter-&gt;vf_data[vf];
<a name="l05509"></a>05509     u32 msg = E1000_VT_MSGTYPE_NACK;
<a name="l05510"></a>05510 
<a name="l05511"></a>05511     <span class="comment">/* if device isn&#39;t clear to send it shouldn&#39;t be reading either */</span>
<a name="l05512"></a>05512     <span class="keywordflow">if</span> (!(vf_data-&gt;flags &amp; IGB_VF_FLAG_CTS) &amp;&amp;
<a name="l05513"></a>05513         time_after(jiffies, vf_data-&gt;last_nack + (2 * HZ))) {
<a name="l05514"></a>05514         e1000_write_mbx(hw, &amp;msg, 1, vf);
<a name="l05515"></a>05515         vf_data-&gt;last_nack = jiffies;
<a name="l05516"></a>05516     }
<a name="l05517"></a>05517 }
<a name="l05518"></a>05518 
<a name="l05519"></a>05519 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_rcv_msg_from_vf(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u32 vf)
<a name="l05520"></a>05520 {
<a name="l05521"></a>05521     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l05522"></a>05522     u32 msgbuf[E1000_VFMAILBOX_SIZE];
<a name="l05523"></a>05523     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05524"></a>05524     <span class="keyword">struct </span><a class="code" href="structvf__data__storage.html">vf_data_storage</a> *vf_data = &amp;adapter-&gt;vf_data[vf];
<a name="l05525"></a>05525     s32 retval;
<a name="l05526"></a>05526 
<a name="l05527"></a>05527     retval = e1000_read_mbx(hw, msgbuf, E1000_VFMAILBOX_SIZE, vf);
<a name="l05528"></a>05528 
<a name="l05529"></a>05529     <span class="keywordflow">if</span> (retval) {
<a name="l05530"></a>05530         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Error receiving message from VF\n&quot;</span>);
<a name="l05531"></a>05531         <span class="keywordflow">return</span>;
<a name="l05532"></a>05532     }
<a name="l05533"></a>05533 
<a name="l05534"></a>05534     <span class="comment">/* this is a message we already processed, do nothing */</span>
<a name="l05535"></a>05535     <span class="keywordflow">if</span> (msgbuf[0] &amp; (E1000_VT_MSGTYPE_ACK | E1000_VT_MSGTYPE_NACK))
<a name="l05536"></a>05536         <span class="keywordflow">return</span>;
<a name="l05537"></a>05537 
<a name="l05538"></a>05538     <span class="comment">/*</span>
<a name="l05539"></a>05539 <span class="comment">     * until the vf completes a reset it should not be</span>
<a name="l05540"></a>05540 <span class="comment">     * allowed to start any configuration.</span>
<a name="l05541"></a>05541 <span class="comment">     */</span>
<a name="l05542"></a>05542 
<a name="l05543"></a>05543     <span class="keywordflow">if</span> (msgbuf[0] == E1000_VF_RESET) {
<a name="l05544"></a>05544         igb_vf_reset_msg(adapter, vf);
<a name="l05545"></a>05545         <span class="keywordflow">return</span>;
<a name="l05546"></a>05546     }
<a name="l05547"></a>05547 
<a name="l05548"></a>05548     <span class="keywordflow">if</span> (!(vf_data-&gt;flags &amp; IGB_VF_FLAG_CTS)) {
<a name="l05549"></a>05549         msgbuf[0] = E1000_VT_MSGTYPE_NACK;
<a name="l05550"></a>05550         <span class="keywordflow">if</span> (time_after(jiffies, vf_data-&gt;last_nack + (2 * HZ))) {
<a name="l05551"></a>05551             e1000_write_mbx(hw, msgbuf, 1, vf);
<a name="l05552"></a>05552             vf_data-&gt;last_nack = jiffies;
<a name="l05553"></a>05553         }
<a name="l05554"></a>05554         <span class="keywordflow">return</span>;
<a name="l05555"></a>05555     }
<a name="l05556"></a>05556 
<a name="l05557"></a>05557     <span class="keywordflow">switch</span> ((msgbuf[0] &amp; 0xFFFF)) {
<a name="l05558"></a>05558     <span class="keywordflow">case</span> E1000_VF_SET_MAC_ADDR:
<a name="l05559"></a>05559         retval = -EINVAL;
<a name="l05560"></a>05560 <span class="preprocessor">#ifndef IGB_DISABLE_VF_MAC_SET</span>
<a name="l05561"></a>05561 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!(vf_data-&gt;flags &amp; IGB_VF_FLAG_PF_SET_MAC))
<a name="l05562"></a>05562             retval = igb_set_vf_mac_addr(adapter, msgbuf, vf);
<a name="l05563"></a>05563         <span class="keywordflow">else</span>
<a name="l05564"></a>05564             DPRINTK(DRV, INFO,
<a name="l05565"></a>05565                 <span class="stringliteral">&quot;VF %d attempted to override administratively &quot;</span>
<a name="l05566"></a>05566                 <span class="stringliteral">&quot;set MAC address\nReload the VF driver to &quot;</span>
<a name="l05567"></a>05567                 <span class="stringliteral">&quot;resume operations\n&quot;</span>, vf);
<a name="l05568"></a>05568 <span class="preprocessor">#endif</span>
<a name="l05569"></a>05569 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
<a name="l05570"></a>05570     <span class="keywordflow">case</span> E1000_VF_SET_PROMISC:
<a name="l05571"></a>05571         retval = igb_set_vf_promisc(adapter, msgbuf, vf);
<a name="l05572"></a>05572         <span class="keywordflow">break</span>;
<a name="l05573"></a>05573     <span class="keywordflow">case</span> E1000_VF_SET_MULTICAST:
<a name="l05574"></a>05574         retval = igb_set_vf_multicasts(adapter, msgbuf, vf);
<a name="l05575"></a>05575         <span class="keywordflow">break</span>;
<a name="l05576"></a>05576     <span class="keywordflow">case</span> E1000_VF_SET_LPE:
<a name="l05577"></a>05577         retval = igb_set_vf_rlpml(adapter, msgbuf[1], vf);
<a name="l05578"></a>05578         <span class="keywordflow">break</span>;
<a name="l05579"></a>05579     <span class="keywordflow">case</span> E1000_VF_SET_VLAN:
<a name="l05580"></a>05580         retval = -1;
<a name="l05581"></a>05581 <span class="preprocessor">#ifdef IFLA_VF_MAX</span>
<a name="l05582"></a>05582 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (vf_data-&gt;pf_vlan)
<a name="l05583"></a>05583             DPRINTK(DRV, INFO,
<a name="l05584"></a>05584                 <span class="stringliteral">&quot;VF %d attempted to override administratively &quot;</span>
<a name="l05585"></a>05585                 <span class="stringliteral">&quot;set VLAN tag\nReload the VF driver to &quot;</span>
<a name="l05586"></a>05586                 <span class="stringliteral">&quot;resume operations\n&quot;</span>, vf);
<a name="l05587"></a>05587         <span class="keywordflow">else</span>
<a name="l05588"></a>05588 <span class="preprocessor">#endif</span>
<a name="l05589"></a>05589 <span class="preprocessor"></span>            retval = igb_set_vf_vlan(adapter, msgbuf, vf);
<a name="l05590"></a>05590         <span class="keywordflow">break</span>;
<a name="l05591"></a>05591     <span class="keywordflow">default</span>:
<a name="l05592"></a>05592         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Unhandled Msg %08x\n&quot;</span>, msgbuf[0]);
<a name="l05593"></a>05593         retval = -E1000_ERR_MBX;
<a name="l05594"></a>05594         <span class="keywordflow">break</span>;
<a name="l05595"></a>05595     }
<a name="l05596"></a>05596 
<a name="l05597"></a>05597     <span class="comment">/* notify the VF of the results of what it sent us */</span>
<a name="l05598"></a>05598     <span class="keywordflow">if</span> (retval)
<a name="l05599"></a>05599         msgbuf[0] |= E1000_VT_MSGTYPE_NACK;
<a name="l05600"></a>05600     <span class="keywordflow">else</span>
<a name="l05601"></a>05601         msgbuf[0] |= E1000_VT_MSGTYPE_ACK;
<a name="l05602"></a>05602 
<a name="l05603"></a>05603     msgbuf[0] |= E1000_VT_MSGTYPE_CTS;
<a name="l05604"></a>05604 
<a name="l05605"></a>05605     e1000_write_mbx(hw, msgbuf, 1, vf);
<a name="l05606"></a>05606 }
<a name="l05607"></a>05607 
<a name="l05608"></a>05608 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_msg_task(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l05609"></a>05609 {
<a name="l05610"></a>05610     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05611"></a>05611     u32 vf;
<a name="l05612"></a>05612 
<a name="l05613"></a>05613     <span class="keywordflow">for</span> (vf = 0; vf &lt; adapter-&gt;vfs_allocated_count; vf++) {
<a name="l05614"></a>05614         <span class="comment">/* process any reset requests */</span>
<a name="l05615"></a>05615         <span class="keywordflow">if</span> (!e1000_check_for_rst(hw, vf))
<a name="l05616"></a>05616             igb_vf_reset_event(adapter, vf);
<a name="l05617"></a>05617 
<a name="l05618"></a>05618         <span class="comment">/* process any messages pending */</span>
<a name="l05619"></a>05619         <span class="keywordflow">if</span> (!e1000_check_for_msg(hw, vf))
<a name="l05620"></a>05620             igb_rcv_msg_from_vf(adapter, vf);
<a name="l05621"></a>05621 
<a name="l05622"></a>05622         <span class="comment">/* process any acks */</span>
<a name="l05623"></a>05623         <span class="keywordflow">if</span> (!e1000_check_for_ack(hw, vf))
<a name="l05624"></a>05624             igb_rcv_ack_from_vf(adapter, vf);
<a name="l05625"></a>05625     }
<a name="l05626"></a>05626 }
<a name="l05627"></a>05627 
<a name="l05638"></a>05638 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_uta(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l05639"></a>05639 {
<a name="l05640"></a>05640     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05641"></a>05641     <span class="keywordtype">int</span> i;
<a name="l05642"></a>05642 
<a name="l05643"></a>05643     <span class="comment">/* The UTA table only exists on 82576 hardware and newer */</span>
<a name="l05644"></a>05644     <span class="keywordflow">if</span> (hw-&gt;mac.type &lt; e1000_82576)
<a name="l05645"></a>05645         <span class="keywordflow">return</span>;
<a name="l05646"></a>05646 
<a name="l05647"></a>05647     <span class="comment">/* we only need to do this if VMDq is enabled */</span>
<a name="l05648"></a>05648     <span class="keywordflow">if</span> (!adapter-&gt;vmdq_pools)
<a name="l05649"></a>05649         <span class="keywordflow">return</span>;
<a name="l05650"></a>05650 
<a name="l05651"></a>05651     <span class="keywordflow">for</span> (i = 0; i &lt; hw-&gt;mac.uta_reg_count; i++)
<a name="l05652"></a>05652         E1000_WRITE_REG_ARRAY(hw, E1000_UTA, i, ~0);
<a name="l05653"></a>05653 }
<a name="l05654"></a>05654 
<a name="l05660"></a>05660 <span class="keyword">static</span> irqreturn_t igb_intr_msi(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l05661"></a>05661 {
<a name="l05662"></a>05662     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = data;
<a name="l05663"></a>05663     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector = adapter-&gt;q_vector[0];
<a name="l05664"></a>05664     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05665"></a>05665     <span class="comment">/* read ICR disables interrupts using IAM */</span>
<a name="l05666"></a>05666     u32 icr = E1000_READ_REG(hw, E1000_ICR);
<a name="l05667"></a>05667 
<a name="l05668"></a>05668     igb_write_itr(q_vector);
<a name="l05669"></a>05669 
<a name="l05670"></a>05670     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_DRSTA)
<a name="l05671"></a>05671         schedule_work(&amp;adapter-&gt;reset_task);
<a name="l05672"></a>05672 
<a name="l05673"></a>05673     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_DOUTSYNC) {
<a name="l05674"></a>05674         <span class="comment">/* HW is reporting DMA is out of sync */</span>
<a name="l05675"></a>05675         adapter-&gt;stats.doosync++;
<a name="l05676"></a>05676     }
<a name="l05677"></a>05677 
<a name="l05678"></a>05678     <span class="keywordflow">if</span> (icr &amp; (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
<a name="l05679"></a>05679         hw-&gt;mac.get_link_status = 1;
<a name="l05680"></a>05680         <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l05681"></a>05681             mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);
<a name="l05682"></a>05682     }
<a name="l05683"></a>05683 
<a name="l05684"></a>05684     napi_schedule(&amp;q_vector-&gt;napi);
<a name="l05685"></a>05685 
<a name="l05686"></a>05686     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l05687"></a>05687 }
<a name="l05688"></a>05688 
<a name="l05694"></a>05694 <span class="keyword">static</span> irqreturn_t igb_intr(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l05695"></a>05695 {
<a name="l05696"></a>05696     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = data;
<a name="l05697"></a>05697     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector = adapter-&gt;q_vector[0];
<a name="l05698"></a>05698     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05699"></a>05699     <span class="comment">/* Interrupt Auto-Mask...upon reading ICR, interrupts are masked.  No</span>
<a name="l05700"></a>05700 <span class="comment">     * need for the IMC write */</span>
<a name="l05701"></a>05701     u32 icr = E1000_READ_REG(hw, E1000_ICR);
<a name="l05702"></a>05702 
<a name="l05703"></a>05703     <span class="comment">/* IMS will not auto-mask if INT_ASSERTED is not set, and if it is</span>
<a name="l05704"></a>05704 <span class="comment">     * not set, then the adapter didn&#39;t send an interrupt */</span>
<a name="l05705"></a>05705     <span class="keywordflow">if</span> (!(icr &amp; E1000_ICR_INT_ASSERTED))
<a name="l05706"></a>05706         <span class="keywordflow">return</span> IRQ_NONE;
<a name="l05707"></a>05707 
<a name="l05708"></a>05708     igb_write_itr(q_vector);
<a name="l05709"></a>05709 
<a name="l05710"></a>05710     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_DRSTA)
<a name="l05711"></a>05711         schedule_work(&amp;adapter-&gt;reset_task);
<a name="l05712"></a>05712 
<a name="l05713"></a>05713     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_DOUTSYNC) {
<a name="l05714"></a>05714         <span class="comment">/* HW is reporting DMA is out of sync */</span>
<a name="l05715"></a>05715         adapter-&gt;stats.doosync++;
<a name="l05716"></a>05716     }
<a name="l05717"></a>05717 
<a name="l05718"></a>05718     <span class="keywordflow">if</span> (icr &amp; (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
<a name="l05719"></a>05719         hw-&gt;mac.get_link_status = 1;
<a name="l05720"></a>05720         <span class="comment">/* guard against interrupt when we&#39;re going down */</span>
<a name="l05721"></a>05721         <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l05722"></a>05722             mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);
<a name="l05723"></a>05723     }
<a name="l05724"></a>05724 
<a name="l05725"></a>05725     napi_schedule(&amp;q_vector-&gt;napi);
<a name="l05726"></a>05726 
<a name="l05727"></a>05727     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l05728"></a>05728 }
<a name="l05729"></a>05729 
<a name="l05730"></a>05730 <span class="keywordtype">void</span> igb_ring_irq_enable(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector)
<a name="l05731"></a>05731 {
<a name="l05732"></a>05732     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l05733"></a>05733     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05734"></a>05734 
<a name="l05735"></a>05735     <span class="keywordflow">if</span> ((q_vector-&gt;rx_ring &amp;&amp; (adapter-&gt;rx_itr_setting &amp; 3)) ||
<a name="l05736"></a>05736         (!q_vector-&gt;rx_ring &amp;&amp; (adapter-&gt;tx_itr_setting &amp; 3))) {
<a name="l05737"></a>05737         <span class="keywordflow">if</span> ((adapter-&gt;num_q_vectors == 1) &amp;&amp; !adapter-&gt;vf_data)
<a name="l05738"></a>05738             igb_set_itr(q_vector);
<a name="l05739"></a>05739         <span class="keywordflow">else</span>
<a name="l05740"></a>05740             igb_update_ring_itr(q_vector);
<a name="l05741"></a>05741     }
<a name="l05742"></a>05742 
<a name="l05743"></a>05743     <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state)) {
<a name="l05744"></a>05744         <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l05745"></a>05745             E1000_WRITE_REG(hw, E1000_EIMS, q_vector-&gt;eims_value);
<a name="l05746"></a>05746         <span class="keywordflow">else</span>
<a name="l05747"></a>05747             igb_irq_enable(adapter);
<a name="l05748"></a>05748     }
<a name="l05749"></a>05749 }
<a name="l05750"></a>05750 
<a name="l05756"></a>05756 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_poll(<span class="keyword">struct</span> napi_struct *napi, <span class="keywordtype">int</span> budget)
<a name="l05757"></a>05757 {
<a name="l05758"></a>05758     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector = container_of(napi, <span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a>, napi);
<a name="l05759"></a>05759     <span class="keywordtype">int</span> tx_clean_complete = 1, work_done = 0;
<a name="l05760"></a>05760 
<a name="l05761"></a>05761 <span class="preprocessor">#ifdef IGB_DCA</span>
<a name="l05762"></a>05762 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (q_vector-&gt;adapter-&gt;flags &amp; IGB_FLAG_DCA_ENABLED)
<a name="l05763"></a>05763         igb_update_dca(q_vector);
<a name="l05764"></a>05764 <span class="preprocessor">#endif</span>
<a name="l05765"></a>05765 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (q_vector-&gt;tx_ring)
<a name="l05766"></a>05766         tx_clean_complete = igb_clean_tx_irq(q_vector, budget);
<a name="l05767"></a>05767 
<a name="l05768"></a>05768     <span class="keywordflow">if</span> (q_vector-&gt;rx_ring)
<a name="l05769"></a>05769         igb_clean_rx_irq(q_vector, &amp;work_done, budget);
<a name="l05770"></a>05770 
<a name="l05771"></a>05771     <span class="keywordflow">if</span> (!tx_clean_complete)
<a name="l05772"></a>05772         work_done = budget;
<a name="l05773"></a>05773 
<a name="l05774"></a>05774 <span class="preprocessor">#ifndef HAVE_NETDEV_NAPI_LIST</span>
<a name="l05775"></a>05775 <span class="preprocessor"></span>    <span class="comment">/* if netdev is disabled we need to stop polling */</span>
<a name="l05776"></a>05776     <span class="keywordflow">if</span> (!netif_running(q_vector-&gt;adapter-&gt;netdev))
<a name="l05777"></a>05777         work_done = 0;
<a name="l05778"></a>05778 
<a name="l05779"></a>05779 <span class="preprocessor">#endif</span>
<a name="l05780"></a>05780 <span class="preprocessor"></span>    <span class="comment">/* If not enough Rx work done, exit the polling mode */</span>
<a name="l05781"></a>05781     <span class="keywordflow">if</span> (work_done &lt; budget) {
<a name="l05782"></a>05782         napi_complete(napi);
<a name="l05783"></a>05783         igb_ring_irq_enable(q_vector);
<a name="l05784"></a>05784     }
<a name="l05785"></a>05785 
<a name="l05786"></a>05786     <span class="keywordflow">return</span> work_done;
<a name="l05787"></a>05787 }
<a name="l05788"></a>05788 
<a name="l05789"></a>05789 <span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l05790"></a>05790 <span class="preprocessor"></span>
<a name="l05799"></a>05799 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_systim_to_hwtstamp(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l05800"></a>05800                                    <span class="keyword">struct</span> skb_shared_hwtstamps *shhwtstamps,
<a name="l05801"></a>05801                                    u64 regval)
<a name="l05802"></a>05802 {
<a name="l05803"></a>05803     u64 ns;
<a name="l05804"></a>05804 
<a name="l05805"></a>05805     <span class="comment">/*</span>
<a name="l05806"></a>05806 <span class="comment">     * The 82580 starts with 1ns at bit 0 in RX/TXSTMPL, shift this up to</span>
<a name="l05807"></a>05807 <span class="comment">     * 24 to match clock shift we setup earlier.</span>
<a name="l05808"></a>05808 <span class="comment">     */</span>
<a name="l05809"></a>05809     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type &gt;= e1000_82580)
<a name="l05810"></a>05810         regval &lt;&lt;= IGB_82580_TSYNC_SHIFT;
<a name="l05811"></a>05811 
<a name="l05812"></a>05812     ns = timecounter_cyc2time(&amp;adapter-&gt;clock, regval);
<a name="l05813"></a>05813     timecompare_update(&amp;adapter-&gt;compare, ns);
<a name="l05814"></a>05814     memset(shhwtstamps, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skb_shared_hwtstamps));
<a name="l05815"></a>05815     shhwtstamps-&gt;hwtstamp = ns_to_ktime(ns);
<a name="l05816"></a>05816     shhwtstamps-&gt;syststamp = timecompare_transform(&amp;adapter-&gt;compare, ns);
<a name="l05817"></a>05817 }
<a name="l05818"></a>05818 
<a name="l05828"></a>05828 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_tx_hwtstamp(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector, <span class="keyword">struct</span> <a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info)
<a name="l05829"></a>05829 {
<a name="l05830"></a>05830     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l05831"></a>05831     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05832"></a>05832     <span class="keyword">struct </span>skb_shared_hwtstamps shhwtstamps;
<a name="l05833"></a>05833     u64 regval;
<a name="l05834"></a>05834 
<a name="l05835"></a>05835     <span class="comment">/* if skb does not support hw timestamp or TX stamp not valid exit */</span>
<a name="l05836"></a>05836     <span class="keywordflow">if</span> (likely(!buffer_info-&gt;shtx &amp; SKBTX_HW_TSTAMP) ||
<a name="l05837"></a>05837         !(E1000_READ_REG(hw, E1000_TSYNCTXCTL) &amp; E1000_TSYNCTXCTL_VALID))
<a name="l05838"></a>05838         <span class="keywordflow">return</span>;
<a name="l05839"></a>05839 
<a name="l05840"></a>05840     regval = E1000_READ_REG(hw, E1000_TXSTMPL);
<a name="l05841"></a>05841     regval |= (u64)E1000_READ_REG(hw, E1000_TXSTMPH) &lt;&lt; 32;
<a name="l05842"></a>05842 
<a name="l05843"></a>05843     igb_systim_to_hwtstamp(adapter, &amp;shhwtstamps, regval);
<a name="l05844"></a>05844     skb_tstamp_tx(buffer_info-&gt;skb, &amp;shhwtstamps);
<a name="l05845"></a>05845 }
<a name="l05846"></a>05846 
<a name="l05847"></a>05847 <span class="preprocessor">#endif</span>
<a name="l05848"></a>05848 <span class="preprocessor"></span>
<a name="l05853"></a>05853 <span class="keyword">static</span> <span class="keywordtype">bool</span> igb_clean_tx_irq(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector, <span class="keywordtype">int</span> budget)
<a name="l05854"></a>05854 {
<a name="l05855"></a>05855     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l05856"></a>05856     <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *tx_ring = q_vector-&gt;tx_ring;
<a name="l05857"></a>05857     <span class="keyword">union </span><a class="code" href="unione1000__adv__tx__desc.html">e1000_adv_tx_desc</a> *eop_desc;
<a name="l05858"></a>05858     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_bytes = 0, total_packets = 0;
<a name="l05859"></a>05859     <span class="keywordtype">int</span> count = 0;
<a name="l05860"></a>05860     u16 i = tx_ring-&gt;next_to_clean;
<a name="l05861"></a>05861     u16 eop = tx_ring-&gt;buffer_info[i].next_to_watch;
<a name="l05862"></a>05862 
<a name="l05863"></a>05863     eop_desc = IGB_TX_DESC(tx_ring, eop);
<a name="l05864"></a>05864 
<a name="l05865"></a>05865     <span class="keywordflow">while</span> (eop_desc-&gt;wb.status &amp; __constant_cpu_to_le32(E1000_TXD_STAT_DD)) {
<a name="l05866"></a>05866         <span class="keywordtype">bool</span> cleaned = <span class="keyword">false</span>;
<a name="l05867"></a>05867         <span class="keywordflow">while</span> (!cleaned) {
<a name="l05868"></a>05868             <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l05869"></a>05869             <span class="keyword">union </span><a class="code" href="unione1000__adv__tx__desc.html">e1000_adv_tx_desc</a> *tx_desc = IGB_TX_DESC(tx_ring, i);
<a name="l05870"></a>05870 
<a name="l05871"></a>05871             tx_desc-&gt;wb.status = 0;
<a name="l05872"></a>05872             cleaned = (i == eop);
<a name="l05873"></a>05873 
<a name="l05874"></a>05874             i++;
<a name="l05875"></a>05875             <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l05876"></a>05876                 i = 0;
<a name="l05877"></a>05877 
<a name="l05878"></a>05878             <span class="keywordflow">if</span> (buffer_info-&gt;skb) {
<a name="l05879"></a>05879                 total_bytes += buffer_info-&gt;bytecount;
<a name="l05880"></a>05880 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l05881"></a>05881 <span class="preprocessor"></span>                <span class="comment">/* gso_segs is currently only valid for tcp */</span>
<a name="l05882"></a>05882                 total_packets += buffer_info-&gt;gso_segs;
<a name="l05883"></a>05883 <span class="preprocessor">#else</span>
<a name="l05884"></a>05884 <span class="preprocessor"></span>                total_packets++;
<a name="l05885"></a>05885 <span class="preprocessor">#endif</span>
<a name="l05886"></a>05886 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l05887"></a>05887 <span class="preprocessor"></span>                igb_tx_hwtstamp(q_vector, buffer_info);
<a name="l05888"></a>05888 <span class="preprocessor">#endif</span>
<a name="l05889"></a>05889 <span class="preprocessor"></span>            }
<a name="l05890"></a>05890 
<a name="l05891"></a>05891             igb_unmap_and_free_tx_resource(tx_ring, buffer_info);
<a name="l05892"></a>05892         }
<a name="l05893"></a>05893         count++;
<a name="l05894"></a>05894         <span class="keywordflow">if</span> (count &gt;= budget)
<a name="l05895"></a>05895             <span class="keywordflow">break</span>;
<a name="l05896"></a>05896         eop = tx_ring-&gt;buffer_info[i].next_to_watch;
<a name="l05897"></a>05897         eop_desc = IGB_TX_DESC(tx_ring, eop);
<a name="l05898"></a>05898     }
<a name="l05899"></a>05899 
<a name="l05900"></a>05900     tx_ring-&gt;next_to_clean = i;
<a name="l05901"></a>05901 
<a name="l05902"></a>05902     <span class="keywordflow">if</span> (unlikely(count &amp;&amp;
<a name="l05903"></a>05903              netif_carrier_ok(netdev_ring(tx_ring)) &amp;&amp;
<a name="l05904"></a>05904              igb_desc_unused(tx_ring) &gt;= IGB_TX_QUEUE_WAKE)) {
<a name="l05905"></a>05905         <span class="comment">/* Make sure that anybody stopping the queue after this</span>
<a name="l05906"></a>05906 <span class="comment">         * sees the new next_to_clean.</span>
<a name="l05907"></a>05907 <span class="comment">         */</span>
<a name="l05908"></a>05908         smp_mb();
<a name="l05909"></a>05909         <span class="keywordflow">if</span> (netif_is_multiqueue(netdev_ring(tx_ring))) {
<a name="l05910"></a>05910             <span class="keywordflow">if</span> (__netif_subqueue_stopped(netdev_ring(tx_ring), ring_queue_index(tx_ring)) &amp;&amp;
<a name="l05911"></a>05911                 !(test_bit(__IGB_DOWN, &amp;adapter-&gt;state))) {
<a name="l05912"></a>05912                 netif_wake_subqueue(netdev_ring(tx_ring), ring_queue_index(tx_ring));
<a name="l05913"></a>05913                 tx_ring-&gt;tx_stats.restart_queue++;
<a name="l05914"></a>05914             }
<a name="l05915"></a>05915         } <span class="keywordflow">else</span> {
<a name="l05916"></a>05916             <span class="keywordflow">if</span> (netif_queue_stopped(netdev_ring(tx_ring)) &amp;&amp;
<a name="l05917"></a>05917                 !(test_bit(__IGB_DOWN, &amp;adapter-&gt;state))) {
<a name="l05918"></a>05918                 netif_wake_queue(netdev_ring(tx_ring));
<a name="l05919"></a>05919                 tx_ring-&gt;tx_stats.restart_queue++;
<a name="l05920"></a>05920             }
<a name="l05921"></a>05921         }
<a name="l05922"></a>05922     }
<a name="l05923"></a>05923 
<a name="l05924"></a>05924     <span class="keywordflow">if</span> (test_bit(IGB_RING_FLAG_TX_DETECT_HANG, &amp;tx_ring-&gt;flags)) {
<a name="l05925"></a>05925         <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05926"></a>05926 
<a name="l05927"></a>05927         <span class="comment">/* Detect a transmit hang in hardware, this serializes the</span>
<a name="l05928"></a>05928 <span class="comment">         * check with the clearing of time_stamp and movement of i */</span>
<a name="l05929"></a>05929         clear_bit(IGB_RING_FLAG_TX_DETECT_HANG, &amp;tx_ring-&gt;flags);
<a name="l05930"></a>05930         <span class="keywordflow">if</span> (tx_ring-&gt;buffer_info[i].time_stamp &amp;&amp;
<a name="l05931"></a>05931             time_after(jiffies, tx_ring-&gt;buffer_info[i].time_stamp +
<a name="l05932"></a>05932                        (adapter-&gt;tx_timeout_factor * HZ))
<a name="l05933"></a>05933             &amp;&amp; !(E1000_READ_REG(hw, E1000_STATUS) &amp;
<a name="l05934"></a>05934                  E1000_STATUS_TXOFF)) {
<a name="l05935"></a>05935 
<a name="l05936"></a>05936             <span class="comment">/* detected Tx unit hang */</span>
<a name="l05937"></a>05937             dev_err(tx_ring-&gt;dev,
<a name="l05938"></a>05938                 <span class="stringliteral">&quot;Detected Tx Unit Hang\n&quot;</span>
<a name="l05939"></a>05939                 <span class="stringliteral">&quot;  Tx Queue             &lt;%d&gt;\n&quot;</span>
<a name="l05940"></a>05940                 <span class="stringliteral">&quot;  TDH                  &lt;%x&gt;\n&quot;</span>
<a name="l05941"></a>05941                 <span class="stringliteral">&quot;  TDT                  &lt;%x&gt;\n&quot;</span>
<a name="l05942"></a>05942                 <span class="stringliteral">&quot;  next_to_use          &lt;%x&gt;\n&quot;</span>
<a name="l05943"></a>05943                 <span class="stringliteral">&quot;  next_to_clean        &lt;%x&gt;\n&quot;</span>
<a name="l05944"></a>05944                 <span class="stringliteral">&quot;buffer_info[next_to_clean]\n&quot;</span>
<a name="l05945"></a>05945                 <span class="stringliteral">&quot;  time_stamp           &lt;%lx&gt;\n&quot;</span>
<a name="l05946"></a>05946                 <span class="stringliteral">&quot;  next_to_watch        &lt;%x&gt;\n&quot;</span>
<a name="l05947"></a>05947                 <span class="stringliteral">&quot;  jiffies              &lt;%lx&gt;\n&quot;</span>
<a name="l05948"></a>05948                 <span class="stringliteral">&quot;  desc.status          &lt;%x&gt;\n&quot;</span>,
<a name="l05949"></a>05949                 tx_ring-&gt;queue_index,
<a name="l05950"></a>05950                 E1000_READ_REG(hw, E1000_TDH(tx_ring-&gt;reg_idx)),
<a name="l05951"></a>05951                 readl(tx_ring-&gt;tail),
<a name="l05952"></a>05952                 tx_ring-&gt;next_to_use,
<a name="l05953"></a>05953                 tx_ring-&gt;next_to_clean,
<a name="l05954"></a>05954                 tx_ring-&gt;buffer_info[eop].time_stamp,
<a name="l05955"></a>05955                 eop,
<a name="l05956"></a>05956                 jiffies,
<a name="l05957"></a>05957                 eop_desc-&gt;wb.status);
<a name="l05958"></a>05958             <span class="keywordflow">if</span> (netif_is_multiqueue(netdev_ring(tx_ring)))
<a name="l05959"></a>05959                 netif_stop_subqueue(netdev_ring(tx_ring),
<a name="l05960"></a>05960                             ring_queue_index(tx_ring));
<a name="l05961"></a>05961             <span class="keywordflow">else</span>
<a name="l05962"></a>05962                 netif_stop_queue(netdev_ring(tx_ring));
<a name="l05963"></a>05963         }
<a name="l05964"></a>05964     }
<a name="l05965"></a>05965     tx_ring-&gt;total_bytes += total_bytes;
<a name="l05966"></a>05966     tx_ring-&gt;total_packets += total_packets;
<a name="l05967"></a>05967     tx_ring-&gt;tx_stats.bytes += total_bytes;
<a name="l05968"></a>05968     tx_ring-&gt;tx_stats.packets += total_packets;
<a name="l05969"></a>05969     <span class="keywordflow">return</span> (count &lt; budget);
<a name="l05970"></a>05970 }
<a name="l05971"></a>05971 
<a name="l05978"></a>05978 <span class="keyword">static</span>
<a name="l05979"></a>05979 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l05980"></a>05980 <span class="preprocessor"></span><span class="keywordtype">int</span>
<a name="l05981"></a>05981 <span class="preprocessor">#else</span>
<a name="l05982"></a>05982 <span class="preprocessor"></span><span class="keywordtype">void</span>
<a name="l05983"></a>05983 <span class="preprocessor">#endif</span>
<a name="l05984"></a>05984 <span class="preprocessor"></span>igb_receive_skb(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector,
<a name="l05985"></a>05985                             <span class="keyword">struct</span> sk_buff *skb,
<a name="l05986"></a>05986                             u16 <a class="code" href="structvlan__tag.html">vlan_tag</a>)
<a name="l05987"></a>05987 {
<a name="l05988"></a>05988     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l05989"></a>05989     <span class="keyword">struct </span>vlan_group *vlgrp = adapter-&gt;vlgrp;
<a name="l05990"></a>05990 
<a name="l05991"></a>05991 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l05992"></a>05992 <span class="preprocessor"></span>        {
<a name="l05993"></a>05993           <span class="keywordtype">int</span> debug = 0;
<a name="l05994"></a>05994           <span class="keyword">struct </span>pfring_hooks *hook = (<span class="keyword">struct </span>pfring_hooks*)skb-&gt;dev-&gt;pfring_ptr;
<a name="l05995"></a>05995 
<a name="l05996"></a>05996           <span class="keywordflow">if</span>(hook &amp;&amp; (hook-&gt;magic == PF_RING)) {
<a name="l05997"></a>05997             <span class="comment">/* Wow: PF_RING is alive &amp; kickin&#39; ! */</span>
<a name="l05998"></a>05998             <span class="keywordtype">int</span> rc;
<a name="l05999"></a>05999 
<a name="l06000"></a>06000             <span class="keywordflow">if</span>(debug)
<a name="l06001"></a>06001               printk(KERN_INFO <span class="stringliteral">&quot;[PF_RING] alive [%s][len=%d]\n&quot;</span>,
<a name="l06002"></a>06002                      skb-&gt;dev-&gt;name, skb-&gt;len);
<a name="l06003"></a>06003 
<a name="l06004"></a>06004             <span class="comment">// printk(KERN_INFO &quot;[PF_RING] queue_index=%d\n&quot;, ring-&gt;queue_index);                                                                                        </span>
<a name="l06005"></a>06005 
<a name="l06006"></a>06006             <span class="keywordflow">if</span>(*hook-&gt;transparent_mode != standard_linux_path) {
<a name="l06007"></a>06007               rc = hook-&gt;ring_handler(skb, 1, 1, q_vector-&gt;rx_ring-&gt;queue_index, adapter-&gt;num_rx_queues);
<a name="l06008"></a>06008 
<a name="l06009"></a>06009               <span class="keywordflow">if</span>(rc &gt; 0 <span class="comment">/* Packet handled by PF_RING */</span>) {
<a name="l06010"></a>06010                 <span class="keywordflow">if</span>(*hook-&gt;transparent_mode == driver2pf_ring_non_transparent) {
<a name="l06011"></a>06011                   <span class="comment">/* PF_RING has already freed the memory */</span>
<a name="l06012"></a>06012                   <span class="keywordflow">return</span>(rc);
<a name="l06013"></a>06013                 }
<a name="l06014"></a>06014               }
<a name="l06015"></a>06015             } <span class="keywordflow">else</span> {
<a name="l06016"></a>06016               <span class="keywordflow">if</span>(debug) printk(KERN_INFO <span class="stringliteral">&quot;[PF_RING] not present on %s\n&quot;</span>,
<a name="l06017"></a>06017                                skb-&gt;dev-&gt;name);
<a name="l06018"></a>06018             }
<a name="l06019"></a>06019           }
<a name="l06020"></a>06020         }
<a name="l06021"></a>06021 <span class="preprocessor">#endif</span>
<a name="l06022"></a>06022 <span class="preprocessor"></span>
<a name="l06023"></a>06023 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l06024"></a>06024 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (q_vector-&gt;rx_ring-&gt;vmdq_netdev) {
<a name="l06025"></a>06025         <span class="keyword">struct </span>igb_vmdq_adapter *vadapt;
<a name="l06026"></a>06026         vadapt = netdev_priv(q_vector-&gt;rx_ring-&gt;vmdq_netdev);
<a name="l06027"></a>06027         vlgrp = vadapt-&gt;vlgrp;
<a name="l06028"></a>06028     }
<a name="l06029"></a>06029 <span class="preprocessor">#endif</span>
<a name="l06030"></a>06030 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (vlan_tag &amp;&amp; vlgrp)
<a name="l06031"></a>06031         vlan_gro_receive(&amp;q_vector-&gt;napi, vlgrp,
<a name="l06032"></a>06032                          vlan_tag, skb);
<a name="l06033"></a>06033     <span class="keywordflow">else</span>
<a name="l06034"></a>06034         napi_gro_receive(&amp;q_vector-&gt;napi, skb);
<a name="l06035"></a>06035 
<a name="l06036"></a>06036 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l06037"></a>06037 <span class="preprocessor"></span>        <span class="keywordflow">return</span>(0);
<a name="l06038"></a>06038 <span class="preprocessor">#endif</span>
<a name="l06039"></a>06039 <span class="preprocessor"></span>}
<a name="l06040"></a>06040 
<a name="l06041"></a>06041 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> igb_rx_checksum(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *ring,
<a name="l06042"></a>06042                                    u32 status_err, <span class="keyword">struct</span> sk_buff *skb)
<a name="l06043"></a>06043 {
<a name="l06044"></a>06044     <span class="comment">/* Ignore Checksum bit is set or checksum is disabled through ethtool */</span>
<a name="l06045"></a>06045     <span class="keywordflow">if</span> (!test_bit(IGB_RING_FLAG_RX_CSUM, &amp;ring-&gt;flags) ||
<a name="l06046"></a>06046          (status_err &amp; E1000_RXD_STAT_IXSM))
<a name="l06047"></a>06047         <span class="keywordflow">return</span>;
<a name="l06048"></a>06048 
<a name="l06049"></a>06049     <span class="comment">/* TCP/UDP checksum error bit is set */</span>
<a name="l06050"></a>06050     <span class="keywordflow">if</span> (status_err &amp;
<a name="l06051"></a>06051         (E1000_RXDEXT_STATERR_TCPE | E1000_RXDEXT_STATERR_IPE)) {
<a name="l06052"></a>06052         <span class="comment">/*</span>
<a name="l06053"></a>06053 <span class="comment">         * work around errata with sctp packets where the TCPE aka</span>
<a name="l06054"></a>06054 <span class="comment">         * L4E bit is set incorrectly on 64 byte (60 byte w/o crc)</span>
<a name="l06055"></a>06055 <span class="comment">         * packets, (aka let the stack check the crc32c)</span>
<a name="l06056"></a>06056 <span class="comment">         */</span>
<a name="l06057"></a>06057         <span class="keywordflow">if</span> (!((skb-&gt;len == 60) &amp;&amp;
<a name="l06058"></a>06058               test_bit(IGB_RING_FLAG_RX_SCTP_CSUM, &amp;ring-&gt;flags)))
<a name="l06059"></a>06059             ring-&gt;rx_stats.csum_err++;
<a name="l06060"></a>06060 
<a name="l06061"></a>06061         <span class="comment">/* let the stack verify checksum errors */</span>
<a name="l06062"></a>06062         <span class="keywordflow">return</span>;
<a name="l06063"></a>06063     }
<a name="l06064"></a>06064     <span class="comment">/* It must be a TCP or UDP packet with a valid checksum */</span>
<a name="l06065"></a>06065     <span class="keywordflow">if</span> (status_err &amp; (E1000_RXD_STAT_TCPCS | E1000_RXD_STAT_UDPCS))
<a name="l06066"></a>06066         skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<a name="l06067"></a>06067 }
<a name="l06068"></a>06068 
<a name="l06069"></a>06069 <span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l06070"></a>06070 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_rx_hwtstamp(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector, u32 staterr,
<a name="l06071"></a>06071                                    <span class="keyword">struct</span> sk_buff *skb)
<a name="l06072"></a>06072 {
<a name="l06073"></a>06073     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l06074"></a>06074     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06075"></a>06075     u64 regval;
<a name="l06076"></a>06076 
<a name="l06077"></a>06077     <span class="comment">/*</span>
<a name="l06078"></a>06078 <span class="comment">     * If this bit is set, then the RX registers contain the time stamp. No</span>
<a name="l06079"></a>06079 <span class="comment">     * other packet will be time stamped until we read these registers, so</span>
<a name="l06080"></a>06080 <span class="comment">     * read the registers to make them available again. Because only one</span>
<a name="l06081"></a>06081 <span class="comment">     * packet can be time stamped at a time, we know that the register</span>
<a name="l06082"></a>06082 <span class="comment">     * values must belong to this one here and therefore we don&#39;t need to</span>
<a name="l06083"></a>06083 <span class="comment">     * compare any of the additional attributes stored for it.</span>
<a name="l06084"></a>06084 <span class="comment">     *</span>
<a name="l06085"></a>06085 <span class="comment">     * If nothing went wrong, then it should have a skb_shared_tx that we</span>
<a name="l06086"></a>06086 <span class="comment">     * can turn into a skb_shared_hwtstamps.</span>
<a name="l06087"></a>06087 <span class="comment">     */</span>
<a name="l06088"></a>06088     <span class="keywordflow">if</span> (staterr &amp; E1000_RXDADV_STAT_TSIP) {
<a name="l06089"></a>06089         u32 *stamp = (u32 *)skb-&gt;data;
<a name="l06090"></a>06090         regval = le32_to_cpu(*(stamp + 2));
<a name="l06091"></a>06091         regval |= (u64)le32_to_cpu(*(stamp + 3)) &lt;&lt; 32;
<a name="l06092"></a>06092         skb_pull(skb, IGB_TS_HDR_LEN);
<a name="l06093"></a>06093     } <span class="keywordflow">else</span> {
<a name="l06094"></a>06094         <span class="keywordflow">if</span>(!(E1000_READ_REG(hw, E1000_TSYNCRXCTL) &amp; E1000_TSYNCRXCTL_VALID))
<a name="l06095"></a>06095             <span class="keywordflow">return</span>;
<a name="l06096"></a>06096 
<a name="l06097"></a>06097         regval = E1000_READ_REG(hw, E1000_RXSTMPL);
<a name="l06098"></a>06098         regval |= (u64)E1000_READ_REG(hw, E1000_RXSTMPH) &lt;&lt; 32;
<a name="l06099"></a>06099     }
<a name="l06100"></a>06100 
<a name="l06101"></a>06101     igb_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), regval);
<a name="l06102"></a>06102 }
<a name="l06103"></a>06103 <span class="preprocessor">#endif</span>
<a name="l06104"></a>06104 <span class="preprocessor"></span><span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06105"></a>06105 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">inline</span> u16 igb_get_hlen(<span class="keyword">union</span> <a class="code" href="unione1000__adv__rx__desc.html">e1000_adv_rx_desc</a> *rx_desc)
<a name="l06106"></a>06106 {
<a name="l06107"></a>06107     <span class="comment">/* HW will not DMA in data larger than the given buffer, even if it</span>
<a name="l06108"></a>06108 <span class="comment">     * parses the (NFS, of course) header to be larger.  In that case, it</span>
<a name="l06109"></a>06109 <span class="comment">     * fills the header buffer and spills the rest into the page.</span>
<a name="l06110"></a>06110 <span class="comment">     */</span>
<a name="l06111"></a>06111     u16 hlen = (le16_to_cpu(rx_desc-&gt;wb.lower.lo_dword.hs_rss.hdr_info) &amp;
<a name="l06112"></a>06112                E1000_RXDADV_HDRBUFLEN_MASK) &gt;&gt; E1000_RXDADV_HDRBUFLEN_SHIFT;
<a name="l06113"></a>06113     <span class="keywordflow">if</span> (hlen &gt; IGB_RX_HDR_LEN)
<a name="l06114"></a>06114         hlen = IGB_RX_HDR_LEN;
<a name="l06115"></a>06115     <span class="keywordflow">return</span> hlen;
<a name="l06116"></a>06116 }
<a name="l06117"></a>06117 
<a name="l06118"></a>06118 <span class="preprocessor">#endif</span>
<a name="l06119"></a>06119 <span class="preprocessor"></span><span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l06120"></a>06120 <span class="preprocessor"></span>
<a name="l06128"></a>06128 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>sk_buff *igb_transform_rsc_queue(<span class="keyword">struct</span> sk_buff *skb)
<a name="l06129"></a>06129 {
<a name="l06130"></a>06130     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frag_list_size = 0;
<a name="l06131"></a>06131 
<a name="l06132"></a>06132     <span class="keywordflow">while</span> (skb-&gt;prev) {
<a name="l06133"></a>06133         <span class="keyword">struct </span>sk_buff *prev = skb-&gt;prev;
<a name="l06134"></a>06134         frag_list_size += skb-&gt;len;
<a name="l06135"></a>06135         skb-&gt;prev = NULL;
<a name="l06136"></a>06136         skb = prev;
<a name="l06137"></a>06137     }
<a name="l06138"></a>06138 
<a name="l06139"></a>06139     skb_shinfo(skb)-&gt;frag_list = skb-&gt;next;
<a name="l06140"></a>06140     skb-&gt;next = NULL;
<a name="l06141"></a>06141     skb-&gt;len += frag_list_size;
<a name="l06142"></a>06142     skb-&gt;data_len += frag_list_size;
<a name="l06143"></a>06143     skb-&gt;truesize += frag_list_size;
<a name="l06144"></a>06144     <span class="keywordflow">return</span> skb;
<a name="l06145"></a>06145 }
<a name="l06146"></a>06146 
<a name="l06154"></a>06154 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> igb_can_lro(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *rx_ring,
<a name="l06155"></a>06155                    <span class="keyword">union</span> <a class="code" href="unione1000__adv__rx__desc.html">e1000_adv_rx_desc</a> *rx_desc,
<a name="l06156"></a>06156                    <span class="keyword">struct</span> sk_buff *skb)
<a name="l06157"></a>06157 {
<a name="l06158"></a>06158     u16 pkt_info = le16_to_cpu(rx_desc-&gt;wb.lower.lo_dword.hs_rss.pkt_info);
<a name="l06159"></a>06159 
<a name="l06160"></a>06160     <span class="keywordflow">return</span> (test_bit(IGB_RING_FLAG_RX_LRO, &amp;rx_ring-&gt;flags) &amp;&amp;
<a name="l06161"></a>06161         (skb-&gt;protocol == __constant_htons(ETH_P_IP)) &amp;&amp;
<a name="l06162"></a>06162         (pkt_info &amp; E1000_RXDADV_PKTTYPE_IPV4) &amp;&amp;
<a name="l06163"></a>06163         (pkt_info &amp; E1000_RXDADV_PKTTYPE_TCP));
<a name="l06164"></a>06164 }
<a name="l06165"></a>06165 
<a name="l06172"></a>06172 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_lro_flush(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector,
<a name="l06173"></a>06173                                  <span class="keyword">struct</span> igb_lro_desc *lrod)
<a name="l06174"></a>06174 {
<a name="l06175"></a>06175     <span class="keyword">struct </span>igb_lro_list *lrolist = q_vector-&gt;lrolist;
<a name="l06176"></a>06176     <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph;
<a name="l06177"></a>06177     <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *th;
<a name="l06178"></a>06178     <span class="keyword">struct </span>sk_buff *skb;
<a name="l06179"></a>06179     u32 *ts_ptr;
<a name="l06180"></a>06180 
<a name="l06181"></a>06181     hlist_del(&amp;lrod-&gt;lro_node);
<a name="l06182"></a>06182     lrolist-&gt;active_cnt--;
<a name="l06183"></a>06183 
<a name="l06184"></a>06184     skb = lrod-&gt;skb;
<a name="l06185"></a>06185     lrod-&gt;skb = NULL;
<a name="l06186"></a>06186 
<a name="l06187"></a>06187     <span class="keywordflow">if</span> (lrod-&gt;append_cnt) {
<a name="l06188"></a>06188         <span class="comment">/* take the lro queue and convert to skb format */</span>
<a name="l06189"></a>06189         skb = igb_transform_rsc_queue(skb);
<a name="l06190"></a>06190 
<a name="l06191"></a>06191         <span class="comment">/* incorporate ip header and re-calculate checksum */</span>
<a name="l06192"></a>06192         iph = (<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *)skb-&gt;data;
<a name="l06193"></a>06193         iph-&gt;tot_len = ntohs(skb-&gt;len);
<a name="l06194"></a>06194         iph-&gt;check = 0;
<a name="l06195"></a>06195         iph-&gt;check = ip_fast_csum((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)iph, iph-&gt;ihl);
<a name="l06196"></a>06196 
<a name="l06197"></a>06197         <span class="comment">/* incorporate the latest ack into the tcp header */</span>
<a name="l06198"></a>06198         th = (<span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *) ((<span class="keywordtype">char</span> *)skb-&gt;data + <span class="keyword">sizeof</span>(*iph));
<a name="l06199"></a>06199         th-&gt;ack_seq = lrod-&gt;ack_seq;
<a name="l06200"></a>06200         th-&gt;psh = lrod-&gt;psh;
<a name="l06201"></a>06201         th-&gt;window = lrod-&gt;window;
<a name="l06202"></a>06202         th-&gt;check = 0;
<a name="l06203"></a>06203 
<a name="l06204"></a>06204         <span class="comment">/* incorporate latest timestamp into the tcp header */</span>
<a name="l06205"></a>06205         <span class="keywordflow">if</span> (lrod-&gt;opt_bytes) {
<a name="l06206"></a>06206             ts_ptr = (u32 *)(th + 1);
<a name="l06207"></a>06207             ts_ptr[1] = htonl(lrod-&gt;tsval);
<a name="l06208"></a>06208             ts_ptr[2] = lrod-&gt;tsecr;
<a name="l06209"></a>06209         }
<a name="l06210"></a>06210     }
<a name="l06211"></a>06211 
<a name="l06212"></a>06212 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l06213"></a>06213 <span class="preprocessor"></span>    skb_shinfo(skb)-&gt;gso_size = lrod-&gt;mss;
<a name="l06214"></a>06214 <span class="preprocessor">#endif</span>
<a name="l06215"></a>06215 <span class="preprocessor"></span>    igb_receive_skb(q_vector, skb, lrod-&gt;vlan_tag);
<a name="l06216"></a>06216     lrolist-&gt;stats.flushed++;
<a name="l06217"></a>06217 
<a name="l06218"></a>06218 
<a name="l06219"></a>06219     hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;free);
<a name="l06220"></a>06220 }
<a name="l06221"></a>06221 
<a name="l06222"></a>06222 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_lro_flush_all(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector)
<a name="l06223"></a>06223 {
<a name="l06224"></a>06224     <span class="keyword">struct </span>igb_lro_desc *lrod;
<a name="l06225"></a>06225     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l06226"></a>06226     <span class="keyword">struct </span>igb_lro_list *lrolist = q_vector-&gt;lrolist;
<a name="l06227"></a>06227 
<a name="l06228"></a>06228     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;active, lro_node)
<a name="l06229"></a>06229         igb_lro_flush(q_vector, lrod);
<a name="l06230"></a>06230 }
<a name="l06231"></a>06231 
<a name="l06232"></a>06232 <span class="comment">/*</span>
<a name="l06233"></a>06233 <span class="comment"> * igb_lro_header_ok - Main LRO function.</span>
<a name="l06234"></a>06234 <span class="comment"> **/</span>
<a name="l06235"></a>06235 static u16 igb_lro_header_ok(struct sk_buff *new_skb, struct <a class="code" href="structiphdr.html">iphdr</a> *iph,
<a name="l06236"></a>06236                                struct <a class="code" href="structtcphdr.html">tcphdr</a> *th)
<a name="l06237"></a>06237 {
<a name="l06238"></a>06238     <span class="keywordtype">int</span> opt_bytes, tcp_data_len;
<a name="l06239"></a>06239     u32 *ts_ptr = NULL;
<a name="l06240"></a>06240 
<a name="l06241"></a>06241     <span class="comment">/* If we see CE codepoint in IP header, packet is not mergeable */</span>
<a name="l06242"></a>06242     <span class="keywordflow">if</span> (INET_ECN_is_ce(ipv4_get_dsfield(iph)))
<a name="l06243"></a>06243         <span class="keywordflow">return</span> -1;
<a name="l06244"></a>06244 
<a name="l06245"></a>06245     <span class="comment">/* ensure there are no options */</span>
<a name="l06246"></a>06246     <span class="keywordflow">if</span> ((iph-&gt;ihl &lt;&lt; 2) != <span class="keyword">sizeof</span>(*iph))
<a name="l06247"></a>06247         <span class="keywordflow">return</span> -1;
<a name="l06248"></a>06248 
<a name="l06249"></a>06249     <span class="comment">/* .. and the packet is not fragmented */</span>
<a name="l06250"></a>06250     <span class="keywordflow">if</span> (iph-&gt;frag_off &amp; htons(IP_MF|IP_OFFSET))
<a name="l06251"></a>06251         <span class="keywordflow">return</span> -1;
<a name="l06252"></a>06252 
<a name="l06253"></a>06253     <span class="comment">/* ensure no bits set besides ack or psh */</span>
<a name="l06254"></a>06254     <span class="keywordflow">if</span> (th-&gt;fin || th-&gt;syn || th-&gt;rst ||
<a name="l06255"></a>06255         th-&gt;urg || th-&gt;ece || th-&gt;cwr || !th-&gt;ack)
<a name="l06256"></a>06256         <span class="keywordflow">return</span> -1;
<a name="l06257"></a>06257 
<a name="l06258"></a>06258     <span class="comment">/* ensure that the checksum is valid */</span>
<a name="l06259"></a>06259     <span class="keywordflow">if</span> (new_skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
<a name="l06260"></a>06260         <span class="keywordflow">return</span> -1;
<a name="l06261"></a>06261 
<a name="l06262"></a>06262     <span class="comment">/*</span>
<a name="l06263"></a>06263 <span class="comment">     * check for timestamps. Since the only option we handle are timestamps,</span>
<a name="l06264"></a>06264 <span class="comment">     * we only have to handle the simple case of aligned timestamps</span>
<a name="l06265"></a>06265 <span class="comment">     */</span>
<a name="l06266"></a>06266 
<a name="l06267"></a>06267     opt_bytes = (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*th);
<a name="l06268"></a>06268     <span class="keywordflow">if</span> (opt_bytes != 0) {
<a name="l06269"></a>06269         ts_ptr = (u32 *)(th + 1);
<a name="l06270"></a>06270         <span class="keywordflow">if</span> ((opt_bytes != TCPOLEN_TSTAMP_ALIGNED) ||
<a name="l06271"></a>06271             (*ts_ptr != ntohl((TCPOPT_NOP &lt;&lt; 24) |
<a name="l06272"></a>06272             (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) |
<a name="l06273"></a>06273             TCPOLEN_TIMESTAMP))) {
<a name="l06274"></a>06274             <span class="keywordflow">return</span> -1;
<a name="l06275"></a>06275         }
<a name="l06276"></a>06276     }
<a name="l06277"></a>06277 
<a name="l06278"></a>06278     tcp_data_len = ntohs(iph-&gt;tot_len) - (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*iph);
<a name="l06279"></a>06279 
<a name="l06280"></a>06280     <span class="keywordflow">return</span> tcp_data_len;
<a name="l06281"></a>06281 }
<a name="l06282"></a>06282 
<a name="l06293"></a>06293 <span class="keyword">static</span> <span class="keyword">struct </span>sk_buff *igb_lro_queue(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector,
<a name="l06294"></a>06294                                        <span class="keyword">struct</span> sk_buff *new_skb,
<a name="l06295"></a>06295                        u16 tag)
<a name="l06296"></a>06296 {
<a name="l06297"></a>06297     <span class="keyword">struct </span>sk_buff *lro_skb;
<a name="l06298"></a>06298     <span class="keyword">struct </span>igb_lro_desc *lrod;
<a name="l06299"></a>06299     <span class="keyword">struct </span>hlist_node *node;
<a name="l06300"></a>06300     <span class="keyword">struct </span>skb_shared_info *new_skb_info = skb_shinfo(new_skb);
<a name="l06301"></a>06301     <span class="keyword">struct </span>igb_lro_list *lrolist = q_vector-&gt;lrolist;
<a name="l06302"></a>06302     <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = (<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *)new_skb-&gt;data;
<a name="l06303"></a>06303     <span class="keyword">struct</span> <a class="code" href="structtcphdr.html">tcphdr</a> *th = (<span class="keyword">struct</span> <a class="code" href="structtcphdr.html">tcphdr</a> *)(iph + 1);
<a name="l06304"></a>06304     <span class="keywordtype">int</span> tcp_data_len = igb_lro_header_ok(new_skb, iph, th);
<a name="l06305"></a>06305     u16  opt_bytes = (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*th);
<a name="l06306"></a>06306     u32 *ts_ptr = (opt_bytes ? (u32 *)(th + 1) : NULL);
<a name="l06307"></a>06307     u32 seq = ntohl(th-&gt;seq);
<a name="l06308"></a>06308 
<a name="l06309"></a>06309     <span class="comment">/*</span>
<a name="l06310"></a>06310 <span class="comment">     * we have a packet that might be eligible for LRO,</span>
<a name="l06311"></a>06311 <span class="comment">     * so see if it matches anything we might expect</span>
<a name="l06312"></a>06312 <span class="comment">     */</span>
<a name="l06313"></a>06313     hlist_for_each_entry(lrod, node, &amp;lrolist-&gt;active, lro_node) {
<a name="l06314"></a>06314         <span class="keywordflow">if</span> (lrod-&gt;source_port != th-&gt;source ||
<a name="l06315"></a>06315             lrod-&gt;dest_port != th-&gt;dest ||
<a name="l06316"></a>06316             lrod-&gt;source_ip != iph-&gt;saddr ||
<a name="l06317"></a>06317             lrod-&gt;dest_ip != iph-&gt;daddr ||
<a name="l06318"></a>06318             lrod-&gt;vlan_tag != tag)
<a name="l06319"></a>06319             <span class="keywordflow">continue</span>;
<a name="l06320"></a>06320 
<a name="l06321"></a>06321         <span class="comment">/*</span>
<a name="l06322"></a>06322 <span class="comment">         * malformed header, no tcp data, resultant packet would</span>
<a name="l06323"></a>06323 <span class="comment">         * be too large, ack sequence numbers do not match, window</span>
<a name="l06324"></a>06324 <span class="comment">         * size has changed, or new skb is larger than our current mss.</span>
<a name="l06325"></a>06325 <span class="comment">         * If any of the above we should flush the lro descriptor and</span>
<a name="l06326"></a>06326 <span class="comment">         * start over if possible</span>
<a name="l06327"></a>06327 <span class="comment">         */</span>
<a name="l06328"></a>06328         <span class="keywordflow">if</span> (tcp_data_len &lt;= 0 || (tcp_data_len + lrod-&gt;len) &gt; 65521 ||
<a name="l06329"></a>06329             lrod-&gt;ack_seq != th-&gt;ack_seq ||
<a name="l06330"></a>06330             lrod-&gt;window != th-&gt;window ||
<a name="l06331"></a>06331             lrod-&gt;mss &lt; tcp_data_len) {
<a name="l06332"></a>06332             igb_lro_flush(q_vector, lrod);
<a name="l06333"></a>06333             <span class="keywordflow">break</span>;
<a name="l06334"></a>06334         }
<a name="l06335"></a>06335 
<a name="l06336"></a>06336         <span class="comment">/* out of order packet */</span>
<a name="l06337"></a>06337         <span class="keywordflow">if</span> (seq != lrod-&gt;next_seq) {
<a name="l06338"></a>06338             igb_lro_flush(q_vector, lrod);
<a name="l06339"></a>06339             tcp_data_len = -1;
<a name="l06340"></a>06340             <span class="keywordflow">break</span>;
<a name="l06341"></a>06341         }
<a name="l06342"></a>06342 
<a name="l06343"></a>06343         <span class="comment">/* packet without timestamp, or timestamp suddenly added to flow */</span>
<a name="l06344"></a>06344         <span class="keywordflow">if</span> (lrod-&gt;opt_bytes != opt_bytes) {
<a name="l06345"></a>06345             igb_lro_flush(q_vector, lrod);
<a name="l06346"></a>06346             <span class="keywordflow">break</span>;
<a name="l06347"></a>06347         }
<a name="l06348"></a>06348 
<a name="l06349"></a>06349         <span class="keywordflow">if</span> (opt_bytes) {
<a name="l06350"></a>06350             u32 tsval = ntohl(*(ts_ptr + 1));
<a name="l06351"></a>06351             <span class="comment">/* make sure timestamp values are increasing */</span>
<a name="l06352"></a>06352             <span class="keywordflow">if</span> (opt_bytes != lrod-&gt;opt_bytes ||
<a name="l06353"></a>06353                 lrod-&gt;tsval &gt; tsval || *(ts_ptr + 2) == 0) {
<a name="l06354"></a>06354                 igb_lro_flush(q_vector, lrod);
<a name="l06355"></a>06355                 tcp_data_len = -1;
<a name="l06356"></a>06356                 <span class="keywordflow">break</span>;
<a name="l06357"></a>06357             }
<a name="l06358"></a>06358 
<a name="l06359"></a>06359             lrod-&gt;tsval = tsval;
<a name="l06360"></a>06360             lrod-&gt;tsecr = *(ts_ptr + 2);
<a name="l06361"></a>06361         }
<a name="l06362"></a>06362 
<a name="l06363"></a>06363         <span class="comment">/* remove any padding from the end of the skb */</span>
<a name="l06364"></a>06364         __pskb_trim(new_skb, ntohs(iph-&gt;tot_len));
<a name="l06365"></a>06365         <span class="comment">/* Remove IP and TCP header*/</span>
<a name="l06366"></a>06366         skb_pull(new_skb, ntohs(iph-&gt;tot_len) - tcp_data_len);
<a name="l06367"></a>06367 
<a name="l06368"></a>06368         lrod-&gt;next_seq += tcp_data_len;
<a name="l06369"></a>06369         lrod-&gt;len += tcp_data_len;
<a name="l06370"></a>06370         lrod-&gt;psh |= th-&gt;psh;
<a name="l06371"></a>06371         lrod-&gt;append_cnt++;
<a name="l06372"></a>06372         lrolist-&gt;stats.coal++;
<a name="l06373"></a>06373         lro_skb = lrod-&gt;skb;
<a name="l06374"></a>06374 
<a name="l06375"></a>06375 <span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06376"></a>06376 <span class="preprocessor"></span>        <span class="comment">/* if header is empty pull pages into current skb */</span>
<a name="l06377"></a>06377         <span class="keywordflow">if</span> (!skb_headlen(new_skb) &amp;&amp;
<a name="l06378"></a>06378             ((skb_shinfo(lro_skb)-&gt;nr_frags +
<a name="l06379"></a>06379               skb_shinfo(new_skb)-&gt;nr_frags) &lt;= MAX_SKB_FRAGS )) {
<a name="l06380"></a>06380             <span class="keyword">struct </span>skb_shared_info *lro_skb_info = skb_shinfo(lro_skb);
<a name="l06381"></a>06381 
<a name="l06382"></a>06382             <span class="comment">/* copy frags into the last skb */</span>
<a name="l06383"></a>06383             memcpy(lro_skb_info-&gt;frags + lro_skb_info-&gt;nr_frags,
<a name="l06384"></a>06384                    new_skb_info-&gt;frags,
<a name="l06385"></a>06385                    new_skb_info-&gt;nr_frags * <span class="keyword">sizeof</span>(skb_frag_t));
<a name="l06386"></a>06386 
<a name="l06387"></a>06387             lro_skb_info-&gt;nr_frags += new_skb_info-&gt;nr_frags;
<a name="l06388"></a>06388             lro_skb-&gt;len += tcp_data_len;
<a name="l06389"></a>06389             lro_skb-&gt;data_len += tcp_data_len;
<a name="l06390"></a>06390             lro_skb-&gt;truesize += tcp_data_len;
<a name="l06391"></a>06391 
<a name="l06392"></a>06392             new_skb_info-&gt;nr_frags = 0;
<a name="l06393"></a>06393             new_skb-&gt;truesize -= tcp_data_len;
<a name="l06394"></a>06394             new_skb-&gt;len = new_skb-&gt;data_len = 0;
<a name="l06395"></a>06395             new_skb-&gt;data = skb_mac_header(new_skb);
<a name="l06396"></a>06396             skb_reset_tail_pointer(new_skb);
<a name="l06397"></a>06397             new_skb-&gt;protocol = 0;
<a name="l06398"></a>06398             lrolist-&gt;stats.recycled++;
<a name="l06399"></a>06399         } <span class="keywordflow">else</span> {
<a name="l06400"></a>06400 <span class="preprocessor">#endif</span>
<a name="l06401"></a>06401 <span class="preprocessor"></span>            <span class="comment">/* Chain this new skb in frag_list */</span>
<a name="l06402"></a>06402             new_skb-&gt;prev = lro_skb;
<a name="l06403"></a>06403             lro_skb-&gt;next = new_skb;
<a name="l06404"></a>06404             lrod-&gt;skb = new_skb ;
<a name="l06405"></a>06405             new_skb = NULL;
<a name="l06406"></a>06406 <span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06407"></a>06407 <span class="preprocessor"></span>        }
<a name="l06408"></a>06408 <span class="preprocessor">#endif</span>
<a name="l06409"></a>06409 <span class="preprocessor"></span>
<a name="l06410"></a>06410         <span class="keywordflow">if</span> (lrod-&gt;psh || (tcp_data_len &lt; lrod-&gt;mss))
<a name="l06411"></a>06411             igb_lro_flush(q_vector, lrod);
<a name="l06412"></a>06412 
<a name="l06413"></a>06413         <span class="keywordflow">return</span> new_skb;
<a name="l06414"></a>06414     }
<a name="l06415"></a>06415 
<a name="l06416"></a>06416     <span class="comment">/* start a new packet */</span>
<a name="l06417"></a>06417     <span class="keywordflow">if</span> (tcp_data_len &gt; 0 &amp;&amp; !hlist_empty(&amp;lrolist-&gt;free) &amp;&amp; !th-&gt;psh) {
<a name="l06418"></a>06418         lrod = hlist_entry(lrolist-&gt;free.first, <span class="keyword">struct</span> igb_lro_desc,
<a name="l06419"></a>06419                            lro_node);
<a name="l06420"></a>06420 
<a name="l06421"></a>06421         <span class="comment">/* remove any padding from the end of the skb */</span>
<a name="l06422"></a>06422         __pskb_trim(new_skb, ntohs(iph-&gt;tot_len));
<a name="l06423"></a>06423 
<a name="l06424"></a>06424         lrod-&gt;skb = new_skb;
<a name="l06425"></a>06425         lrod-&gt;source_ip = iph-&gt;saddr;
<a name="l06426"></a>06426         lrod-&gt;dest_ip = iph-&gt;daddr;
<a name="l06427"></a>06427         lrod-&gt;source_port = th-&gt;source;
<a name="l06428"></a>06428         lrod-&gt;dest_port = th-&gt;dest;
<a name="l06429"></a>06429         lrod-&gt;vlan_tag = tag;
<a name="l06430"></a>06430         lrod-&gt;len = new_skb-&gt;len;
<a name="l06431"></a>06431         lrod-&gt;next_seq = seq + tcp_data_len;
<a name="l06432"></a>06432         lrod-&gt;ack_seq = th-&gt;ack_seq;
<a name="l06433"></a>06433         lrod-&gt;window = th-&gt;window;
<a name="l06434"></a>06434         lrod-&gt;mss = tcp_data_len;
<a name="l06435"></a>06435         lrod-&gt;opt_bytes = opt_bytes;
<a name="l06436"></a>06436         lrod-&gt;psh = 0;
<a name="l06437"></a>06437         lrod-&gt;append_cnt = 0;
<a name="l06438"></a>06438 
<a name="l06439"></a>06439         <span class="comment">/* record timestamp if it is present */</span>
<a name="l06440"></a>06440         <span class="keywordflow">if</span> (opt_bytes) {
<a name="l06441"></a>06441             lrod-&gt;tsval = ntohl(*(ts_ptr + 1));
<a name="l06442"></a>06442             lrod-&gt;tsecr = *(ts_ptr + 2);
<a name="l06443"></a>06443         }
<a name="l06444"></a>06444         <span class="comment">/* remove first packet from freelist.. */</span>
<a name="l06445"></a>06445         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l06446"></a>06446         <span class="comment">/* .. and insert at the front of the active list */</span>
<a name="l06447"></a>06447         hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;active);
<a name="l06448"></a>06448         lrolist-&gt;active_cnt++;
<a name="l06449"></a>06449         lrolist-&gt;stats.coal++;
<a name="l06450"></a>06450         <span class="keywordflow">return</span> NULL;
<a name="l06451"></a>06451     }
<a name="l06452"></a>06452 
<a name="l06453"></a>06453     <span class="comment">/* packet not handled by any of the above, pass it to the stack */</span>
<a name="l06454"></a>06454     igb_receive_skb(q_vector, new_skb, tag);
<a name="l06455"></a>06455     <span class="keywordflow">return</span> NULL;
<a name="l06456"></a>06456 }
<a name="l06457"></a>06457 
<a name="l06458"></a>06458 <span class="preprocessor">#endif </span><span class="comment">/* IGB_LRO */</span>
<a name="l06459"></a>06459 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_clean_rx_irq(<span class="keyword">struct</span> <a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector,
<a name="l06460"></a>06460                              <span class="keywordtype">int</span> *work_done, <span class="keywordtype">int</span> budget)
<a name="l06461"></a>06461 {
<a name="l06462"></a>06462     <span class="keyword">struct </span><a class="code" href="structigb__ring.html">igb_ring</a> *rx_ring = q_vector-&gt;rx_ring;
<a name="l06463"></a>06463     <span class="keyword">union </span><a class="code" href="unione1000__adv__rx__desc.html">e1000_adv_rx_desc</a> *rx_desc;
<a name="l06464"></a>06464 <span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06465"></a>06465 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> current_node = numa_node_id();
<a name="l06466"></a>06466 <span class="preprocessor">#endif</span>
<a name="l06467"></a>06467 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_bytes = 0, total_packets = 0;
<a name="l06468"></a>06468     u32 staterr;
<a name="l06469"></a>06469     u16 cleaned_count = 0;
<a name="l06470"></a>06470     u16 i = rx_ring-&gt;next_to_clean;
<a name="l06471"></a>06471 
<a name="l06472"></a>06472     rx_desc = IGB_RX_DESC(rx_ring, i);
<a name="l06473"></a>06473     staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l06474"></a>06474 
<a name="l06475"></a>06475     <span class="keywordflow">while</span> (staterr &amp; E1000_RXD_STAT_DD) {
<a name="l06476"></a>06476         <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l06477"></a>06477         <span class="keyword">struct </span>sk_buff *skb = buffer_info-&gt;skb;
<a name="l06478"></a>06478         <span class="keyword">union </span><a class="code" href="unione1000__adv__rx__desc.html">e1000_adv_rx_desc</a> *next_rxd;
<a name="l06479"></a>06479         u16 vlan_tag;
<a name="l06480"></a>06480 
<a name="l06481"></a>06481         rx_desc-&gt;wb.upper.status_error = 0;
<a name="l06482"></a>06482 
<a name="l06483"></a>06483         buffer_info-&gt;skb = NULL;
<a name="l06484"></a>06484         prefetch(skb-&gt;data - NET_IP_ALIGN);
<a name="l06485"></a>06485 
<a name="l06486"></a>06486         i++;
<a name="l06487"></a>06487         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l06488"></a>06488             i = 0;
<a name="l06489"></a>06489 
<a name="l06490"></a>06490         next_rxd = IGB_RX_DESC(rx_ring, i);
<a name="l06491"></a>06491         prefetch(next_rxd);
<a name="l06492"></a>06492 
<a name="l06493"></a>06493 <span class="preprocessor">#ifdef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06494"></a>06494 <span class="preprocessor"></span>        __skb_put(skb, le16_to_cpu(rx_desc-&gt;wb.upper.length));
<a name="l06495"></a>06495         dma_unmap_single(rx_ring-&gt;dev, buffer_info-&gt;dma,
<a name="l06496"></a>06496                  rx_ring-&gt;rx_buffer_len,
<a name="l06497"></a>06497                  DMA_FROM_DEVICE);
<a name="l06498"></a>06498         buffer_info-&gt;dma = 0;
<a name="l06499"></a>06499 
<a name="l06500"></a>06500 <span class="preprocessor">#else</span>
<a name="l06501"></a>06501 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!skb_is_nonlinear(skb)) {
<a name="l06502"></a>06502             __skb_put(skb, igb_get_hlen(rx_desc));
<a name="l06503"></a>06503             dma_unmap_single(rx_ring-&gt;dev, buffer_info-&gt;dma,
<a name="l06504"></a>06504                              IGB_RX_HDR_LEN,
<a name="l06505"></a>06505                      DMA_FROM_DEVICE);
<a name="l06506"></a>06506             buffer_info-&gt;dma = 0;
<a name="l06507"></a>06507         }
<a name="l06508"></a>06508 
<a name="l06509"></a>06509         <span class="keywordflow">if</span> (rx_desc-&gt;wb.upper.length) {
<a name="l06510"></a>06510             u16 length = le16_to_cpu(rx_desc-&gt;wb.upper.length);
<a name="l06511"></a>06511 
<a name="l06512"></a>06512             skb_fill_page_desc(skb, skb_shinfo(skb)-&gt;nr_frags,
<a name="l06513"></a>06513                        buffer_info-&gt;page,
<a name="l06514"></a>06514                        buffer_info-&gt;page_offset,
<a name="l06515"></a>06515                        length);
<a name="l06516"></a>06516 
<a name="l06517"></a>06517             skb-&gt;len += length;
<a name="l06518"></a>06518             skb-&gt;data_len += length;
<a name="l06519"></a>06519             skb-&gt;truesize += length;
<a name="l06520"></a>06520 
<a name="l06521"></a>06521             <span class="keywordflow">if</span> ((page_count(buffer_info-&gt;page) != 1) ||
<a name="l06522"></a>06522                 (page_to_nid(buffer_info-&gt;page) != current_node))
<a name="l06523"></a>06523                 buffer_info-&gt;page = NULL;
<a name="l06524"></a>06524             <span class="keywordflow">else</span>
<a name="l06525"></a>06525                 get_page(buffer_info-&gt;page);
<a name="l06526"></a>06526 
<a name="l06527"></a>06527             dma_unmap_page(rx_ring-&gt;dev, buffer_info-&gt;page_dma,
<a name="l06528"></a>06528                        PAGE_SIZE / 2, DMA_FROM_DEVICE);
<a name="l06529"></a>06529             buffer_info-&gt;page_dma = 0;
<a name="l06530"></a>06530         }
<a name="l06531"></a>06531 
<a name="l06532"></a>06532         <span class="keywordflow">if</span> (!(staterr &amp; E1000_RXD_STAT_EOP)) {
<a name="l06533"></a>06533             <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *next_buffer;
<a name="l06534"></a>06534             next_buffer = &amp;rx_ring-&gt;buffer_info[i];
<a name="l06535"></a>06535             buffer_info-&gt;skb = next_buffer-&gt;skb;
<a name="l06536"></a>06536             buffer_info-&gt;dma = next_buffer-&gt;dma;
<a name="l06537"></a>06537             next_buffer-&gt;skb = skb;
<a name="l06538"></a>06538             next_buffer-&gt;dma = 0;
<a name="l06539"></a>06539             <span class="keywordflow">goto</span> next_desc;
<a name="l06540"></a>06540         }
<a name="l06541"></a>06541 
<a name="l06542"></a>06542 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IGB_DISABLE_PACKET_SPLIT */</span>
<a name="l06543"></a>06543         <span class="keywordflow">if</span> (staterr &amp; E1000_RXDEXT_ERR_FRAME_ERR_MASK) {
<a name="l06544"></a>06544             dev_kfree_skb_any(skb);
<a name="l06545"></a>06545             <span class="keywordflow">goto</span> next_desc;
<a name="l06546"></a>06546         }
<a name="l06547"></a>06547 
<a name="l06548"></a>06548 <span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l06549"></a>06549 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (staterr &amp; (E1000_RXDADV_STAT_TSIP | E1000_RXDADV_STAT_TS))
<a name="l06550"></a>06550             igb_rx_hwtstamp(q_vector, staterr, skb);
<a name="l06551"></a>06551 <span class="preprocessor">#endif</span>
<a name="l06552"></a>06552 <span class="preprocessor"></span>        total_bytes += skb-&gt;len;
<a name="l06553"></a>06553         total_packets++;
<a name="l06554"></a>06554 
<a name="l06555"></a>06555         igb_rx_checksum(rx_ring, staterr, skb);
<a name="l06556"></a>06556 
<a name="l06557"></a>06557         skb-&gt;protocol = eth_type_trans(skb, netdev_ring(rx_ring));
<a name="l06558"></a>06558 
<a name="l06559"></a>06559         <span class="keywordflow">if</span> (staterr &amp; E1000_RXD_STAT_VP) {
<a name="l06560"></a>06560             <span class="keywordflow">if</span> (test_bit(IGB_RING_FLAG_RX_LB_VLAN_BSWAP, &amp;rx_ring-&gt;flags) &amp;&amp;
<a name="l06561"></a>06561                 (staterr &amp; E1000_RXDEXT_STATERR_LB))
<a name="l06562"></a>06562                 vlan_tag = be16_to_cpu(rx_desc-&gt;wb.upper.vlan);
<a name="l06563"></a>06563             <span class="keywordflow">else</span>
<a name="l06564"></a>06564                 vlan_tag = le16_to_cpu(rx_desc-&gt;wb.upper.vlan);
<a name="l06565"></a>06565         } <span class="keywordflow">else</span>
<a name="l06566"></a>06566             vlan_tag = 0;
<a name="l06567"></a>06567 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l06568"></a>06568 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (igb_can_lro(rx_ring, rx_desc, skb))
<a name="l06569"></a>06569             buffer_info-&gt;skb = igb_lro_queue(q_vector, skb, vlan_tag);
<a name="l06570"></a>06570         <span class="keywordflow">else</span>
<a name="l06571"></a>06571 <span class="preprocessor">#endif</span>
<a name="l06572"></a>06572 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l06573"></a>06573 <span class="preprocessor"></span>                  <span class="keywordflow">if</span>(igb_receive_skb(q_vector, skb, vlan_tag) == 2) {
<a name="l06574"></a>06574                     <span class="comment">/* Force adapter to stop polling as we have no room for packets */</span>
<a name="l06575"></a>06575                     <span class="comment">/* printk(&quot;[PF_RING] No room for packets\n&quot;); */</span>
<a name="l06576"></a>06576                     *work_done = budget;
<a name="l06577"></a>06577                     <span class="comment">/* schedule(); */</span>
<a name="l06578"></a>06578                   }
<a name="l06579"></a>06579 <span class="preprocessor">#else</span>
<a name="l06580"></a>06580 <span class="preprocessor"></span>        igb_receive_skb(q_vector, skb, vlan_tag);
<a name="l06581"></a>06581 <span class="preprocessor">#endif</span>
<a name="l06582"></a>06582 <span class="preprocessor"></span>
<a name="l06583"></a>06583 
<a name="l06584"></a>06584 <span class="preprocessor">#ifndef NETIF_F_GRO</span>
<a name="l06585"></a>06585 <span class="preprocessor"></span>        netdev_ring(rx_ring)-&gt;last_rx = jiffies;
<a name="l06586"></a>06586 
<a name="l06587"></a>06587 <span class="preprocessor">#endif</span>
<a name="l06588"></a>06588 <span class="preprocessor"></span>        (*work_done)++;
<a name="l06589"></a>06589 
<a name="l06590"></a>06590 next_desc:
<a name="l06591"></a>06591         <span class="keywordflow">if</span> (*work_done &gt;= budget)
<a name="l06592"></a>06592             <span class="keywordflow">break</span>;
<a name="l06593"></a>06593 
<a name="l06594"></a>06594         cleaned_count++;
<a name="l06595"></a>06595         <span class="comment">/* return some buffers to hardware, one at a time is too slow */</span>
<a name="l06596"></a>06596         <span class="keywordflow">if</span> (cleaned_count &gt;= IGB_RX_BUFFER_WRITE) {
<a name="l06597"></a>06597             igb_alloc_rx_buffers(rx_ring, cleaned_count);
<a name="l06598"></a>06598             cleaned_count = 0;
<a name="l06599"></a>06599         }
<a name="l06600"></a>06600 
<a name="l06601"></a>06601         <span class="comment">/* use prefetched values */</span>
<a name="l06602"></a>06602         rx_desc = next_rxd;
<a name="l06603"></a>06603         staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l06604"></a>06604     }
<a name="l06605"></a>06605 
<a name="l06606"></a>06606 <span class="preprocessor">#ifdef IGB_LRO</span>
<a name="l06607"></a>06607 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (test_bit(IGB_RING_FLAG_RX_LRO, &amp;rx_ring-&gt;flags))
<a name="l06608"></a>06608         igb_lro_flush_all(q_vector);
<a name="l06609"></a>06609 <span class="preprocessor">#endif </span><span class="comment">/* IGB_LRO */</span>
<a name="l06610"></a>06610     rx_ring-&gt;next_to_clean = i;
<a name="l06611"></a>06611     cleaned_count = igb_desc_unused(rx_ring);
<a name="l06612"></a>06612 
<a name="l06613"></a>06613     <span class="keywordflow">if</span> (cleaned_count)
<a name="l06614"></a>06614         igb_alloc_rx_buffers(rx_ring, cleaned_count);
<a name="l06615"></a>06615 
<a name="l06616"></a>06616     rx_ring-&gt;total_packets += total_packets;
<a name="l06617"></a>06617     rx_ring-&gt;total_bytes += total_bytes;
<a name="l06618"></a>06618     rx_ring-&gt;rx_stats.packets += total_packets;
<a name="l06619"></a>06619     rx_ring-&gt;rx_stats.bytes += total_bytes;
<a name="l06620"></a>06620 }
<a name="l06621"></a>06621 
<a name="l06626"></a>06626 <span class="keywordtype">void</span> igb_alloc_rx_buffers(<span class="keyword">struct</span> <a class="code" href="structigb__ring.html">igb_ring</a> *rx_ring, u16 cleaned_count)
<a name="l06627"></a>06627 {
<a name="l06628"></a>06628 <span class="preprocessor">#ifdef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06629"></a>06629 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> bufsz = rx_ring-&gt;rx_buffer_len;
<a name="l06630"></a>06630 <span class="preprocessor">#else</span>
<a name="l06631"></a>06631 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">int</span> bufsz = IGB_RX_HDR_LEN;
<a name="l06632"></a>06632 <span class="preprocessor">#endif</span>
<a name="l06633"></a>06633 <span class="preprocessor"></span>    u16 i = rx_ring-&gt;next_to_use;
<a name="l06634"></a>06634 
<a name="l06635"></a>06635     <span class="keywordflow">while</span> (cleaned_count--) {
<a name="l06636"></a>06636         <span class="keyword">union </span><a class="code" href="unione1000__adv__rx__desc.html">e1000_adv_rx_desc</a> *rx_desc = IGB_RX_DESC(rx_ring, i);
<a name="l06637"></a>06637         <span class="keyword">struct </span><a class="code" href="structigb__buffer.html">igb_buffer</a> *buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l06638"></a>06638         <span class="keyword">struct </span>sk_buff *skb = buffer_info-&gt;skb;
<a name="l06639"></a>06639 
<a name="l06640"></a>06640         <span class="keywordflow">if</span> (likely(!skb)) {
<a name="l06641"></a>06641             skb = netdev_alloc_skb_ip_align(netdev_ring(rx_ring),
<a name="l06642"></a>06642                             bufsz);
<a name="l06643"></a>06643             buffer_info-&gt;skb = skb;
<a name="l06644"></a>06644             <span class="keywordflow">if</span> (!skb) {
<a name="l06645"></a>06645                 rx_ring-&gt;rx_stats.alloc_failed++;
<a name="l06646"></a>06646                 <span class="keywordflow">goto</span> no_buffers;
<a name="l06647"></a>06647             }
<a name="l06648"></a>06648             <span class="comment">/* initialize queue mapping */</span>
<a name="l06649"></a>06649             skb_record_rx_queue(skb, ring_queue_index(rx_ring));
<a name="l06650"></a>06650         }
<a name="l06651"></a>06651 
<a name="l06652"></a>06652         <span class="keywordflow">if</span> (!buffer_info-&gt;dma) {
<a name="l06653"></a>06653             <span class="comment">/* reset ip_summed value */</span>
<a name="l06654"></a>06654             skb-&gt;ip_summed = CHECKSUM_NONE;
<a name="l06655"></a>06655 
<a name="l06656"></a>06656             buffer_info-&gt;dma = dma_map_single(rx_ring-&gt;dev,
<a name="l06657"></a>06657                                               skb-&gt;data,
<a name="l06658"></a>06658                                               bufsz,
<a name="l06659"></a>06659                                               DMA_FROM_DEVICE);
<a name="l06660"></a>06660             <span class="keywordflow">if</span> (dma_mapping_error(rx_ring-&gt;dev, buffer_info-&gt;dma)) {
<a name="l06661"></a>06661                 buffer_info-&gt;dma = 0;
<a name="l06662"></a>06662                 rx_ring-&gt;rx_stats.alloc_failed++;
<a name="l06663"></a>06663                 <span class="keywordflow">goto</span> no_buffers;
<a name="l06664"></a>06664             }
<a name="l06665"></a>06665         }
<a name="l06666"></a>06666 
<a name="l06667"></a>06667 <span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06668"></a>06668 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!buffer_info-&gt;page) {
<a name="l06669"></a>06669             buffer_info-&gt;page =
<a name="l06670"></a>06670                 netdev_alloc_page(netdev_ring(rx_ring));
<a name="l06671"></a>06671             <span class="keywordflow">if</span> (!buffer_info-&gt;page) {
<a name="l06672"></a>06672                 rx_ring-&gt;rx_stats.alloc_failed++;
<a name="l06673"></a>06673                 <span class="keywordflow">goto</span> no_buffers;
<a name="l06674"></a>06674             }
<a name="l06675"></a>06675         }
<a name="l06676"></a>06676 
<a name="l06677"></a>06677         <span class="keywordflow">if</span> (!buffer_info-&gt;page_dma) {
<a name="l06678"></a>06678             buffer_info-&gt;page_offset ^= PAGE_SIZE / 2;
<a name="l06679"></a>06679             buffer_info-&gt;page_dma =
<a name="l06680"></a>06680                 dma_map_page(rx_ring-&gt;dev, buffer_info-&gt;page,
<a name="l06681"></a>06681                              buffer_info-&gt;page_offset,
<a name="l06682"></a>06682                              PAGE_SIZE / 2,
<a name="l06683"></a>06683                              DMA_FROM_DEVICE);
<a name="l06684"></a>06684             <span class="keywordflow">if</span> (dma_mapping_error(rx_ring-&gt;dev, buffer_info-&gt;page_dma)) {
<a name="l06685"></a>06685                 buffer_info-&gt;page_dma = 0;
<a name="l06686"></a>06686                 rx_ring-&gt;rx_stats.alloc_failed++;
<a name="l06687"></a>06687                 <span class="keywordflow">goto</span> no_buffers;
<a name="l06688"></a>06688             }
<a name="l06689"></a>06689         }
<a name="l06690"></a>06690 
<a name="l06691"></a>06691 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IGB_DISABLE_PACKET_SPLIT */</span>
<a name="l06692"></a>06692         <span class="comment">/* Refresh the desc even if buffer_addrs didn&#39;t change because</span>
<a name="l06693"></a>06693 <span class="comment">         * each write-back erases this info. */</span>
<a name="l06694"></a>06694 <span class="preprocessor">#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT</span>
<a name="l06695"></a>06695 <span class="preprocessor"></span>        rx_desc-&gt;read.pkt_addr = cpu_to_le64(buffer_info-&gt;page_dma);
<a name="l06696"></a>06696         rx_desc-&gt;read.hdr_addr = cpu_to_le64(buffer_info-&gt;dma);
<a name="l06697"></a>06697 <span class="preprocessor">#else</span>
<a name="l06698"></a>06698 <span class="preprocessor"></span>        rx_desc-&gt;read.pkt_addr = cpu_to_le64(buffer_info-&gt;dma);
<a name="l06699"></a>06699         rx_desc-&gt;read.hdr_addr = 0;
<a name="l06700"></a>06700 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IGB_DISABLE_PACKET_SPLIT */</span>
<a name="l06701"></a>06701 
<a name="l06702"></a>06702         i++;
<a name="l06703"></a>06703         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l06704"></a>06704             i = 0;
<a name="l06705"></a>06705     }
<a name="l06706"></a>06706 
<a name="l06707"></a>06707 no_buffers:
<a name="l06708"></a>06708     <span class="keywordflow">if</span> (rx_ring-&gt;next_to_use != i) {
<a name="l06709"></a>06709         rx_ring-&gt;next_to_use = i;
<a name="l06710"></a>06710 
<a name="l06711"></a>06711         <span class="comment">/* Force memory writes to complete before letting h/w</span>
<a name="l06712"></a>06712 <span class="comment">         * know there are new descriptors to fetch.  (Only</span>
<a name="l06713"></a>06713 <span class="comment">         * applicable for weak-ordered memory model archs,</span>
<a name="l06714"></a>06714 <span class="comment">         * such as IA-64). */</span>
<a name="l06715"></a>06715         wmb();
<a name="l06716"></a>06716         writel(i, rx_ring-&gt;tail);
<a name="l06717"></a>06717     }
<a name="l06718"></a>06718 }
<a name="l06719"></a>06719 
<a name="l06720"></a>06720 <span class="preprocessor">#ifdef SIOCGMIIPHY</span>
<a name="l06721"></a>06721 <span class="preprocessor"></span>
<a name="l06727"></a>06727 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_mii_ioctl(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *ifr, <span class="keywordtype">int</span> cmd)
<a name="l06728"></a>06728 {
<a name="l06729"></a>06729     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06730"></a>06730     <span class="keyword">struct </span>mii_ioctl_data *data = if_mii(ifr);
<a name="l06731"></a>06731 
<a name="l06732"></a>06732     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.media_type != e1000_media_type_copper)
<a name="l06733"></a>06733         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l06734"></a>06734 
<a name="l06735"></a>06735     <span class="keywordflow">switch</span> (cmd) {
<a name="l06736"></a>06736     <span class="keywordflow">case</span> SIOCGMIIPHY:
<a name="l06737"></a>06737         data-&gt;phy_id = adapter-&gt;hw.phy.addr;
<a name="l06738"></a>06738         <span class="keywordflow">break</span>;
<a name="l06739"></a>06739     <span class="keywordflow">case</span> SIOCGMIIREG:
<a name="l06740"></a>06740         <span class="keywordflow">if</span> (!capable(CAP_NET_ADMIN))
<a name="l06741"></a>06741             <span class="keywordflow">return</span> -EPERM;
<a name="l06742"></a>06742         <span class="keywordflow">if</span> (e1000_read_phy_reg(&amp;adapter-&gt;hw, data-&gt;reg_num &amp; 0x1F,
<a name="l06743"></a>06743                    &amp;data-&gt;val_out))
<a name="l06744"></a>06744             <span class="keywordflow">return</span> -EIO;
<a name="l06745"></a>06745         <span class="keywordflow">break</span>;
<a name="l06746"></a>06746     <span class="keywordflow">case</span> SIOCSMIIREG:
<a name="l06747"></a>06747     <span class="keywordflow">default</span>:
<a name="l06748"></a>06748         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l06749"></a>06749     }
<a name="l06750"></a>06750     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l06751"></a>06751 }
<a name="l06752"></a>06752 
<a name="l06753"></a>06753 <span class="preprocessor">#endif</span>
<a name="l06754"></a>06754 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l06755"></a>06755 <span class="preprocessor"></span>
<a name="l06774"></a>06774 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_hwtstamp_ioctl(<span class="keyword">struct</span> net_device *netdev,
<a name="l06775"></a>06775                   <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *ifr, <span class="keywordtype">int</span> cmd)
<a name="l06776"></a>06776 {
<a name="l06777"></a>06777     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06778"></a>06778     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06779"></a>06779     <span class="keyword">struct </span>hwtstamp_config config;
<a name="l06780"></a>06780     u32 tsync_tx_ctl = E1000_TSYNCTXCTL_ENABLED;
<a name="l06781"></a>06781     u32 tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;
<a name="l06782"></a>06782     u32 tsync_rx_cfg = 0;
<a name="l06783"></a>06783     <span class="keywordtype">bool</span> is_l4 = <span class="keyword">false</span>;
<a name="l06784"></a>06784     <span class="keywordtype">bool</span> is_l2 = <span class="keyword">false</span>;
<a name="l06785"></a>06785     u32 regval;
<a name="l06786"></a>06786 
<a name="l06787"></a>06787     <span class="keywordflow">if</span> (copy_from_user(&amp;config, ifr-&gt;ifr_data, <span class="keyword">sizeof</span>(config)))
<a name="l06788"></a>06788         <span class="keywordflow">return</span> -EFAULT;
<a name="l06789"></a>06789 
<a name="l06790"></a>06790     <span class="comment">/* reserved for future extensions */</span>
<a name="l06791"></a>06791     <span class="keywordflow">if</span> (config.flags)
<a name="l06792"></a>06792         <span class="keywordflow">return</span> -EINVAL;
<a name="l06793"></a>06793 
<a name="l06794"></a>06794     <span class="keywordflow">switch</span> (config.tx_type) {
<a name="l06795"></a>06795     <span class="keywordflow">case</span> HWTSTAMP_TX_OFF:
<a name="l06796"></a>06796         tsync_tx_ctl = 0;
<a name="l06797"></a>06797     <span class="keywordflow">case</span> HWTSTAMP_TX_ON:
<a name="l06798"></a>06798         <span class="keywordflow">break</span>;
<a name="l06799"></a>06799     <span class="keywordflow">default</span>:
<a name="l06800"></a>06800         <span class="keywordflow">return</span> -ERANGE;
<a name="l06801"></a>06801     }
<a name="l06802"></a>06802 
<a name="l06803"></a>06803     <span class="keywordflow">switch</span> (config.rx_filter) {
<a name="l06804"></a>06804     <span class="keywordflow">case</span> HWTSTAMP_FILTER_NONE:
<a name="l06805"></a>06805         tsync_rx_ctl = 0;
<a name="l06806"></a>06806         <span class="keywordflow">break</span>;
<a name="l06807"></a>06807     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
<a name="l06808"></a>06808     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
<a name="l06809"></a>06809     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
<a name="l06810"></a>06810     <span class="keywordflow">case</span> HWTSTAMP_FILTER_ALL:
<a name="l06811"></a>06811         <span class="comment">/*</span>
<a name="l06812"></a>06812 <span class="comment">         * register TSYNCRXCFG must be set, therefore it is not</span>
<a name="l06813"></a>06813 <span class="comment">         * possible to time stamp both Sync and Delay_Req messages</span>
<a name="l06814"></a>06814 <span class="comment">         * =&gt; fall back to time stamping all packets</span>
<a name="l06815"></a>06815 <span class="comment">         */</span>
<a name="l06816"></a>06816         tsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;
<a name="l06817"></a>06817         config.rx_filter = HWTSTAMP_FILTER_ALL;
<a name="l06818"></a>06818         <span class="keywordflow">break</span>;
<a name="l06819"></a>06819     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
<a name="l06820"></a>06820         tsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;
<a name="l06821"></a>06821         tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE;
<a name="l06822"></a>06822         is_l4 = <span class="keyword">true</span>;
<a name="l06823"></a>06823         <span class="keywordflow">break</span>;
<a name="l06824"></a>06824     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
<a name="l06825"></a>06825         tsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;
<a name="l06826"></a>06826         tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE;
<a name="l06827"></a>06827         is_l4 = <span class="keyword">true</span>;
<a name="l06828"></a>06828         <span class="keywordflow">break</span>;
<a name="l06829"></a>06829     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
<a name="l06830"></a>06830     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
<a name="l06831"></a>06831         tsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;
<a name="l06832"></a>06832         tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V2_SYNC_MESSAGE;
<a name="l06833"></a>06833         is_l2 = <span class="keyword">true</span>;
<a name="l06834"></a>06834         is_l4 = <span class="keyword">true</span>;
<a name="l06835"></a>06835         config.rx_filter = HWTSTAMP_FILTER_SOME;
<a name="l06836"></a>06836         <span class="keywordflow">break</span>;
<a name="l06837"></a>06837     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
<a name="l06838"></a>06838     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
<a name="l06839"></a>06839         tsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;
<a name="l06840"></a>06840         tsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V2_DELAY_REQ_MESSAGE;
<a name="l06841"></a>06841         is_l2 = <span class="keyword">true</span>;
<a name="l06842"></a>06842         is_l4 = <span class="keyword">true</span>;
<a name="l06843"></a>06843         config.rx_filter = HWTSTAMP_FILTER_SOME;
<a name="l06844"></a>06844         <span class="keywordflow">break</span>;
<a name="l06845"></a>06845     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_EVENT:
<a name="l06846"></a>06846     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_SYNC:
<a name="l06847"></a>06847     <span class="keywordflow">case</span> HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
<a name="l06848"></a>06848         tsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_EVENT_V2;
<a name="l06849"></a>06849         config.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
<a name="l06850"></a>06850         is_l2 = <span class="keyword">true</span>;
<a name="l06851"></a>06851         <span class="keywordflow">break</span>;
<a name="l06852"></a>06852     <span class="keywordflow">default</span>:
<a name="l06853"></a>06853         <span class="keywordflow">return</span> -ERANGE;
<a name="l06854"></a>06854     }
<a name="l06855"></a>06855 
<a name="l06856"></a>06856     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82575) {
<a name="l06857"></a>06857         <span class="keywordflow">if</span> (tsync_rx_ctl | tsync_tx_ctl)
<a name="l06858"></a>06858             <span class="keywordflow">return</span> -EINVAL;
<a name="l06859"></a>06859         <span class="keywordflow">return</span> 0;
<a name="l06860"></a>06860     }
<a name="l06861"></a>06861 
<a name="l06862"></a>06862 <span class="preprocessor">#ifdef IGB_PER_PKT_TIMESTAMP</span>
<a name="l06863"></a>06863 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l06864"></a>06864 <span class="comment">     * Per-packet timestamping only works if all packets are</span>
<a name="l06865"></a>06865 <span class="comment">     * timestamped, so enable timestamping in all packets as</span>
<a name="l06866"></a>06866 <span class="comment">     * long as one rx filter was configured.</span>
<a name="l06867"></a>06867 <span class="comment">     */</span>
<a name="l06868"></a>06868     <span class="keywordflow">if</span> ((hw-&gt;mac.type == e1000_82580) &amp;&amp; tsync_rx_ctl) {
<a name="l06869"></a>06869         tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;
<a name="l06870"></a>06870         tsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;
<a name="l06871"></a>06871     }
<a name="l06872"></a>06872 <span class="preprocessor">#endif</span>
<a name="l06873"></a>06873 <span class="preprocessor"></span>
<a name="l06874"></a>06874     <span class="comment">/* enable/disable TX */</span>
<a name="l06875"></a>06875     regval = E1000_READ_REG(hw, E1000_TSYNCTXCTL);
<a name="l06876"></a>06876     regval &amp;= ~E1000_TSYNCTXCTL_ENABLED;
<a name="l06877"></a>06877     regval |= tsync_tx_ctl;
<a name="l06878"></a>06878     E1000_WRITE_REG(hw, E1000_TSYNCTXCTL, regval);
<a name="l06879"></a>06879 
<a name="l06880"></a>06880     <span class="comment">/* enable/disable RX */</span>
<a name="l06881"></a>06881     regval = E1000_READ_REG(hw, E1000_TSYNCRXCTL);
<a name="l06882"></a>06882     regval &amp;= ~(E1000_TSYNCRXCTL_ENABLED | E1000_TSYNCRXCTL_TYPE_MASK);
<a name="l06883"></a>06883     regval |= tsync_rx_ctl;
<a name="l06884"></a>06884     E1000_WRITE_REG(hw, E1000_TSYNCRXCTL, regval);
<a name="l06885"></a>06885 
<a name="l06886"></a>06886     <span class="comment">/* define which PTP packets are time stamped */</span>
<a name="l06887"></a>06887     E1000_WRITE_REG(hw, E1000_TSYNCRXCFG, tsync_rx_cfg);
<a name="l06888"></a>06888 
<a name="l06889"></a>06889     <span class="comment">/* define ethertype filter for timestamped packets */</span>
<a name="l06890"></a>06890     <span class="keywordflow">if</span> (is_l2)
<a name="l06891"></a>06891         E1000_WRITE_REG(hw, E1000_ETQF(3),
<a name="l06892"></a>06892                         (E1000_ETQF_FILTER_ENABLE | <span class="comment">/* enable filter */</span>
<a name="l06893"></a>06893                          E1000_ETQF_1588 | <span class="comment">/* enable timestamping */</span>
<a name="l06894"></a>06894                          ETH_P_1588));     <span class="comment">/* 1588 eth protocol type */</span>
<a name="l06895"></a>06895     <span class="keywordflow">else</span>
<a name="l06896"></a>06896         E1000_WRITE_REG(hw, E1000_ETQF(3), 0);
<a name="l06897"></a>06897 
<a name="l06898"></a>06898 <span class="preprocessor">#define PTP_PORT 319</span>
<a name="l06899"></a>06899 <span class="preprocessor"></span>    <span class="comment">/* L4 Queue Filter[3]: filter by destination port and protocol */</span>
<a name="l06900"></a>06900     <span class="keywordflow">if</span> (is_l4) {
<a name="l06901"></a>06901         u32 ftqf = (IPPROTO_UDP <span class="comment">/* UDP */</span>
<a name="l06902"></a>06902             | E1000_FTQF_VF_BP <span class="comment">/* VF not compared */</span>
<a name="l06903"></a>06903             | E1000_FTQF_1588_TIME_STAMP <span class="comment">/* Enable Timestamping */</span>
<a name="l06904"></a>06904             | E1000_FTQF_MASK); <span class="comment">/* mask all inputs */</span>
<a name="l06905"></a>06905         ftqf &amp;= ~E1000_FTQF_MASK_PROTO_BP; <span class="comment">/* enable protocol check */</span>
<a name="l06906"></a>06906 
<a name="l06907"></a>06907         E1000_WRITE_REG(hw, E1000_IMIR(3), htons(PTP_PORT));
<a name="l06908"></a>06908         E1000_WRITE_REG(hw, E1000_IMIREXT(3),
<a name="l06909"></a>06909                 (E1000_IMIREXT_SIZE_BP | E1000_IMIREXT_CTRL_BP));
<a name="l06910"></a>06910         <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82576) {
<a name="l06911"></a>06911             <span class="comment">/* enable source port check */</span>
<a name="l06912"></a>06912             E1000_WRITE_REG(hw, E1000_SPQF(3), htons(PTP_PORT));
<a name="l06913"></a>06913             ftqf &amp;= ~E1000_FTQF_MASK_SOURCE_PORT_BP;
<a name="l06914"></a>06914         }
<a name="l06915"></a>06915         E1000_WRITE_REG(hw, E1000_FTQF(3), ftqf);
<a name="l06916"></a>06916     } <span class="keywordflow">else</span> {
<a name="l06917"></a>06917         E1000_WRITE_REG(hw, E1000_FTQF(3), E1000_FTQF_MASK);
<a name="l06918"></a>06918     }
<a name="l06919"></a>06919     E1000_WRITE_FLUSH(hw);
<a name="l06920"></a>06920 
<a name="l06921"></a>06921     adapter-&gt;hwtstamp_config = config;
<a name="l06922"></a>06922 
<a name="l06923"></a>06923     <span class="comment">/* clear TX/RX time stamp registers, just to be sure */</span>
<a name="l06924"></a>06924     regval = E1000_READ_REG(hw, E1000_TXSTMPH);
<a name="l06925"></a>06925     regval = E1000_READ_REG(hw, E1000_RXSTMPH);
<a name="l06926"></a>06926 
<a name="l06927"></a>06927     <span class="keywordflow">return</span> copy_to_user(ifr-&gt;ifr_data, &amp;config, <span class="keyword">sizeof</span>(config)) ?
<a name="l06928"></a>06928         -EFAULT : 0;
<a name="l06929"></a>06929 }
<a name="l06930"></a>06930 
<a name="l06931"></a>06931 <span class="preprocessor">#endif</span>
<a name="l06932"></a>06932 <span class="preprocessor"></span>
<a name="l06938"></a>06938 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ioctl(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *ifr, <span class="keywordtype">int</span> cmd)
<a name="l06939"></a>06939 {
<a name="l06940"></a>06940     <span class="keywordflow">switch</span> (cmd) {
<a name="l06941"></a>06941 <span class="preprocessor">#ifdef SIOCGMIIPHY</span>
<a name="l06942"></a>06942 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCGMIIPHY:
<a name="l06943"></a>06943     <span class="keywordflow">case</span> SIOCGMIIREG:
<a name="l06944"></a>06944     <span class="keywordflow">case</span> SIOCSMIIREG:
<a name="l06945"></a>06945         <span class="keywordflow">return</span> igb_mii_ioctl(netdev, ifr, cmd);
<a name="l06946"></a>06946 <span class="preprocessor">#endif</span>
<a name="l06947"></a>06947 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_HW_TIME_STAMP</span>
<a name="l06948"></a>06948 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCSHWTSTAMP:
<a name="l06949"></a>06949         <span class="keywordflow">return</span> igb_hwtstamp_ioctl(netdev, ifr, cmd);
<a name="l06950"></a>06950 <span class="preprocessor">#endif</span>
<a name="l06951"></a>06951 <span class="preprocessor"></span><span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l06952"></a>06952 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCETHTOOL:
<a name="l06953"></a>06953         <span class="keywordflow">return</span> ethtool_ioctl(ifr);
<a name="l06954"></a>06954 <span class="preprocessor">#endif</span>
<a name="l06955"></a>06955 <span class="preprocessor"></span>    <span class="keywordflow">default</span>:
<a name="l06956"></a>06956         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l06957"></a>06957     }
<a name="l06958"></a>06958 }
<a name="l06959"></a>06959 
<a name="l06960"></a>06960 s32 e1000_read_pcie_cap_reg(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 reg, u16 *value)
<a name="l06961"></a>06961 {
<a name="l06962"></a>06962     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = hw-&gt;back;
<a name="l06963"></a>06963     u16 cap_offset;
<a name="l06964"></a>06964 
<a name="l06965"></a>06965     cap_offset = pci_find_capability(adapter-&gt;pdev, PCI_CAP_ID_EXP);
<a name="l06966"></a>06966     <span class="keywordflow">if</span> (!cap_offset)
<a name="l06967"></a>06967         <span class="keywordflow">return</span> -E1000_ERR_CONFIG;
<a name="l06968"></a>06968 
<a name="l06969"></a>06969     pci_read_config_word(adapter-&gt;pdev, cap_offset + reg, value);
<a name="l06970"></a>06970 
<a name="l06971"></a>06971     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l06972"></a>06972 }
<a name="l06973"></a>06973 
<a name="l06974"></a>06974 s32 e1000_write_pcie_cap_reg(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 reg, u16 *value)
<a name="l06975"></a>06975 {
<a name="l06976"></a>06976     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = hw-&gt;back;
<a name="l06977"></a>06977     u16 cap_offset;
<a name="l06978"></a>06978 
<a name="l06979"></a>06979     cap_offset = pci_find_capability(adapter-&gt;pdev, PCI_CAP_ID_EXP);
<a name="l06980"></a>06980     <span class="keywordflow">if</span> (!cap_offset)
<a name="l06981"></a>06981         <span class="keywordflow">return</span> -E1000_ERR_CONFIG;
<a name="l06982"></a>06982 
<a name="l06983"></a>06983     pci_write_config_word(adapter-&gt;pdev, cap_offset + reg, *value);
<a name="l06984"></a>06984 
<a name="l06985"></a>06985     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l06986"></a>06986 }
<a name="l06987"></a>06987 
<a name="l06988"></a>06988 <span class="keywordtype">void</span> igb_enable_vlan_tags(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l06989"></a>06989 {
<a name="l06990"></a>06990     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06991"></a>06991     u32 ctrl, rctl;
<a name="l06992"></a>06992     <span class="keywordtype">int</span> enable = <span class="keyword">false</span>;
<a name="l06993"></a>06993 <span class="preprocessor">#ifdef CONFIG_IGB_VMDQ_NETDEV</span>
<a name="l06994"></a>06994 <span class="preprocessor"></span>    <span class="keyword">struct </span>igb_vmdq_adapter *vadapter;
<a name="l06995"></a>06995     <span class="keywordtype">int</span> i;
<a name="l06996"></a>06996 
<a name="l06997"></a>06997     <span class="keywordflow">for</span> (i = 1; i &lt; adapter-&gt;vmdq_pools; i++) {
<a name="l06998"></a>06998         vadapter = netdev_priv(adapter-&gt;vmdq_netdev[i-1]);
<a name="l06999"></a>06999         <span class="keywordflow">if</span> (vadapter-&gt;vlgrp) {
<a name="l07000"></a>07000             enable = <span class="keyword">true</span>;
<a name="l07001"></a>07001             igb_set_vf_vlan_strip(adapter, 
<a name="l07002"></a>07002                           adapter-&gt;vfs_allocated_count + i,
<a name="l07003"></a>07003                           <span class="keyword">true</span>);
<a name="l07004"></a>07004         } <span class="keywordflow">else</span>
<a name="l07005"></a>07005             igb_set_vf_vlan_strip(adapter, 
<a name="l07006"></a>07006                           adapter-&gt;vfs_allocated_count + i,
<a name="l07007"></a>07007                           <span class="keyword">false</span>);
<a name="l07008"></a>07008     }
<a name="l07009"></a>07009 
<a name="l07010"></a>07010 <span class="preprocessor">#endif</span>
<a name="l07011"></a>07011 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;vlgrp)
<a name="l07012"></a>07012         enable = <span class="keyword">true</span>;
<a name="l07013"></a>07013 
<a name="l07014"></a>07014     <span class="keywordflow">if</span> (enable) {
<a name="l07015"></a>07015         <span class="comment">/* enable VLAN tag insert/strip */</span>
<a name="l07016"></a>07016         ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l07017"></a>07017         ctrl |= E1000_CTRL_VME;
<a name="l07018"></a>07018         E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l07019"></a>07019 
<a name="l07020"></a>07020         <span class="comment">/* Disable CFI check */</span>
<a name="l07021"></a>07021         rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l07022"></a>07022         rctl &amp;= ~E1000_RCTL_CFIEN;
<a name="l07023"></a>07023         E1000_WRITE_REG(hw, E1000_RCTL, rctl);
<a name="l07024"></a>07024     } <span class="keywordflow">else</span> {
<a name="l07025"></a>07025         <span class="comment">/* disable VLAN tag insert/strip */</span>
<a name="l07026"></a>07026         ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l07027"></a>07027         ctrl &amp;= ~E1000_CTRL_VME;
<a name="l07028"></a>07028         E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l07029"></a>07029     }
<a name="l07030"></a>07030     igb_rlpml_set(adapter);
<a name="l07031"></a>07031 }
<a name="l07032"></a>07032 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vlan_rx_register(<span class="keyword">struct</span> net_device *netdev,
<a name="l07033"></a>07033                  <span class="keyword">struct</span> vlan_group *grp)
<a name="l07034"></a>07034 {
<a name="l07035"></a>07035     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07036"></a>07036 
<a name="l07037"></a>07037     igb_irq_disable(adapter);
<a name="l07038"></a>07038     adapter-&gt;vlgrp = grp;
<a name="l07039"></a>07039 
<a name="l07040"></a>07040     igb_enable_vlan_tags(adapter);
<a name="l07041"></a>07041 
<a name="l07042"></a>07042     <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l07043"></a>07043         igb_irq_enable(adapter);
<a name="l07044"></a>07044 }
<a name="l07045"></a>07045 
<a name="l07046"></a>07046 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vlan_rx_add_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l07047"></a>07047 {
<a name="l07048"></a>07048     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07049"></a>07049     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07050"></a>07050     <span class="keywordtype">int</span> pf_id = adapter-&gt;vfs_allocated_count;
<a name="l07051"></a>07051 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l07052"></a>07052 <span class="preprocessor"></span>    <span class="keyword">struct </span>net_device *v_netdev;
<a name="l07053"></a>07053 <span class="preprocessor">#endif</span>
<a name="l07054"></a>07054 <span class="preprocessor"></span>
<a name="l07055"></a>07055     <span class="comment">/* attempt to add filter to vlvf array */</span>
<a name="l07056"></a>07056     igb_vlvf_set(adapter, vid, TRUE, pf_id);
<a name="l07057"></a>07057 
<a name="l07058"></a>07058     <span class="comment">/* add the filter since PF can receive vlans w/o entry in vlvf */</span>
<a name="l07059"></a>07059     igb_vfta_set(hw, vid, TRUE);
<a name="l07060"></a>07060 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l07061"></a>07061 <span class="preprocessor"></span>
<a name="l07062"></a>07062     <span class="comment">/* Copy feature flags from netdev to the vlan netdev for this vid.</span>
<a name="l07063"></a>07063 <span class="comment">     * This allows things like TSO to bubble down to our vlan device.</span>
<a name="l07064"></a>07064 <span class="comment">     */</span>
<a name="l07065"></a>07065     v_netdev = vlan_group_get_device(adapter-&gt;vlgrp, vid);
<a name="l07066"></a>07066     v_netdev-&gt;features |= adapter-&gt;netdev-&gt;features;
<a name="l07067"></a>07067     vlan_group_set_device(adapter-&gt;vlgrp, vid, v_netdev);
<a name="l07068"></a>07068 <span class="preprocessor">#endif</span>
<a name="l07069"></a>07069 <span class="preprocessor"></span>}
<a name="l07070"></a>07070 
<a name="l07071"></a>07071 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_vlan_rx_kill_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l07072"></a>07072 {
<a name="l07073"></a>07073     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07074"></a>07074     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07075"></a>07075     <span class="keywordtype">int</span> pf_id = adapter-&gt;vfs_allocated_count;
<a name="l07076"></a>07076     s32 err;
<a name="l07077"></a>07077 
<a name="l07078"></a>07078     igb_irq_disable(adapter);
<a name="l07079"></a>07079     vlan_group_set_device(adapter-&gt;vlgrp, vid, NULL);
<a name="l07080"></a>07080 
<a name="l07081"></a>07081     <span class="keywordflow">if</span> (!test_bit(__IGB_DOWN, &amp;adapter-&gt;state))
<a name="l07082"></a>07082         igb_irq_enable(adapter);
<a name="l07083"></a>07083 
<a name="l07084"></a>07084     <span class="comment">/* remove vlan from VLVF table array */</span>
<a name="l07085"></a>07085     err = igb_vlvf_set(adapter, vid, FALSE, pf_id);
<a name="l07086"></a>07086 
<a name="l07087"></a>07087     <span class="comment">/* if vid was not present in VLVF just remove it from table */</span>
<a name="l07088"></a>07088     <span class="keywordflow">if</span> (err)
<a name="l07089"></a>07089         igb_vfta_set(hw, vid, FALSE);
<a name="l07090"></a>07090 }
<a name="l07091"></a>07091 
<a name="l07092"></a>07092 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_restore_vlan(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l07093"></a>07093 {
<a name="l07094"></a>07094     igb_vlan_rx_register(adapter-&gt;netdev, adapter-&gt;vlgrp);
<a name="l07095"></a>07095 
<a name="l07096"></a>07096     <span class="keywordflow">if</span> (adapter-&gt;vlgrp) {
<a name="l07097"></a>07097         u16 vid;
<a name="l07098"></a>07098         <span class="keywordflow">for</span> (vid = 0; vid &lt; VLAN_N_VID; vid++) {
<a name="l07099"></a>07099             <span class="keywordflow">if</span> (!vlan_group_get_device(adapter-&gt;vlgrp, vid))
<a name="l07100"></a>07100                 <span class="keywordflow">continue</span>;
<a name="l07101"></a>07101             igb_vlan_rx_add_vid(adapter-&gt;netdev, vid);
<a name="l07102"></a>07102         }
<a name="l07103"></a>07103     }
<a name="l07104"></a>07104 }
<a name="l07105"></a>07105 
<a name="l07106"></a>07106 <span class="keywordtype">int</span> igb_set_spd_dplx(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u16 spddplx)
<a name="l07107"></a>07107 {
<a name="l07108"></a>07108     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l07109"></a>07109     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;adapter-&gt;hw.mac;
<a name="l07110"></a>07110 
<a name="l07111"></a>07111     mac-&gt;autoneg = 0;
<a name="l07112"></a>07112 
<a name="l07113"></a>07113     <span class="comment">/* Fiber NIC&#39;s only allow 1000 gbps Full duplex */</span>
<a name="l07114"></a>07114     <span class="keywordflow">if</span> ((adapter-&gt;hw.phy.media_type == e1000_media_type_internal_serdes ) &amp;&amp;
<a name="l07115"></a>07115         spddplx != (SPEED_1000 + DUPLEX_FULL)) {
<a name="l07116"></a>07116         dev_err(pci_dev_to_dev(pdev),
<a name="l07117"></a>07117                 <span class="stringliteral">&quot;Unsupported Speed/Duplex configuration\n&quot;</span>);
<a name="l07118"></a>07118         <span class="keywordflow">return</span> -EINVAL;
<a name="l07119"></a>07119     }
<a name="l07120"></a>07120 
<a name="l07121"></a>07121     <span class="keywordflow">switch</span> (spddplx) {
<a name="l07122"></a>07122     <span class="keywordflow">case</span> SPEED_10 + DUPLEX_HALF:
<a name="l07123"></a>07123         mac-&gt;forced_speed_duplex = ADVERTISE_10_HALF;
<a name="l07124"></a>07124         <span class="keywordflow">break</span>;
<a name="l07125"></a>07125     <span class="keywordflow">case</span> SPEED_10 + DUPLEX_FULL:
<a name="l07126"></a>07126         mac-&gt;forced_speed_duplex = ADVERTISE_10_FULL;
<a name="l07127"></a>07127         <span class="keywordflow">break</span>;
<a name="l07128"></a>07128     <span class="keywordflow">case</span> SPEED_100 + DUPLEX_HALF:
<a name="l07129"></a>07129         mac-&gt;forced_speed_duplex = ADVERTISE_100_HALF;
<a name="l07130"></a>07130         <span class="keywordflow">break</span>;
<a name="l07131"></a>07131     <span class="keywordflow">case</span> SPEED_100 + DUPLEX_FULL:
<a name="l07132"></a>07132         mac-&gt;forced_speed_duplex = ADVERTISE_100_FULL;
<a name="l07133"></a>07133         <span class="keywordflow">break</span>;
<a name="l07134"></a>07134     <span class="keywordflow">case</span> SPEED_1000 + DUPLEX_FULL:
<a name="l07135"></a>07135         mac-&gt;autoneg = 1;
<a name="l07136"></a>07136         adapter-&gt;hw.phy.autoneg_advertised = ADVERTISE_1000_FULL;
<a name="l07137"></a>07137         <span class="keywordflow">break</span>;
<a name="l07138"></a>07138     <span class="keywordflow">case</span> SPEED_1000 + DUPLEX_HALF: <span class="comment">/* not supported */</span>
<a name="l07139"></a>07139     <span class="keywordflow">default</span>:
<a name="l07140"></a>07140         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Unsupported Speed/Duplex configuration\n&quot;</span>);
<a name="l07141"></a>07141         <span class="keywordflow">return</span> -EINVAL;
<a name="l07142"></a>07142     }
<a name="l07143"></a>07143     <span class="keywordflow">return</span> 0;
<a name="l07144"></a>07144 }
<a name="l07145"></a>07145 
<a name="l07146"></a>07146 <span class="keyword">static</span> <span class="keywordtype">int</span> __igb_shutdown(<span class="keyword">struct</span> pci_dev *pdev, <span class="keywordtype">bool</span> *enable_wake)
<a name="l07147"></a>07147 {
<a name="l07148"></a>07148     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l07149"></a>07149     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07150"></a>07150     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07151"></a>07151     u32 ctrl, rctl, status;
<a name="l07152"></a>07152     u32 wufc = adapter-&gt;wol;
<a name="l07153"></a>07153 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l07154"></a>07154 <span class="preprocessor"></span>    <span class="keywordtype">int</span> retval = 0;
<a name="l07155"></a>07155 <span class="preprocessor">#endif</span>
<a name="l07156"></a>07156 <span class="preprocessor"></span>
<a name="l07157"></a>07157     netif_device_detach(netdev);
<a name="l07158"></a>07158 
<a name="l07159"></a>07159     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l07160"></a>07160         igb_close(netdev);
<a name="l07161"></a>07161 
<a name="l07162"></a>07162     igb_clear_interrupt_scheme(adapter);
<a name="l07163"></a>07163 
<a name="l07164"></a>07164 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l07165"></a>07165 <span class="preprocessor"></span>    retval = pci_save_state(pdev);
<a name="l07166"></a>07166     <span class="keywordflow">if</span> (retval)
<a name="l07167"></a>07167         <span class="keywordflow">return</span> retval;
<a name="l07168"></a>07168 <span class="preprocessor">#endif</span>
<a name="l07169"></a>07169 <span class="preprocessor"></span>
<a name="l07170"></a>07170     status = E1000_READ_REG(hw, E1000_STATUS);
<a name="l07171"></a>07171     <span class="keywordflow">if</span> (status &amp; E1000_STATUS_LU)
<a name="l07172"></a>07172         wufc &amp;= ~E1000_WUFC_LNKC;
<a name="l07173"></a>07173 
<a name="l07174"></a>07174     <span class="keywordflow">if</span> (wufc) {
<a name="l07175"></a>07175         igb_setup_rctl(adapter);
<a name="l07176"></a>07176         igb_set_rx_mode(netdev);
<a name="l07177"></a>07177 
<a name="l07178"></a>07178         <span class="comment">/* turn on all-multi mode if wake on multicast is enabled */</span>
<a name="l07179"></a>07179         <span class="keywordflow">if</span> (wufc &amp; E1000_WUFC_MC) {
<a name="l07180"></a>07180             rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l07181"></a>07181             rctl |= E1000_RCTL_MPE;
<a name="l07182"></a>07182             E1000_WRITE_REG(hw, E1000_RCTL, rctl);
<a name="l07183"></a>07183         }
<a name="l07184"></a>07184 
<a name="l07185"></a>07185         ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l07186"></a>07186         <span class="comment">/* phy power management enable */</span>
<a name="l07187"></a>07187 <span class="preprocessor">        #define E1000_CTRL_EN_PHY_PWR_MGMT 0x00200000</span>
<a name="l07188"></a>07188 <span class="preprocessor"></span>        ctrl |= E1000_CTRL_ADVD3WUC;
<a name="l07189"></a>07189         E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l07190"></a>07190 
<a name="l07191"></a>07191         <span class="comment">/* Allow time for pending master requests to run */</span>
<a name="l07192"></a>07192         e1000_disable_pcie_master(hw);
<a name="l07193"></a>07193 
<a name="l07194"></a>07194         E1000_WRITE_REG(hw, E1000_WUC, E1000_WUC_PME_EN);
<a name="l07195"></a>07195         E1000_WRITE_REG(hw, E1000_WUFC, wufc);
<a name="l07196"></a>07196     } <span class="keywordflow">else</span> {
<a name="l07197"></a>07197         E1000_WRITE_REG(hw, E1000_WUC, 0);
<a name="l07198"></a>07198         E1000_WRITE_REG(hw, E1000_WUFC, 0);
<a name="l07199"></a>07199     }
<a name="l07200"></a>07200 
<a name="l07201"></a>07201     *enable_wake = wufc || adapter-&gt;en_mng_pt;
<a name="l07202"></a>07202     <span class="keywordflow">if</span> (!*enable_wake)
<a name="l07203"></a>07203         igb_power_down_link(adapter);
<a name="l07204"></a>07204     <span class="keywordflow">else</span>
<a name="l07205"></a>07205         igb_power_up_link(adapter);
<a name="l07206"></a>07206 
<a name="l07207"></a>07207     <span class="comment">/* Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<a name="l07208"></a>07208 <span class="comment">     * would have already happened in close and is redundant. */</span>
<a name="l07209"></a>07209     igb_release_hw_control(adapter);
<a name="l07210"></a>07210 
<a name="l07211"></a>07211     pci_disable_device(pdev);
<a name="l07212"></a>07212 
<a name="l07213"></a>07213     <span class="keywordflow">return</span> 0;
<a name="l07214"></a>07214 }
<a name="l07215"></a>07215 
<a name="l07216"></a>07216 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l07217"></a>07217 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> igb_suspend(<span class="keyword">struct</span> pci_dev *pdev, pm_message_t <a class="code" href="structstate.html">state</a>)
<a name="l07218"></a>07218 {
<a name="l07219"></a>07219 <span class="preprocessor">#define E1000_PMCSR       0x0044</span>
<a name="l07220"></a>07220 <span class="preprocessor"></span><span class="preprocessor">#define E1000_PMCSR_PS_D3 0x00000003</span>
<a name="l07221"></a>07221 <span class="preprocessor"></span>        <span class="keyword">struct </span>net_device *netdev = NULL;
<a name="l07222"></a>07222         <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = NULL;
<a name="l07223"></a>07223         <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = NULL;
<a name="l07224"></a>07224         u32 pmcsr = 0;
<a name="l07225"></a>07225     <span class="keywordtype">int</span> retval;
<a name="l07226"></a>07226     <span class="keywordtype">bool</span> wake;
<a name="l07227"></a>07227 
<a name="l07228"></a>07228     retval = __igb_shutdown(pdev, &amp;wake);
<a name="l07229"></a>07229     <span class="keywordflow">if</span> (retval)
<a name="l07230"></a>07230         <span class="keywordflow">return</span> retval;
<a name="l07231"></a>07231 
<a name="l07232"></a>07232     <span class="keywordflow">if</span> (wake) {
<a name="l07233"></a>07233         pci_prepare_to_sleep(pdev);
<a name="l07234"></a>07234     } <span class="keywordflow">else</span> {
<a name="l07235"></a>07235         pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l07236"></a>07236         pci_set_power_state(pdev, PCI_D3hot);
<a name="l07237"></a>07237     }
<a name="l07238"></a>07238 
<a name="l07239"></a>07239         <span class="comment">/* This is WoL workaround for DH89xxCC */</span>
<a name="l07240"></a>07240         <span class="keywordflow">switch</span> (pdev-&gt;device) {
<a name="l07241"></a>07241         <span class="keywordflow">case</span> E1000_DEV_ID_DH89XXCC_SFP:
<a name="l07242"></a>07242         <span class="keywordflow">case</span> E1000_DEV_ID_DH89XXCC_BACKPLANE:
<a name="l07243"></a>07243         <span class="keywordflow">case</span> E1000_DEV_ID_DH89XXCC_SERDES:
<a name="l07244"></a>07244         <span class="keywordflow">case</span> E1000_DEV_ID_DH89XXCC_SGMII:
<a name="l07245"></a>07245                 netdev = pci_get_drvdata(pdev);
<a name="l07246"></a>07246                 adapter = netdev_priv(netdev);
<a name="l07247"></a>07247                 hw = &amp;adapter-&gt;hw;
<a name="l07248"></a>07248                 pmcsr = E1000_READ_REG( hw, E1000_PMCSR );
<a name="l07249"></a>07249                 pmcsr |= E1000_PMCSR_PS_D3;
<a name="l07250"></a>07250                 E1000_WRITE_REG( hw, E1000_PMCSR, pmcsr );
<a name="l07251"></a>07251                 E1000_WRITE_REG( hw, E1000_PMCSR, pmcsr );
<a name="l07252"></a>07252                 <span class="keywordflow">break</span>;
<a name="l07253"></a>07253         <span class="keywordflow">default</span>:
<a name="l07254"></a>07254                 <span class="keywordflow">break</span>;
<a name="l07255"></a>07255     }
<a name="l07256"></a>07256 
<a name="l07257"></a>07257     <span class="keywordflow">return</span> 0;
<a name="l07258"></a>07258 }
<a name="l07259"></a>07259 
<a name="l07260"></a>07260 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l07261"></a>07261 {
<a name="l07262"></a>07262     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l07263"></a>07263     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07264"></a>07264     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07265"></a>07265     u32 err;
<a name="l07266"></a>07266 
<a name="l07267"></a>07267     pci_set_power_state(pdev, PCI_D0);
<a name="l07268"></a>07268     pci_restore_state(pdev);
<a name="l07269"></a>07269     pci_save_state(pdev);
<a name="l07270"></a>07270 
<a name="l07271"></a>07271     err = pci_enable_device_mem(pdev);
<a name="l07272"></a>07272     <span class="keywordflow">if</span> (err) {
<a name="l07273"></a>07273         dev_err(pci_dev_to_dev(pdev),
<a name="l07274"></a>07274             <span class="stringliteral">&quot;igb: Cannot enable PCI device from suspend\n&quot;</span>);
<a name="l07275"></a>07275         <span class="keywordflow">return</span> err;
<a name="l07276"></a>07276     }
<a name="l07277"></a>07277     pci_set_master(pdev);
<a name="l07278"></a>07278 
<a name="l07279"></a>07279     pci_enable_wake(pdev, PCI_D3hot, 0);
<a name="l07280"></a>07280     pci_enable_wake(pdev, PCI_D3cold, 0);
<a name="l07281"></a>07281 
<a name="l07282"></a>07282     <span class="keywordflow">if</span> (igb_init_interrupt_scheme(adapter)) {
<a name="l07283"></a>07283         dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Unable to allocate memory for queues\n&quot;</span>);
<a name="l07284"></a>07284         <span class="keywordflow">return</span> -ENOMEM;
<a name="l07285"></a>07285     }
<a name="l07286"></a>07286 
<a name="l07287"></a>07287     igb_reset(adapter);
<a name="l07288"></a>07288 
<a name="l07289"></a>07289     <span class="comment">/* let the f/w know that the h/w is now under the control of the</span>
<a name="l07290"></a>07290 <span class="comment">     * driver. */</span>
<a name="l07291"></a>07291     igb_get_hw_control(adapter);
<a name="l07292"></a>07292 
<a name="l07293"></a>07293     E1000_WRITE_REG(hw, E1000_WUS, ~0);
<a name="l07294"></a>07294 
<a name="l07295"></a>07295     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l07296"></a>07296         err = igb_open(netdev);
<a name="l07297"></a>07297         <span class="keywordflow">if</span> (err)
<a name="l07298"></a>07298             <span class="keywordflow">return</span> err;
<a name="l07299"></a>07299     }
<a name="l07300"></a>07300 
<a name="l07301"></a>07301     netif_device_attach(netdev);
<a name="l07302"></a>07302 
<a name="l07303"></a>07303     <span class="keywordflow">return</span> 0;
<a name="l07304"></a>07304 }
<a name="l07305"></a>07305 <span class="preprocessor">#endif</span>
<a name="l07306"></a>07306 <span class="preprocessor"></span>
<a name="l07307"></a>07307 <span class="preprocessor">#ifdef USE_REBOOT_NOTIFIER</span>
<a name="l07308"></a>07308 <span class="preprocessor"></span><span class="comment">/* only want to do this for 2.4 kernels? */</span>
<a name="l07309"></a>07309 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_notify_reboot(<span class="keyword">struct</span> notifier_block *nb, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l07310"></a>07310                              <span class="keywordtype">void</span> *p)
<a name="l07311"></a>07311 {
<a name="l07312"></a>07312     <span class="keyword">struct </span>pci_dev *pdev = NULL;
<a name="l07313"></a>07313     <span class="keywordtype">bool</span> wake;
<a name="l07314"></a>07314 
<a name="l07315"></a>07315     <span class="keywordflow">switch</span> (event) {
<a name="l07316"></a>07316     <span class="keywordflow">case</span> SYS_DOWN:
<a name="l07317"></a>07317     <span class="keywordflow">case</span> SYS_HALT:
<a name="l07318"></a>07318     <span class="keywordflow">case</span> SYS_POWER_OFF:
<a name="l07319"></a>07319         <span class="keywordflow">while</span> ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev))) {
<a name="l07320"></a>07320             <span class="keywordflow">if</span> (pci_dev_driver(pdev) == &amp;igb_driver) {
<a name="l07321"></a>07321                 __igb_shutdown(pdev, &amp;wake);
<a name="l07322"></a>07322                 <span class="keywordflow">if</span> (event == SYS_POWER_OFF) {
<a name="l07323"></a>07323                     pci_wake_from_d3(pdev, wake);
<a name="l07324"></a>07324                     pci_set_power_state(pdev, PCI_D3hot);
<a name="l07325"></a>07325                 }
<a name="l07326"></a>07326             }
<a name="l07327"></a>07327         }
<a name="l07328"></a>07328     }
<a name="l07329"></a>07329     <span class="keywordflow">return</span> NOTIFY_DONE;
<a name="l07330"></a>07330 }
<a name="l07331"></a>07331 <span class="preprocessor">#else</span>
<a name="l07332"></a>07332 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_shutdown(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l07333"></a>07333 {
<a name="l07334"></a>07334     <span class="keywordtype">bool</span> wake;
<a name="l07335"></a>07335 
<a name="l07336"></a>07336     __igb_shutdown(pdev, &amp;wake);
<a name="l07337"></a>07337 
<a name="l07338"></a>07338     <span class="keywordflow">if</span> (system_state == SYSTEM_POWER_OFF) {
<a name="l07339"></a>07339         pci_wake_from_d3(pdev, wake);
<a name="l07340"></a>07340         pci_set_power_state(pdev, PCI_D3hot);
<a name="l07341"></a>07341     }
<a name="l07342"></a>07342 }
<a name="l07343"></a>07343 <span class="preprocessor">#endif </span><span class="comment">/* USE_REBOOT_NOTIFIER */</span>
<a name="l07344"></a>07344 
<a name="l07345"></a>07345 <span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l07346"></a>07346 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l07347"></a>07347 <span class="comment"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<a name="l07348"></a>07348 <span class="comment"> * without having to re-enable interrupts. It&#39;s not called while</span>
<a name="l07349"></a>07349 <span class="comment"> * the interrupt routine is executing.</span>
<a name="l07350"></a>07350 <span class="comment"> */</span>
<a name="l07351"></a>07351 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_netpoll(<span class="keyword">struct</span> net_device *netdev)
<a name="l07352"></a>07352 {
<a name="l07353"></a>07353     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07354"></a>07354     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07355"></a>07355     <span class="keyword">struct </span><a class="code" href="structigb__q__vector.html">igb_q_vector</a> *q_vector;
<a name="l07356"></a>07356     <span class="keywordtype">int</span> i;
<a name="l07357"></a>07357 
<a name="l07358"></a>07358     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_q_vectors; i++) {
<a name="l07359"></a>07359         q_vector = adapter-&gt;q_vector[i];
<a name="l07360"></a>07360         <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l07361"></a>07361             E1000_WRITE_REG(hw, E1000_EIMC, q_vector-&gt;eims_value);
<a name="l07362"></a>07362         <span class="keywordflow">else</span>
<a name="l07363"></a>07363             igb_irq_disable(adapter);
<a name="l07364"></a>07364         napi_schedule(&amp;q_vector-&gt;napi);
<a name="l07365"></a>07365     }
<a name="l07366"></a>07366 }
<a name="l07367"></a>07367 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_NET_POLL_CONTROLLER */</span>
<a name="l07368"></a>07368 
<a name="l07369"></a>07369 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l07370"></a>07370 <span class="preprocessor"></span>
<a name="l07378"></a>07378 <span class="keyword">static</span> pci_ers_result_t igb_io_error_detected(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l07379"></a>07379                           pci_channel_state_t state)
<a name="l07380"></a>07380 {
<a name="l07381"></a>07381     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l07382"></a>07382     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07383"></a>07383 
<a name="l07384"></a>07384     netif_device_detach(netdev);
<a name="l07385"></a>07385 
<a name="l07386"></a>07386     <span class="keywordflow">if</span> (state == pci_channel_io_perm_failure)
<a name="l07387"></a>07387         <span class="keywordflow">return</span> PCI_ERS_RESULT_DISCONNECT;
<a name="l07388"></a>07388 
<a name="l07389"></a>07389     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l07390"></a>07390         igb_down(adapter);
<a name="l07391"></a>07391     pci_disable_device(pdev);
<a name="l07392"></a>07392 
<a name="l07393"></a>07393     <span class="comment">/* Request a slot slot reset. */</span>
<a name="l07394"></a>07394     <span class="keywordflow">return</span> PCI_ERS_RESULT_NEED_RESET;
<a name="l07395"></a>07395 }
<a name="l07396"></a>07396 
<a name="l07404"></a>07404 <span class="keyword">static</span> pci_ers_result_t igb_io_slot_reset(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l07405"></a>07405 {
<a name="l07406"></a>07406     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l07407"></a>07407     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07408"></a>07408     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07409"></a>07409     pci_ers_result_t result;
<a name="l07410"></a>07410 
<a name="l07411"></a>07411     <span class="keywordflow">if</span> (pci_enable_device_mem(pdev)) {
<a name="l07412"></a>07412         dev_err(pci_dev_to_dev(pdev),
<a name="l07413"></a>07413             <span class="stringliteral">&quot;Cannot re-enable PCI device after reset.\n&quot;</span>);
<a name="l07414"></a>07414         result = PCI_ERS_RESULT_DISCONNECT;
<a name="l07415"></a>07415     } <span class="keywordflow">else</span> {
<a name="l07416"></a>07416         pci_set_master(pdev);
<a name="l07417"></a>07417         pci_restore_state(pdev);
<a name="l07418"></a>07418         pci_save_state(pdev);
<a name="l07419"></a>07419 
<a name="l07420"></a>07420         pci_enable_wake(pdev, PCI_D3hot, 0);
<a name="l07421"></a>07421         pci_enable_wake(pdev, PCI_D3cold, 0);
<a name="l07422"></a>07422 
<a name="l07423"></a>07423         igb_reset(adapter);
<a name="l07424"></a>07424         E1000_WRITE_REG(hw, E1000_WUS, ~0);
<a name="l07425"></a>07425         result = PCI_ERS_RESULT_RECOVERED;
<a name="l07426"></a>07426     }
<a name="l07427"></a>07427 
<a name="l07428"></a>07428     pci_cleanup_aer_uncorrect_error_status(pdev);
<a name="l07429"></a>07429 
<a name="l07430"></a>07430     <span class="keywordflow">return</span> result;
<a name="l07431"></a>07431 }
<a name="l07432"></a>07432 
<a name="l07441"></a>07441 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_io_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l07442"></a>07442 {
<a name="l07443"></a>07443     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l07444"></a>07444     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07445"></a>07445 
<a name="l07446"></a>07446     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l07447"></a>07447         <span class="keywordflow">if</span> (igb_up(adapter)) {
<a name="l07448"></a>07448             dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;igb_up failed after reset\n&quot;</span>);
<a name="l07449"></a>07449             <span class="keywordflow">return</span>;
<a name="l07450"></a>07450         }
<a name="l07451"></a>07451     }
<a name="l07452"></a>07452 
<a name="l07453"></a>07453     netif_device_attach(netdev);
<a name="l07454"></a>07454 
<a name="l07455"></a>07455     <span class="comment">/* let the f/w know that the h/w is now under the control of the</span>
<a name="l07456"></a>07456 <span class="comment">     * driver. */</span>
<a name="l07457"></a>07457     igb_get_hw_control(adapter);
<a name="l07458"></a>07458 }
<a name="l07459"></a>07459 
<a name="l07460"></a>07460 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PCI_ERS */</span>
<a name="l07461"></a>07461 
<a name="l07462"></a>07462 <span class="keywordtype">int</span> igb_add_mac_filter(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u8 *addr, u16 queue)
<a name="l07463"></a>07463 {
<a name="l07464"></a>07464     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07465"></a>07465     <span class="keywordtype">int</span> i;
<a name="l07466"></a>07466 
<a name="l07467"></a>07467     <span class="keywordflow">if</span> (is_zero_ether_addr(addr))
<a name="l07468"></a>07468         <span class="keywordflow">return</span> 0;
<a name="l07469"></a>07469 
<a name="l07470"></a>07470     <span class="keywordflow">for</span> (i = 0; i &lt; hw-&gt;mac.rar_entry_count; i++) {
<a name="l07471"></a>07471         <span class="keywordflow">if</span> (adapter-&gt;mac_table[i].state &amp; IGB_MAC_STATE_IN_USE)
<a name="l07472"></a>07472             <span class="keywordflow">continue</span>;
<a name="l07473"></a>07473         adapter-&gt;mac_table[i].state = (IGB_MAC_STATE_MODIFIED |
<a name="l07474"></a>07474                            IGB_MAC_STATE_IN_USE);
<a name="l07475"></a>07475         memcpy(adapter-&gt;mac_table[i].addr, addr, ETH_ALEN);
<a name="l07476"></a>07476         adapter-&gt;mac_table[i].queue = queue;
<a name="l07477"></a>07477         igb_sync_mac_table(adapter);
<a name="l07478"></a>07478         <span class="keywordflow">return</span> 0;
<a name="l07479"></a>07479     }
<a name="l07480"></a>07480     <span class="keywordflow">return</span> -ENOMEM;
<a name="l07481"></a>07481 }
<a name="l07482"></a>07482 <span class="keywordtype">int</span> igb_del_mac_filter(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter, u8* addr, u16 queue)
<a name="l07483"></a>07483 {
<a name="l07484"></a>07484     <span class="comment">/* search table for addr, if found, set to 0 and sync */</span>
<a name="l07485"></a>07485     <span class="keywordtype">int</span> i;
<a name="l07486"></a>07486     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07487"></a>07487 
<a name="l07488"></a>07488     <span class="keywordflow">if</span> (is_zero_ether_addr(addr))
<a name="l07489"></a>07489         <span class="keywordflow">return</span> 0;
<a name="l07490"></a>07490     <span class="keywordflow">for</span> (i = 0; i &lt; hw-&gt;mac.rar_entry_count; i++) {
<a name="l07491"></a>07491         <span class="keywordflow">if</span> (!compare_ether_addr(addr, adapter-&gt;mac_table[i].addr) &amp;&amp;
<a name="l07492"></a>07492             adapter-&gt;mac_table[i].queue == queue) {
<a name="l07493"></a>07493             adapter-&gt;mac_table[i].state = IGB_MAC_STATE_MODIFIED;
<a name="l07494"></a>07494             memset(adapter-&gt;mac_table[i].addr, 0, ETH_ALEN);
<a name="l07495"></a>07495             adapter-&gt;mac_table[i].queue = 0;
<a name="l07496"></a>07496             igb_sync_mac_table(adapter);
<a name="l07497"></a>07497             <span class="keywordflow">return</span> 0;
<a name="l07498"></a>07498         }
<a name="l07499"></a>07499     }
<a name="l07500"></a>07500     <span class="keywordflow">return</span> -ENOMEM;
<a name="l07501"></a>07501 }
<a name="l07502"></a>07502 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_set_vf_mac(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter,
<a name="l07503"></a>07503                           <span class="keywordtype">int</span> vf, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *mac_addr)
<a name="l07504"></a>07504 {
<a name="l07505"></a>07505     igb_del_mac_filter(adapter, adapter-&gt;vf_data[vf].vf_mac_addresses, vf);
<a name="l07506"></a>07506     memcpy(adapter-&gt;vf_data[vf].vf_mac_addresses, mac_addr, ETH_ALEN);
<a name="l07507"></a>07507 
<a name="l07508"></a>07508     igb_add_mac_filter(adapter, mac_addr, vf);
<a name="l07509"></a>07509 
<a name="l07510"></a>07510     <span class="keywordflow">return</span> 0;
<a name="l07511"></a>07511 }
<a name="l07512"></a>07512 
<a name="l07513"></a>07513 <span class="preprocessor">#ifdef IFLA_VF_MAX</span>
<a name="l07514"></a>07514 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_set_vf_mac(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> vf, u8 *mac)
<a name="l07515"></a>07515 {
<a name="l07516"></a>07516     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07517"></a>07517     <span class="keywordflow">if</span> (!is_valid_ether_addr(mac) || (vf &gt;= adapter-&gt;vfs_allocated_count))
<a name="l07518"></a>07518         <span class="keywordflow">return</span> -EINVAL;
<a name="l07519"></a>07519     adapter-&gt;vf_data[vf].flags |= IGB_VF_FLAG_PF_SET_MAC;
<a name="l07520"></a>07520     dev_info(&amp;adapter-&gt;pdev-&gt;dev, <span class="stringliteral">&quot;setting MAC %pM on VF %d\n&quot;</span>, mac, vf);
<a name="l07521"></a>07521     dev_info(&amp;adapter-&gt;pdev-&gt;dev, <span class="stringliteral">&quot;Reload the VF driver to make this&quot;</span>
<a name="l07522"></a>07522                       <span class="stringliteral">&quot; change effective.\n&quot;</span>);
<a name="l07523"></a>07523     <span class="keywordflow">if</span> (test_bit(__IGB_DOWN, &amp;adapter-&gt;state)) {
<a name="l07524"></a>07524         dev_warn(&amp;adapter-&gt;pdev-&gt;dev, <span class="stringliteral">&quot;The VF MAC address has been set,&quot;</span>
<a name="l07525"></a>07525              <span class="stringliteral">&quot; but the PF device is not up.\n&quot;</span>);
<a name="l07526"></a>07526         dev_warn(&amp;adapter-&gt;pdev-&gt;dev, <span class="stringliteral">&quot;Bring the PF device up before&quot;</span>
<a name="l07527"></a>07527              <span class="stringliteral">&quot; attempting to use the VF device.\n&quot;</span>);
<a name="l07528"></a>07528     }
<a name="l07529"></a>07529     <span class="keywordflow">return</span> igb_set_vf_mac(adapter, vf, mac);
<a name="l07530"></a>07530 }
<a name="l07531"></a>07531 
<a name="l07532"></a>07532 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_link_mbps(<span class="keywordtype">int</span> internal_link_speed)
<a name="l07533"></a>07533 {
<a name="l07534"></a>07534     <span class="keywordflow">switch</span> (internal_link_speed) {
<a name="l07535"></a>07535     <span class="keywordflow">case</span> SPEED_100:
<a name="l07536"></a>07536         <span class="keywordflow">return</span> 100;
<a name="l07537"></a>07537     <span class="keywordflow">case</span> SPEED_1000:
<a name="l07538"></a>07538         <span class="keywordflow">return</span> 1000;
<a name="l07539"></a>07539     <span class="keywordflow">default</span>:
<a name="l07540"></a>07540         <span class="keywordflow">return</span> 0;
<a name="l07541"></a>07541     }
<a name="l07542"></a>07542 }
<a name="l07543"></a>07543 
<a name="l07544"></a>07544 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_set_vf_rate_limit(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">int</span> vf, <span class="keywordtype">int</span> tx_rate,
<a name="l07545"></a>07545             <span class="keywordtype">int</span> link_speed)
<a name="l07546"></a>07546 {
<a name="l07547"></a>07547     <span class="keywordtype">int</span> rf_dec, rf_int;
<a name="l07548"></a>07548     u32 bcnrc_val;
<a name="l07549"></a>07549 
<a name="l07550"></a>07550     <span class="keywordflow">if</span> (tx_rate != 0) {
<a name="l07551"></a>07551         <span class="comment">/* Calculate the rate factor values to set */</span>
<a name="l07552"></a>07552         rf_int = link_speed / tx_rate;
<a name="l07553"></a>07553         rf_dec = (link_speed - (rf_int * tx_rate));
<a name="l07554"></a>07554         rf_dec = (rf_dec * (1&lt;&lt;E1000_RTTBCNRC_RF_INT_SHIFT)) / tx_rate;
<a name="l07555"></a>07555 
<a name="l07556"></a>07556         bcnrc_val = E1000_RTTBCNRC_RS_ENA;
<a name="l07557"></a>07557         bcnrc_val |= ((rf_int&lt;&lt;E1000_RTTBCNRC_RF_INT_SHIFT) &amp;
<a name="l07558"></a>07558                 E1000_RTTBCNRC_RF_INT_MASK);
<a name="l07559"></a>07559         bcnrc_val |= (rf_dec &amp; E1000_RTTBCNRC_RF_DEC_MASK);
<a name="l07560"></a>07560     } <span class="keywordflow">else</span> {
<a name="l07561"></a>07561         bcnrc_val = 0;
<a name="l07562"></a>07562     }
<a name="l07563"></a>07563 
<a name="l07564"></a>07564     E1000_WRITE_REG(hw, E1000_RTTDQSEL, vf); <span class="comment">/* vf X uses queue X */</span>
<a name="l07565"></a>07565     E1000_WRITE_REG(hw, E1000_RTTBCNRC, bcnrc_val);
<a name="l07566"></a>07566 }
<a name="l07567"></a>07567 
<a name="l07568"></a>07568 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_check_vf_rate_limit(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l07569"></a>07569 {
<a name="l07570"></a>07570     <span class="keywordtype">int</span> actual_link_speed, i;
<a name="l07571"></a>07571     <span class="keywordtype">bool</span> reset_rate = <span class="keyword">false</span>;
<a name="l07572"></a>07572 
<a name="l07573"></a>07573     <span class="comment">/* VF TX rate limit was not set */</span>
<a name="l07574"></a>07574     <span class="keywordflow">if</span> ((adapter-&gt;vf_rate_link_speed == 0) || 
<a name="l07575"></a>07575         (adapter-&gt;hw.mac.type != e1000_82576))
<a name="l07576"></a>07576         <span class="keywordflow">return</span>;
<a name="l07577"></a>07577 
<a name="l07578"></a>07578     actual_link_speed = igb_link_mbps(adapter-&gt;link_speed);
<a name="l07579"></a>07579     <span class="keywordflow">if</span> (actual_link_speed != adapter-&gt;vf_rate_link_speed) {
<a name="l07580"></a>07580         reset_rate = <span class="keyword">true</span>;
<a name="l07581"></a>07581         adapter-&gt;vf_rate_link_speed = 0;
<a name="l07582"></a>07582         dev_info(&amp;adapter-&gt;pdev-&gt;dev,
<a name="l07583"></a>07583         <span class="stringliteral">&quot;Link speed has been changed. VF Transmit rate is disabled\n&quot;</span>);
<a name="l07584"></a>07584     }
<a name="l07585"></a>07585 
<a name="l07586"></a>07586     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;vfs_allocated_count; i++) {
<a name="l07587"></a>07587         <span class="keywordflow">if</span> (reset_rate)
<a name="l07588"></a>07588             adapter-&gt;vf_data[i].tx_rate = 0;
<a name="l07589"></a>07589 
<a name="l07590"></a>07590         igb_set_vf_rate_limit(&amp;adapter-&gt;hw, i,
<a name="l07591"></a>07591             adapter-&gt;vf_data[i].tx_rate, actual_link_speed);
<a name="l07592"></a>07592     }
<a name="l07593"></a>07593 }
<a name="l07594"></a>07594 
<a name="l07595"></a>07595 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_set_vf_bw(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> vf, <span class="keywordtype">int</span> tx_rate)
<a name="l07596"></a>07596 {
<a name="l07597"></a>07597     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07598"></a>07598     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07599"></a>07599     <span class="keywordtype">int</span> actual_link_speed;
<a name="l07600"></a>07600     
<a name="l07601"></a>07601     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82576)
<a name="l07602"></a>07602         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l07603"></a>07603 
<a name="l07604"></a>07604     actual_link_speed = igb_link_mbps(adapter-&gt;link_speed);
<a name="l07605"></a>07605     <span class="keywordflow">if</span> ((vf &gt;= adapter-&gt;vfs_allocated_count) ||
<a name="l07606"></a>07606         (!(E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STATUS_LU)) ||
<a name="l07607"></a>07607         (tx_rate &lt; 0) || (tx_rate &gt; actual_link_speed))
<a name="l07608"></a>07608         <span class="keywordflow">return</span> -EINVAL;
<a name="l07609"></a>07609 
<a name="l07610"></a>07610     adapter-&gt;vf_rate_link_speed = actual_link_speed;
<a name="l07611"></a>07611     adapter-&gt;vf_data[vf].tx_rate = (u16)tx_rate;
<a name="l07612"></a>07612     igb_set_vf_rate_limit(hw, vf, tx_rate, actual_link_speed);
<a name="l07613"></a>07613 
<a name="l07614"></a>07614     <span class="keywordflow">return</span> 0;
<a name="l07615"></a>07615 }
<a name="l07616"></a>07616 
<a name="l07617"></a>07617 <span class="keyword">static</span> <span class="keywordtype">int</span> igb_ndo_get_vf_config(<span class="keyword">struct</span> net_device *netdev,
<a name="l07618"></a>07618                  <span class="keywordtype">int</span> vf, <span class="keyword">struct</span> ifla_vf_info *ivi)
<a name="l07619"></a>07619 {
<a name="l07620"></a>07620     <span class="keyword">struct </span><a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07621"></a>07621     <span class="keywordflow">if</span> (vf &gt;= adapter-&gt;vfs_allocated_count)
<a name="l07622"></a>07622         <span class="keywordflow">return</span> -EINVAL;
<a name="l07623"></a>07623     ivi-&gt;vf = vf;
<a name="l07624"></a>07624     memcpy(&amp;ivi-&gt;mac, adapter-&gt;vf_data[vf].vf_mac_addresses, ETH_ALEN);
<a name="l07625"></a>07625     ivi-&gt;tx_rate = adapter-&gt;vf_data[vf].tx_rate;
<a name="l07626"></a>07626     ivi-&gt;vlan = adapter-&gt;vf_data[vf].pf_vlan;
<a name="l07627"></a>07627     ivi-&gt;qos = adapter-&gt;vf_data[vf].pf_qos;
<a name="l07628"></a>07628     <span class="keywordflow">return</span> 0;
<a name="l07629"></a>07629 }
<a name="l07630"></a>07630 <span class="preprocessor">#endif</span>
<a name="l07631"></a>07631 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> igb_vmm_control(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter)
<a name="l07632"></a>07632 {
<a name="l07633"></a>07633     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07634"></a>07634     u32 reg;
<a name="l07635"></a>07635 
<a name="l07636"></a>07636     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l07637"></a>07637     <span class="keywordflow">case</span> e1000_82575:
<a name="l07638"></a>07638     <span class="keywordflow">default</span>:
<a name="l07639"></a>07639         <span class="comment">/* replication is not supported for 82575 */</span>
<a name="l07640"></a>07640         <span class="keywordflow">return</span>;
<a name="l07641"></a>07641     <span class="keywordflow">case</span> e1000_82576:
<a name="l07642"></a>07642         <span class="comment">/* notify HW that the MAC is adding vlan tags */</span>
<a name="l07643"></a>07643         reg = E1000_READ_REG(hw, E1000_DTXCTL);
<a name="l07644"></a>07644         reg |= (E1000_DTXCTL_VLAN_ADDED |
<a name="l07645"></a>07645             E1000_DTXCTL_SPOOF_INT);
<a name="l07646"></a>07646         E1000_WRITE_REG(hw, E1000_DTXCTL, reg);
<a name="l07647"></a>07647     <span class="keywordflow">case</span> e1000_82580:
<a name="l07648"></a>07648         <span class="comment">/* enable replication vlan tag stripping */</span>
<a name="l07649"></a>07649         reg = E1000_READ_REG(hw, E1000_RPLOLR);
<a name="l07650"></a>07650         reg |= E1000_RPLOLR_STRVLAN;
<a name="l07651"></a>07651         E1000_WRITE_REG(hw, E1000_RPLOLR, reg);
<a name="l07652"></a>07652     <span class="keywordflow">case</span> e1000_i350:
<a name="l07653"></a>07653         <span class="comment">/* none of the above registers are supported by i350 */</span>
<a name="l07654"></a>07654         <span class="keywordflow">break</span>;
<a name="l07655"></a>07655     }
<a name="l07656"></a>07656 
<a name="l07657"></a>07657     <span class="comment">/* enable replication and loopback support */</span>
<a name="l07658"></a>07658     e1000_vmdq_set_loopback_pf(hw, adapter-&gt;vfs_allocated_count ||
<a name="l07659"></a>07659                    adapter-&gt;vmdq_pools);
<a name="l07660"></a>07660 
<a name="l07661"></a>07661     e1000_vmdq_set_anti_spoofing_pf(hw, adapter-&gt;vfs_allocated_count ||
<a name="l07662"></a>07662                     adapter-&gt;vmdq_pools,
<a name="l07663"></a>07663                     adapter-&gt;vfs_allocated_count);
<a name="l07664"></a>07664     e1000_vmdq_set_replication_pf(hw, adapter-&gt;vfs_allocated_count ||
<a name="l07665"></a>07665                       adapter-&gt;vmdq_pools);
<a name="l07666"></a>07666 }
<a name="l07667"></a>07667 
<a name="l07668"></a>07668 <span class="keyword">static</span> <span class="keywordtype">void</span> igb_init_fw(<span class="keyword">struct</span> <a class="code" href="structigb__adapter.html">igb_adapter</a> *adapter) 
<a name="l07669"></a>07669 {
<a name="l07670"></a>07670     <span class="keyword">struct </span><a class="code" href="structe1000__fw__drv__info.html">e1000_fw_drv_info</a> fw_cmd;
<a name="l07671"></a>07671     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07672"></a>07672     <span class="keywordtype">int</span> maj = MAJ;
<a name="l07673"></a>07673     <span class="keywordtype">int</span> min = MIN;
<a name="l07674"></a>07674     <span class="keywordtype">int</span> build  = BUILD;
<a name="l07675"></a>07675     <span class="keywordtype">int</span> i;
<a name="l07676"></a>07676     
<a name="l07677"></a>07677     <span class="keywordflow">if</span> (!e1000_get_hw_semaphore_generic(hw)) { 
<a name="l07678"></a>07678         <span class="keywordflow">for</span> (i = 0; i &lt;= FW_MAX_RETRIES; i++) {
<a name="l07679"></a>07679             E1000_WRITE_REG(hw, E1000_FWSTS, E1000_FWSTS_FWRI);
<a name="l07680"></a>07680             fw_cmd.hdr.cmd = FW_CMD_DRV_INFO;
<a name="l07681"></a>07681             fw_cmd.hdr.buf_len = FW_CMD_DRV_INFO_LEN;
<a name="l07682"></a>07682             fw_cmd.hdr.cmd_or_resp.cmd_resv = FW_CMD_RESERVED;
<a name="l07683"></a>07683             fw_cmd.port_num = hw-&gt;bus.func;
<a name="l07684"></a>07684             fw_cmd.drv_version = (maj &lt;&lt; 24) + (min &lt;&lt; 16)
<a name="l07685"></a>07685                                   + (build &lt;&lt; 8) + FW_UNUSED_VER;
<a name="l07686"></a>07686             fw_cmd.hdr.checksum = e1000_calculate_checksum((u8 *)&amp;fw_cmd,
<a name="l07687"></a>07687                                                        (FW_HDR_LEN +
<a name="l07688"></a>07688                                                         fw_cmd.hdr.buf_len));
<a name="l07689"></a>07689              e1000_host_interface_command(hw, (u8*)&amp;fw_cmd,
<a name="l07690"></a>07690                                          <span class="keyword">sizeof</span>(fw_cmd)); 
<a name="l07691"></a>07691             <span class="keywordflow">if</span> (fw_cmd.hdr.cmd_or_resp.ret_status == FW_STATUS_SUCCESS)
<a name="l07692"></a>07692                 <span class="keywordflow">break</span>;
<a name="l07693"></a>07693         }
<a name="l07694"></a>07694     } <span class="keywordflow">else</span>
<a name="l07695"></a>07695         dev_warn(pci_dev_to_dev(adapter-&gt;pdev),
<a name="l07696"></a>07696              <span class="stringliteral">&quot;Unable to get semaphore, firmware init failed.\n&quot;</span>);
<a name="l07697"></a>07697     e1000_put_hw_semaphore_generic(hw);
<a name="l07698"></a>07698 }
<a name="l07699"></a>07699 <span class="comment">/* igb_main.c */</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:27 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
