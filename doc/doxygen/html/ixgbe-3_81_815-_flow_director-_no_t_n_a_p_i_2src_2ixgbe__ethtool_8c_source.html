<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/ixgbe/ixgbe-3.1.15-FlowDirector-NoTNAPI/src/ixgbe_ethtool.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_aa6459e1e92664bab04094557f6624be.html">ixgbe</a>      </li>
      <li class="navelem"><a class="el" href="dir_841ccacdd8dc0779375a2d0bee41ab9a.html">ixgbe-3.1.15-FlowDirector-NoTNAPI</a>      </li>
      <li class="navelem"><a class="el" href="dir_48709381b9d94a6f6b2ce25044cf89fa.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ixgbe_ethtool.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Intel 10 Gigabit PCI Express Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">  Copyright(c) 1999 - 2010 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">  under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">  version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">  more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">  The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00024"></a>00024 <span class="comment">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">*******************************************************************************/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">/* ethtool support for ixgbe */</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;linux/pci.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;linux/netdevice.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;linux/ethtool.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;linux/vmalloc.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#ifdef SIOCETHTOOL</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#include &lt;asm/uaccess.h&gt;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;ixgbe.h&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#include &quot;../../../../../kernel/linux/pf_ring.h&quot;</span>
<a name="l00043"></a>00043 <span class="keyword">extern</span> s32 ixgbe_ftqf_add_filter(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw, u8 proto, u32 saddr, u16 sport, u32 daddr, u16 dport, u8 rx_queue, u8 filter_id);
<a name="l00044"></a>00044 <span class="preprocessor">#endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="preprocessor">#ifndef ETH_GSTRING_LEN</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define ETH_GSTRING_LEN 32</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="preprocessor">#define IXGBE_ALL_RAR_ENTRIES 16</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#include &quot;kcompat_ethtool.c&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#endif</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#ifdef ETHTOOL_GSTATS</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="keyword">struct </span>ixgbe_stats {
<a name="l00057"></a>00057     <span class="keywordtype">char</span> stat_string[ETH_GSTRING_LEN];
<a name="l00058"></a>00058     <span class="keywordtype">int</span> sizeof_stat;
<a name="l00059"></a>00059     <span class="keywordtype">int</span> stat_offset;
<a name="l00060"></a>00060 };
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="preprocessor">#define IXGBE_NETDEV_STAT(_net_stat) { \</span>
<a name="l00063"></a>00063 <span class="preprocessor">    .stat_string = #_net_stat, \</span>
<a name="l00064"></a>00064 <span class="preprocessor">    .sizeof_stat = FIELD_SIZEOF(struct net_device_stats, _net_stat), \</span>
<a name="l00065"></a>00065 <span class="preprocessor">    .stat_offset = offsetof(struct net_device_stats, _net_stat) \</span>
<a name="l00066"></a>00066 <span class="preprocessor">}</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>ixgbe_stats ixgbe_gstrings_net_stats[] = {
<a name="l00068"></a>00068     IXGBE_NETDEV_STAT(rx_packets),
<a name="l00069"></a>00069     IXGBE_NETDEV_STAT(tx_packets),
<a name="l00070"></a>00070     IXGBE_NETDEV_STAT(rx_bytes),
<a name="l00071"></a>00071     IXGBE_NETDEV_STAT(tx_bytes),
<a name="l00072"></a>00072     IXGBE_NETDEV_STAT(rx_errors),
<a name="l00073"></a>00073     IXGBE_NETDEV_STAT(tx_errors),
<a name="l00074"></a>00074     IXGBE_NETDEV_STAT(rx_dropped),
<a name="l00075"></a>00075     IXGBE_NETDEV_STAT(tx_dropped),
<a name="l00076"></a>00076     IXGBE_NETDEV_STAT(multicast),
<a name="l00077"></a>00077     IXGBE_NETDEV_STAT(collisions),
<a name="l00078"></a>00078     IXGBE_NETDEV_STAT(rx_over_errors),
<a name="l00079"></a>00079     IXGBE_NETDEV_STAT(rx_crc_errors),
<a name="l00080"></a>00080     IXGBE_NETDEV_STAT(rx_frame_errors),
<a name="l00081"></a>00081     IXGBE_NETDEV_STAT(rx_fifo_errors),
<a name="l00082"></a>00082     IXGBE_NETDEV_STAT(rx_missed_errors),
<a name="l00083"></a>00083     IXGBE_NETDEV_STAT(tx_aborted_errors),
<a name="l00084"></a>00084     IXGBE_NETDEV_STAT(tx_carrier_errors),
<a name="l00085"></a>00085     IXGBE_NETDEV_STAT(tx_fifo_errors),
<a name="l00086"></a>00086     IXGBE_NETDEV_STAT(tx_heartbeat_errors),
<a name="l00087"></a>00087 };
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="preprocessor">#define IXGBE_STAT(_name, _stat) { \</span>
<a name="l00090"></a>00090 <span class="preprocessor">    .stat_string = _name, \</span>
<a name="l00091"></a>00091 <span class="preprocessor">    .sizeof_stat = FIELD_SIZEOF(struct ixgbe_adapter, _stat), \</span>
<a name="l00092"></a>00092 <span class="preprocessor">    .stat_offset = offsetof(struct ixgbe_adapter, _stat) \</span>
<a name="l00093"></a>00093 <span class="preprocessor">}</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span>ixgbe_stats ixgbe_gstrings_stats[] = {
<a name="l00095"></a>00095     IXGBE_STAT(<span class="stringliteral">&quot;rx_pkts_nic&quot;</span>, stats.gprc),
<a name="l00096"></a>00096     IXGBE_STAT(<span class="stringliteral">&quot;tx_pkts_nic&quot;</span>, stats.gptc),
<a name="l00097"></a>00097     IXGBE_STAT(<span class="stringliteral">&quot;rx_bytes_nic&quot;</span>, stats.gorc),
<a name="l00098"></a>00098     IXGBE_STAT(<span class="stringliteral">&quot;tx_bytes_nic&quot;</span>, stats.gotc),
<a name="l00099"></a>00099     IXGBE_STAT(<span class="stringliteral">&quot;lsc_int&quot;</span>, lsc_int),
<a name="l00100"></a>00100     IXGBE_STAT(<span class="stringliteral">&quot;tx_busy&quot;</span>, tx_busy),
<a name="l00101"></a>00101     IXGBE_STAT(<span class="stringliteral">&quot;non_eop_descs&quot;</span>, non_eop_descs),
<a name="l00102"></a>00102 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;rx_dropped_backlog&quot;</span>, rx_dropped_backlog),
<a name="l00104"></a>00104 <span class="preprocessor">#endif</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;broadcast&quot;</span>, stats.bprc),
<a name="l00106"></a>00106     IXGBE_STAT(<span class="stringliteral">&quot;rx_no_buffer_count&quot;</span>, stats.rnbc[0]) ,
<a name="l00107"></a>00107     IXGBE_STAT(<span class="stringliteral">&quot;tx_timeout_count&quot;</span>, tx_timeout_count),
<a name="l00108"></a>00108     IXGBE_STAT(<span class="stringliteral">&quot;tx_restart_queue&quot;</span>, restart_queue),
<a name="l00109"></a>00109     IXGBE_STAT(<span class="stringliteral">&quot;rx_long_length_errors&quot;</span>, stats.roc),
<a name="l00110"></a>00110     IXGBE_STAT(<span class="stringliteral">&quot;rx_short_length_errors&quot;</span>, stats.ruc),
<a name="l00111"></a>00111     IXGBE_STAT(<span class="stringliteral">&quot;tx_flow_control_xon&quot;</span>, stats.lxontxc),
<a name="l00112"></a>00112     IXGBE_STAT(<span class="stringliteral">&quot;rx_flow_control_xon&quot;</span>, stats.lxonrxc),
<a name="l00113"></a>00113     IXGBE_STAT(<span class="stringliteral">&quot;tx_flow_control_xoff&quot;</span>, stats.lxofftxc),
<a name="l00114"></a>00114     IXGBE_STAT(<span class="stringliteral">&quot;rx_flow_control_xoff&quot;</span>, stats.lxoffrxc),
<a name="l00115"></a>00115     IXGBE_STAT(<span class="stringliteral">&quot;rx_csum_offload_errors&quot;</span>, hw_csum_rx_error),
<a name="l00116"></a>00116 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;low_latency_interrupt&quot;</span>, lli_int),
<a name="l00118"></a>00118 <span class="preprocessor">#endif</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;alloc_rx_page_failed&quot;</span>, alloc_rx_page_failed),
<a name="l00120"></a>00120     IXGBE_STAT(<span class="stringliteral">&quot;alloc_rx_buff_failed&quot;</span>, alloc_rx_buff_failed),
<a name="l00121"></a>00121 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;lro_aggregated&quot;</span>, lro_stats.coal),
<a name="l00123"></a>00123     IXGBE_STAT(<span class="stringliteral">&quot;lro_flushed&quot;</span>, lro_stats.flushed),
<a name="l00124"></a>00124     IXGBE_STAT(<span class="stringliteral">&quot;lro_recycled&quot;</span>, lro_stats.recycled),
<a name="l00125"></a>00125 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l00126"></a>00126     IXGBE_STAT(<span class="stringliteral">&quot;rx_no_dma_resources&quot;</span>, hw_rx_no_dma_resources),
<a name="l00127"></a>00127     IXGBE_STAT(<span class="stringliteral">&quot;hw_rsc_aggregated&quot;</span>, rsc_total_count),
<a name="l00128"></a>00128     IXGBE_STAT(<span class="stringliteral">&quot;hw_rsc_flushed&quot;</span>, rsc_total_flush),
<a name="l00129"></a>00129     IXGBE_STAT(<span class="stringliteral">&quot;rx_flm&quot;</span>, flm),
<a name="l00130"></a>00130 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;fdir_match&quot;</span>, stats.fdirmatch),
<a name="l00132"></a>00132     IXGBE_STAT(<span class="stringliteral">&quot;fdir_miss&quot;</span>, stats.fdirmiss),
<a name="l00133"></a>00133     IXGBE_STAT(<span class="stringliteral">&quot;fdir_overflow&quot;</span>, fdir_overflow),
<a name="l00134"></a>00134 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l00135"></a>00135 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span>    IXGBE_STAT(<span class="stringliteral">&quot;fcoe_bad_fccrc&quot;</span>, stats.fccrc),
<a name="l00137"></a>00137     IXGBE_STAT(<span class="stringliteral">&quot;fcoe_last_errors&quot;</span>, stats.fclast),
<a name="l00138"></a>00138     IXGBE_STAT(<span class="stringliteral">&quot;rx_fcoe_dropped&quot;</span>, stats.fcoerpdc),
<a name="l00139"></a>00139     IXGBE_STAT(<span class="stringliteral">&quot;rx_fcoe_packets&quot;</span>, stats.fcoeprc),
<a name="l00140"></a>00140     IXGBE_STAT(<span class="stringliteral">&quot;rx_fcoe_dwords&quot;</span>, stats.fcoedwrc),
<a name="l00141"></a>00141     IXGBE_STAT(<span class="stringliteral">&quot;tx_fcoe_packets&quot;</span>, stats.fcoeptc),
<a name="l00142"></a>00142     IXGBE_STAT(<span class="stringliteral">&quot;tx_fcoe_dwords&quot;</span>, stats.fcoedwtc),
<a name="l00143"></a>00143 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l00144"></a>00144 };
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="preprocessor">#define IXGBE_QUEUE_STATS_LEN \</span>
<a name="l00147"></a>00147 <span class="preprocessor">           ((((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;num_tx_queues + \</span>
<a name="l00148"></a>00148 <span class="preprocessor">             ((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;num_rx_queues) * \</span>
<a name="l00149"></a>00149 <span class="preprocessor">             (sizeof(struct ixgbe_queue_stats) / sizeof(u64)))</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_GLOBAL_STATS_LEN  ARRAY_SIZE(ixgbe_gstrings_stats)</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_NETDEV_STATS_LEN ARRAY_SIZE(ixgbe_gstrings_net_stats)</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_PB_STATS_LEN ( \</span>
<a name="l00153"></a>00153 <span class="preprocessor">        (((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;flags &amp; \</span>
<a name="l00154"></a>00154 <span class="preprocessor">         IXGBE_FLAG_DCB_ENABLED) ? \</span>
<a name="l00155"></a>00155 <span class="preprocessor">         (sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxonrxc) + \</span>
<a name="l00156"></a>00156 <span class="preprocessor">          sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxontxc) + \</span>
<a name="l00157"></a>00157 <span class="preprocessor">          sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxoffrxc) + \</span>
<a name="l00158"></a>00158 <span class="preprocessor">          sizeof(((struct ixgbe_adapter *)0)-&gt;stats.pxofftxc)) \</span>
<a name="l00159"></a>00159 <span class="preprocessor">         / sizeof(u64) : 0)</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_VF_STATS_LEN \</span>
<a name="l00161"></a>00161 <span class="preprocessor">        ((((struct ixgbe_adapter *)netdev_priv(netdev))-&gt;num_vfs) * \</span>
<a name="l00162"></a>00162 <span class="preprocessor">          (sizeof(struct vf_stats) / sizeof(u64)))</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor">#define IXGBE_STATS_LEN (IXGBE_GLOBAL_STATS_LEN + \</span>
<a name="l00164"></a>00164 <span class="preprocessor">             IXGBE_NETDEV_STATS_LEN + \</span>
<a name="l00165"></a>00165 <span class="preprocessor">             IXGBE_PB_STATS_LEN + \</span>
<a name="l00166"></a>00166 <span class="preprocessor">             IXGBE_QUEUE_STATS_LEN + \</span>
<a name="l00167"></a>00167 <span class="preprocessor">             IXGBE_VF_STATS_LEN)</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>
<a name="l00169"></a>00169 <span class="preprocessor">#endif </span><span class="comment">/* ETHTOOL_GSTATS */</span>
<a name="l00170"></a>00170 <span class="preprocessor">#ifdef ETHTOOL_TEST</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> ixgbe_gstrings_test[][ETH_GSTRING_LEN] = {
<a name="l00172"></a>00172     <span class="stringliteral">&quot;Register test  (offline)&quot;</span>, <span class="stringliteral">&quot;Eeprom test    (offline)&quot;</span>,
<a name="l00173"></a>00173     <span class="stringliteral">&quot;Interrupt test (offline)&quot;</span>, <span class="stringliteral">&quot;Loopback test  (offline)&quot;</span>,
<a name="l00174"></a>00174     <span class="stringliteral">&quot;Link test   (on/offline)&quot;</span>
<a name="l00175"></a>00175 };
<a name="l00176"></a>00176 <span class="preprocessor">#define IXGBE_TEST_LEN sizeof(ixgbe_gstrings_test) / ETH_GSTRING_LEN</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* ETHTOOL_TEST */</span>
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_settings(<span class="keyword">struct</span> net_device *netdev,
<a name="l00180"></a>00180                               <span class="keyword">struct</span> ethtool_cmd *ecmd)
<a name="l00181"></a>00181 {
<a name="l00182"></a>00182     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00183"></a>00183     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00184"></a>00184     u32 link_speed = 0;
<a name="l00185"></a>00185     <span class="keywordtype">bool</span> link_up;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     ecmd-&gt;supported = SUPPORTED_10000baseT_Full;
<a name="l00188"></a>00188     ecmd-&gt;autoneg = AUTONEG_ENABLE;
<a name="l00189"></a>00189     ecmd-&gt;transceiver = XCVR_EXTERNAL;
<a name="l00190"></a>00190     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type == ixgbe_media_type_copper) ||
<a name="l00191"></a>00191         (hw-&gt;phy.multispeed_fiber)) {
<a name="l00192"></a>00192         ecmd-&gt;supported |= (SUPPORTED_1000baseT_Full |
<a name="l00193"></a>00193                             SUPPORTED_Autoneg);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         ecmd-&gt;advertising = ADVERTISED_Autoneg;
<a name="l00196"></a>00196         <span class="keywordflow">if</span> (hw-&gt;phy.autoneg_advertised &amp; IXGBE_LINK_SPEED_10GB_FULL)
<a name="l00197"></a>00197             ecmd-&gt;advertising |= ADVERTISED_10000baseT_Full;
<a name="l00198"></a>00198         <span class="keywordflow">if</span> (hw-&gt;phy.autoneg_advertised &amp; IXGBE_LINK_SPEED_1GB_FULL)
<a name="l00199"></a>00199             ecmd-&gt;advertising |= ADVERTISED_1000baseT_Full;
<a name="l00200"></a>00200         <span class="comment">/*</span>
<a name="l00201"></a>00201 <span class="comment">         * It&#39;s possible that phy.autoneg_advertised may not be</span>
<a name="l00202"></a>00202 <span class="comment">         * set yet.  If so display what the default would be -</span>
<a name="l00203"></a>00203 <span class="comment">         * both 1G and 10G supported.</span>
<a name="l00204"></a>00204 <span class="comment">         */</span>
<a name="l00205"></a>00205         <span class="keywordflow">if</span> (!(ecmd-&gt;advertising &amp; (ADVERTISED_1000baseT_Full |
<a name="l00206"></a>00206                        ADVERTISED_10000baseT_Full)))
<a name="l00207"></a>00207             ecmd-&gt;advertising |= (ADVERTISED_10000baseT_Full |
<a name="l00208"></a>00208                           ADVERTISED_1000baseT_Full);
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <span class="keywordflow">if</span> (hw-&gt;phy.media_type == ixgbe_media_type_copper) {
<a name="l00211"></a>00211             ecmd-&gt;supported |= SUPPORTED_TP;
<a name="l00212"></a>00212             ecmd-&gt;advertising |= ADVERTISED_TP;
<a name="l00213"></a>00213             ecmd-&gt;port = PORT_TP;
<a name="l00214"></a>00214         } <span class="keywordflow">else</span> {
<a name="l00215"></a>00215             ecmd-&gt;supported |= SUPPORTED_FIBRE;
<a name="l00216"></a>00216             ecmd-&gt;advertising |= ADVERTISED_FIBRE;
<a name="l00217"></a>00217             ecmd-&gt;port = PORT_FIBRE;
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;phy.media_type == ixgbe_media_type_backplane) {
<a name="l00220"></a>00220         <span class="comment">/* Set as FIBRE until SERDES defined in kernel */</span>
<a name="l00221"></a>00221         <span class="keywordflow">if</span> (hw-&gt;device_id == IXGBE_DEV_ID_82598_BX) {
<a name="l00222"></a>00222             ecmd-&gt;supported = (SUPPORTED_1000baseT_Full |
<a name="l00223"></a>00223                        SUPPORTED_FIBRE);
<a name="l00224"></a>00224             ecmd-&gt;advertising = (ADVERTISED_1000baseT_Full |
<a name="l00225"></a>00225                          ADVERTISED_FIBRE);
<a name="l00226"></a>00226             ecmd-&gt;port = PORT_FIBRE;
<a name="l00227"></a>00227             ecmd-&gt;autoneg = AUTONEG_DISABLE;
<a name="l00228"></a>00228         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((hw-&gt;device_id == IXGBE_DEV_ID_82599_COMBO_BACKPLANE) ||
<a name="l00229"></a>00229                (hw-&gt;device_id == IXGBE_DEV_ID_82599_KX4_MEZZ)) {
<a name="l00230"></a>00230             ecmd-&gt;supported |= (SUPPORTED_1000baseT_Full |
<a name="l00231"></a>00231                         SUPPORTED_Autoneg |
<a name="l00232"></a>00232                         SUPPORTED_FIBRE);
<a name="l00233"></a>00233             ecmd-&gt;advertising = (ADVERTISED_10000baseT_Full |
<a name="l00234"></a>00234                          ADVERTISED_1000baseT_Full |
<a name="l00235"></a>00235                          ADVERTISED_Autoneg |
<a name="l00236"></a>00236                          ADVERTISED_FIBRE);
<a name="l00237"></a>00237             ecmd-&gt;port = PORT_FIBRE;
<a name="l00238"></a>00238         } <span class="keywordflow">else</span> {
<a name="l00239"></a>00239             ecmd-&gt;supported |= (SUPPORTED_1000baseT_Full |
<a name="l00240"></a>00240                         SUPPORTED_FIBRE);
<a name="l00241"></a>00241             ecmd-&gt;advertising = (ADVERTISED_10000baseT_Full |
<a name="l00242"></a>00242                          ADVERTISED_1000baseT_Full |
<a name="l00243"></a>00243                          ADVERTISED_FIBRE);
<a name="l00244"></a>00244             ecmd-&gt;port = PORT_FIBRE;
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246     } <span class="keywordflow">else</span> {
<a name="l00247"></a>00247         ecmd-&gt;supported |= SUPPORTED_FIBRE;
<a name="l00248"></a>00248         ecmd-&gt;advertising = (ADVERTISED_10000baseT_Full |
<a name="l00249"></a>00249                              ADVERTISED_FIBRE);
<a name="l00250"></a>00250         ecmd-&gt;port = PORT_FIBRE;
<a name="l00251"></a>00251         ecmd-&gt;autoneg = AUTONEG_DISABLE;
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="preprocessor">#ifdef HAVE_ETHTOOL_SFP_DISPLAY_PORT</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>    <span class="comment">/* Get PHY type */</span>
<a name="l00256"></a>00256     <span class="keywordflow">switch</span> (adapter-&gt;hw.phy.type) {
<a name="l00257"></a>00257     <span class="keywordflow">case</span> ixgbe_phy_tn:
<a name="l00258"></a>00258     <span class="keywordflow">case</span> ixgbe_phy_aq:
<a name="l00259"></a>00259     <span class="keywordflow">case</span> ixgbe_phy_cu_unknown:
<a name="l00260"></a>00260         <span class="comment">/* Copper 10G-BASET */</span>
<a name="l00261"></a>00261         ecmd-&gt;port = PORT_TP;
<a name="l00262"></a>00262         <span class="keywordflow">break</span>;
<a name="l00263"></a>00263     <span class="keywordflow">case</span> ixgbe_phy_qt:
<a name="l00264"></a>00264         ecmd-&gt;port = PORT_FIBRE;
<a name="l00265"></a>00265         <span class="keywordflow">break</span>;
<a name="l00266"></a>00266     <span class="keywordflow">case</span> ixgbe_phy_nl:
<a name="l00267"></a>00267     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_tyco:
<a name="l00268"></a>00268     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_unknown:
<a name="l00269"></a>00269     <span class="keywordflow">case</span> ixgbe_phy_sfp_ftl:
<a name="l00270"></a>00270     <span class="keywordflow">case</span> ixgbe_phy_sfp_avago:
<a name="l00271"></a>00271     <span class="keywordflow">case</span> ixgbe_phy_sfp_intel:
<a name="l00272"></a>00272     <span class="keywordflow">case</span> ixgbe_phy_sfp_unknown:
<a name="l00273"></a>00273         <span class="keywordflow">switch</span> (adapter-&gt;hw.phy.sfp_type) {
<a name="l00274"></a>00274         <span class="comment">/* SFP+ devices, further checking needed */</span>
<a name="l00275"></a>00275         <span class="keywordflow">case</span> ixgbe_sfp_type_da_cu:
<a name="l00276"></a>00276         <span class="keywordflow">case</span> ixgbe_sfp_type_da_cu_core0:
<a name="l00277"></a>00277         <span class="keywordflow">case</span> ixgbe_sfp_type_da_cu_core1:
<a name="l00278"></a>00278             ecmd-&gt;port = PORT_DA;
<a name="l00279"></a>00279             <span class="keywordflow">break</span>;
<a name="l00280"></a>00280         <span class="keywordflow">case</span> ixgbe_sfp_type_sr:
<a name="l00281"></a>00281         <span class="keywordflow">case</span> ixgbe_sfp_type_lr:
<a name="l00282"></a>00282         <span class="keywordflow">case</span> ixgbe_sfp_type_srlr_core0:
<a name="l00283"></a>00283         <span class="keywordflow">case</span> ixgbe_sfp_type_srlr_core1:
<a name="l00284"></a>00284             ecmd-&gt;port = PORT_FIBRE;
<a name="l00285"></a>00285             <span class="keywordflow">break</span>;
<a name="l00286"></a>00286         <span class="keywordflow">case</span> ixgbe_sfp_type_not_present:
<a name="l00287"></a>00287             ecmd-&gt;port = PORT_NONE;
<a name="l00288"></a>00288             <span class="keywordflow">break</span>;
<a name="l00289"></a>00289         <span class="keywordflow">case</span> ixgbe_sfp_type_1g_cu_core0:
<a name="l00290"></a>00290         <span class="keywordflow">case</span> ixgbe_sfp_type_1g_cu_core1:
<a name="l00291"></a>00291             ecmd-&gt;port = PORT_TP;
<a name="l00292"></a>00292             ecmd-&gt;supported = SUPPORTED_TP;
<a name="l00293"></a>00293             ecmd-&gt;advertising = (ADVERTISED_1000baseT_Full |
<a name="l00294"></a>00294                 ADVERTISED_TP);
<a name="l00295"></a>00295             <span class="keywordflow">break</span>;
<a name="l00296"></a>00296         <span class="keywordflow">case</span> ixgbe_sfp_type_unknown:
<a name="l00297"></a>00297         <span class="keywordflow">default</span>:
<a name="l00298"></a>00298             ecmd-&gt;port = PORT_OTHER;
<a name="l00299"></a>00299             <span class="keywordflow">break</span>;
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301         <span class="keywordflow">break</span>;
<a name="l00302"></a>00302     <span class="keywordflow">case</span> ixgbe_phy_xaui:
<a name="l00303"></a>00303         ecmd-&gt;port = PORT_NONE;
<a name="l00304"></a>00304         <span class="keywordflow">break</span>;
<a name="l00305"></a>00305     <span class="keywordflow">case</span> ixgbe_phy_unknown:
<a name="l00306"></a>00306     <span class="keywordflow">case</span> ixgbe_phy_generic:
<a name="l00307"></a>00307     <span class="keywordflow">case</span> ixgbe_phy_sfp_unsupported:
<a name="l00308"></a>00308     <span class="keywordflow">default</span>:
<a name="l00309"></a>00309         ecmd-&gt;port = PORT_OTHER;
<a name="l00310"></a>00310         <span class="keywordflow">break</span>;
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312 <span class="preprocessor">#endif</span>
<a name="l00313"></a>00313 <span class="preprocessor"></span>
<a name="l00314"></a>00314     <span class="keywordflow">if</span> (!in_interrupt()) {
<a name="l00315"></a>00315         hw-&gt;mac.ops.check_link(hw, &amp;link_speed, &amp;link_up, <span class="keyword">false</span>);
<a name="l00316"></a>00316     } <span class="keywordflow">else</span> {
<a name="l00317"></a>00317         <span class="comment">/*</span>
<a name="l00318"></a>00318 <span class="comment">         * this case is a special workaround for RHEL5 bonding</span>
<a name="l00319"></a>00319 <span class="comment">         * that calls this routine from interrupt context</span>
<a name="l00320"></a>00320 <span class="comment">         */</span>
<a name="l00321"></a>00321         link_speed = adapter-&gt;link_speed;
<a name="l00322"></a>00322         link_up = adapter-&gt;link_up;
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="keywordflow">if</span> (link_up) {
<a name="l00326"></a>00326         ecmd-&gt;speed = (link_speed == IXGBE_LINK_SPEED_10GB_FULL) ?
<a name="l00327"></a>00327                        SPEED_10000 : SPEED_1000;
<a name="l00328"></a>00328         ecmd-&gt;duplex = DUPLEX_FULL;
<a name="l00329"></a>00329     } <span class="keywordflow">else</span> {
<a name="l00330"></a>00330         ecmd-&gt;speed = -1;
<a name="l00331"></a>00331         ecmd-&gt;duplex = -1;
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     <span class="keywordflow">return</span> 0;
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_settings(<span class="keyword">struct</span> net_device *netdev,
<a name="l00338"></a>00338                               <span class="keyword">struct</span> ethtool_cmd *ecmd)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00341"></a>00341     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00342"></a>00342     u32 advertised, old;
<a name="l00343"></a>00343     s32 err = 0;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type == ixgbe_media_type_copper) ||
<a name="l00346"></a>00346         (hw-&gt;phy.multispeed_fiber)) {
<a name="l00347"></a>00347         <span class="comment">/* 10000/copper and 1000/copper must autoneg</span>
<a name="l00348"></a>00348 <span class="comment">         * this function does not support any duplex forcing, but can</span>
<a name="l00349"></a>00349 <span class="comment">         * limit the advertising of the adapter to only 10000 or 1000 */</span>
<a name="l00350"></a>00350         <span class="keywordflow">if</span> (ecmd-&gt;autoneg == AUTONEG_DISABLE)
<a name="l00351"></a>00351             <span class="keywordflow">return</span> -EINVAL;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353         old = hw-&gt;phy.autoneg_advertised;
<a name="l00354"></a>00354         advertised = 0;
<a name="l00355"></a>00355         <span class="keywordflow">if</span> (ecmd-&gt;advertising &amp; ADVERTISED_10000baseT_Full)
<a name="l00356"></a>00356             advertised |= IXGBE_LINK_SPEED_10GB_FULL;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="keywordflow">if</span> (ecmd-&gt;advertising &amp; ADVERTISED_1000baseT_Full)
<a name="l00359"></a>00359             advertised |= IXGBE_LINK_SPEED_1GB_FULL;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         <span class="keywordflow">if</span> (old == advertised)
<a name="l00362"></a>00362             <span class="keywordflow">return</span> err;
<a name="l00363"></a>00363         <span class="comment">/* this sets the link speed and restarts auto-neg */</span>
<a name="l00364"></a>00364         hw-&gt;mac.autotry_restart = <span class="keyword">true</span>;
<a name="l00365"></a>00365         err = hw-&gt;mac.ops.setup_link(hw, advertised, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l00366"></a>00366         <span class="keywordflow">if</span> (err) {
<a name="l00367"></a>00367             DPRINTK(PROBE, INFO,
<a name="l00368"></a>00368                     <span class="stringliteral">&quot;setup link failed with code %d\n&quot;</span>, err);
<a name="l00369"></a>00369             hw-&gt;mac.ops.setup_link(hw, old, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l00370"></a>00370         }
<a name="l00371"></a>00371     } <span class="keywordflow">else</span> {
<a name="l00372"></a>00372         <span class="comment">/* in this case we currently only support 10Gb/FULL */</span>
<a name="l00373"></a>00373         <span class="keywordflow">if</span> ((ecmd-&gt;autoneg == AUTONEG_ENABLE) ||
<a name="l00374"></a>00374             (ecmd-&gt;advertising != ADVERTISED_10000baseT_Full) ||
<a name="l00375"></a>00375             (ecmd-&gt;speed + ecmd-&gt;duplex != SPEED_10000 + DUPLEX_FULL))
<a name="l00376"></a>00376             <span class="keywordflow">return</span> -EINVAL;
<a name="l00377"></a>00377     }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379     <span class="keywordflow">return</span> err;
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_pauseparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l00383"></a>00383                                  <span class="keyword">struct</span> ethtool_pauseparam *pause)
<a name="l00384"></a>00384 {
<a name="l00385"></a>00385     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00386"></a>00386     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="comment">/*</span>
<a name="l00389"></a>00389 <span class="comment">     * Flow Control Autoneg isn&#39;t on if</span>
<a name="l00390"></a>00390 <span class="comment">     *  - we didn&#39;t ask for it OR</span>
<a name="l00391"></a>00391 <span class="comment">     *  - it failed, we know this by tx &amp; rx being off</span>
<a name="l00392"></a>00392 <span class="comment">     */</span>
<a name="l00393"></a>00393     <span class="keywordflow">if</span> (hw-&gt;fc.disable_fc_autoneg ||
<a name="l00394"></a>00394         (hw-&gt;fc.current_mode == ixgbe_fc_none))
<a name="l00395"></a>00395         pause-&gt;autoneg = 0;
<a name="l00396"></a>00396     <span class="keywordflow">else</span>
<a name="l00397"></a>00397         pause-&gt;autoneg = 1;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399     <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_rx_pause) {
<a name="l00400"></a>00400         pause-&gt;rx_pause = 1;
<a name="l00401"></a>00401     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_tx_pause) {
<a name="l00402"></a>00402         pause-&gt;tx_pause = 1;
<a name="l00403"></a>00403     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_full) {
<a name="l00404"></a>00404         pause-&gt;rx_pause = 1;
<a name="l00405"></a>00405         pause-&gt;tx_pause = 1;
<a name="l00406"></a>00406 <span class="preprocessor">#ifdef CONFIG_DCB</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;fc.current_mode == ixgbe_fc_pfc) {
<a name="l00408"></a>00408         pause-&gt;rx_pause = 0;
<a name="l00409"></a>00409         pause-&gt;tx_pause = 0;
<a name="l00410"></a>00410 <span class="preprocessor">#endif</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span>    }
<a name="l00412"></a>00412 }
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_pauseparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l00415"></a>00415                                 <span class="keyword">struct</span> ethtool_pauseparam *pause)
<a name="l00416"></a>00416 {
<a name="l00417"></a>00417     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00418"></a>00418     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00419"></a>00419     <span class="keyword">struct </span><a class="code" href="structixgbe__fc__info.html">ixgbe_fc_info</a> fc;
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (adapter-&gt;dcb_cfg.pfc_mode_enable ||
<a name="l00422"></a>00422         ((hw-&gt;mac.type == ixgbe_mac_82598EB) &amp;&amp;
<a name="l00423"></a>00423         (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)))
<a name="l00424"></a>00424         <span class="keywordflow">return</span> -EINVAL;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     fc = hw-&gt;fc;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="keywordflow">if</span> (pause-&gt;autoneg != AUTONEG_ENABLE)
<a name="l00429"></a>00429         fc.disable_fc_autoneg = <span class="keyword">true</span>;
<a name="l00430"></a>00430     <span class="keywordflow">else</span>
<a name="l00431"></a>00431         fc.disable_fc_autoneg = <span class="keyword">false</span>;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="keywordflow">if</span> ((pause-&gt;rx_pause &amp;&amp; pause-&gt;tx_pause) || pause-&gt;autoneg)
<a name="l00434"></a>00434         fc.requested_mode = ixgbe_fc_full;
<a name="l00435"></a>00435     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pause-&gt;rx_pause &amp;&amp; !pause-&gt;tx_pause)
<a name="l00436"></a>00436         fc.requested_mode = ixgbe_fc_rx_pause;
<a name="l00437"></a>00437     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pause-&gt;rx_pause &amp;&amp; pause-&gt;tx_pause)
<a name="l00438"></a>00438         fc.requested_mode = ixgbe_fc_tx_pause;
<a name="l00439"></a>00439     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pause-&gt;rx_pause &amp;&amp; !pause-&gt;tx_pause)
<a name="l00440"></a>00440         fc.requested_mode = ixgbe_fc_none;
<a name="l00441"></a>00441     <span class="keywordflow">else</span>
<a name="l00442"></a>00442         <span class="keywordflow">return</span> -EINVAL;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     adapter-&gt;last_lfc_mode = fc.requested_mode;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446     <span class="comment">/* if the thing changed then we&#39;ll update and use new autoneg */</span>
<a name="l00447"></a>00447     <span class="keywordflow">if</span> (memcmp(&amp;fc, &amp;hw-&gt;fc, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__fc__info.html">ixgbe_fc_info</a>))) {
<a name="l00448"></a>00448         hw-&gt;fc = fc;
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l00450"></a>00450             ixgbe_reinit_locked(adapter);
<a name="l00451"></a>00451         <span class="keywordflow">else</span>
<a name="l00452"></a>00452             ixgbe_reset(adapter);
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="keywordflow">return</span> 0;
<a name="l00456"></a>00456 }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="keyword">static</span> u32 ixgbe_get_rx_csum(<span class="keyword">struct</span> net_device *netdev)
<a name="l00459"></a>00459 {
<a name="l00460"></a>00460     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00461"></a>00461     <span class="keywordflow">return</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_CSUM_ENABLED);
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_rx_csum(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00465"></a>00465 {
<a name="l00466"></a>00466     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00467"></a>00467     <span class="keywordflow">if</span> (data)
<a name="l00468"></a>00468         adapter-&gt;flags |= IXGBE_FLAG_RX_CSUM_ENABLED;
<a name="l00469"></a>00469     <span class="keywordflow">else</span>
<a name="l00470"></a>00470         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RX_CSUM_ENABLED;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472     <span class="keywordflow">return</span> 0;
<a name="l00473"></a>00473 }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="keyword">static</span> u32 ixgbe_get_tx_csum(<span class="keyword">struct</span> net_device *netdev)
<a name="l00476"></a>00476 {
<a name="l00477"></a>00477     <span class="keywordflow">return</span> (netdev-&gt;features &amp; NETIF_F_IP_CSUM) != 0;
<a name="l00478"></a>00478 }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_tx_csum(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00481"></a>00481 {
<a name="l00482"></a>00482     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00483"></a>00483     u32 feature_list;
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l00486"></a>00486 <span class="preprocessor"></span>    feature_list = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
<a name="l00487"></a>00487 <span class="preprocessor">#else</span>
<a name="l00488"></a>00488 <span class="preprocessor"></span>    feature_list = NETIF_F_IP_CSUM;
<a name="l00489"></a>00489 <span class="preprocessor">#endif</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>    <span class="keywordflow">switch</span>(adapter-&gt;hw.mac.type) {
<a name="l00491"></a>00491     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00492"></a>00492     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00493"></a>00493         feature_list |= NETIF_F_SCTP_CSUM;
<a name="l00494"></a>00494         <span class="keywordflow">break</span>;
<a name="l00495"></a>00495     <span class="keywordflow">default</span>:
<a name="l00496"></a>00496         <span class="keywordflow">break</span>;
<a name="l00497"></a>00497     }
<a name="l00498"></a>00498     <span class="keywordflow">if</span> (data)
<a name="l00499"></a>00499         netdev-&gt;features |= feature_list;
<a name="l00500"></a>00500     <span class="keywordflow">else</span>
<a name="l00501"></a>00501         netdev-&gt;features &amp;= ~feature_list;
<a name="l00502"></a>00502 
<a name="l00503"></a>00503     <span class="keywordflow">return</span> 0;
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l00507"></a>00507 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_tso(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00508"></a>00508 {
<a name="l00509"></a>00509     <span class="keywordflow">if</span> (data) {
<a name="l00510"></a>00510         netdev-&gt;features |= NETIF_F_TSO;
<a name="l00511"></a>00511 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>        netdev-&gt;features |= NETIF_F_TSO6;
<a name="l00513"></a>00513 <span class="preprocessor">#endif</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l00515"></a>00515 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l00516"></a>00516 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l00517"></a>00517 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00518"></a>00518         <span class="comment">/* disable TSO on all VLANs if they&#39;re present */</span>
<a name="l00519"></a>00519         <span class="keywordflow">if</span> (adapter-&gt;vlgrp) {
<a name="l00520"></a>00520             <span class="keywordtype">int</span> i;
<a name="l00521"></a>00521             <span class="keyword">struct </span>net_device *v_netdev;
<a name="l00522"></a>00522             <span class="keywordflow">for</span> (i = 0; i &lt; VLAN_N_VID; i++) {
<a name="l00523"></a>00523                 v_netdev =
<a name="l00524"></a>00524                        vlan_group_get_device(adapter-&gt;vlgrp, i);
<a name="l00525"></a>00525                 <span class="keywordflow">if</span> (v_netdev) {
<a name="l00526"></a>00526                     v_netdev-&gt;features &amp;= ~NETIF_F_TSO;
<a name="l00527"></a>00527 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span>                    v_netdev-&gt;features &amp;= ~NETIF_F_TSO6;
<a name="l00529"></a>00529 <span class="preprocessor">#endif</span>
<a name="l00530"></a>00530 <span class="preprocessor"></span>                    vlan_group_set_device(adapter-&gt;vlgrp, i,
<a name="l00531"></a>00531                                           v_netdev);
<a name="l00532"></a>00532                 }
<a name="l00533"></a>00533             }
<a name="l00534"></a>00534         }
<a name="l00535"></a>00535 <span class="preprocessor">#endif</span>
<a name="l00536"></a>00536 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l00537"></a>00537         netdev-&gt;features &amp;= ~NETIF_F_TSO;
<a name="l00538"></a>00538 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span>        netdev-&gt;features &amp;= ~NETIF_F_TSO6;
<a name="l00540"></a>00540 <span class="preprocessor">#endif</span>
<a name="l00541"></a>00541 <span class="preprocessor"></span>    }
<a name="l00542"></a>00542     <span class="keywordflow">return</span> 0;
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 <span class="keyword">static</span> u32 ixgbe_get_msglevel(<span class="keyword">struct</span> net_device *netdev)
<a name="l00547"></a>00547 {
<a name="l00548"></a>00548     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00549"></a>00549     <span class="keywordflow">return</span> adapter-&gt;msg_enable;
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_msglevel(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l00553"></a>00553 {
<a name="l00554"></a>00554     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00555"></a>00555     adapter-&gt;msg_enable = data;
<a name="l00556"></a>00556 }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_regs_len(<span class="keyword">struct</span> net_device *netdev)
<a name="l00559"></a>00559 {
<a name="l00560"></a>00560 <span class="preprocessor">#define IXGBE_REGS_LEN  1128</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span>    <span class="keywordflow">return</span> IXGBE_REGS_LEN * <span class="keyword">sizeof</span>(u32);
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="preprocessor">#define IXGBE_GET_STAT(_A_, _R_) _A_-&gt;stats._R_</span>
<a name="l00565"></a>00565 <span class="preprocessor"></span>
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_regs(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> ethtool_regs *regs,
<a name="l00568"></a>00568                            <span class="keywordtype">void</span> *p)
<a name="l00569"></a>00569 {
<a name="l00570"></a>00570     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00571"></a>00571     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00572"></a>00572     u32 *regs_buff = p;
<a name="l00573"></a>00573     u8 i;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575     memset(p, 0, IXGBE_REGS_LEN * <span class="keyword">sizeof</span>(u32));
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     regs-&gt;version = (1 &lt;&lt; 24) | hw-&gt;revision_id &lt;&lt; 16 | hw-&gt;device_id;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="comment">/* General Registers */</span>
<a name="l00580"></a>00580     regs_buff[0] = IXGBE_READ_REG(hw, IXGBE_CTRL);
<a name="l00581"></a>00581     regs_buff[1] = IXGBE_READ_REG(hw, IXGBE_STATUS);
<a name="l00582"></a>00582     regs_buff[2] = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
<a name="l00583"></a>00583     regs_buff[3] = IXGBE_READ_REG(hw, IXGBE_ESDP);
<a name="l00584"></a>00584     regs_buff[4] = IXGBE_READ_REG(hw, IXGBE_EODSDP);
<a name="l00585"></a>00585     regs_buff[5] = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
<a name="l00586"></a>00586     regs_buff[6] = IXGBE_READ_REG(hw, IXGBE_FRTIMER);
<a name="l00587"></a>00587     regs_buff[7] = IXGBE_READ_REG(hw, IXGBE_TCPTIMER);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589     <span class="comment">/* NVM Register */</span>
<a name="l00590"></a>00590     regs_buff[8] = IXGBE_READ_REG(hw, IXGBE_EEC);
<a name="l00591"></a>00591     regs_buff[9] = IXGBE_READ_REG(hw, IXGBE_EERD);
<a name="l00592"></a>00592     regs_buff[10] = IXGBE_READ_REG(hw, IXGBE_FLA);
<a name="l00593"></a>00593     regs_buff[11] = IXGBE_READ_REG(hw, IXGBE_EEMNGCTL);
<a name="l00594"></a>00594     regs_buff[12] = IXGBE_READ_REG(hw, IXGBE_EEMNGDATA);
<a name="l00595"></a>00595     regs_buff[13] = IXGBE_READ_REG(hw, IXGBE_FLMNGCTL);
<a name="l00596"></a>00596     regs_buff[14] = IXGBE_READ_REG(hw, IXGBE_FLMNGDATA);
<a name="l00597"></a>00597     regs_buff[15] = IXGBE_READ_REG(hw, IXGBE_FLMNGCNT);
<a name="l00598"></a>00598     regs_buff[16] = IXGBE_READ_REG(hw, IXGBE_FLOP);
<a name="l00599"></a>00599     regs_buff[17] = IXGBE_READ_REG(hw, IXGBE_GRC);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601     <span class="comment">/* Interrupt */</span>
<a name="l00602"></a>00602     <span class="comment">/* don&#39;t read EICR because it can clear interrupt causes, instead</span>
<a name="l00603"></a>00603 <span class="comment">     * read EICS which is a shadow but doesn&#39;t clear EICR */</span>
<a name="l00604"></a>00604     regs_buff[18] = IXGBE_READ_REG(hw, IXGBE_EICS);
<a name="l00605"></a>00605     regs_buff[19] = IXGBE_READ_REG(hw, IXGBE_EICS);
<a name="l00606"></a>00606     regs_buff[20] = IXGBE_READ_REG(hw, IXGBE_EIMS);
<a name="l00607"></a>00607     regs_buff[21] = IXGBE_READ_REG(hw, IXGBE_EIMC);
<a name="l00608"></a>00608     regs_buff[22] = IXGBE_READ_REG(hw, IXGBE_EIAC);
<a name="l00609"></a>00609     regs_buff[23] = IXGBE_READ_REG(hw, IXGBE_EIAM);
<a name="l00610"></a>00610     regs_buff[24] = IXGBE_READ_REG(hw, IXGBE_EITR(0));
<a name="l00611"></a>00611     regs_buff[25] = IXGBE_READ_REG(hw, IXGBE_IVAR(0));
<a name="l00612"></a>00612     regs_buff[26] = IXGBE_READ_REG(hw, IXGBE_MSIXT);
<a name="l00613"></a>00613     regs_buff[27] = IXGBE_READ_REG(hw, IXGBE_MSIXPBA);
<a name="l00614"></a>00614     regs_buff[28] = IXGBE_READ_REG(hw, IXGBE_PBACL(0));
<a name="l00615"></a>00615     regs_buff[29] = IXGBE_READ_REG(hw, IXGBE_GPIE);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     <span class="comment">/* Flow Control */</span>
<a name="l00618"></a>00618     regs_buff[30] = IXGBE_READ_REG(hw, IXGBE_PFCTOP);
<a name="l00619"></a>00619     regs_buff[31] = IXGBE_READ_REG(hw, IXGBE_FCTTV(0));
<a name="l00620"></a>00620     regs_buff[32] = IXGBE_READ_REG(hw, IXGBE_FCTTV(1));
<a name="l00621"></a>00621     regs_buff[33] = IXGBE_READ_REG(hw, IXGBE_FCTTV(2));
<a name="l00622"></a>00622     regs_buff[34] = IXGBE_READ_REG(hw, IXGBE_FCTTV(3));
<a name="l00623"></a>00623     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {
<a name="l00624"></a>00624         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00625"></a>00625         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00626"></a>00626             regs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL(i));
<a name="l00627"></a>00627             regs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH(i));
<a name="l00628"></a>00628             <span class="keywordflow">break</span>;
<a name="l00629"></a>00629         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00630"></a>00630         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00631"></a>00631             regs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL_82599(i));
<a name="l00632"></a>00632             regs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH_82599(i));
<a name="l00633"></a>00633             <span class="keywordflow">break</span>;
<a name="l00634"></a>00634         <span class="keywordflow">default</span>:
<a name="l00635"></a>00635             <span class="keywordflow">break</span>;
<a name="l00636"></a>00636         }
<a name="l00637"></a>00637     }
<a name="l00638"></a>00638     regs_buff[51] = IXGBE_READ_REG(hw, IXGBE_FCRTV);
<a name="l00639"></a>00639     regs_buff[52] = IXGBE_READ_REG(hw, IXGBE_TFCS);
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     <span class="comment">/* Receive DMA */</span>
<a name="l00642"></a>00642     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00643"></a>00643         regs_buff[53 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAL(i));
<a name="l00644"></a>00644     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00645"></a>00645         regs_buff[117 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAH(i));
<a name="l00646"></a>00646     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00647"></a>00647         regs_buff[181 + i] = IXGBE_READ_REG(hw, IXGBE_RDLEN(i));
<a name="l00648"></a>00648     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00649"></a>00649         regs_buff[245 + i] = IXGBE_READ_REG(hw, IXGBE_RDH(i));
<a name="l00650"></a>00650     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00651"></a>00651         regs_buff[309 + i] = IXGBE_READ_REG(hw, IXGBE_RDT(i));
<a name="l00652"></a>00652     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++)
<a name="l00653"></a>00653         regs_buff[373 + i] = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));
<a name="l00654"></a>00654     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00655"></a>00655         regs_buff[437 + i] = IXGBE_READ_REG(hw, IXGBE_SRRCTL(i));
<a name="l00656"></a>00656     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00657"></a>00657         regs_buff[453 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
<a name="l00658"></a>00658     regs_buff[469] = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
<a name="l00659"></a>00659     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00660"></a>00660         regs_buff[470 + i] = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i));
<a name="l00661"></a>00661     regs_buff[478] = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l00662"></a>00662     regs_buff[479] = IXGBE_READ_REG(hw, IXGBE_DROPEN);
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="comment">/* Receive */</span>
<a name="l00665"></a>00665     regs_buff[480] = IXGBE_READ_REG(hw, IXGBE_RXCSUM);
<a name="l00666"></a>00666     regs_buff[481] = IXGBE_READ_REG(hw, IXGBE_RFCTL);
<a name="l00667"></a>00667     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00668"></a>00668         regs_buff[482 + i] = IXGBE_READ_REG(hw, IXGBE_RAL(i));
<a name="l00669"></a>00669     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00670"></a>00670         regs_buff[498 + i] = IXGBE_READ_REG(hw, IXGBE_RAH(i));
<a name="l00671"></a>00671     regs_buff[514] = IXGBE_READ_REG(hw, IXGBE_PSRTYPE(0));
<a name="l00672"></a>00672     regs_buff[515] = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l00673"></a>00673     regs_buff[516] = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l00674"></a>00674     regs_buff[517] = IXGBE_READ_REG(hw, IXGBE_MCSTCTRL);
<a name="l00675"></a>00675     regs_buff[518] = IXGBE_READ_REG(hw, IXGBE_MRQC);
<a name="l00676"></a>00676     regs_buff[519] = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
<a name="l00677"></a>00677     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00678"></a>00678         regs_buff[520 + i] = IXGBE_READ_REG(hw, IXGBE_IMIR(i));
<a name="l00679"></a>00679     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00680"></a>00680         regs_buff[528 + i] = IXGBE_READ_REG(hw, IXGBE_IMIREXT(i));
<a name="l00681"></a>00681     regs_buff[536] = IXGBE_READ_REG(hw, IXGBE_IMIRVP);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683     <span class="comment">/* Transmit */</span>
<a name="l00684"></a>00684     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00685"></a>00685         regs_buff[537 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAL(i));
<a name="l00686"></a>00686     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00687"></a>00687         regs_buff[569 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAH(i));
<a name="l00688"></a>00688     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00689"></a>00689         regs_buff[601 + i] = IXGBE_READ_REG(hw, IXGBE_TDLEN(i));
<a name="l00690"></a>00690     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00691"></a>00691         regs_buff[633 + i] = IXGBE_READ_REG(hw, IXGBE_TDH(i));
<a name="l00692"></a>00692     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00693"></a>00693         regs_buff[665 + i] = IXGBE_READ_REG(hw, IXGBE_TDT(i));
<a name="l00694"></a>00694     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00695"></a>00695         regs_buff[697 + i] = IXGBE_READ_REG(hw, IXGBE_TXDCTL(i));
<a name="l00696"></a>00696     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00697"></a>00697         regs_buff[729 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAL(i));
<a name="l00698"></a>00698     <span class="keywordflow">for</span> (i = 0; i &lt; 32; i++)
<a name="l00699"></a>00699         regs_buff[761 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAH(i));
<a name="l00700"></a>00700     regs_buff[793] = IXGBE_READ_REG(hw, IXGBE_DTXCTL);
<a name="l00701"></a>00701     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00702"></a>00702         regs_buff[794 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));
<a name="l00703"></a>00703     regs_buff[810] = IXGBE_READ_REG(hw, IXGBE_TIPG);
<a name="l00704"></a>00704     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00705"></a>00705         regs_buff[811 + i] = IXGBE_READ_REG(hw, IXGBE_TXPBSIZE(i));
<a name="l00706"></a>00706     regs_buff[819] = IXGBE_READ_REG(hw, IXGBE_MNGTXMAP);
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     <span class="comment">/* Wake Up */</span>
<a name="l00709"></a>00709     regs_buff[820] = IXGBE_READ_REG(hw, IXGBE_WUC);
<a name="l00710"></a>00710     regs_buff[821] = IXGBE_READ_REG(hw, IXGBE_WUFC);
<a name="l00711"></a>00711     regs_buff[822] = IXGBE_READ_REG(hw, IXGBE_WUS);
<a name="l00712"></a>00712     regs_buff[823] = IXGBE_READ_REG(hw, IXGBE_IPAV);
<a name="l00713"></a>00713     regs_buff[824] = IXGBE_READ_REG(hw, IXGBE_IP4AT);
<a name="l00714"></a>00714     regs_buff[825] = IXGBE_READ_REG(hw, IXGBE_IP6AT);
<a name="l00715"></a>00715     regs_buff[826] = IXGBE_READ_REG(hw, IXGBE_WUPL);
<a name="l00716"></a>00716     regs_buff[827] = IXGBE_READ_REG(hw, IXGBE_WUPM);
<a name="l00717"></a>00717     regs_buff[828] = IXGBE_READ_REG(hw, IXGBE_FHFT(0));
<a name="l00718"></a>00718 
<a name="l00719"></a>00719     <span class="comment">/* DCB */</span>
<a name="l00720"></a>00720     regs_buff[829] = IXGBE_READ_REG(hw, IXGBE_RMCS);
<a name="l00721"></a>00721     regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_DPMCS);
<a name="l00722"></a>00722     regs_buff[831] = IXGBE_READ_REG(hw, IXGBE_PDPMCS);
<a name="l00723"></a>00723     regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RUPPBMR);
<a name="l00724"></a>00724     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00725"></a>00725         regs_buff[833 + i] = IXGBE_READ_REG(hw, IXGBE_RT2CR(i));
<a name="l00726"></a>00726     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00727"></a>00727         regs_buff[841 + i] = IXGBE_READ_REG(hw, IXGBE_RT2SR(i));
<a name="l00728"></a>00728     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00729"></a>00729         regs_buff[849 + i] = IXGBE_READ_REG(hw, IXGBE_TDTQ2TCCR(i));
<a name="l00730"></a>00730     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00731"></a>00731         regs_buff[857 + i] = IXGBE_READ_REG(hw, IXGBE_TDTQ2TCSR(i));
<a name="l00732"></a>00732     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00733"></a>00733         regs_buff[865 + i] = IXGBE_READ_REG(hw, IXGBE_TDPT2TCCR(i));
<a name="l00734"></a>00734     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00735"></a>00735         regs_buff[873 + i] = IXGBE_READ_REG(hw, IXGBE_TDPT2TCSR(i));
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     <span class="comment">/* Statistics */</span>
<a name="l00738"></a>00738     regs_buff[881] = IXGBE_GET_STAT(adapter, crcerrs);
<a name="l00739"></a>00739     regs_buff[882] = IXGBE_GET_STAT(adapter, illerrc);
<a name="l00740"></a>00740     regs_buff[883] = IXGBE_GET_STAT(adapter, errbc);
<a name="l00741"></a>00741     regs_buff[884] = IXGBE_GET_STAT(adapter, mspdc);
<a name="l00742"></a>00742     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00743"></a>00743         regs_buff[885 + i] = IXGBE_GET_STAT(adapter, mpc[i]);
<a name="l00744"></a>00744     regs_buff[893] = IXGBE_GET_STAT(adapter, mlfc);
<a name="l00745"></a>00745     regs_buff[894] = IXGBE_GET_STAT(adapter, mrfc);
<a name="l00746"></a>00746     regs_buff[895] = IXGBE_GET_STAT(adapter, rlec);
<a name="l00747"></a>00747     regs_buff[896] = IXGBE_GET_STAT(adapter, lxontxc);
<a name="l00748"></a>00748     regs_buff[897] = IXGBE_GET_STAT(adapter, lxonrxc);
<a name="l00749"></a>00749     regs_buff[898] = IXGBE_GET_STAT(adapter, lxofftxc);
<a name="l00750"></a>00750     regs_buff[899] = IXGBE_GET_STAT(adapter, lxoffrxc);
<a name="l00751"></a>00751     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00752"></a>00752         regs_buff[900 + i] = IXGBE_GET_STAT(adapter, pxontxc[i]);
<a name="l00753"></a>00753     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00754"></a>00754         regs_buff[908 + i] = IXGBE_GET_STAT(adapter, pxonrxc[i]);
<a name="l00755"></a>00755     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00756"></a>00756         regs_buff[916 + i] = IXGBE_GET_STAT(adapter, pxofftxc[i]);
<a name="l00757"></a>00757     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00758"></a>00758         regs_buff[924 + i] = IXGBE_GET_STAT(adapter, pxoffrxc[i]);
<a name="l00759"></a>00759     regs_buff[932] = IXGBE_GET_STAT(adapter, prc64);
<a name="l00760"></a>00760     regs_buff[933] = IXGBE_GET_STAT(adapter, prc127);
<a name="l00761"></a>00761     regs_buff[934] = IXGBE_GET_STAT(adapter, prc255);
<a name="l00762"></a>00762     regs_buff[935] = IXGBE_GET_STAT(adapter, prc511);
<a name="l00763"></a>00763     regs_buff[936] = IXGBE_GET_STAT(adapter, prc1023);
<a name="l00764"></a>00764     regs_buff[937] = IXGBE_GET_STAT(adapter, prc1522);
<a name="l00765"></a>00765     regs_buff[938] = IXGBE_GET_STAT(adapter, gprc);
<a name="l00766"></a>00766     regs_buff[939] = IXGBE_GET_STAT(adapter, bprc);
<a name="l00767"></a>00767     regs_buff[940] = IXGBE_GET_STAT(adapter, mprc);
<a name="l00768"></a>00768     regs_buff[941] = IXGBE_GET_STAT(adapter, gptc);
<a name="l00769"></a>00769     regs_buff[942] = IXGBE_GET_STAT(adapter, gorc);
<a name="l00770"></a>00770     regs_buff[944] = IXGBE_GET_STAT(adapter, gotc);
<a name="l00771"></a>00771     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00772"></a>00772         regs_buff[946 + i] = IXGBE_GET_STAT(adapter, rnbc[i]);
<a name="l00773"></a>00773     regs_buff[954] = IXGBE_GET_STAT(adapter, ruc);
<a name="l00774"></a>00774     regs_buff[955] = IXGBE_GET_STAT(adapter, rfc);
<a name="l00775"></a>00775     regs_buff[956] = IXGBE_GET_STAT(adapter, roc);
<a name="l00776"></a>00776     regs_buff[957] = IXGBE_GET_STAT(adapter, rjc);
<a name="l00777"></a>00777     regs_buff[958] = IXGBE_GET_STAT(adapter, mngprc);
<a name="l00778"></a>00778     regs_buff[959] = IXGBE_GET_STAT(adapter, mngpdc);
<a name="l00779"></a>00779     regs_buff[960] = IXGBE_GET_STAT(adapter, mngptc);
<a name="l00780"></a>00780     regs_buff[961] = IXGBE_GET_STAT(adapter, tor);
<a name="l00781"></a>00781     regs_buff[963] = IXGBE_GET_STAT(adapter, tpr);
<a name="l00782"></a>00782     regs_buff[964] = IXGBE_GET_STAT(adapter, tpt);
<a name="l00783"></a>00783     regs_buff[965] = IXGBE_GET_STAT(adapter, ptc64);
<a name="l00784"></a>00784     regs_buff[966] = IXGBE_GET_STAT(adapter, ptc127);
<a name="l00785"></a>00785     regs_buff[967] = IXGBE_GET_STAT(adapter, ptc255);
<a name="l00786"></a>00786     regs_buff[968] = IXGBE_GET_STAT(adapter, ptc511);
<a name="l00787"></a>00787     regs_buff[969] = IXGBE_GET_STAT(adapter, ptc1023);
<a name="l00788"></a>00788     regs_buff[970] = IXGBE_GET_STAT(adapter, ptc1522);
<a name="l00789"></a>00789     regs_buff[971] = IXGBE_GET_STAT(adapter, mptc);
<a name="l00790"></a>00790     regs_buff[972] = IXGBE_GET_STAT(adapter, bptc);
<a name="l00791"></a>00791     regs_buff[973] = IXGBE_GET_STAT(adapter, xec);
<a name="l00792"></a>00792     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00793"></a>00793         regs_buff[974 + i] = IXGBE_GET_STAT(adapter, qprc[i]);
<a name="l00794"></a>00794     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00795"></a>00795         regs_buff[990 + i] = IXGBE_GET_STAT(adapter, qptc[i]);
<a name="l00796"></a>00796     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00797"></a>00797         regs_buff[1006 + i] = IXGBE_GET_STAT(adapter, qbrc[i]);
<a name="l00798"></a>00798     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l00799"></a>00799         regs_buff[1022 + i] = IXGBE_GET_STAT(adapter, qbtc[i]);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801     <span class="comment">/* MAC */</span>
<a name="l00802"></a>00802     regs_buff[1038] = IXGBE_READ_REG(hw, IXGBE_PCS1GCFIG);
<a name="l00803"></a>00803     regs_buff[1039] = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);
<a name="l00804"></a>00804     regs_buff[1040] = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);
<a name="l00805"></a>00805     regs_buff[1041] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG0);
<a name="l00806"></a>00806     regs_buff[1042] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG1);
<a name="l00807"></a>00807     regs_buff[1043] = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
<a name="l00808"></a>00808     regs_buff[1044] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);
<a name="l00809"></a>00809     regs_buff[1045] = IXGBE_READ_REG(hw, IXGBE_PCS1GANNP);
<a name="l00810"></a>00810     regs_buff[1046] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLPNP);
<a name="l00811"></a>00811     regs_buff[1047] = IXGBE_READ_REG(hw, IXGBE_HLREG0);
<a name="l00812"></a>00812     regs_buff[1048] = IXGBE_READ_REG(hw, IXGBE_HLREG1);
<a name="l00813"></a>00813     regs_buff[1049] = IXGBE_READ_REG(hw, IXGBE_PAP);
<a name="l00814"></a>00814     regs_buff[1050] = IXGBE_READ_REG(hw, IXGBE_MACA);
<a name="l00815"></a>00815     regs_buff[1051] = IXGBE_READ_REG(hw, IXGBE_APAE);
<a name="l00816"></a>00816     regs_buff[1052] = IXGBE_READ_REG(hw, IXGBE_ARD);
<a name="l00817"></a>00817     regs_buff[1053] = IXGBE_READ_REG(hw, IXGBE_AIS);
<a name="l00818"></a>00818     regs_buff[1054] = IXGBE_READ_REG(hw, IXGBE_MSCA);
<a name="l00819"></a>00819     regs_buff[1055] = IXGBE_READ_REG(hw, IXGBE_MSRWD);
<a name="l00820"></a>00820     regs_buff[1056] = IXGBE_READ_REG(hw, IXGBE_MLADD);
<a name="l00821"></a>00821     regs_buff[1057] = IXGBE_READ_REG(hw, IXGBE_MHADD);
<a name="l00822"></a>00822     regs_buff[1058] = IXGBE_READ_REG(hw, IXGBE_TREG);
<a name="l00823"></a>00823     regs_buff[1059] = IXGBE_READ_REG(hw, IXGBE_PCSS1);
<a name="l00824"></a>00824     regs_buff[1060] = IXGBE_READ_REG(hw, IXGBE_PCSS2);
<a name="l00825"></a>00825     regs_buff[1061] = IXGBE_READ_REG(hw, IXGBE_XPCSS);
<a name="l00826"></a>00826     regs_buff[1062] = IXGBE_READ_REG(hw, IXGBE_SERDESC);
<a name="l00827"></a>00827     regs_buff[1063] = IXGBE_READ_REG(hw, IXGBE_MACS);
<a name="l00828"></a>00828     regs_buff[1064] = IXGBE_READ_REG(hw, IXGBE_AUTOC);
<a name="l00829"></a>00829     regs_buff[1065] = IXGBE_READ_REG(hw, IXGBE_LINKS);
<a name="l00830"></a>00830     regs_buff[1066] = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
<a name="l00831"></a>00831     regs_buff[1067] = IXGBE_READ_REG(hw, IXGBE_AUTOC3);
<a name="l00832"></a>00832     regs_buff[1068] = IXGBE_READ_REG(hw, IXGBE_ANLP1);
<a name="l00833"></a>00833     regs_buff[1069] = IXGBE_READ_REG(hw, IXGBE_ANLP2);
<a name="l00834"></a>00834     regs_buff[1070] = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);
<a name="l00835"></a>00835 
<a name="l00836"></a>00836     <span class="comment">/* Diagnostic */</span>
<a name="l00837"></a>00837     regs_buff[1071] = IXGBE_READ_REG(hw, IXGBE_RDSTATCTL);
<a name="l00838"></a>00838     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00839"></a>00839         regs_buff[1072 + i] = IXGBE_READ_REG(hw, IXGBE_RDSTAT(i));
<a name="l00840"></a>00840     regs_buff[1080] = IXGBE_READ_REG(hw, IXGBE_RDHMPN);
<a name="l00841"></a>00841     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
<a name="l00842"></a>00842         regs_buff[1081 + i] = IXGBE_READ_REG(hw, IXGBE_RIC_DW(i));
<a name="l00843"></a>00843     regs_buff[1085] = IXGBE_READ_REG(hw, IXGBE_RDPROBE);
<a name="l00844"></a>00844     regs_buff[1086] = IXGBE_READ_REG(hw, IXGBE_TDSTATCTL);
<a name="l00845"></a>00845     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00846"></a>00846         regs_buff[1087 + i] = IXGBE_READ_REG(hw, IXGBE_TDSTAT(i));
<a name="l00847"></a>00847     regs_buff[1095] = IXGBE_READ_REG(hw, IXGBE_TDHMPN);
<a name="l00848"></a>00848     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
<a name="l00849"></a>00849         regs_buff[1096 + i] = IXGBE_READ_REG(hw, IXGBE_TIC_DW(i));
<a name="l00850"></a>00850     regs_buff[1100] = IXGBE_READ_REG(hw, IXGBE_TDPROBE);
<a name="l00851"></a>00851     regs_buff[1101] = IXGBE_READ_REG(hw, IXGBE_TXBUFCTRL);
<a name="l00852"></a>00852     regs_buff[1102] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA0);
<a name="l00853"></a>00853     regs_buff[1103] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA1);
<a name="l00854"></a>00854     regs_buff[1104] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA2);
<a name="l00855"></a>00855     regs_buff[1105] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA3);
<a name="l00856"></a>00856     regs_buff[1106] = IXGBE_READ_REG(hw, IXGBE_RXBUFCTRL);
<a name="l00857"></a>00857     regs_buff[1107] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA0);
<a name="l00858"></a>00858     regs_buff[1108] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA1);
<a name="l00859"></a>00859     regs_buff[1109] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA2);
<a name="l00860"></a>00860     regs_buff[1110] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA3);
<a name="l00861"></a>00861     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)
<a name="l00862"></a>00862         regs_buff[1111 + i] = IXGBE_READ_REG(hw, IXGBE_PCIE_DIAG(i));
<a name="l00863"></a>00863     regs_buff[1119] = IXGBE_READ_REG(hw, IXGBE_RFVAL);
<a name="l00864"></a>00864     regs_buff[1120] = IXGBE_READ_REG(hw, IXGBE_MDFTC1);
<a name="l00865"></a>00865     regs_buff[1121] = IXGBE_READ_REG(hw, IXGBE_MDFTC2);
<a name="l00866"></a>00866     regs_buff[1122] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO1);
<a name="l00867"></a>00867     regs_buff[1123] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO2);
<a name="l00868"></a>00868     regs_buff[1124] = IXGBE_READ_REG(hw, IXGBE_MDFTS);
<a name="l00869"></a>00869     regs_buff[1125] = IXGBE_READ_REG(hw, IXGBE_PCIEECCCTL);
<a name="l00870"></a>00870     regs_buff[1126] = IXGBE_READ_REG(hw, IXGBE_PBTXECC);
<a name="l00871"></a>00871     regs_buff[1127] = IXGBE_READ_REG(hw, IXGBE_PBRXECC);
<a name="l00872"></a>00872 }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_eeprom_len(<span class="keyword">struct</span> net_device *netdev)
<a name="l00875"></a>00875 {
<a name="l00876"></a>00876     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00877"></a>00877     <span class="keywordflow">return</span> adapter-&gt;hw.eeprom.word_size * 2;
<a name="l00878"></a>00878 }
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_eeprom(<span class="keyword">struct</span> net_device *netdev,
<a name="l00881"></a>00881                             <span class="keyword">struct</span> <a class="code" href="structethtool__eeprom.html">ethtool_eeprom</a> *eeprom, u8 *bytes)
<a name="l00882"></a>00882 {
<a name="l00883"></a>00883     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00884"></a>00884     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00885"></a>00885     u16 *eeprom_buff;
<a name="l00886"></a>00886     <span class="keywordtype">int</span> first_word, last_word, eeprom_len;
<a name="l00887"></a>00887     <span class="keywordtype">int</span> ret_val = 0;
<a name="l00888"></a>00888     u16 i;
<a name="l00889"></a>00889 
<a name="l00890"></a>00890     <span class="keywordflow">if</span> (eeprom-&gt;len == 0)
<a name="l00891"></a>00891         <span class="keywordflow">return</span> -EINVAL;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893     eeprom-&gt;magic = hw-&gt;vendor_id | (hw-&gt;device_id &lt;&lt; 16);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     first_word = eeprom-&gt;offset &gt;&gt; 1;
<a name="l00896"></a>00896     last_word = (eeprom-&gt;offset + eeprom-&gt;len - 1) &gt;&gt; 1;
<a name="l00897"></a>00897     eeprom_len = last_word - first_word + 1;
<a name="l00898"></a>00898 
<a name="l00899"></a>00899     eeprom_buff = kmalloc(<span class="keyword">sizeof</span>(u16) * eeprom_len, GFP_KERNEL);
<a name="l00900"></a>00900     <span class="keywordflow">if</span> (!eeprom_buff)
<a name="l00901"></a>00901         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903     <span class="keywordflow">for</span> (i = 0; i &lt; eeprom_len; i++) {
<a name="l00904"></a>00904         <span class="keywordflow">if</span> ((ret_val = ixgbe_read_eeprom(hw, first_word + i,
<a name="l00905"></a>00905                          &amp;eeprom_buff[i])))
<a name="l00906"></a>00906             <span class="keywordflow">break</span>;
<a name="l00907"></a>00907     }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     <span class="comment">/* Device&#39;s eeprom is always little-endian, word addressable */</span>
<a name="l00910"></a>00910     <span class="keywordflow">for</span> (i = 0; i &lt; eeprom_len; i++)
<a name="l00911"></a>00911         le16_to_cpus(&amp;eeprom_buff[i]);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913     memcpy(bytes, (u8 *)eeprom_buff + (eeprom-&gt;offset &amp; 1), eeprom-&gt;len);
<a name="l00914"></a>00914     kfree(eeprom_buff);
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     <span class="keywordflow">return</span> ret_val;
<a name="l00917"></a>00917 }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_eeprom(<span class="keyword">struct</span> net_device *netdev,
<a name="l00920"></a>00920                             <span class="keyword">struct</span> <a class="code" href="structethtool__eeprom.html">ethtool_eeprom</a> *eeprom, u8 *bytes)
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00923"></a>00923     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00924"></a>00924     u16 *eeprom_buff;
<a name="l00925"></a>00925     <span class="keywordtype">void</span> *ptr;
<a name="l00926"></a>00926     <span class="keywordtype">int</span> max_len, first_word, last_word, ret_val = 0;
<a name="l00927"></a>00927     u16 i;
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00930"></a>00930 <span class="preprocessor"></span>    {
<a name="l00931"></a>00931       <span class="comment">/* Let&#39;s see if we can cast this structure to a filter */</span>
<a name="l00932"></a>00932       <span class="keywordtype">int</span> debug = 0;
<a name="l00933"></a>00933       u8 request_type = eeprom-&gt;len;
<a name="l00934"></a>00934 
<a name="l00935"></a>00935       <span class="keywordflow">if</span>(debug)
<a name="l00936"></a>00936         printk(<span class="stringliteral">&quot;--&gt; ixgbe_set_eeprom(command=%d/magic=%d/bytes=%p)\n&quot;</span>, 
<a name="l00937"></a>00937            request_type, eeprom-&gt;magic, bytes);
<a name="l00938"></a>00938 
<a name="l00939"></a>00939       <span class="keywordflow">if</span>((eeprom-&gt;magic == MAGIC_HW_FILTERING_RULE_REQUEST)
<a name="l00940"></a>00940          &amp;&amp; ((request_type == 0 <span class="comment">/* ckeck */</span>) || (request_type == 1 <span class="comment">/* add/remove */</span>))) {
<a name="l00941"></a>00941         <span class="comment">/* Here we go! */</span>
<a name="l00942"></a>00942         <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00943"></a>00943         <span class="keyword">union </span><a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a> input_struct;
<a name="l00944"></a>00944         <span class="keyword">struct </span><a class="code" href="structixgbe__atr__input__masks.html">ixgbe_atr_input_masks</a> input_masks;
<a name="l00945"></a>00945         <span class="keywordtype">int</span> target_queue;
<a name="l00946"></a>00946         hw_filtering_rule_command request = (hw_filtering_rule_command)eeprom-&gt;offset;
<a name="l00947"></a>00947         <a class="code" href="structhw__filtering__rule.html">hw_filtering_rule</a> *rule = (<a class="code" href="structhw__filtering__rule.html">hw_filtering_rule</a>*)bytes;
<a name="l00948"></a>00948         <a class="code" href="structintel__82599__perfect__filter__hw__rule.html">intel_82599_perfect_filter_hw_rule</a> *perfect_rule;
<a name="l00949"></a>00949         <a class="code" href="structintel__82599__five__tuple__filter__hw__rule.html">intel_82599_five_tuple_filter_hw_rule</a> *ftfq_rule;
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         <span class="keywordflow">if</span>(debug)
<a name="l00952"></a>00952           printk(<span class="stringliteral">&quot;--&gt; ixgbe_set_eeprom(command=%d)\n&quot;</span>, request_type);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB) {
<a name="l00955"></a>00955           <span class="keywordflow">if</span>(debug) printk(<span class="stringliteral">&quot;--&gt; ixgbe_set_rx_ntuple [error %d]\n&quot;</span>, 1);
<a name="l00956"></a>00956           <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958 
<a name="l00959"></a>00959         <span class="keywordflow">if</span>(request_type == 0) {
<a name="l00960"></a>00960           <span class="comment">/* ckeck */</span>
<a name="l00961"></a>00961           <span class="comment">/*</span>
<a name="l00962"></a>00962 <span class="comment">        We just want to check if this interface</span>
<a name="l00963"></a>00963 <span class="comment">        supports hardware filtering</span>
<a name="l00964"></a>00964 <span class="comment">          */</span>
<a name="l00965"></a>00965           <span class="keywordflow">return</span>(0);
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         <span class="keywordflow">if</span>(bytes != NULL) {
<a name="l00969"></a>00969           <span class="keywordflow">switch</span>(rule-&gt;rule_family_type) {
<a name="l00970"></a>00970           <span class="keywordflow">case</span> intel_82599_five_tuple_rule:
<a name="l00971"></a>00971         ftfq_rule = &amp;rule-&gt;rule_family.five_tuple_rule;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="comment">/* determine if we need to drop or route the packet */</span>
<a name="l00974"></a>00974         <span class="keywordflow">if</span>(ftfq_rule-&gt;queue_id &gt;= (MAX_RX_QUEUES - 1))
<a name="l00975"></a>00975           target_queue = MAX_RX_QUEUES - 1;
<a name="l00976"></a>00976         <span class="keywordflow">else</span>
<a name="l00977"></a>00977           target_queue = ftfq_rule-&gt;queue_id;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         <span class="keywordflow">if</span>(debug)
<a name="l00980"></a>00980           printk(<span class="stringliteral">&quot;--&gt; ixgbe_ftqf_add_filter(id=%d,target_queue=%d) called\n&quot;</span>,
<a name="l00981"></a>00981              rule-&gt;rule_id, target_queue);
<a name="l00982"></a>00982 
<a name="l00983"></a>00983         spin_lock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l00984"></a>00984         <span class="keywordflow">if</span>(request == add_hw_rule) {
<a name="l00985"></a>00985           ixgbe_ftqf_add_filter(&amp;adapter-&gt;hw, ftfq_rule-&gt;proto,
<a name="l00986"></a>00986                     ftfq_rule-&gt;s_addr, ftfq_rule-&gt;s_port,
<a name="l00987"></a>00987                     ftfq_rule-&gt;d_addr, ftfq_rule-&gt;d_port,
<a name="l00988"></a>00988                     target_queue, rule-&gt;rule_id);
<a name="l00989"></a>00989         } <span class="keywordflow">else</span> { <span class="comment">/* Remove */</span>
<a name="l00990"></a>00990           <span class="comment">/* Set the rule to accept all */</span>
<a name="l00991"></a>00991           ixgbe_ftqf_add_filter(&amp;adapter-&gt;hw,
<a name="l00992"></a>00992                     0, 0, 0, 0, 0,
<a name="l00993"></a>00993                     0, rule-&gt;rule_id);
<a name="l00994"></a>00994         }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996         spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l00997"></a>00997         <span class="keywordflow">break</span>;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999           <span class="keywordflow">case</span> intel_82599_perfect_filter_rule:
<a name="l01000"></a>01000         perfect_rule = &amp;rule-&gt;rule_family.perfect_rule;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002         <span class="comment">/*</span>
<a name="l01003"></a>01003 <span class="comment">         * Don&#39;t allow programming if we&#39;re not in perfect filter mode, or</span>
<a name="l01004"></a>01004 <span class="comment">         * if the action is a queue greater than the number of online Tx</span>
<a name="l01005"></a>01005 <span class="comment">         * queues.</span>
<a name="l01006"></a>01006 <span class="comment">         */</span>
<a name="l01007"></a>01007         <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)) {
<a name="l01008"></a>01008           <span class="keywordflow">if</span>(debug) {
<a name="l01009"></a>01009             printk(<span class="stringliteral">&quot;--&gt; IXGBE_FLAG_FDIR_PERFECT_CAPABLE=%d\n&quot;</span>, (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE) ? 1 : 0);
<a name="l01010"></a>01010           }
<a name="l01011"></a>01011           <span class="keywordflow">return</span> -EINVAL;
<a name="l01012"></a>01012         }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 
<a name="l01015"></a>01015         <span class="comment">/* determine if we need to drop or route the packet */</span>
<a name="l01016"></a>01016         <span class="keywordflow">if</span>(perfect_rule-&gt;queue_id &gt;= (MAX_RX_QUEUES - 1))
<a name="l01017"></a>01017           target_queue = MAX_RX_QUEUES - 1;
<a name="l01018"></a>01018         <span class="keywordflow">else</span>
<a name="l01019"></a>01019           target_queue = perfect_rule-&gt;queue_id;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021         memset(&amp;input_struct, 0, <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a>));
<a name="l01022"></a>01022         memset(&amp;input_masks, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__atr__input__masks.html">ixgbe_atr_input_masks</a>));
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <span class="keywordflow">if</span>(debug)
<a name="l01025"></a>01025           printk(<span class="stringliteral">&quot;--&gt; ixgbe_set_rx_ntuple(rule_id=%d, request=%d, proto=%d, vlan=%d, ips=%08X, sport=%d, ipd=%08X, dport=%d)\n&quot;</span>,
<a name="l01026"></a>01026              rule-&gt;rule_id, request,
<a name="l01027"></a>01027              perfect_rule-&gt;proto, perfect_rule-&gt;vlan_id,
<a name="l01028"></a>01028              perfect_rule-&gt;s_addr, perfect_rule-&gt;s_port,
<a name="l01029"></a>01029              perfect_rule-&gt;d_addr, perfect_rule-&gt;d_port);
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         <span class="keywordflow">if</span>(perfect_rule-&gt;proto == 6 <span class="comment">/* TCP */</span>) {
<a name="l01032"></a>01032           ixgbe_atr_set_l4type_82599(&amp;input_struct, IXGBE_ATR_L4TYPE_TCP);
<a name="l01033"></a>01033         } <span class="keywordflow">else</span> {
<a name="l01034"></a>01034           ixgbe_atr_set_l4type_82599(&amp;input_struct, IXGBE_ATR_L4TYPE_UDP);
<a name="l01035"></a>01035         }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037         <span class="keywordflow">if</span>(request == add_hw_rule) {
<a name="l01038"></a>01038           <span class="comment">/* Mask bits from the inputs based on user-supplied mask */</span>
<a name="l01039"></a>01039           <span class="keywordflow">if</span>(perfect_rule-&gt;s_addr) {
<a name="l01040"></a>01040             perfect_rule-&gt;s_addr = htonl(perfect_rule-&gt;s_addr);
<a name="l01041"></a>01041             ixgbe_atr_set_src_ipv4_82599(&amp;input_struct, (perfect_rule-&gt;s_addr &amp; ~perfect_rule-&gt;s_addr));
<a name="l01042"></a>01042           }
<a name="l01043"></a>01043 
<a name="l01044"></a>01044           <span class="keywordflow">if</span>(perfect_rule-&gt;d_addr) {
<a name="l01045"></a>01045             perfect_rule-&gt;d_addr = htonl(perfect_rule-&gt;d_addr);
<a name="l01046"></a>01046             ixgbe_atr_set_dst_ipv4_82599(&amp;input_struct, (perfect_rule-&gt;d_addr &amp; ~perfect_rule-&gt;d_addr));
<a name="l01047"></a>01047           }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049           <span class="comment">/* 82599 expects these to be byte-swapped for perfect filtering */</span>
<a name="l01050"></a>01050           <span class="keywordflow">if</span>(perfect_rule-&gt;s_port) {
<a name="l01051"></a>01051             perfect_rule-&gt;s_port = perfect_rule-&gt;s_port;
<a name="l01052"></a>01052             ixgbe_atr_set_src_port_82599(&amp;input_struct, ((ntohs(perfect_rule-&gt;s_port)) &amp; ~perfect_rule-&gt;s_port));
<a name="l01053"></a>01053           }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055           <span class="keywordflow">if</span>(perfect_rule-&gt;d_port) {
<a name="l01056"></a>01056             perfect_rule-&gt;d_port = perfect_rule-&gt;d_port;
<a name="l01057"></a>01057             ixgbe_atr_set_dst_port_82599(&amp;input_struct, ((ntohs(perfect_rule-&gt;d_port)) &amp; ~perfect_rule-&gt;d_port));
<a name="l01058"></a>01058           }
<a name="l01059"></a>01059 
<a name="l01060"></a>01060           <span class="comment">/* VLAN and Flex bytes are either completely masked or not */</span>
<a name="l01061"></a>01061           <span class="keywordflow">if</span> (perfect_rule-&gt;vlan_id) {
<a name="l01062"></a>01062             input_struct.formatted.vlan_id = htons(perfect_rule-&gt;vlan_id &amp; 0xEFFF);
<a name="l01063"></a>01063             input_masks.vlan_id_mask = htons(0xFFF);
<a name="l01064"></a>01064           }
<a name="l01065"></a>01065         }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067         spin_lock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l01068"></a>01068         <span class="keywordflow">if</span>(debug)
<a name="l01069"></a>01069           printk(<span class="stringliteral">&quot;--&gt; ixgbe_fdir_add_perfect_filter_82599(id=%d,target_queue=%d/%d/%d) called\n&quot;</span>,
<a name="l01070"></a>01070              rule-&gt;rule_id, target_queue, target_queue, MAX_RX_QUEUES);
<a name="l01071"></a>01071         ixgbe_fdir_add_perfect_filter_82599(&amp;adapter-&gt;hw, &amp;input_struct, &amp;input_masks, rule-&gt;rule_id,
<a name="l01072"></a>01072                             (request == add_hw_rule) ? target_queue : 0);
<a name="l01073"></a>01073         spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l01074"></a>01074         <span class="keywordflow">break</span>;
<a name="l01075"></a>01075 
<a name="l01076"></a>01076           <span class="keywordflow">default</span>:
<a name="l01077"></a>01077         <span class="keywordflow">return</span> -EOPNOTSUPP; <span class="comment">/* It should not happen */</span>
<a name="l01078"></a>01078           } <span class="comment">/* switch */</span>
<a name="l01079"></a>01079 
<a name="l01080"></a>01080           <span class="keywordflow">return</span> 0;
<a name="l01081"></a>01081         }
<a name="l01082"></a>01082       }
<a name="l01083"></a>01083     }
<a name="l01084"></a>01084 <span class="preprocessor">#endif</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span>
<a name="l01086"></a>01086     <span class="keywordflow">if</span> (eeprom-&gt;len == 0)
<a name="l01087"></a>01087         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l01088"></a>01088 
<a name="l01089"></a>01089     <span class="keywordflow">if</span> (eeprom-&gt;magic != (hw-&gt;vendor_id | (hw-&gt;device_id &lt;&lt; 16)))
<a name="l01090"></a>01090         <span class="keywordflow">return</span> -EFAULT;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     max_len = hw-&gt;eeprom.word_size * 2;
<a name="l01093"></a>01093 
<a name="l01094"></a>01094     first_word = eeprom-&gt;offset &gt;&gt; 1;
<a name="l01095"></a>01095     last_word = (eeprom-&gt;offset + eeprom-&gt;len - 1) &gt;&gt; 1;
<a name="l01096"></a>01096     eeprom_buff = kmalloc(max_len, GFP_KERNEL);
<a name="l01097"></a>01097     <span class="keywordflow">if</span> (!eeprom_buff)
<a name="l01098"></a>01098         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01099"></a>01099 
<a name="l01100"></a>01100     ptr = (<span class="keywordtype">void</span> *)eeprom_buff;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="keywordflow">if</span> (eeprom-&gt;offset &amp; 1) {
<a name="l01103"></a>01103         <span class="comment">/* need read/modify/write of first changed EEPROM word */</span>
<a name="l01104"></a>01104         <span class="comment">/* only the second byte of the word is being modified */</span>
<a name="l01105"></a>01105         ret_val = ixgbe_read_eeprom(hw, first_word, &amp;eeprom_buff[0]);
<a name="l01106"></a>01106         ptr++;
<a name="l01107"></a>01107     }
<a name="l01108"></a>01108     <span class="keywordflow">if</span> (((eeprom-&gt;offset + eeprom-&gt;len) &amp; 1) &amp;&amp; (ret_val == 0)) {
<a name="l01109"></a>01109         <span class="comment">/* need read/modify/write of last changed EEPROM word */</span>
<a name="l01110"></a>01110         <span class="comment">/* only the first byte of the word is being modified */</span>
<a name="l01111"></a>01111         ret_val = ixgbe_read_eeprom(hw, last_word,
<a name="l01112"></a>01112                           &amp;eeprom_buff[last_word - first_word]);
<a name="l01113"></a>01113     }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115     <span class="comment">/* Device&#39;s eeprom is always little-endian, word addressable */</span>
<a name="l01116"></a>01116     <span class="keywordflow">for</span> (i = 0; i &lt; last_word - first_word + 1; i++)
<a name="l01117"></a>01117         le16_to_cpus(&amp;eeprom_buff[i]);
<a name="l01118"></a>01118 
<a name="l01119"></a>01119     memcpy(ptr, bytes, eeprom-&gt;len);
<a name="l01120"></a>01120 
<a name="l01121"></a>01121     <span class="keywordflow">for</span> (i = 0; i &lt;= (last_word - first_word); i++)
<a name="l01122"></a>01122         ret_val |= ixgbe_write_eeprom(hw, first_word + i, eeprom_buff[i]);
<a name="l01123"></a>01123 
<a name="l01124"></a>01124     <span class="comment">/* Update the checksum */</span>
<a name="l01125"></a>01125     ixgbe_update_eeprom_checksum(hw);
<a name="l01126"></a>01126 
<a name="l01127"></a>01127     kfree(eeprom_buff);
<a name="l01128"></a>01128     <span class="keywordflow">return</span> ret_val;
<a name="l01129"></a>01129 }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_drvinfo(<span class="keyword">struct</span> net_device *netdev,
<a name="l01132"></a>01132                               <span class="keyword">struct</span> ethtool_drvinfo *drvinfo)
<a name="l01133"></a>01133 {
<a name="l01134"></a>01134     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01135"></a>01135     <span class="keywordtype">char</span> firmware_version[32];
<a name="l01136"></a>01136 
<a name="l01137"></a>01137     strncpy(drvinfo-&gt;driver, ixgbe_driver_name, <span class="keyword">sizeof</span>(drvinfo-&gt;driver));
<a name="l01138"></a>01138     strncpy(drvinfo-&gt;version, ixgbe_driver_version,
<a name="l01139"></a>01139             <span class="keyword">sizeof</span>(drvinfo-&gt;version));
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     snprintf(firmware_version, <span class="keyword">sizeof</span>(firmware_version), <span class="stringliteral">&quot;%d.%d-%d&quot;</span>,
<a name="l01142"></a>01142              (adapter-&gt;eeprom_version &amp; 0xF000) &gt;&gt; 12,
<a name="l01143"></a>01143              (adapter-&gt;eeprom_version &amp; 0x0FF0) &gt;&gt; 4,
<a name="l01144"></a>01144              adapter-&gt;eeprom_version &amp; 0x000F);
<a name="l01145"></a>01145 
<a name="l01146"></a>01146     strncpy(drvinfo-&gt;fw_version, firmware_version,
<a name="l01147"></a>01147             <span class="keyword">sizeof</span>(drvinfo-&gt;fw_version));
<a name="l01148"></a>01148     strncpy(drvinfo-&gt;bus_info, pci_name(adapter-&gt;pdev),
<a name="l01149"></a>01149             <span class="keyword">sizeof</span>(drvinfo-&gt;bus_info));
<a name="l01150"></a>01150     drvinfo-&gt;n_stats = IXGBE_STATS_LEN;
<a name="l01151"></a>01151     drvinfo-&gt;testinfo_len = IXGBE_TEST_LEN;
<a name="l01152"></a>01152     drvinfo-&gt;regdump_len = ixgbe_get_regs_len(netdev);
<a name="l01153"></a>01153 }
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_ringparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l01156"></a>01156                                 <span class="keyword">struct</span> ethtool_ringparam *ring)
<a name="l01157"></a>01157 {
<a name="l01158"></a>01158     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01159"></a>01159     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[0];
<a name="l01160"></a>01160     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = adapter-&gt;rx_ring[0];
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     ring-&gt;rx_max_pending = IXGBE_MAX_RXD;
<a name="l01163"></a>01163     ring-&gt;tx_max_pending = IXGBE_MAX_TXD;
<a name="l01164"></a>01164     ring-&gt;rx_mini_max_pending = 0;
<a name="l01165"></a>01165     ring-&gt;rx_jumbo_max_pending = 0;
<a name="l01166"></a>01166     ring-&gt;rx_pending = rx_ring-&gt;count;
<a name="l01167"></a>01167     ring-&gt;tx_pending = tx_ring-&gt;count;
<a name="l01168"></a>01168     ring-&gt;rx_mini_pending = 0;
<a name="l01169"></a>01169     ring-&gt;rx_jumbo_pending = 0;
<a name="l01170"></a>01170 }
<a name="l01171"></a>01171 
<a name="l01172"></a>01172 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_ringparam(<span class="keyword">struct</span> net_device *netdev,
<a name="l01173"></a>01173                                <span class="keyword">struct</span> ethtool_ringparam *ring)
<a name="l01174"></a>01174 {
<a name="l01175"></a>01175     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01176"></a>01176     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *temp_tx_ring, *temp_rx_ring;
<a name="l01177"></a>01177     <span class="keywordtype">int</span> i, err = 0;
<a name="l01178"></a>01178     u32 new_rx_count, new_tx_count;
<a name="l01179"></a>01179     <span class="keywordtype">bool</span> need_update = <span class="keyword">false</span>;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181     <span class="keywordflow">if</span> ((ring-&gt;rx_mini_pending) || (ring-&gt;rx_jumbo_pending))
<a name="l01182"></a>01182         <span class="keywordflow">return</span> -EINVAL;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     new_rx_count = max(ring-&gt;rx_pending, (u32)IXGBE_MIN_RXD);
<a name="l01185"></a>01185     new_rx_count = min(new_rx_count, (u32)IXGBE_MAX_RXD);
<a name="l01186"></a>01186     new_rx_count = ALIGN(new_rx_count, IXGBE_REQ_RX_DESCRIPTOR_MULTIPLE);
<a name="l01187"></a>01187 
<a name="l01188"></a>01188     new_tx_count = max(ring-&gt;tx_pending, (u32)IXGBE_MIN_TXD);
<a name="l01189"></a>01189     new_tx_count = min(new_tx_count, (u32)IXGBE_MAX_TXD);
<a name="l01190"></a>01190     new_tx_count = ALIGN(new_tx_count, IXGBE_REQ_TX_DESCRIPTOR_MULTIPLE);
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     <span class="keywordflow">if</span> ((new_tx_count == adapter-&gt;tx_ring[0]-&gt;count) &amp;&amp;
<a name="l01193"></a>01193         (new_rx_count == adapter-&gt;rx_ring[0]-&gt;count)) {
<a name="l01194"></a>01194         <span class="comment">/* nothing to do */</span>
<a name="l01195"></a>01195         <span class="keywordflow">return</span> 0;
<a name="l01196"></a>01196     }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198     <span class="keywordflow">while</span> (test_and_set_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l01199"></a>01199         msleep(1);
<a name="l01200"></a>01200 
<a name="l01201"></a>01201     <span class="keywordflow">if</span> (!netif_running(adapter-&gt;netdev)) {
<a name="l01202"></a>01202         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l01203"></a>01203             adapter-&gt;tx_ring[i]-&gt;count = new_tx_count;
<a name="l01204"></a>01204         for (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l01205"></a>01205             adapter-&gt;rx_ring[i]-&gt;count = new_rx_count;
<a name="l01206"></a>01206         adapter-&gt;tx_ring_count = new_tx_count;
<a name="l01207"></a>01207         adapter-&gt;rx_ring_count = new_rx_count;
<a name="l01208"></a>01208         <span class="keywordflow">goto</span> clear_reset;
<a name="l01209"></a>01209     }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211     temp_tx_ring = vmalloc(adapter-&gt;num_tx_queues * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01212"></a>01212     <span class="keywordflow">if</span> (!temp_tx_ring) {
<a name="l01213"></a>01213         err = -ENOMEM;
<a name="l01214"></a>01214         <span class="keywordflow">goto</span> clear_reset;
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216 
<a name="l01217"></a>01217     <span class="keywordflow">if</span> (new_tx_count != adapter-&gt;tx_ring_count) {
<a name="l01218"></a>01218         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l01219"></a>01219             memcpy(&amp;temp_tx_ring[i], adapter-&gt;tx_ring[i],
<a name="l01220"></a>01220                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01221"></a>01221             temp_tx_ring[i].count = new_tx_count;
<a name="l01222"></a>01222             err = ixgbe_setup_tx_resources(&amp;temp_tx_ring[i]);
<a name="l01223"></a>01223             <span class="keywordflow">if</span> (err) {
<a name="l01224"></a>01224                 <span class="keywordflow">while</span> (i) {
<a name="l01225"></a>01225                     i--;
<a name="l01226"></a>01226                     ixgbe_free_tx_resources(&amp;temp_tx_ring[i]);
<a name="l01227"></a>01227                 }
<a name="l01228"></a>01228                 <span class="keywordflow">goto</span> clear_reset;
<a name="l01229"></a>01229             }
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231         need_update = <span class="keyword">true</span>;
<a name="l01232"></a>01232     }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234     temp_rx_ring = vmalloc(adapter-&gt;num_rx_queues * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01235"></a>01235     <span class="keywordflow">if</span> (!temp_rx_ring) {
<a name="l01236"></a>01236         err = -ENOMEM;
<a name="l01237"></a>01237         <span class="keywordflow">goto</span> err_setup;
<a name="l01238"></a>01238     }
<a name="l01239"></a>01239 
<a name="l01240"></a>01240     <span class="keywordflow">if</span> (new_rx_count != adapter-&gt;rx_ring_count) {
<a name="l01241"></a>01241         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01242"></a>01242             memcpy(&amp;temp_rx_ring[i], adapter-&gt;rx_ring[i],
<a name="l01243"></a>01243                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01244"></a>01244             temp_rx_ring[i].count = new_rx_count;
<a name="l01245"></a>01245             err = ixgbe_setup_rx_resources(&amp;temp_rx_ring[i]);
<a name="l01246"></a>01246             <span class="keywordflow">if</span> (err) {
<a name="l01247"></a>01247                 <span class="keywordflow">while</span> (i) {
<a name="l01248"></a>01248                     i--;
<a name="l01249"></a>01249                     ixgbe_free_rx_resources(&amp;temp_rx_ring[i]);
<a name="l01250"></a>01250                 }
<a name="l01251"></a>01251                 <span class="keywordflow">goto</span> err_setup;
<a name="l01252"></a>01252             }
<a name="l01253"></a>01253         }
<a name="l01254"></a>01254         need_update = <span class="keyword">true</span>;
<a name="l01255"></a>01255     }
<a name="l01256"></a>01256 
<a name="l01257"></a>01257     <span class="comment">/* if rings need to be updated, here&#39;s the place to do it in one shot */</span>
<a name="l01258"></a>01258     <span class="keywordflow">if</span> (need_update) {
<a name="l01259"></a>01259         ixgbe_down(adapter);
<a name="l01260"></a>01260 
<a name="l01261"></a>01261         <span class="comment">/* tx */</span>
<a name="l01262"></a>01262         <span class="keywordflow">if</span> (new_tx_count != adapter-&gt;tx_ring_count) {
<a name="l01263"></a>01263             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l01264"></a>01264                 ixgbe_free_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l01265"></a>01265                 memcpy(adapter-&gt;tx_ring[i], &amp;temp_tx_ring[i],
<a name="l01266"></a>01266                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01267"></a>01267             }
<a name="l01268"></a>01268             adapter-&gt;tx_ring_count = new_tx_count;
<a name="l01269"></a>01269         }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         <span class="comment">/* rx */</span>
<a name="l01272"></a>01272         <span class="keywordflow">if</span> (new_rx_count != adapter-&gt;rx_ring_count) {
<a name="l01273"></a>01273             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01274"></a>01274                 ixgbe_free_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l01275"></a>01275                 memcpy(adapter-&gt;rx_ring[i], &amp;temp_rx_ring[i],
<a name="l01276"></a>01276                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>));
<a name="l01277"></a>01277             }
<a name="l01278"></a>01278             adapter-&gt;rx_ring_count = new_rx_count;
<a name="l01279"></a>01279         }
<a name="l01280"></a>01280         ixgbe_up(adapter);
<a name="l01281"></a>01281     }
<a name="l01282"></a>01282 
<a name="l01283"></a>01283     vfree(temp_rx_ring);
<a name="l01284"></a>01284 err_setup:
<a name="l01285"></a>01285     vfree(temp_tx_ring);
<a name="l01286"></a>01286 clear_reset:
<a name="l01287"></a>01287     clear_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state);
<a name="l01288"></a>01288     <span class="keywordflow">return</span> err;
<a name="l01289"></a>01289 }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291 <span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l01292"></a>01292 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_stats_count(<span class="keyword">struct</span> net_device *netdev)
<a name="l01293"></a>01293 {
<a name="l01294"></a>01294     <span class="keywordflow">return</span> IXGBE_STATS_LEN;
<a name="l01295"></a>01295 }
<a name="l01296"></a>01296 
<a name="l01297"></a>01297 <span class="preprocessor">#else </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l01298"></a>01298 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_sset_count(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> sset)
<a name="l01299"></a>01299 {
<a name="l01300"></a>01300     <span class="keywordflow">switch</span> (sset) {
<a name="l01301"></a>01301     <span class="keywordflow">case</span> ETH_SS_TEST:
<a name="l01302"></a>01302         <span class="keywordflow">return</span> IXGBE_TEST_LEN;
<a name="l01303"></a>01303     <span class="keywordflow">case</span> ETH_SS_STATS:
<a name="l01304"></a>01304         <span class="keywordflow">return</span> IXGBE_STATS_LEN;
<a name="l01305"></a>01305 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l01306"></a>01306 <span class="preprocessor"></span>    <span class="keywordflow">case</span> ETH_SS_NTUPLE_FILTERS:
<a name="l01307"></a>01307         <span class="keywordflow">return</span> (ETHTOOL_MAX_NTUPLE_LIST_ENTRY *
<a name="l01308"></a>01308                 ETHTOOL_MAX_NTUPLE_STRING_PER_ENTRY);
<a name="l01309"></a>01309 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l01310"></a>01310     <span class="keywordflow">default</span>:
<a name="l01311"></a>01311         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313 }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l01316"></a>01316 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_ethtool_stats(<span class="keyword">struct</span> net_device *netdev,
<a name="l01317"></a>01317                                     <span class="keyword">struct</span> <a class="code" href="structethtool__stats.html">ethtool_stats</a> *stats, u64 *data)
<a name="l01318"></a>01318 {
<a name="l01319"></a>01319     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01320"></a>01320 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l01321"></a>01321 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *net_stats = &amp;netdev-&gt;stats;
<a name="l01322"></a>01322 <span class="preprocessor">#else</span>
<a name="l01323"></a>01323 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *net_stats = &amp;adapter-&gt;net_stats;
<a name="l01324"></a>01324 <span class="preprocessor">#endif</span>
<a name="l01325"></a>01325 <span class="preprocessor"></span>    u64 *queue_stat;
<a name="l01326"></a>01326     <span class="keywordtype">int</span> stat_count = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__queue__stats.html">ixgbe_queue_stats</a>) / sizeof(u64);
<a name="l01327"></a>01327     <span class="keywordtype">int</span> i, j, k;
<a name="l01328"></a>01328     <span class="keywordtype">char</span> *p;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330     ixgbe_update_stats(adapter);
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="keywordflow">for</span> (i = 0; i &lt; IXGBE_NETDEV_STATS_LEN; i++) {
<a name="l01333"></a>01333         p = (<span class="keywordtype">char</span> *)net_stats + ixgbe_gstrings_net_stats[i].stat_offset;
<a name="l01334"></a>01334         data[i] = (ixgbe_gstrings_net_stats[i].sizeof_stat ==
<a name="l01335"></a>01335             <span class="keyword">sizeof</span>(u64)) ? *(u64 *)p : *(u32 *)p;
<a name="l01336"></a>01336     }
<a name="l01337"></a>01337     <span class="keywordflow">for</span> (j = 0; j &lt; IXGBE_GLOBAL_STATS_LEN; j++, i++) {
<a name="l01338"></a>01338         p = (<span class="keywordtype">char</span> *)adapter + ixgbe_gstrings_stats[j].stat_offset;
<a name="l01339"></a>01339         data[i] = (ixgbe_gstrings_stats[j].sizeof_stat ==
<a name="l01340"></a>01340                    <span class="keyword">sizeof</span>(u64)) ? *(u64 *)p : *(u32 *)p;
<a name="l01341"></a>01341     }
<a name="l01342"></a>01342     <span class="keywordflow">for</span> (j = 0; j &lt; adapter-&gt;num_tx_queues; j++) {
<a name="l01343"></a>01343         queue_stat = (u64 *)&amp;adapter-&gt;tx_ring[j]-&gt;stats;
<a name="l01344"></a>01344         for (k = 0; k &lt; stat_count; k++)
<a name="l01345"></a>01345             data[i + k] = queue_stat[k];
<a name="l01346"></a>01346         i += k;
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348     <span class="keywordflow">for</span> (j = 0; j &lt; adapter-&gt;num_rx_queues; j++) {
<a name="l01349"></a>01349         queue_stat = (u64 *)&amp;adapter-&gt;rx_ring[j]-&gt;stats;
<a name="l01350"></a>01350         for (k = 0; k &lt; stat_count; k++)
<a name="l01351"></a>01351             data[i + k] = queue_stat[k];
<a name="l01352"></a>01352         i += k;
<a name="l01353"></a>01353     }
<a name="l01354"></a>01354     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l01355"></a>01355         <span class="keywordflow">for</span> (j = 0; j &lt; MAX_TX_PACKET_BUFFERS; j++) {
<a name="l01356"></a>01356             data[i++] = adapter-&gt;stats.pxontxc[j];
<a name="l01357"></a>01357             data[i++] = adapter-&gt;stats.pxofftxc[j];
<a name="l01358"></a>01358         }
<a name="l01359"></a>01359         <span class="keywordflow">for</span> (j = 0; j &lt; MAX_RX_PACKET_BUFFERS; j++) {
<a name="l01360"></a>01360             data[i++] = adapter-&gt;stats.pxonrxc[j];
<a name="l01361"></a>01361             data[i++] = adapter-&gt;stats.pxoffrxc[j];
<a name="l01362"></a>01362         }
<a name="l01363"></a>01363     }
<a name="l01364"></a>01364     stat_count = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structvf__stats.html">vf_stats</a>) / sizeof(u64);
<a name="l01365"></a>01365     <span class="keywordflow">for</span>(j = 0; j &lt; adapter-&gt;num_vfs; j++) {
<a name="l01366"></a>01366         queue_stat = (u64 *)&amp;adapter-&gt;vfinfo[j].vfstats;
<a name="l01367"></a>01367         for (k = 0; k &lt; stat_count; k++) {
<a name="l01368"></a>01368             data[i + k] = queue_stat[k];
<a name="l01369"></a>01369         }
<a name="l01370"></a>01370         queue_stat = (u64 *)&amp;adapter-&gt;vfinfo[j].saved_rst_vfstats;
<a name="l01371"></a>01371         for (k = 0; k &lt; stat_count; k++) {
<a name="l01372"></a>01372             data[i + k] += queue_stat[k];
<a name="l01373"></a>01373         }
<a name="l01374"></a>01374         i += k;
<a name="l01375"></a>01375     }
<a name="l01376"></a>01376 }
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_strings(<span class="keyword">struct</span> net_device *netdev, u32 stringset,
<a name="l01379"></a>01379                               u8 *data)
<a name="l01380"></a>01380 {
<a name="l01381"></a>01381     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01382"></a>01382     <span class="keywordtype">char</span> *p = (<span class="keywordtype">char</span> *)data;
<a name="l01383"></a>01383     <span class="keywordtype">int</span> i;
<a name="l01384"></a>01384 
<a name="l01385"></a>01385     <span class="keywordflow">switch</span> (stringset) {
<a name="l01386"></a>01386     <span class="keywordflow">case</span> ETH_SS_TEST:
<a name="l01387"></a>01387         memcpy(data, *ixgbe_gstrings_test,
<a name="l01388"></a>01388                IXGBE_TEST_LEN * ETH_GSTRING_LEN);
<a name="l01389"></a>01389         <span class="keywordflow">break</span>;
<a name="l01390"></a>01390     <span class="keywordflow">case</span> ETH_SS_STATS:
<a name="l01391"></a>01391         <span class="keywordflow">for</span> (i = 0; i &lt; IXGBE_NETDEV_STATS_LEN; i++) {
<a name="l01392"></a>01392             memcpy(p, ixgbe_gstrings_net_stats[i].stat_string,
<a name="l01393"></a>01393                    ETH_GSTRING_LEN);
<a name="l01394"></a>01394             p += ETH_GSTRING_LEN;
<a name="l01395"></a>01395         }
<a name="l01396"></a>01396         <span class="keywordflow">for</span> (i = 0; i &lt; IXGBE_GLOBAL_STATS_LEN; i++) {
<a name="l01397"></a>01397             memcpy(p, ixgbe_gstrings_stats[i].stat_string,
<a name="l01398"></a>01398                    ETH_GSTRING_LEN);
<a name="l01399"></a>01399             p += ETH_GSTRING_LEN;
<a name="l01400"></a>01400         }
<a name="l01401"></a>01401         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l01402"></a>01402             sprintf(p, <span class="stringliteral">&quot;tx_queue_%u_packets&quot;</span>, i);
<a name="l01403"></a>01403             p += ETH_GSTRING_LEN;
<a name="l01404"></a>01404             sprintf(p, <span class="stringliteral">&quot;tx_queue_%u_bytes&quot;</span>, i);
<a name="l01405"></a>01405             p += ETH_GSTRING_LEN;
<a name="l01406"></a>01406         }
<a name="l01407"></a>01407         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l01408"></a>01408             sprintf(p, <span class="stringliteral">&quot;rx_queue_%u_packets&quot;</span>, i);
<a name="l01409"></a>01409             p += ETH_GSTRING_LEN;
<a name="l01410"></a>01410             sprintf(p, <span class="stringliteral">&quot;rx_queue_%u_bytes&quot;</span>, i);
<a name="l01411"></a>01411             p += ETH_GSTRING_LEN;
<a name="l01412"></a>01412         }
<a name="l01413"></a>01413         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l01414"></a>01414             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TX_PACKET_BUFFERS; i++) {
<a name="l01415"></a>01415                 sprintf(p, <span class="stringliteral">&quot;tx_pb_%u_pxon&quot;</span>, i);
<a name="l01416"></a>01416                 p += ETH_GSTRING_LEN;
<a name="l01417"></a>01417                 sprintf(p, <span class="stringliteral">&quot;tx_pb_%u_pxoff&quot;</span>, i);
<a name="l01418"></a>01418                 p += ETH_GSTRING_LEN;
<a name="l01419"></a>01419             }
<a name="l01420"></a>01420             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_RX_PACKET_BUFFERS; i++) {
<a name="l01421"></a>01421                 sprintf(p, <span class="stringliteral">&quot;rx_pb_%u_pxon&quot;</span>, i);
<a name="l01422"></a>01422                 p += ETH_GSTRING_LEN;
<a name="l01423"></a>01423                 sprintf(p, <span class="stringliteral">&quot;rx_pb_%u_pxoff&quot;</span>, i);
<a name="l01424"></a>01424                 p += ETH_GSTRING_LEN;
<a name="l01425"></a>01425             }
<a name="l01426"></a>01426         }
<a name="l01427"></a>01427         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l01428"></a>01428             sprintf(p, <span class="stringliteral">&quot;VF %d Rx Packets&quot;</span>, i);
<a name="l01429"></a>01429             p += ETH_GSTRING_LEN;
<a name="l01430"></a>01430             sprintf(p, <span class="stringliteral">&quot;VF %d Rx Bytes&quot;</span>, i);
<a name="l01431"></a>01431             p += ETH_GSTRING_LEN;
<a name="l01432"></a>01432             sprintf(p, <span class="stringliteral">&quot;VF %d Tx Packets&quot;</span>, i);
<a name="l01433"></a>01433             p += ETH_GSTRING_LEN;
<a name="l01434"></a>01434             sprintf(p, <span class="stringliteral">&quot;VF %d Tx Bytes&quot;</span>, i);
<a name="l01435"></a>01435             p += ETH_GSTRING_LEN;
<a name="l01436"></a>01436             sprintf(p, <span class="stringliteral">&quot;VF %d MC Packets&quot;</span>, i);
<a name="l01437"></a>01437             p += ETH_GSTRING_LEN;
<a name="l01438"></a>01438         }
<a name="l01439"></a>01439         <span class="comment">/* BUG_ON(p - data != IXGBE_STATS_LEN * ETH_GSTRING_LEN); */</span>
<a name="l01440"></a>01440         <span class="keywordflow">break</span>;
<a name="l01441"></a>01441     }
<a name="l01442"></a>01442 }
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_link_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01445"></a>01445 {
<a name="l01446"></a>01446     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01447"></a>01447     <span class="keywordtype">bool</span> link_up;
<a name="l01448"></a>01448     u32 link_speed = 0;
<a name="l01449"></a>01449     *data = 0;
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     hw-&gt;mac.ops.check_link(hw, &amp;link_speed, &amp;link_up, <span class="keyword">true</span>);
<a name="l01452"></a>01452     <span class="keywordflow">if</span> (link_up)
<a name="l01453"></a>01453         <span class="keywordflow">return</span> *data;
<a name="l01454"></a>01454     <span class="keywordflow">else</span>
<a name="l01455"></a>01455         *data = 1;
<a name="l01456"></a>01456     <span class="keywordflow">return</span> *data;
<a name="l01457"></a>01457 }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="comment">/* ethtool register test data */</span>
<a name="l01460"></a>01460 <span class="keyword">struct </span>ixgbe_reg_test {
<a name="l01461"></a>01461     u16 reg;
<a name="l01462"></a>01462     u8  array_len;
<a name="l01463"></a>01463     u8  test_type;
<a name="l01464"></a>01464     u32 mask;
<a name="l01465"></a>01465     u32 write;
<a name="l01466"></a>01466 };
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 <span class="comment">/* In the hardware, registers are laid out either singly, in arrays</span>
<a name="l01469"></a>01469 <span class="comment"> * spaced 0x40 bytes apart, or in contiguous tables.  We assume</span>
<a name="l01470"></a>01470 <span class="comment"> * most tests take place on arrays or single registers (handled</span>
<a name="l01471"></a>01471 <span class="comment"> * as a single-element array) and special-case the tables.</span>
<a name="l01472"></a>01472 <span class="comment"> * Table tests are always pattern tests.</span>
<a name="l01473"></a>01473 <span class="comment"> *</span>
<a name="l01474"></a>01474 <span class="comment"> * We also make provision for some required setup steps by specifying</span>
<a name="l01475"></a>01475 <span class="comment"> * registers to be written without any read-back testing.</span>
<a name="l01476"></a>01476 <span class="comment"> */</span>
<a name="l01477"></a>01477 
<a name="l01478"></a>01478 <span class="preprocessor">#define PATTERN_TEST    1</span>
<a name="l01479"></a>01479 <span class="preprocessor"></span><span class="preprocessor">#define SET_READ_TEST   2</span>
<a name="l01480"></a>01480 <span class="preprocessor"></span><span class="preprocessor">#define WRITE_NO_TEST   3</span>
<a name="l01481"></a>01481 <span class="preprocessor"></span><span class="preprocessor">#define TABLE32_TEST    4</span>
<a name="l01482"></a>01482 <span class="preprocessor"></span><span class="preprocessor">#define TABLE64_TEST_LO 5</span>
<a name="l01483"></a>01483 <span class="preprocessor"></span><span class="preprocessor">#define TABLE64_TEST_HI 6</span>
<a name="l01484"></a>01484 <span class="preprocessor"></span>
<a name="l01485"></a>01485 <span class="comment">/* default 82599 register test */</span>
<a name="l01486"></a>01486 <span class="keyword">static</span> <span class="keyword">struct </span>ixgbe_reg_test reg_test_82599[] = {
<a name="l01487"></a>01487     { IXGBE_FCRTL_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01488"></a>01488     { IXGBE_FCRTH_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01489"></a>01489     { IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01490"></a>01490     { IXGBE_VLNCTRL, 1, PATTERN_TEST, 0x00000000, 0x00000000 },
<a name="l01491"></a>01491     { IXGBE_RDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFF80 },
<a name="l01492"></a>01492     { IXGBE_RDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01493"></a>01493     { IXGBE_RDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },
<a name="l01494"></a>01494     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, IXGBE_RXDCTL_ENABLE },
<a name="l01495"></a>01495     { IXGBE_RDT(0), 4, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },
<a name="l01496"></a>01496     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, 0 },
<a name="l01497"></a>01497     { IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01498"></a>01498     { IXGBE_FCTTV(0), 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01499"></a>01499     { IXGBE_TDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },
<a name="l01500"></a>01500     { IXGBE_TDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01501"></a>01501     { IXGBE_TDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFF80 },
<a name="l01502"></a>01502     { IXGBE_RXCTRL, 1, SET_READ_TEST, 0x00000001, 0x00000001 },
<a name="l01503"></a>01503     { IXGBE_RAL(0), 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01504"></a>01504     { IXGBE_RAL(0), 16, TABLE64_TEST_HI, 0x8001FFFF, 0x800CFFFF },
<a name="l01505"></a>01505     { IXGBE_MTA(0), 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01506"></a>01506     { 0, 0, 0, 0 }
<a name="l01507"></a>01507 };
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="comment">/* default 82598 register test */</span>
<a name="l01510"></a>01510 <span class="keyword">static</span> <span class="keyword">struct </span>ixgbe_reg_test reg_test_82598[] = {
<a name="l01511"></a>01511     { IXGBE_FCRTL(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01512"></a>01512     { IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01513"></a>01513     { IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01514"></a>01514     { IXGBE_VLNCTRL, 1, PATTERN_TEST, 0x00000000, 0x00000000 },
<a name="l01515"></a>01515     { IXGBE_RDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },
<a name="l01516"></a>01516     { IXGBE_RDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01517"></a>01517     { IXGBE_RDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },
<a name="l01518"></a>01518     <span class="comment">/* Enable all four RX queues before testing. */</span>
<a name="l01519"></a>01519     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, IXGBE_RXDCTL_ENABLE },
<a name="l01520"></a>01520     <span class="comment">/* RDH is read-only for 82598, only test RDT. */</span>
<a name="l01521"></a>01521     { IXGBE_RDT(0), 4, PATTERN_TEST, 0x0000FFFF, 0x0000FFFF },
<a name="l01522"></a>01522     { IXGBE_RXDCTL(0), 4, WRITE_NO_TEST, 0, 0 },
<a name="l01523"></a>01523     { IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
<a name="l01524"></a>01524     { IXGBE_FCTTV(0), 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01525"></a>01525     { IXGBE_TIPG, 1, PATTERN_TEST, 0x000000FF, 0x000000FF },
<a name="l01526"></a>01526     { IXGBE_TDBAL(0), 4, PATTERN_TEST, 0xFFFFFF80, 0xFFFFFFFF },
<a name="l01527"></a>01527     { IXGBE_TDBAH(0), 4, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01528"></a>01528     { IXGBE_TDLEN(0), 4, PATTERN_TEST, 0x000FFF80, 0x000FFFFF },
<a name="l01529"></a>01529     { IXGBE_RXCTRL, 1, SET_READ_TEST, 0x00000003, 0x00000003 },
<a name="l01530"></a>01530     { IXGBE_DTXCTL, 1, SET_READ_TEST, 0x00000005, 0x00000005 },
<a name="l01531"></a>01531     { IXGBE_RAL(0), 16, TABLE64_TEST_LO, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01532"></a>01532     { IXGBE_RAL(0), 16, TABLE64_TEST_HI, 0x800CFFFF, 0x800CFFFF },
<a name="l01533"></a>01533     { IXGBE_MTA(0), 128, TABLE32_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
<a name="l01534"></a>01534     { 0, 0, 0, 0 }
<a name="l01535"></a>01535 };
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 <span class="preprocessor">#define REG_PATTERN_TEST(R, M, W)                                             \</span>
<a name="l01538"></a>01538 <span class="preprocessor">{                                                                             \</span>
<a name="l01539"></a>01539 <span class="preprocessor">    u32 pat, val, before;                                                 \</span>
<a name="l01540"></a>01540 <span class="preprocessor">    const u32 _test[] = {0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF}; \</span>
<a name="l01541"></a>01541 <span class="preprocessor">    for (pat = 0; pat &lt; ARRAY_SIZE(_test); pat++) {                       \</span>
<a name="l01542"></a>01542 <span class="preprocessor">        before = readl(adapter-&gt;hw.hw_addr + R);                      \</span>
<a name="l01543"></a>01543 <span class="preprocessor">        writel((_test[pat] &amp; W), (adapter-&gt;hw.hw_addr + R));          \</span>
<a name="l01544"></a>01544 <span class="preprocessor">        val = readl(adapter-&gt;hw.hw_addr + R);                         \</span>
<a name="l01545"></a>01545 <span class="preprocessor">        if (val != (_test[pat] &amp; W &amp; M)) {                            \</span>
<a name="l01546"></a>01546 <span class="preprocessor">            DPRINTK(DRV, ERR, &quot;pattern test reg %04X failed: got &quot;\</span>
<a name="l01547"></a>01547 <span class="preprocessor">                      &quot;0x%08X expected 0x%08X\n&quot;,         \</span>
<a name="l01548"></a>01548 <span class="preprocessor">                R, val, (_test[pat] &amp; W &amp; M));                \</span>
<a name="l01549"></a>01549 <span class="preprocessor">            *data = R;                                            \</span>
<a name="l01550"></a>01550 <span class="preprocessor">            writel(before, adapter-&gt;hw.hw_addr + R);              \</span>
<a name="l01551"></a>01551 <span class="preprocessor">            return 1;                                             \</span>
<a name="l01552"></a>01552 <span class="preprocessor">        }                                                             \</span>
<a name="l01553"></a>01553 <span class="preprocessor">        writel(before, adapter-&gt;hw.hw_addr + R);                      \</span>
<a name="l01554"></a>01554 <span class="preprocessor">    }                                                                     \</span>
<a name="l01555"></a>01555 <span class="preprocessor">}</span>
<a name="l01556"></a>01556 <span class="preprocessor"></span>
<a name="l01557"></a>01557 <span class="preprocessor">#define REG_SET_AND_CHECK(R, M, W)                                            \</span>
<a name="l01558"></a>01558 <span class="preprocessor">{                                                                             \</span>
<a name="l01559"></a>01559 <span class="preprocessor">    u32 val, before;                                                      \</span>
<a name="l01560"></a>01560 <span class="preprocessor">    before = readl(adapter-&gt;hw.hw_addr + R);                              \</span>
<a name="l01561"></a>01561 <span class="preprocessor">    writel((W &amp; M), (adapter-&gt;hw.hw_addr + R));                           \</span>
<a name="l01562"></a>01562 <span class="preprocessor">    val = readl(adapter-&gt;hw.hw_addr + R);                                 \</span>
<a name="l01563"></a>01563 <span class="preprocessor">    if ((W &amp; M) != (val &amp; M)) {                                           \</span>
<a name="l01564"></a>01564 <span class="preprocessor">        DPRINTK(DRV, ERR, &quot;set/check reg %04X test failed: got 0x%08X &quot;\</span>
<a name="l01565"></a>01565 <span class="preprocessor">                 &quot;expected 0x%08X\n&quot;, R, (val &amp; M), (W &amp; M)); \</span>
<a name="l01566"></a>01566 <span class="preprocessor">        *data = R;                                                    \</span>
<a name="l01567"></a>01567 <span class="preprocessor">        writel(before, (adapter-&gt;hw.hw_addr + R));                    \</span>
<a name="l01568"></a>01568 <span class="preprocessor">        return 1;                                                     \</span>
<a name="l01569"></a>01569 <span class="preprocessor">    }                                                                     \</span>
<a name="l01570"></a>01570 <span class="preprocessor">    writel(before, (adapter-&gt;hw.hw_addr + R));                            \</span>
<a name="l01571"></a>01571 <span class="preprocessor">}</span>
<a name="l01572"></a>01572 <span class="preprocessor"></span>
<a name="l01573"></a>01573 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_reg_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01574"></a>01574 {
<a name="l01575"></a>01575     <span class="keyword">struct </span>ixgbe_reg_test *test;
<a name="l01576"></a>01576     u32 value, status_before, status_after;
<a name="l01577"></a>01577     u32 i, toggle;
<a name="l01578"></a>01578 
<a name="l01579"></a>01579     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01580"></a>01580     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01581"></a>01581         toggle = 0x7FFFF3FF;
<a name="l01582"></a>01582         test = reg_test_82598;
<a name="l01583"></a>01583         <span class="keywordflow">break</span>;
<a name="l01584"></a>01584     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01585"></a>01585     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01586"></a>01586         toggle = 0x7FFFF30F;
<a name="l01587"></a>01587         test = reg_test_82599;
<a name="l01588"></a>01588         <span class="keywordflow">break</span>;
<a name="l01589"></a>01589     <span class="keywordflow">default</span>:
<a name="l01590"></a>01590         *data = 1;
<a name="l01591"></a>01591         <span class="keywordflow">return</span> 1;
<a name="l01592"></a>01592         <span class="keywordflow">break</span>;
<a name="l01593"></a>01593     }
<a name="l01594"></a>01594 
<a name="l01595"></a>01595     <span class="comment">/*</span>
<a name="l01596"></a>01596 <span class="comment">     * Because the status register is such a special case,</span>
<a name="l01597"></a>01597 <span class="comment">     * we handle it separately from the rest of the register</span>
<a name="l01598"></a>01598 <span class="comment">     * tests.  Some bits are read-only, some toggle, and some</span>
<a name="l01599"></a>01599 <span class="comment">     * are writeable on newer MACs.</span>
<a name="l01600"></a>01600 <span class="comment">     */</span>
<a name="l01601"></a>01601     status_before = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_STATUS);
<a name="l01602"></a>01602     value = (IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_STATUS) &amp; toggle);
<a name="l01603"></a>01603     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_STATUS, toggle);
<a name="l01604"></a>01604     status_after = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_STATUS) &amp; toggle;
<a name="l01605"></a>01605     <span class="keywordflow">if</span> (value != status_after) {
<a name="l01606"></a>01606         DPRINTK(DRV, ERR, <span class="stringliteral">&quot;failed STATUS register test got: &quot;</span>
<a name="l01607"></a>01607                 <span class="stringliteral">&quot;0x%08X expected: 0x%08X\n&quot;</span>, status_after, value);
<a name="l01608"></a>01608         *data = 1;
<a name="l01609"></a>01609         <span class="keywordflow">return</span> 1;
<a name="l01610"></a>01610     }
<a name="l01611"></a>01611     <span class="comment">/* restore previous status */</span>
<a name="l01612"></a>01612     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_STATUS, status_before);
<a name="l01613"></a>01613 
<a name="l01614"></a>01614     <span class="comment">/*</span>
<a name="l01615"></a>01615 <span class="comment">     * Perform the remainder of the register test, looping through</span>
<a name="l01616"></a>01616 <span class="comment">     * the test table until we either fail or reach the null entry.</span>
<a name="l01617"></a>01617 <span class="comment">     */</span>
<a name="l01618"></a>01618     <span class="keywordflow">while</span> (test-&gt;reg) {
<a name="l01619"></a>01619         <span class="keywordflow">for</span> (i = 0; i &lt; test-&gt;array_len; i++) {
<a name="l01620"></a>01620             <span class="keywordflow">switch</span> (test-&gt;test_type) {
<a name="l01621"></a>01621             <span class="keywordflow">case</span> PATTERN_TEST:
<a name="l01622"></a>01622                 REG_PATTERN_TEST(test-&gt;reg + (i * 0x40),
<a name="l01623"></a>01623                         test-&gt;mask,
<a name="l01624"></a>01624                         test-&gt;write);
<a name="l01625"></a>01625                 <span class="keywordflow">break</span>;
<a name="l01626"></a>01626             <span class="keywordflow">case</span> SET_READ_TEST:
<a name="l01627"></a>01627                 REG_SET_AND_CHECK(test-&gt;reg + (i * 0x40),
<a name="l01628"></a>01628                         test-&gt;mask,
<a name="l01629"></a>01629                         test-&gt;write);
<a name="l01630"></a>01630                 <span class="keywordflow">break</span>;
<a name="l01631"></a>01631             <span class="keywordflow">case</span> WRITE_NO_TEST:
<a name="l01632"></a>01632                 writel(test-&gt;write,
<a name="l01633"></a>01633                        (adapter-&gt;hw.hw_addr + test-&gt;reg)
<a name="l01634"></a>01634                        + (i * 0x40));
<a name="l01635"></a>01635                 <span class="keywordflow">break</span>;
<a name="l01636"></a>01636             <span class="keywordflow">case</span> TABLE32_TEST:
<a name="l01637"></a>01637                 REG_PATTERN_TEST(test-&gt;reg + (i * 4),
<a name="l01638"></a>01638                         test-&gt;mask,
<a name="l01639"></a>01639                         test-&gt;write);
<a name="l01640"></a>01640                 <span class="keywordflow">break</span>;
<a name="l01641"></a>01641             <span class="keywordflow">case</span> TABLE64_TEST_LO:
<a name="l01642"></a>01642                 REG_PATTERN_TEST(test-&gt;reg + (i * 8),
<a name="l01643"></a>01643                         test-&gt;mask,
<a name="l01644"></a>01644                         test-&gt;write);
<a name="l01645"></a>01645                 <span class="keywordflow">break</span>;
<a name="l01646"></a>01646             <span class="keywordflow">case</span> TABLE64_TEST_HI:
<a name="l01647"></a>01647                 REG_PATTERN_TEST((test-&gt;reg + 4) + (i * 8),
<a name="l01648"></a>01648                         test-&gt;mask,
<a name="l01649"></a>01649                         test-&gt;write);
<a name="l01650"></a>01650                 <span class="keywordflow">break</span>;
<a name="l01651"></a>01651             }
<a name="l01652"></a>01652         }
<a name="l01653"></a>01653         test++;
<a name="l01654"></a>01654     }
<a name="l01655"></a>01655 
<a name="l01656"></a>01656     *data = 0;
<a name="l01657"></a>01657     <span class="keywordflow">return</span> 0;
<a name="l01658"></a>01658 }
<a name="l01659"></a>01659 
<a name="l01660"></a>01660 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_eeprom_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01661"></a>01661 {
<a name="l01662"></a>01662     <span class="keywordflow">if</span> (ixgbe_validate_eeprom_checksum(&amp;adapter-&gt;hw, NULL))
<a name="l01663"></a>01663         *data = 1;
<a name="l01664"></a>01664     <span class="keywordflow">else</span>
<a name="l01665"></a>01665         *data = 0;
<a name="l01666"></a>01666     <span class="keywordflow">return</span> *data;
<a name="l01667"></a>01667 }
<a name="l01668"></a>01668 
<a name="l01669"></a>01669 <span class="keyword">static</span> irqreturn_t ixgbe_test_intr(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l01670"></a>01670 {
<a name="l01671"></a>01671     <span class="keyword">struct </span>net_device *netdev = (<span class="keyword">struct </span>net_device *) data;
<a name="l01672"></a>01672     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01673"></a>01673 
<a name="l01674"></a>01674     adapter-&gt;test_icr |= IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_EICR);
<a name="l01675"></a>01675 
<a name="l01676"></a>01676     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l01677"></a>01677 }
<a name="l01678"></a>01678 
<a name="l01679"></a>01679 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_intr_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l01680"></a>01680 {
<a name="l01681"></a>01681     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01682"></a>01682     u32 mask, i = 0, shared_int = <span class="keyword">true</span>;
<a name="l01683"></a>01683     u32 irq = adapter-&gt;pdev-&gt;irq;
<a name="l01684"></a>01684 
<a name="l01685"></a>01685     *data = 0;
<a name="l01686"></a>01686 
<a name="l01687"></a>01687     <span class="comment">/* Hook up test interrupt handler just for this test */</span>
<a name="l01688"></a>01688     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l01689"></a>01689         <span class="comment">/* NOTE: we don&#39;t test MSI-X interrupts here, yet */</span>
<a name="l01690"></a>01690         <span class="keywordflow">return</span> 0;
<a name="l01691"></a>01691     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED) {
<a name="l01692"></a>01692         shared_int = <span class="keyword">false</span>;
<a name="l01693"></a>01693         <span class="keywordflow">if</span> (request_irq(irq, &amp;ixgbe_test_intr, 0, netdev-&gt;name,
<a name="l01694"></a>01694                 netdev)) {
<a name="l01695"></a>01695             *data = 1;
<a name="l01696"></a>01696             <span class="keywordflow">return</span> -1;
<a name="l01697"></a>01697         }
<a name="l01698"></a>01698     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!request_irq(irq, &amp;ixgbe_test_intr, IRQF_PROBE_SHARED,
<a name="l01699"></a>01699                             netdev-&gt;name, netdev)) {
<a name="l01700"></a>01700         shared_int = <span class="keyword">false</span>;
<a name="l01701"></a>01701     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (request_irq(irq, &amp;ixgbe_test_intr, IRQF_SHARED,
<a name="l01702"></a>01702                            netdev-&gt;name, netdev)) {
<a name="l01703"></a>01703         *data = 1;
<a name="l01704"></a>01704         <span class="keywordflow">return</span> -1;
<a name="l01705"></a>01705     }
<a name="l01706"></a>01706     DPRINTK(HW, INFO, <span class="stringliteral">&quot;testing %s interrupt\n&quot;</span>,
<a name="l01707"></a>01707         (shared_int ? <span class="stringliteral">&quot;shared&quot;</span> : <span class="stringliteral">&quot;unshared&quot;</span>));
<a name="l01708"></a>01708 
<a name="l01709"></a>01709     <span class="comment">/* Disable all the interrupts */</span>
<a name="l01710"></a>01710     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, 0xFFFFFFFF);
<a name="l01711"></a>01711     msleep(10);
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     <span class="comment">/* Test each interrupt */</span>
<a name="l01714"></a>01714     <span class="keywordflow">for</span> (; i &lt; 10; i++) {
<a name="l01715"></a>01715         <span class="comment">/* Interrupt to test */</span>
<a name="l01716"></a>01716         mask = 1 &lt;&lt; i;
<a name="l01717"></a>01717 
<a name="l01718"></a>01718         <span class="keywordflow">if</span> (!shared_int) {
<a name="l01719"></a>01719             <span class="comment">/*</span>
<a name="l01720"></a>01720 <span class="comment">             * Disable the interrupts to be reported in</span>
<a name="l01721"></a>01721 <span class="comment">             * the cause register and then force the same</span>
<a name="l01722"></a>01722 <span class="comment">             * interrupt and see if one gets posted.  If</span>
<a name="l01723"></a>01723 <span class="comment">             * an interrupt was posted to the bus, the</span>
<a name="l01724"></a>01724 <span class="comment">             * test failed.</span>
<a name="l01725"></a>01725 <span class="comment">             */</span>
<a name="l01726"></a>01726             adapter-&gt;test_icr = 0;
<a name="l01727"></a>01727             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC,
<a name="l01728"></a>01728                             ~mask &amp; 0x00007FFF);
<a name="l01729"></a>01729             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS,
<a name="l01730"></a>01730                             ~mask &amp; 0x00007FFF);
<a name="l01731"></a>01731             msleep(10);
<a name="l01732"></a>01732 
<a name="l01733"></a>01733             <span class="keywordflow">if</span> (adapter-&gt;test_icr &amp; mask) {
<a name="l01734"></a>01734                 *data = 3;
<a name="l01735"></a>01735                 <span class="keywordflow">break</span>;
<a name="l01736"></a>01736             }
<a name="l01737"></a>01737         }
<a name="l01738"></a>01738 
<a name="l01739"></a>01739         <span class="comment">/*</span>
<a name="l01740"></a>01740 <span class="comment">         * Enable the interrupt to be reported in the cause</span>
<a name="l01741"></a>01741 <span class="comment">         * register and then force the same interrupt and see</span>
<a name="l01742"></a>01742 <span class="comment">         * if one gets posted.  If an interrupt was not posted</span>
<a name="l01743"></a>01743 <span class="comment">         * to the bus, the test failed.</span>
<a name="l01744"></a>01744 <span class="comment">         */</span>
<a name="l01745"></a>01745         adapter-&gt;test_icr = 0;
<a name="l01746"></a>01746         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMS, mask);
<a name="l01747"></a>01747         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS, mask);
<a name="l01748"></a>01748         msleep(10);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         <span class="keywordflow">if</span> (!(adapter-&gt;test_icr &amp;mask)) {
<a name="l01751"></a>01751             *data = 4;
<a name="l01752"></a>01752             <span class="keywordflow">break</span>;
<a name="l01753"></a>01753         }
<a name="l01754"></a>01754 
<a name="l01755"></a>01755         <span class="keywordflow">if</span> (!shared_int) {
<a name="l01756"></a>01756             <span class="comment">/*</span>
<a name="l01757"></a>01757 <span class="comment">             * Disable the other interrupts to be reported in</span>
<a name="l01758"></a>01758 <span class="comment">             * the cause register and then force the other</span>
<a name="l01759"></a>01759 <span class="comment">             * interrupts and see if any get posted.  If</span>
<a name="l01760"></a>01760 <span class="comment">             * an interrupt was posted to the bus, the</span>
<a name="l01761"></a>01761 <span class="comment">             * test failed.</span>
<a name="l01762"></a>01762 <span class="comment">             */</span>
<a name="l01763"></a>01763             adapter-&gt;test_icr = 0;
<a name="l01764"></a>01764             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC,
<a name="l01765"></a>01765                             ~mask &amp; 0x00007FFF);
<a name="l01766"></a>01766             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS,
<a name="l01767"></a>01767                             ~mask &amp; 0x00007FFF);
<a name="l01768"></a>01768             msleep(10);
<a name="l01769"></a>01769 
<a name="l01770"></a>01770             <span class="keywordflow">if</span> (adapter-&gt;test_icr) {
<a name="l01771"></a>01771                 *data = 5;
<a name="l01772"></a>01772                 <span class="keywordflow">break</span>;
<a name="l01773"></a>01773             }
<a name="l01774"></a>01774         }
<a name="l01775"></a>01775     }
<a name="l01776"></a>01776 
<a name="l01777"></a>01777     <span class="comment">/* Disable all the interrupts */</span>
<a name="l01778"></a>01778     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, 0xFFFFFFFF);
<a name="l01779"></a>01779     msleep(10);
<a name="l01780"></a>01780 
<a name="l01781"></a>01781     <span class="comment">/* Unhook test interrupt handler */</span>
<a name="l01782"></a>01782     free_irq(irq, netdev);
<a name="l01783"></a>01783 
<a name="l01784"></a>01784     <span class="keywordflow">return</span> *data;
<a name="l01785"></a>01785 }
<a name="l01786"></a>01786 
<a name="l01787"></a>01787 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_desc_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01788"></a>01788 {
<a name="l01789"></a>01789     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = &amp;adapter-&gt;test_tx_ring;
<a name="l01790"></a>01790     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = &amp;adapter-&gt;test_rx_ring;
<a name="l01791"></a>01791     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01792"></a>01792     u32 reg_ctl;
<a name="l01793"></a>01793 
<a name="l01794"></a>01794     <span class="comment">/* shut down the DMA engines now so they can be reinitialized later */</span>
<a name="l01795"></a>01795 
<a name="l01796"></a>01796     <span class="comment">/* first Rx */</span>
<a name="l01797"></a>01797     reg_ctl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l01798"></a>01798     reg_ctl &amp;= ~IXGBE_RXCTRL_RXEN;
<a name="l01799"></a>01799     IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, reg_ctl);
<a name="l01800"></a>01800     ixgbe_disable_rx_queue(adapter, rx_ring);
<a name="l01801"></a>01801 
<a name="l01802"></a>01802     <span class="comment">/* now Tx */</span>
<a name="l01803"></a>01803     IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(tx_ring-&gt;reg_idx), 0);
<a name="l01804"></a>01804 
<a name="l01805"></a>01805     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l01806"></a>01806     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01807"></a>01807     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01808"></a>01808         reg_ctl = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);
<a name="l01809"></a>01809         reg_ctl &amp;= ~IXGBE_DMATXCTL_TE;
<a name="l01810"></a>01810         IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, reg_ctl);
<a name="l01811"></a>01811         <span class="keywordflow">break</span>;
<a name="l01812"></a>01812     <span class="keywordflow">default</span>:
<a name="l01813"></a>01813         <span class="keywordflow">break</span>;
<a name="l01814"></a>01814     }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816     ixgbe_reset(adapter);
<a name="l01817"></a>01817 
<a name="l01818"></a>01818     ixgbe_free_tx_resources(&amp;adapter-&gt;test_tx_ring);
<a name="l01819"></a>01819     ixgbe_free_rx_resources(&amp;adapter-&gt;test_rx_ring);
<a name="l01820"></a>01820 }
<a name="l01821"></a>01821 
<a name="l01822"></a>01822 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_desc_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01823"></a>01823 {
<a name="l01824"></a>01824     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = &amp;adapter-&gt;test_tx_ring;
<a name="l01825"></a>01825     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = &amp;adapter-&gt;test_rx_ring;
<a name="l01826"></a>01826     u32 rctl, reg_data;
<a name="l01827"></a>01827     <span class="keywordtype">int</span> ret_val;
<a name="l01828"></a>01828     <span class="keywordtype">int</span> err;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830     <span class="comment">/* Setup Tx descriptor ring and Tx buffers */</span>
<a name="l01831"></a>01831     tx_ring-&gt;count = IXGBE_DEFAULT_TXD;
<a name="l01832"></a>01832     tx_ring-&gt;queue_index = 0;
<a name="l01833"></a>01833     tx_ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l01834"></a>01834     tx_ring-&gt;netdev = adapter-&gt;netdev;
<a name="l01835"></a>01835     tx_ring-&gt;reg_idx = adapter-&gt;tx_ring[0]-&gt;reg_idx;
<a name="l01836"></a>01836     tx_ring-&gt;numa_node = adapter-&gt;node;
<a name="l01837"></a>01837 
<a name="l01838"></a>01838     err = ixgbe_setup_tx_resources(tx_ring);
<a name="l01839"></a>01839     <span class="keywordflow">if</span> (err)
<a name="l01840"></a>01840         <span class="keywordflow">return</span> 1;
<a name="l01841"></a>01841 
<a name="l01842"></a>01842     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01843"></a>01843     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01844"></a>01844     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01845"></a>01845         reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_DMATXCTL);
<a name="l01846"></a>01846         reg_data |= IXGBE_DMATXCTL_TE;
<a name="l01847"></a>01847         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DMATXCTL, reg_data);
<a name="l01848"></a>01848         <span class="keywordflow">break</span>;
<a name="l01849"></a>01849     <span class="keywordflow">default</span>:
<a name="l01850"></a>01850         <span class="keywordflow">break</span>;
<a name="l01851"></a>01851     }
<a name="l01852"></a>01852 
<a name="l01853"></a>01853     ixgbe_configure_tx_ring(adapter, tx_ring);
<a name="l01854"></a>01854 
<a name="l01855"></a>01855     <span class="comment">/* Setup Rx Descriptor ring and Rx buffers */</span>
<a name="l01856"></a>01856     rx_ring-&gt;count = IXGBE_DEFAULT_RXD;
<a name="l01857"></a>01857     rx_ring-&gt;queue_index = 0;
<a name="l01858"></a>01858     rx_ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l01859"></a>01859     rx_ring-&gt;netdev = adapter-&gt;netdev;
<a name="l01860"></a>01860     rx_ring-&gt;reg_idx = adapter-&gt;rx_ring[0]-&gt;reg_idx;
<a name="l01861"></a>01861     rx_ring-&gt;rx_buf_len = IXGBE_RXBUFFER_2048;
<a name="l01862"></a>01862     rx_ring-&gt;numa_node = adapter-&gt;node;
<a name="l01863"></a>01863 
<a name="l01864"></a>01864     err = ixgbe_setup_rx_resources(rx_ring);
<a name="l01865"></a>01865     <span class="keywordflow">if</span> (err) {
<a name="l01866"></a>01866         ret_val = 4;
<a name="l01867"></a>01867         <span class="keywordflow">goto</span> err_nomem;
<a name="l01868"></a>01868     }
<a name="l01869"></a>01869 
<a name="l01870"></a>01870     rctl = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL);
<a name="l01871"></a>01871     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL, rctl &amp; ~IXGBE_RXCTRL_RXEN);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     ixgbe_configure_rx_ring(adapter, rx_ring);
<a name="l01874"></a>01874 
<a name="l01875"></a>01875     rctl |= IXGBE_RXCTRL_RXEN | IXGBE_RXCTRL_DMBYPS;
<a name="l01876"></a>01876     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_RXCTRL, rctl);
<a name="l01877"></a>01877 
<a name="l01878"></a>01878     <span class="keywordflow">return</span> 0;
<a name="l01879"></a>01879 
<a name="l01880"></a>01880 err_nomem:
<a name="l01881"></a>01881     ixgbe_free_desc_rings(adapter);
<a name="l01882"></a>01882     <span class="keywordflow">return</span> ret_val;
<a name="l01883"></a>01883 }
<a name="l01884"></a>01884 
<a name="l01885"></a>01885 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_loopback_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01886"></a>01886 {
<a name="l01887"></a>01887     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01888"></a>01888     u32 reg_data;
<a name="l01889"></a>01889 
<a name="l01890"></a>01890     <span class="comment">/* right now we only support MAC loopback in the driver */</span>
<a name="l01891"></a>01891     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0);
<a name="l01892"></a>01892     <span class="comment">/* Setup MAC loopback */</span>
<a name="l01893"></a>01893     reg_data |= IXGBE_HLREG0_LPBK;
<a name="l01894"></a>01894     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0, reg_data);
<a name="l01895"></a>01895 
<a name="l01896"></a>01896     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_FCTRL);
<a name="l01897"></a>01897     reg_data |= IXGBE_FCTRL_BAM | IXGBE_FCTRL_SBP | IXGBE_FCTRL_MPE;
<a name="l01898"></a>01898     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FCTRL, reg_data);
<a name="l01899"></a>01899 
<a name="l01900"></a>01900     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_AUTOC);
<a name="l01901"></a>01901     reg_data &amp;= ~IXGBE_AUTOC_LMS_MASK;
<a name="l01902"></a>01902     reg_data |= IXGBE_AUTOC_LMS_10G_LINK_NO_AN | IXGBE_AUTOC_FLU;
<a name="l01903"></a>01903     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_AUTOC, reg_data);
<a name="l01904"></a>01904     IXGBE_WRITE_FLUSH(&amp;adapter-&gt;hw);
<a name="l01905"></a>01905     msleep(10);
<a name="l01906"></a>01906 
<a name="l01907"></a>01907     <span class="comment">/* Disable Atlas Tx lanes; re-enabled in reset path */</span>
<a name="l01908"></a>01908     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB) {
<a name="l01909"></a>01909         u8 atlas;
<a name="l01910"></a>01910 
<a name="l01911"></a>01911         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &amp;atlas);
<a name="l01912"></a>01912         atlas |= IXGBE_ATLAS_PDN_TX_REG_EN;
<a name="l01913"></a>01913         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, atlas);
<a name="l01914"></a>01914 
<a name="l01915"></a>01915         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, &amp;atlas);
<a name="l01916"></a>01916         atlas |= IXGBE_ATLAS_PDN_TX_10G_QL_ALL;
<a name="l01917"></a>01917         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, atlas);
<a name="l01918"></a>01918 
<a name="l01919"></a>01919         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, &amp;atlas);
<a name="l01920"></a>01920         atlas |= IXGBE_ATLAS_PDN_TX_1G_QL_ALL;
<a name="l01921"></a>01921         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, atlas);
<a name="l01922"></a>01922 
<a name="l01923"></a>01923         ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, &amp;atlas);
<a name="l01924"></a>01924         atlas |= IXGBE_ATLAS_PDN_TX_AN_QL_ALL;
<a name="l01925"></a>01925         ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, atlas);
<a name="l01926"></a>01926     }
<a name="l01927"></a>01927 
<a name="l01928"></a>01928     <span class="keywordflow">return</span> 0;
<a name="l01929"></a>01929 }
<a name="l01930"></a>01930 
<a name="l01931"></a>01931 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_loopback_cleanup(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01932"></a>01932 {
<a name="l01933"></a>01933     u32 reg_data;
<a name="l01934"></a>01934 
<a name="l01935"></a>01935     reg_data = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0);
<a name="l01936"></a>01936     reg_data &amp;= ~IXGBE_HLREG0_LPBK;
<a name="l01937"></a>01937     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_HLREG0, reg_data);
<a name="l01938"></a>01938 }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_create_lbtest_frame(<span class="keyword">struct</span> sk_buff *skb,
<a name="l01941"></a>01941                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frame_size)
<a name="l01942"></a>01942 {
<a name="l01943"></a>01943     memset(skb-&gt;data, 0xFF, frame_size);
<a name="l01944"></a>01944     frame_size &amp;= ~1;
<a name="l01945"></a>01945     memset(&amp;skb-&gt;data[frame_size / 2], 0xAA, frame_size / 2 - 1);
<a name="l01946"></a>01946     memset(&amp;skb-&gt;data[frame_size / 2 + 10], 0xBE, 1);
<a name="l01947"></a>01947     memset(&amp;skb-&gt;data[frame_size / 2 + 12], 0xAF, 1);
<a name="l01948"></a>01948 }
<a name="l01949"></a>01949 
<a name="l01950"></a>01950 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_check_lbtest_frame(<span class="keyword">struct</span> sk_buff *skb,
<a name="l01951"></a>01951                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frame_size)
<a name="l01952"></a>01952 {
<a name="l01953"></a>01953     frame_size &amp;= ~1;
<a name="l01954"></a>01954     <span class="keywordflow">if</span> (*(skb-&gt;data + 3) == 0xFF) {
<a name="l01955"></a>01955         <span class="keywordflow">if</span> ((*(skb-&gt;data + frame_size / 2 + 10) == 0xBE) &amp;&amp;
<a name="l01956"></a>01956             (*(skb-&gt;data + frame_size / 2 + 12) == 0xAF)) {
<a name="l01957"></a>01957             <span class="keywordflow">return</span> 0;
<a name="l01958"></a>01958         }
<a name="l01959"></a>01959     }
<a name="l01960"></a>01960     <span class="keywordflow">return</span> 13;
<a name="l01961"></a>01961 }
<a name="l01962"></a>01962 
<a name="l01963"></a>01963 <span class="keyword">static</span> u16 ixgbe_clean_test_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01964"></a>01964                                   <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l01965"></a>01965                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size)
<a name="l01966"></a>01966 {
<a name="l01967"></a>01967     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc;
<a name="l01968"></a>01968     <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *rx_buffer_info;
<a name="l01969"></a>01969     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info;
<a name="l01970"></a>01970     <span class="keyword">const</span> <span class="keywordtype">int</span> bufsz = rx_ring-&gt;rx_buf_len;
<a name="l01971"></a>01971     u32 staterr;
<a name="l01972"></a>01972     u16 rx_ntc, tx_ntc, count = 0;
<a name="l01973"></a>01973 
<a name="l01974"></a>01974     <span class="comment">/* initialize next to clean and descriptor values */</span>
<a name="l01975"></a>01975     rx_ntc = rx_ring-&gt;next_to_clean;
<a name="l01976"></a>01976     tx_ntc = tx_ring-&gt;next_to_clean;
<a name="l01977"></a>01977     rx_desc = IXGBE_RX_DESC_ADV(rx_ring, rx_ntc);
<a name="l01978"></a>01978     staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l01979"></a>01979 
<a name="l01980"></a>01980     <span class="keywordflow">while</span> (staterr &amp; IXGBE_RXD_STAT_DD) {
<a name="l01981"></a>01981         <span class="comment">/* check Rx buffer */</span>
<a name="l01982"></a>01982         rx_buffer_info = &amp;rx_ring-&gt;rx_buffer_info[rx_ntc];
<a name="l01983"></a>01983 
<a name="l01984"></a>01984         <span class="comment">/* unmap Rx buffer, will be remapped by alloc_rx_buffers */</span>
<a name="l01985"></a>01985         dma_unmap_single(rx_ring-&gt;dev,
<a name="l01986"></a>01986                          rx_buffer_info-&gt;dma,
<a name="l01987"></a>01987                  bufsz,
<a name="l01988"></a>01988                  DMA_FROM_DEVICE);
<a name="l01989"></a>01989         rx_buffer_info-&gt;dma = 0;
<a name="l01990"></a>01990 
<a name="l01991"></a>01991         <span class="comment">/* verify contents of skb */</span>
<a name="l01992"></a>01992         <span class="keywordflow">if</span> (!ixgbe_check_lbtest_frame(rx_buffer_info-&gt;skb, size))
<a name="l01993"></a>01993             count++;
<a name="l01994"></a>01994 
<a name="l01995"></a>01995         <span class="comment">/* unmap buffer on Tx side */</span>
<a name="l01996"></a>01996         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[tx_ntc];
<a name="l01997"></a>01997         ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer_info);
<a name="l01998"></a>01998 
<a name="l01999"></a>01999         <span class="comment">/* increment Rx/Tx next to clean counters */</span>
<a name="l02000"></a>02000         rx_ntc++;
<a name="l02001"></a>02001         <span class="keywordflow">if</span> (rx_ntc == rx_ring-&gt;count)
<a name="l02002"></a>02002             rx_ntc = 0;
<a name="l02003"></a>02003         tx_ntc++;
<a name="l02004"></a>02004         <span class="keywordflow">if</span> (tx_ntc == tx_ring-&gt;count)
<a name="l02005"></a>02005             tx_ntc = 0;
<a name="l02006"></a>02006 
<a name="l02007"></a>02007         <span class="comment">/* fetch next descriptor */</span>
<a name="l02008"></a>02008         rx_desc = IXGBE_RX_DESC_ADV(rx_ring, rx_ntc);
<a name="l02009"></a>02009         staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l02010"></a>02010     }
<a name="l02011"></a>02011 
<a name="l02012"></a>02012     <span class="comment">/* re-map buffers to ring, store next to clean values */</span>
<a name="l02013"></a>02013     ixgbe_alloc_rx_buffers(rx_ring, count);
<a name="l02014"></a>02014     rx_ring-&gt;next_to_clean = rx_ntc;
<a name="l02015"></a>02015     tx_ring-&gt;next_to_clean = tx_ntc;
<a name="l02016"></a>02016 
<a name="l02017"></a>02017     <span class="keywordflow">return</span> count;
<a name="l02018"></a>02018 }
<a name="l02019"></a>02019 
<a name="l02020"></a>02020 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_run_loopback_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02021"></a>02021 {
<a name="l02022"></a>02022     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = &amp;adapter-&gt;test_tx_ring;
<a name="l02023"></a>02023     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = &amp;adapter-&gt;test_rx_ring;
<a name="l02024"></a>02024     <span class="keywordtype">int</span> i, j, lc, good_cnt, ret_val = 0;
<a name="l02025"></a>02025     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 1024;
<a name="l02026"></a>02026     netdev_tx_t tx_ret_val;
<a name="l02027"></a>02027     <span class="keyword">struct </span>sk_buff *skb;
<a name="l02028"></a>02028 
<a name="l02029"></a>02029     <span class="comment">/* allocate test skb */</span>
<a name="l02030"></a>02030     skb = alloc_skb(size, GFP_KERNEL);
<a name="l02031"></a>02031     <span class="keywordflow">if</span> (!skb)
<a name="l02032"></a>02032         <span class="keywordflow">return</span> 11;
<a name="l02033"></a>02033 
<a name="l02034"></a>02034     <span class="comment">/* place data into test skb */</span>
<a name="l02035"></a>02035     ixgbe_create_lbtest_frame(skb, size);
<a name="l02036"></a>02036     skb_put(skb, size);
<a name="l02037"></a>02037 
<a name="l02038"></a>02038     <span class="comment">/*</span>
<a name="l02039"></a>02039 <span class="comment">     * Calculate the loop count based on the largest descriptor ring</span>
<a name="l02040"></a>02040 <span class="comment">     * The idea is to wrap the largest ring a number of times using 64</span>
<a name="l02041"></a>02041 <span class="comment">     * send/receive pairs during each loop</span>
<a name="l02042"></a>02042 <span class="comment">     */</span>
<a name="l02043"></a>02043 
<a name="l02044"></a>02044     <span class="keywordflow">if</span> (rx_ring-&gt;count &lt;= tx_ring-&gt;count)
<a name="l02045"></a>02045         lc = ((tx_ring-&gt;count / 64) * 2) + 1;
<a name="l02046"></a>02046     <span class="keywordflow">else</span>
<a name="l02047"></a>02047         lc = ((rx_ring-&gt;count / 64) * 2) + 1;
<a name="l02048"></a>02048 
<a name="l02049"></a>02049     <span class="keywordflow">for</span> (j = 0; j &lt;= lc; j++) {
<a name="l02050"></a>02050         <span class="comment">/* reset count of good packets */</span>
<a name="l02051"></a>02051         good_cnt = 0;
<a name="l02052"></a>02052 
<a name="l02053"></a>02053         <span class="comment">/* place 64 packets on the transmit queue*/</span>
<a name="l02054"></a>02054         <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++) {
<a name="l02055"></a>02055             skb_get(skb);
<a name="l02056"></a>02056             tx_ret_val = ixgbe_xmit_frame_ring(skb,
<a name="l02057"></a>02057                                adapter,
<a name="l02058"></a>02058                                tx_ring);
<a name="l02059"></a>02059             <span class="keywordflow">if</span> (tx_ret_val == NETDEV_TX_OK)
<a name="l02060"></a>02060                 good_cnt++;
<a name="l02061"></a>02061         }
<a name="l02062"></a>02062 
<a name="l02063"></a>02063         <span class="keywordflow">if</span> (good_cnt != 64) {
<a name="l02064"></a>02064             ret_val = 12;
<a name="l02065"></a>02065             <span class="keywordflow">break</span>;
<a name="l02066"></a>02066         }
<a name="l02067"></a>02067 
<a name="l02068"></a>02068         <span class="comment">/* allow 200 milliseconds for packets to go from Tx to Rx */</span>
<a name="l02069"></a>02069         msleep(200);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071         good_cnt = ixgbe_clean_test_rings(rx_ring, tx_ring, size);
<a name="l02072"></a>02072         <span class="keywordflow">if</span> (good_cnt != 64) {
<a name="l02073"></a>02073             ret_val = 13;
<a name="l02074"></a>02074             <span class="keywordflow">break</span>;
<a name="l02075"></a>02075         }
<a name="l02076"></a>02076     }
<a name="l02077"></a>02077 
<a name="l02078"></a>02078     <span class="comment">/* free the original skb */</span>
<a name="l02079"></a>02079     kfree_skb(skb);
<a name="l02080"></a>02080 
<a name="l02081"></a>02081     <span class="keywordflow">return</span> ret_val;
<a name="l02082"></a>02082 }
<a name="l02083"></a>02083 
<a name="l02084"></a>02084 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_loopback_test(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 *data)
<a name="l02085"></a>02085 {
<a name="l02086"></a>02086     *data = ixgbe_setup_desc_rings(adapter);
<a name="l02087"></a>02087     <span class="keywordflow">if</span> (*data)
<a name="l02088"></a>02088         <span class="keywordflow">goto</span> out;
<a name="l02089"></a>02089     *data = ixgbe_setup_loopback_test(adapter);
<a name="l02090"></a>02090     <span class="keywordflow">if</span> (*data)
<a name="l02091"></a>02091         <span class="keywordflow">goto</span> err_loopback;
<a name="l02092"></a>02092     *data = ixgbe_run_loopback_test(adapter);
<a name="l02093"></a>02093     ixgbe_loopback_cleanup(adapter);
<a name="l02094"></a>02094 
<a name="l02095"></a>02095 err_loopback:
<a name="l02096"></a>02096     ixgbe_free_desc_rings(adapter);
<a name="l02097"></a>02097 out:
<a name="l02098"></a>02098     <span class="keywordflow">return</span> *data;
<a name="l02099"></a>02099 }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101 <span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l02102"></a>02102 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_diag_test_count(<span class="keyword">struct</span> net_device *netdev)
<a name="l02103"></a>02103 {
<a name="l02104"></a>02104     <span class="keywordflow">return</span> IXGBE_TEST_LEN;
<a name="l02105"></a>02105 }
<a name="l02106"></a>02106 
<a name="l02107"></a>02107 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l02108"></a>02108 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_diag_test(<span class="keyword">struct</span> net_device *netdev,
<a name="l02109"></a>02109                             <span class="keyword">struct</span> <a class="code" href="structethtool__test.html">ethtool_test</a> *eth_test, u64 *data)
<a name="l02110"></a>02110 {
<a name="l02111"></a>02111     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02112"></a>02112     <span class="keywordtype">bool</span> if_running = netif_running(netdev);
<a name="l02113"></a>02113 
<a name="l02114"></a>02114     set_bit(__IXGBE_TESTING, &amp;adapter-&gt;state);
<a name="l02115"></a>02115     <span class="keywordflow">if</span> (eth_test-&gt;flags == ETH_TEST_FL_OFFLINE) {
<a name="l02116"></a>02116         <span class="comment">/* Offline tests */</span>
<a name="l02117"></a>02117 
<a name="l02118"></a>02118         DPRINTK(HW, INFO, <span class="stringliteral">&quot;offline testing starting\n&quot;</span>);
<a name="l02119"></a>02119 
<a name="l02120"></a>02120         <span class="comment">/* Link test performed before hardware reset so autoneg doesn&#39;t</span>
<a name="l02121"></a>02121 <span class="comment">         * interfere with test result */</span>
<a name="l02122"></a>02122         <span class="keywordflow">if</span> (ixgbe_link_test(adapter, &amp;data[4]))
<a name="l02123"></a>02123             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02124"></a>02124 
<a name="l02125"></a>02125         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l02126"></a>02126             <span class="keywordtype">int</span> i;
<a name="l02127"></a>02127             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l02128"></a>02128                 <span class="keywordflow">if</span> (adapter-&gt;vfinfo[i].clear_to_send) {
<a name="l02129"></a>02129                     DPRINTK(DRV, WARNING, <span class="stringliteral">&quot;Please take &quot;</span>
<a name="l02130"></a>02130                         <span class="stringliteral">&quot;active VFS offline and &quot;</span>
<a name="l02131"></a>02131                         <span class="stringliteral">&quot;restart the adapter before &quot;</span>
<a name="l02132"></a>02132                         <span class="stringliteral">&quot;running NIC diagnostics\n&quot;</span>);
<a name="l02133"></a>02133                     data[0] = 1;
<a name="l02134"></a>02134                     data[1] = 1;
<a name="l02135"></a>02135                     data[2] = 1;
<a name="l02136"></a>02136                     data[3] = 1;
<a name="l02137"></a>02137                     eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02138"></a>02138                     clear_bit(__IXGBE_TESTING,
<a name="l02139"></a>02139                           &amp;adapter-&gt;state);
<a name="l02140"></a>02140                     <span class="keywordflow">goto</span> skip_ol_tests;
<a name="l02141"></a>02141                 }
<a name="l02142"></a>02142             }
<a name="l02143"></a>02143         }
<a name="l02144"></a>02144 
<a name="l02145"></a>02145         <span class="keywordflow">if</span> (if_running)
<a name="l02146"></a>02146             <span class="comment">/* indicate we&#39;re in test mode */</span>
<a name="l02147"></a>02147             dev_close(netdev);
<a name="l02148"></a>02148         <span class="keywordflow">else</span>
<a name="l02149"></a>02149             ixgbe_reset(adapter);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         DPRINTK(HW, INFO, <span class="stringliteral">&quot;register testing starting\n&quot;</span>);
<a name="l02152"></a>02152         <span class="keywordflow">if</span> (ixgbe_reg_test(adapter, &amp;data[0]))
<a name="l02153"></a>02153             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02154"></a>02154 
<a name="l02155"></a>02155         ixgbe_reset(adapter);
<a name="l02156"></a>02156         DPRINTK(HW, INFO, <span class="stringliteral">&quot;eeprom testing starting\n&quot;</span>);
<a name="l02157"></a>02157         <span class="keywordflow">if</span> (ixgbe_eeprom_test(adapter, &amp;data[1]))
<a name="l02158"></a>02158             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02159"></a>02159 
<a name="l02160"></a>02160         ixgbe_reset(adapter);
<a name="l02161"></a>02161         DPRINTK(HW, INFO, <span class="stringliteral">&quot;interrupt testing starting\n&quot;</span>);
<a name="l02162"></a>02162         <span class="keywordflow">if</span> (ixgbe_intr_test(adapter, &amp;data[2]))
<a name="l02163"></a>02163             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165         <span class="comment">/* If SRIOV or VMDq is enabled then skip MAC</span>
<a name="l02166"></a>02166 <span class="comment">         * loopback diagnostic. */</span>
<a name="l02167"></a>02167         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_SRIOV_ENABLED |
<a name="l02168"></a>02168                       IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l02169"></a>02169             DPRINTK(HW, INFO, <span class="stringliteral">&quot;skip MAC loopback diagnostic in VT &quot;</span>
<a name="l02170"></a>02170                 <span class="stringliteral">&quot;mode\n&quot;</span>);
<a name="l02171"></a>02171             data[3] = 0;
<a name="l02172"></a>02172             <span class="keywordflow">goto</span> skip_loopback;
<a name="l02173"></a>02173         }
<a name="l02174"></a>02174 
<a name="l02175"></a>02175         ixgbe_reset(adapter);
<a name="l02176"></a>02176         DPRINTK(HW, INFO, <span class="stringliteral">&quot;loopback testing starting\n&quot;</span>);
<a name="l02177"></a>02177         <span class="keywordflow">if</span> (ixgbe_loopback_test(adapter, &amp;data[3]))
<a name="l02178"></a>02178             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02179"></a>02179 
<a name="l02180"></a>02180 skip_loopback:
<a name="l02181"></a>02181         ixgbe_reset(adapter);
<a name="l02182"></a>02182 
<a name="l02183"></a>02183         clear_bit(__IXGBE_TESTING, &amp;adapter-&gt;state);
<a name="l02184"></a>02184         <span class="keywordflow">if</span> (if_running)
<a name="l02185"></a>02185             dev_open(netdev);
<a name="l02186"></a>02186     } <span class="keywordflow">else</span> {
<a name="l02187"></a>02187         DPRINTK(HW, INFO, <span class="stringliteral">&quot;online testing starting\n&quot;</span>);
<a name="l02188"></a>02188         <span class="comment">/* Online tests */</span>
<a name="l02189"></a>02189         <span class="keywordflow">if</span> (ixgbe_link_test(adapter, &amp;data[4]))
<a name="l02190"></a>02190             eth_test-&gt;flags |= ETH_TEST_FL_FAILED;
<a name="l02191"></a>02191 
<a name="l02192"></a>02192         <span class="comment">/* Online tests aren&#39;t run; pass by default */</span>
<a name="l02193"></a>02193         data[0] = 0;
<a name="l02194"></a>02194         data[1] = 0;
<a name="l02195"></a>02195         data[2] = 0;
<a name="l02196"></a>02196         data[3] = 0;
<a name="l02197"></a>02197 
<a name="l02198"></a>02198         clear_bit(__IXGBE_TESTING, &amp;adapter-&gt;state);
<a name="l02199"></a>02199     }
<a name="l02200"></a>02200 skip_ol_tests:
<a name="l02201"></a>02201     msleep_interruptible(4 * 1000);
<a name="l02202"></a>02202 }
<a name="l02203"></a>02203 
<a name="l02204"></a>02204 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_wol_exclusion(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02205"></a>02205                                <span class="keyword">struct</span> <a class="code" href="structethtool__wolinfo.html">ethtool_wolinfo</a> *wol)
<a name="l02206"></a>02206 {
<a name="l02207"></a>02207     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02208"></a>02208     <span class="keywordtype">int</span> retval = 1;
<a name="l02209"></a>02209 
<a name="l02210"></a>02210     <span class="comment">/* WOL not supported except for the following */</span>
<a name="l02211"></a>02211     <span class="keywordflow">switch</span>(hw-&gt;device_id) {
<a name="l02212"></a>02212     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_SFP:
<a name="l02213"></a>02213         <span class="comment">/* Only this subdevice supports WOL */</span>
<a name="l02214"></a>02214         <span class="keywordflow">if</span> (hw-&gt;subsystem_device_id != IXGBE_SUBDEV_ID_82599_SFP) {
<a name="l02215"></a>02215             wol-&gt;supported = 0;
<a name="l02216"></a>02216             <span class="keywordflow">break</span>;
<a name="l02217"></a>02217         }
<a name="l02218"></a>02218         retval = 0;
<a name="l02219"></a>02219         <span class="keywordflow">break</span>;
<a name="l02220"></a>02220     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_COMBO_BACKPLANE:
<a name="l02221"></a>02221         <span class="comment">/* All except this subdevice support WOL */</span>
<a name="l02222"></a>02222         <span class="keywordflow">if</span> (hw-&gt;subsystem_device_id ==
<a name="l02223"></a>02223             IXGBE_SUBDEV_ID_82599_KX4_KR_MEZZ) {
<a name="l02224"></a>02224             wol-&gt;supported = 0;
<a name="l02225"></a>02225             <span class="keywordflow">break</span>;
<a name="l02226"></a>02226         }
<a name="l02227"></a>02227         retval = 0;
<a name="l02228"></a>02228         <span class="keywordflow">break</span>;
<a name="l02229"></a>02229     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_KX4:
<a name="l02230"></a>02230         retval = 0;
<a name="l02231"></a>02231         <span class="keywordflow">break</span>;
<a name="l02232"></a>02232     <span class="keywordflow">default</span>:
<a name="l02233"></a>02233         wol-&gt;supported = 0;
<a name="l02234"></a>02234     }
<a name="l02235"></a>02235 
<a name="l02236"></a>02236     <span class="keywordflow">return</span> retval;
<a name="l02237"></a>02237 }
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_wol(<span class="keyword">struct</span> net_device *netdev,
<a name="l02240"></a>02240                           <span class="keyword">struct</span> <a class="code" href="structethtool__wolinfo.html">ethtool_wolinfo</a> *wol)
<a name="l02241"></a>02241 {
<a name="l02242"></a>02242     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02243"></a>02243 
<a name="l02244"></a>02244     wol-&gt;supported = WAKE_UCAST | WAKE_MCAST |
<a name="l02245"></a>02245                      WAKE_BCAST | WAKE_MAGIC;
<a name="l02246"></a>02246     wol-&gt;wolopts = 0;
<a name="l02247"></a>02247 
<a name="l02248"></a>02248     <span class="keywordflow">if</span> (ixgbe_wol_exclusion(adapter, wol) ||
<a name="l02249"></a>02249         !device_can_wakeup(&amp;adapter-&gt;pdev-&gt;dev))
<a name="l02250"></a>02250         <span class="keywordflow">return</span>;
<a name="l02251"></a>02251 
<a name="l02252"></a>02252     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_EX)
<a name="l02253"></a>02253         wol-&gt;wolopts |= WAKE_UCAST;
<a name="l02254"></a>02254     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_MC)
<a name="l02255"></a>02255         wol-&gt;wolopts |= WAKE_MCAST;
<a name="l02256"></a>02256     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_BC)
<a name="l02257"></a>02257         wol-&gt;wolopts |= WAKE_BCAST;
<a name="l02258"></a>02258     <span class="keywordflow">if</span> (adapter-&gt;wol &amp; IXGBE_WUFC_MAG)
<a name="l02259"></a>02259         wol-&gt;wolopts |= WAKE_MAGIC;
<a name="l02260"></a>02260 }
<a name="l02261"></a>02261 
<a name="l02262"></a>02262 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_wol(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structethtool__wolinfo.html">ethtool_wolinfo</a> *wol)
<a name="l02263"></a>02263 {
<a name="l02264"></a>02264     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02265"></a>02265 
<a name="l02266"></a>02266     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))
<a name="l02267"></a>02267         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l02268"></a>02268 
<a name="l02269"></a>02269     <span class="keywordflow">if</span> (ixgbe_wol_exclusion(adapter, wol))
<a name="l02270"></a>02270         <span class="keywordflow">return</span> wol-&gt;wolopts ? -EOPNOTSUPP : 0;
<a name="l02271"></a>02271 
<a name="l02272"></a>02272     adapter-&gt;wol = 0;
<a name="l02273"></a>02273 
<a name="l02274"></a>02274     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_UCAST)
<a name="l02275"></a>02275         adapter-&gt;wol |= IXGBE_WUFC_EX;
<a name="l02276"></a>02276     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_MCAST)
<a name="l02277"></a>02277         adapter-&gt;wol |= IXGBE_WUFC_MC;
<a name="l02278"></a>02278     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_BCAST)
<a name="l02279"></a>02279         adapter-&gt;wol |= IXGBE_WUFC_BC;
<a name="l02280"></a>02280     <span class="keywordflow">if</span> (wol-&gt;wolopts &amp; WAKE_MAGIC)
<a name="l02281"></a>02281         adapter-&gt;wol |= IXGBE_WUFC_MAG;
<a name="l02282"></a>02282 
<a name="l02283"></a>02283     device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);
<a name="l02284"></a>02284 
<a name="l02285"></a>02285     <span class="keywordflow">return</span> 0;
<a name="l02286"></a>02286 }
<a name="l02287"></a>02287 
<a name="l02288"></a>02288 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_nway_reset(<span class="keyword">struct</span> net_device *netdev)
<a name="l02289"></a>02289 {
<a name="l02290"></a>02290     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02291"></a>02291 
<a name="l02292"></a>02292     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l02293"></a>02293         ixgbe_reinit_locked(adapter);
<a name="l02294"></a>02294 
<a name="l02295"></a>02295     <span class="keywordflow">return</span> 0;
<a name="l02296"></a>02296 }
<a name="l02297"></a>02297 
<a name="l02298"></a>02298 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_phys_id(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l02299"></a>02299 {
<a name="l02300"></a>02300     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02301"></a>02301     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02302"></a>02302     u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
<a name="l02303"></a>02303     u32 i;
<a name="l02304"></a>02304 
<a name="l02305"></a>02305     <span class="keywordflow">if</span> (!data || data &gt; 300)
<a name="l02306"></a>02306         data = 300;
<a name="l02307"></a>02307 
<a name="l02308"></a>02308     <span class="keywordflow">for</span> (i = 0; i &lt; (data * 1000); i += 400) {
<a name="l02309"></a>02309         ixgbe_led_on(hw, IXGBE_LED_ON);
<a name="l02310"></a>02310         msleep_interruptible(200);
<a name="l02311"></a>02311         ixgbe_led_off(hw, IXGBE_LED_ON);
<a name="l02312"></a>02312         msleep_interruptible(200);
<a name="l02313"></a>02313     }
<a name="l02314"></a>02314 
<a name="l02315"></a>02315     <span class="comment">/* Restore LED settings */</span>
<a name="l02316"></a>02316     IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
<a name="l02317"></a>02317 
<a name="l02318"></a>02318     <span class="keywordflow">return</span> 0;
<a name="l02319"></a>02319 }
<a name="l02320"></a>02320 
<a name="l02321"></a>02321 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_get_coalesce(<span class="keyword">struct</span> net_device *netdev,
<a name="l02322"></a>02322                               <span class="keyword">struct</span> ethtool_coalesce *ec)
<a name="l02323"></a>02323 {
<a name="l02324"></a>02324     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02325"></a>02325 
<a name="l02326"></a>02326 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02327"></a>02327 <span class="preprocessor"></span>    ec-&gt;tx_max_coalesced_frames_irq = adapter-&gt;tx_work_limit;
<a name="l02328"></a>02328     ec-&gt;rx_max_coalesced_frames_irq = adapter-&gt;rx_work_limit;
<a name="l02329"></a>02329 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02330"></a>02330 
<a name="l02331"></a>02331     <span class="comment">/* only valid if in constant ITR mode */</span>
<a name="l02332"></a>02332     <span class="keywordflow">switch</span> (adapter-&gt;rx_itr_setting) {
<a name="l02333"></a>02333     <span class="keywordflow">case</span> 0:
<a name="l02334"></a>02334         <span class="comment">/* throttling disabled */</span>
<a name="l02335"></a>02335         ec-&gt;rx_coalesce_usecs = 0;
<a name="l02336"></a>02336         <span class="keywordflow">break</span>;
<a name="l02337"></a>02337     <span class="keywordflow">case</span> 1:
<a name="l02338"></a>02338         <span class="comment">/* dynamic ITR mode */</span>
<a name="l02339"></a>02339         ec-&gt;rx_coalesce_usecs = 1;
<a name="l02340"></a>02340         <span class="keywordflow">break</span>;
<a name="l02341"></a>02341     <span class="keywordflow">default</span>:
<a name="l02342"></a>02342         <span class="comment">/* fixed interrupt rate mode */</span>
<a name="l02343"></a>02343         ec-&gt;rx_coalesce_usecs = 1000000/adapter-&gt;rx_eitr_param;
<a name="l02344"></a>02344         <span class="keywordflow">break</span>;
<a name="l02345"></a>02345     }
<a name="l02346"></a>02346 
<a name="l02347"></a>02347     <span class="comment">/* if in mixed tx/rx queues per vector mode, report only rx settings */</span>
<a name="l02348"></a>02348     <span class="keywordflow">if</span> (adapter-&gt;q_vector[0]-&gt;txr_count &amp;&amp; adapter-&gt;q_vector[0]-&gt;rxr_count)
<a name="l02349"></a>02349         <span class="keywordflow">return</span> 0;
<a name="l02350"></a>02350 
<a name="l02351"></a>02351     <span class="comment">/* only valid if in constant ITR mode */</span>
<a name="l02352"></a>02352     <span class="keywordflow">switch</span> (adapter-&gt;tx_itr_setting) {
<a name="l02353"></a>02353     <span class="keywordflow">case</span> 0:
<a name="l02354"></a>02354         <span class="comment">/* throttling disabled */</span>
<a name="l02355"></a>02355         ec-&gt;tx_coalesce_usecs = 0;
<a name="l02356"></a>02356         <span class="keywordflow">break</span>;
<a name="l02357"></a>02357     <span class="keywordflow">case</span> 1:
<a name="l02358"></a>02358         <span class="comment">/* dynamic ITR mode */</span>
<a name="l02359"></a>02359         ec-&gt;tx_coalesce_usecs = 1;
<a name="l02360"></a>02360         <span class="keywordflow">break</span>;
<a name="l02361"></a>02361     <span class="keywordflow">default</span>:
<a name="l02362"></a>02362         ec-&gt;tx_coalesce_usecs = 1000000/adapter-&gt;tx_eitr_param;
<a name="l02363"></a>02363         <span class="keywordflow">break</span>;
<a name="l02364"></a>02364     }
<a name="l02365"></a>02365 
<a name="l02366"></a>02366     <span class="keywordflow">return</span> 0;
<a name="l02367"></a>02367 }
<a name="l02368"></a>02368 
<a name="l02369"></a>02369 <span class="comment">/*</span>
<a name="l02370"></a>02370 <span class="comment"> * this function must be called before setting the new value of</span>
<a name="l02371"></a>02371 <span class="comment"> * rx_itr_setting</span>
<a name="l02372"></a>02372 <span class="comment"> */</span>
<a name="l02373"></a>02373 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_update_rsc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02374"></a>02374                                <span class="keyword">struct</span> ethtool_coalesce *ec)
<a name="l02375"></a>02375 {
<a name="l02376"></a>02376     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02377"></a>02377 
<a name="l02378"></a>02378     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE))
<a name="l02379"></a>02379         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02380"></a>02380 
<a name="l02381"></a>02381     <span class="comment">/* if interrupt rate is too high then disable RSC */</span>
<a name="l02382"></a>02382     <span class="keywordflow">if</span> (ec-&gt;rx_coalesce_usecs != 1 &amp;&amp;
<a name="l02383"></a>02383         ec-&gt;rx_coalesce_usecs &lt;= 1000000/IXGBE_MAX_RSC_INT_RATE) {
<a name="l02384"></a>02384         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l02385"></a>02385             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;rx-usecs set too low, &quot;</span>
<a name="l02386"></a>02386                          <span class="stringliteral">&quot;disabling RSC\n&quot;</span>);
<a name="l02387"></a>02387             adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_ENABLED;
<a name="l02388"></a>02388             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02389"></a>02389         }
<a name="l02390"></a>02390     } <span class="keywordflow">else</span> {
<a name="l02391"></a>02391         <span class="comment">/* check the feature flag value and enable RSC if necessary */</span>
<a name="l02392"></a>02392         <span class="keywordflow">if</span> ((netdev-&gt;features &amp; NETIF_F_LRO) &amp;&amp;
<a name="l02393"></a>02393             !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED)) {
<a name="l02394"></a>02394             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;rx-usecs set to %d, &quot;</span>
<a name="l02395"></a>02395                          <span class="stringliteral">&quot;re-enabling RSC\n&quot;</span>,
<a name="l02396"></a>02396                     ec-&gt;rx_coalesce_usecs);
<a name="l02397"></a>02397             adapter-&gt;flags2 |= IXGBE_FLAG2_RSC_ENABLED;
<a name="l02398"></a>02398             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02399"></a>02399         }
<a name="l02400"></a>02400     }
<a name="l02401"></a>02401     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02402"></a>02402 }
<a name="l02403"></a>02403 
<a name="l02404"></a>02404 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_coalesce(<span class="keyword">struct</span> net_device *netdev,
<a name="l02405"></a>02405                               <span class="keyword">struct</span> ethtool_coalesce *ec)
<a name="l02406"></a>02406 {
<a name="l02407"></a>02407     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02408"></a>02408     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l02409"></a>02409     <span class="keywordtype">int</span> i;
<a name="l02410"></a>02410     <span class="keywordtype">int</span> num_vectors;
<a name="l02411"></a>02411     <span class="keywordtype">bool</span> need_reset = <span class="keyword">false</span>;
<a name="l02412"></a>02412 
<a name="l02413"></a>02413     <span class="comment">/* don&#39;t accept tx specific changes if we&#39;ve got mixed RxTx vectors */</span>
<a name="l02414"></a>02414     <span class="keywordflow">if</span> (adapter-&gt;q_vector[0]-&gt;txr_count &amp;&amp; adapter-&gt;q_vector[0]-&gt;rxr_count
<a name="l02415"></a>02415         &amp;&amp; ec-&gt;tx_coalesce_usecs)
<a name="l02416"></a>02416         <span class="keywordflow">return</span> -EINVAL;
<a name="l02417"></a>02417 
<a name="l02418"></a>02418 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02419"></a>02419 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ec-&gt;tx_max_coalesced_frames_irq)
<a name="l02420"></a>02420         adapter-&gt;tx_work_limit = ec-&gt;tx_max_coalesced_frames_irq;
<a name="l02421"></a>02421     <span class="keywordflow">if</span> (ec-&gt;rx_max_coalesced_frames_irq)
<a name="l02422"></a>02422         adapter-&gt;rx_work_limit = ec-&gt;rx_max_coalesced_frames_irq;
<a name="l02423"></a>02423 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02424"></a>02424 
<a name="l02425"></a>02425     <span class="keywordflow">if</span> (ec-&gt;rx_coalesce_usecs &gt; 1) {
<a name="l02426"></a>02426         <span class="comment">/* check the limits */</span>
<a name="l02427"></a>02427         <span class="keywordflow">if</span> ((1000000/ec-&gt;rx_coalesce_usecs &gt; IXGBE_MAX_INT_RATE) ||
<a name="l02428"></a>02428             (1000000/ec-&gt;rx_coalesce_usecs &lt; IXGBE_MIN_INT_RATE))
<a name="l02429"></a>02429             <span class="keywordflow">return</span> -EINVAL;
<a name="l02430"></a>02430 
<a name="l02431"></a>02431         <span class="comment">/* check the old value and enable RSC if necessary */</span>
<a name="l02432"></a>02432         need_reset = ixgbe_update_rsc(adapter, ec);
<a name="l02433"></a>02433 
<a name="l02434"></a>02434         <span class="comment">/* store the value in ints/second */</span>
<a name="l02435"></a>02435         adapter-&gt;rx_eitr_param = 1000000/ec-&gt;rx_coalesce_usecs;
<a name="l02436"></a>02436 
<a name="l02437"></a>02437         <span class="comment">/* static value of interrupt rate */</span>
<a name="l02438"></a>02438         adapter-&gt;rx_itr_setting = adapter-&gt;rx_eitr_param;
<a name="l02439"></a>02439         <span class="comment">/* clear the lower bit as its used for dynamic state */</span>
<a name="l02440"></a>02440         adapter-&gt;rx_itr_setting &amp;= ~1;
<a name="l02441"></a>02441     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ec-&gt;rx_coalesce_usecs == 1) {
<a name="l02442"></a>02442         <span class="comment">/* check the old value and enable RSC if necessary */</span>
<a name="l02443"></a>02443         need_reset = ixgbe_update_rsc(adapter, ec);
<a name="l02444"></a>02444 
<a name="l02445"></a>02445         <span class="comment">/* 1 means dynamic mode */</span>
<a name="l02446"></a>02446         adapter-&gt;rx_eitr_param = 20000;
<a name="l02447"></a>02447         adapter-&gt;rx_itr_setting = 1;
<a name="l02448"></a>02448     } <span class="keywordflow">else</span> {
<a name="l02449"></a>02449         <span class="comment">/* check the old value and enable RSC if necessary */</span>
<a name="l02450"></a>02450         need_reset = ixgbe_update_rsc(adapter, ec);
<a name="l02451"></a>02451         <span class="comment">/*</span>
<a name="l02452"></a>02452 <span class="comment">         * any other value means disable eitr, which is best</span>
<a name="l02453"></a>02453 <span class="comment">         * served by setting the interrupt rate very high</span>
<a name="l02454"></a>02454 <span class="comment">         */</span>
<a name="l02455"></a>02455         adapter-&gt;rx_eitr_param = IXGBE_MAX_INT_RATE;
<a name="l02456"></a>02456         adapter-&gt;rx_itr_setting = 0;
<a name="l02457"></a>02457     }
<a name="l02458"></a>02458 
<a name="l02459"></a>02459     <span class="keywordflow">if</span> (ec-&gt;tx_coalesce_usecs &gt; 1) {
<a name="l02460"></a>02460         <span class="comment">/*</span>
<a name="l02461"></a>02461 <span class="comment">         * don&#39;t have to worry about max_int as above because</span>
<a name="l02462"></a>02462 <span class="comment">         * tx vectors don&#39;t do hardware RSC (an rx function)</span>
<a name="l02463"></a>02463 <span class="comment">         */</span>
<a name="l02464"></a>02464         <span class="comment">/* check the limits */</span>
<a name="l02465"></a>02465         <span class="keywordflow">if</span> ((1000000/ec-&gt;tx_coalesce_usecs &gt; IXGBE_MAX_INT_RATE) ||
<a name="l02466"></a>02466             (1000000/ec-&gt;tx_coalesce_usecs &lt; IXGBE_MIN_INT_RATE))
<a name="l02467"></a>02467             <span class="keywordflow">return</span> -EINVAL;
<a name="l02468"></a>02468 
<a name="l02469"></a>02469         <span class="comment">/* store the value in ints/second */</span>
<a name="l02470"></a>02470         adapter-&gt;tx_eitr_param = 1000000/ec-&gt;tx_coalesce_usecs;
<a name="l02471"></a>02471 
<a name="l02472"></a>02472         <span class="comment">/* static value of interrupt rate */</span>
<a name="l02473"></a>02473         adapter-&gt;tx_itr_setting = adapter-&gt;tx_eitr_param;
<a name="l02474"></a>02474 
<a name="l02475"></a>02475         <span class="comment">/* clear the lower bit as its used for dynamic state */</span>
<a name="l02476"></a>02476         adapter-&gt;tx_itr_setting &amp;= ~1;
<a name="l02477"></a>02477     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ec-&gt;tx_coalesce_usecs == 1) {
<a name="l02478"></a>02478         <span class="comment">/* 1 means dynamic mode */</span>
<a name="l02479"></a>02479         adapter-&gt;tx_eitr_param = 10000;
<a name="l02480"></a>02480         adapter-&gt;tx_itr_setting = 1;
<a name="l02481"></a>02481     } <span class="keywordflow">else</span> {
<a name="l02482"></a>02482         adapter-&gt;tx_eitr_param = IXGBE_MAX_INT_RATE;
<a name="l02483"></a>02483         adapter-&gt;tx_itr_setting = 0;
<a name="l02484"></a>02484     }
<a name="l02485"></a>02485 
<a name="l02486"></a>02486     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l02487"></a>02487         num_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02488"></a>02488     <span class="keywordflow">else</span>
<a name="l02489"></a>02489         num_vectors = 1;
<a name="l02490"></a>02490 
<a name="l02491"></a>02491     <span class="keywordflow">for</span> (i = 0; i &lt; num_vectors; i++) {
<a name="l02492"></a>02492         q_vector = adapter-&gt;q_vector[i];
<a name="l02493"></a>02493 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02494"></a>02494 <span class="preprocessor"></span>        q_vector-&gt;tx_work_limit = adapter-&gt;tx_work_limit;
<a name="l02495"></a>02495         q_vector-&gt;rx_work_limit = adapter-&gt;rx_work_limit;
<a name="l02496"></a>02496 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02497"></a>02497         <span class="keywordflow">if</span> (q_vector-&gt;txr_count &amp;&amp; !q_vector-&gt;rxr_count)
<a name="l02498"></a>02498             <span class="comment">/* tx only */</span>
<a name="l02499"></a>02499             q_vector-&gt;eitr = adapter-&gt;tx_eitr_param;
<a name="l02500"></a>02500         <span class="keywordflow">else</span>
<a name="l02501"></a>02501             <span class="comment">/* rx only or mixed */</span>
<a name="l02502"></a>02502             q_vector-&gt;eitr = adapter-&gt;rx_eitr_param;
<a name="l02503"></a>02503         ixgbe_write_eitr(q_vector);
<a name="l02504"></a>02504     }
<a name="l02505"></a>02505 
<a name="l02506"></a>02506     <span class="comment">/*</span>
<a name="l02507"></a>02507 <span class="comment">     * do reset here at the end to make sure EITR==0 case is handled</span>
<a name="l02508"></a>02508 <span class="comment">     * correctly w.r.t stopping tx, and changing TXDCTL.WTHRESH settings</span>
<a name="l02509"></a>02509 <span class="comment">     * also locks in RSC enable/disable which requires reset</span>
<a name="l02510"></a>02510 <span class="comment">     */</span>
<a name="l02511"></a>02511     <span class="keywordflow">if</span> (need_reset) {
<a name="l02512"></a>02512         <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l02513"></a>02513             ixgbe_reinit_locked(adapter);
<a name="l02514"></a>02514         <span class="keywordflow">else</span>
<a name="l02515"></a>02515             ixgbe_reset(adapter);
<a name="l02516"></a>02516     }
<a name="l02517"></a>02517 
<a name="l02518"></a>02518     <span class="keywordflow">return</span> 0;
<a name="l02519"></a>02519 }
<a name="l02520"></a>02520 
<a name="l02521"></a>02521 <span class="preprocessor">#ifdef ETHTOOL_GFLAGS</span>
<a name="l02522"></a>02522 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_flags(<span class="keyword">struct</span> net_device *netdev, u32 data)
<a name="l02523"></a>02523 {
<a name="l02524"></a>02524     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02525"></a>02525     <span class="keywordtype">bool</span> need_reset = <span class="keyword">false</span>;
<a name="l02526"></a>02526     <span class="keywordtype">int</span> rc;
<a name="l02527"></a>02527 
<a name="l02528"></a>02528     rc = ethtool_op_set_flags(netdev, data, ETH_FLAG_LRO | ETH_FLAG_NTUPLE);
<a name="l02529"></a>02529     <span class="keywordflow">if</span> (rc)
<a name="l02530"></a>02530         <span class="keywordflow">return</span> rc;
<a name="l02531"></a>02531 
<a name="l02532"></a>02532     <span class="comment">/* if state changes we need to update adapter-&gt;flags and reset */</span>
<a name="l02533"></a>02533     <span class="keywordflow">if</span> ((adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE) &amp;&amp;
<a name="l02534"></a>02534         (!!(data &amp; ETH_FLAG_LRO) !=
<a name="l02535"></a>02535          !!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED))) {
<a name="l02536"></a>02536         <span class="keywordflow">if</span> ((data &amp; ETH_FLAG_LRO) &amp;&amp;
<a name="l02537"></a>02537             (!adapter-&gt;rx_itr_setting ||
<a name="l02538"></a>02538              (adapter-&gt;rx_itr_setting &gt; IXGBE_MAX_RSC_INT_RATE))) {
<a name="l02539"></a>02539             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;rx-usecs set too low, &quot;</span>
<a name="l02540"></a>02540                          <span class="stringliteral">&quot;not enabling RSC\n&quot;</span>);
<a name="l02541"></a>02541         } <span class="keywordflow">else</span> {
<a name="l02542"></a>02542             adapter-&gt;flags2 ^= IXGBE_FLAG2_RSC_ENABLED;
<a name="l02543"></a>02543             <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02544"></a>02544             <span class="keywordtype">int</span> i;
<a name="l02545"></a>02545             <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02546"></a>02546                 <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l02547"></a>02547                     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;rx_ring[i];
<a name="l02548"></a>02548                     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l02549"></a>02549                         set_ring_rsc_enabled(ring);
<a name="l02550"></a>02550                         ixgbe_configure_rscctl(adapter, ring);
<a name="l02551"></a>02551                     } <span class="keywordflow">else</span> {
<a name="l02552"></a>02552                         ixgbe_clear_rscctl(adapter, ring);
<a name="l02553"></a>02553                     }
<a name="l02554"></a>02554                 }
<a name="l02555"></a>02555                 <span class="keywordflow">break</span>;
<a name="l02556"></a>02556             <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02557"></a>02557                 need_reset = <span class="keyword">true</span>;
<a name="l02558"></a>02558                 <span class="keywordflow">break</span>;
<a name="l02559"></a>02559             <span class="keywordflow">default</span>:
<a name="l02560"></a>02560                 <span class="keywordflow">break</span>;
<a name="l02561"></a>02561             }
<a name="l02562"></a>02562         }
<a name="l02563"></a>02563 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l02564"></a>02564 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l02565"></a>02565 <span class="comment">     * Cast both to bool and verify if they are set the same</span>
<a name="l02566"></a>02566 <span class="comment">     * and don&#39;t set LRO if device is RSC capable.</span>
<a name="l02567"></a>02567 <span class="comment">     */</span>
<a name="l02568"></a>02568     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE) &amp;&amp;
<a name="l02569"></a>02569            (!!(data &amp; ETH_FLAG_LRO) !=
<a name="l02570"></a>02570             !!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED))) {
<a name="l02571"></a>02571         <span class="keywordtype">int</span> i;
<a name="l02572"></a>02572         adapter-&gt;flags2 ^= IXGBE_FLAG2_SWLRO_ENABLED;
<a name="l02573"></a>02573         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l02574"></a>02574             <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED)
<a name="l02575"></a>02575                 set_ring_lro_enabled(adapter-&gt;rx_ring[i]);
<a name="l02576"></a>02576             <span class="keywordflow">else</span>
<a name="l02577"></a>02577                 clear_ring_lro_enabled(adapter-&gt;rx_ring[i]);
<a name="l02578"></a>02578         }
<a name="l02579"></a>02579 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l02580"></a>02580     }
<a name="l02581"></a>02581 
<a name="l02582"></a>02582 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l02583"></a>02583 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l02584"></a>02584 <span class="comment">     * Check if Flow Director n-tuple support was enabled or disabled.  If</span>
<a name="l02585"></a>02585 <span class="comment">     * the state changed, we need to reset.</span>
<a name="l02586"></a>02586 <span class="comment">     */</span>
<a name="l02587"></a>02587     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE) &amp;&amp;
<a name="l02588"></a>02588         (!(data &amp; ETH_FLAG_NTUPLE))) {
<a name="l02589"></a>02589         <span class="comment">/* turn off Flow Director perfect, set hash and reset */</span>
<a name="l02590"></a>02590         adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
<a name="l02591"></a>02591         adapter-&gt;flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l02592"></a>02592         need_reset = <span class="keyword">true</span>;
<a name="l02593"></a>02593     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((!(adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)) &amp;&amp;
<a name="l02594"></a>02594                (data &amp; ETH_FLAG_NTUPLE)) {
<a name="l02595"></a>02595         <span class="comment">/* turn off Flow Director hash, enable perfect and reset */</span>
<a name="l02596"></a>02596         adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l02597"></a>02597         adapter-&gt;flags |= IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
<a name="l02598"></a>02598         need_reset = <span class="keyword">true</span>;
<a name="l02599"></a>02599     } <span class="keywordflow">else</span> {
<a name="l02600"></a>02600         <span class="comment">/* no state change */</span>
<a name="l02601"></a>02601     }
<a name="l02602"></a>02602 
<a name="l02603"></a>02603 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l02604"></a>02604     <span class="keywordflow">if</span> (need_reset) {
<a name="l02605"></a>02605         <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l02606"></a>02606             ixgbe_reinit_locked(adapter);
<a name="l02607"></a>02607         <span class="keywordflow">else</span>
<a name="l02608"></a>02608             ixgbe_reset(adapter);
<a name="l02609"></a>02609     }
<a name="l02610"></a>02610 
<a name="l02611"></a>02611     <span class="keywordflow">return</span> 0;
<a name="l02612"></a>02612 }
<a name="l02613"></a>02613 <span class="preprocessor">#endif </span><span class="comment">/* ETHTOOL_GFLAGS */</span>
<a name="l02614"></a>02614 
<a name="l02615"></a>02615 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l02616"></a>02616 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_rx_ntuple(<span class="keyword">struct</span> net_device *dev,
<a name="l02617"></a>02617                                <span class="keyword">struct</span> ethtool_rx_ntuple *cmd)
<a name="l02618"></a>02618 {
<a name="l02619"></a>02619     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l02620"></a>02620     <span class="keyword">struct </span>ethtool_rx_ntuple_flow_spec *fs = &amp;cmd-&gt;fs;
<a name="l02621"></a>02621     <span class="keyword">union </span><a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a> input_struct;
<a name="l02622"></a>02622     <span class="keyword">struct </span><a class="code" href="structixgbe__atr__input__masks.html">ixgbe_atr_input_masks</a> input_masks;
<a name="l02623"></a>02623     <span class="keywordtype">int</span> target_queue;
<a name="l02624"></a>02624     <span class="keywordtype">int</span> err;
<a name="l02625"></a>02625 
<a name="l02626"></a>02626     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l02627"></a>02627         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l02628"></a>02628 
<a name="l02629"></a>02629     <span class="comment">/*</span>
<a name="l02630"></a>02630 <span class="comment">     * Don&#39;t allow programming if the action is a queue greater than</span>
<a name="l02631"></a>02631 <span class="comment">     * the number of online Tx queues.</span>
<a name="l02632"></a>02632 <span class="comment">     */</span>
<a name="l02633"></a>02633     <span class="keywordflow">if</span> ((fs-&gt;action &gt;= adapter-&gt;num_tx_queues) ||
<a name="l02634"></a>02634         (fs-&gt;action &lt; ETHTOOL_RXNTUPLE_ACTION_DROP))
<a name="l02635"></a>02635         <span class="keywordflow">return</span> -EINVAL;
<a name="l02636"></a>02636 
<a name="l02637"></a>02637     memset(&amp;input_struct, 0, <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a>));
<a name="l02638"></a>02638     memset(&amp;input_masks, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__atr__input__masks.html">ixgbe_atr_input_masks</a>));
<a name="l02639"></a>02639 
<a name="l02640"></a>02640     <span class="comment">/* record flow type */</span>
<a name="l02641"></a>02641     <span class="keywordflow">switch</span> (fs-&gt;flow_type) {
<a name="l02642"></a>02642     <span class="keywordflow">case</span> IPV4_FLOW:
<a name="l02643"></a>02643         input_struct.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_IPV4;
<a name="l02644"></a>02644         <span class="keywordflow">break</span>;
<a name="l02645"></a>02645     <span class="keywordflow">case</span> TCP_V4_FLOW:
<a name="l02646"></a>02646         input_struct.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;
<a name="l02647"></a>02647         <span class="keywordflow">break</span>;
<a name="l02648"></a>02648     <span class="keywordflow">case</span> UDP_V4_FLOW:
<a name="l02649"></a>02649         input_struct.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_UDPV4;
<a name="l02650"></a>02650         <span class="keywordflow">break</span>;
<a name="l02651"></a>02651     <span class="keywordflow">case</span> SCTP_V4_FLOW:
<a name="l02652"></a>02652         input_struct.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_SCTPV4;
<a name="l02653"></a>02653         <span class="keywordflow">break</span>;
<a name="l02654"></a>02654     <span class="keywordflow">default</span>:
<a name="l02655"></a>02655         <span class="keywordflow">return</span> -1;
<a name="l02656"></a>02656     }
<a name="l02657"></a>02657 
<a name="l02658"></a>02658     <span class="comment">/* copy vlan tag minus the CFI bit */</span>
<a name="l02659"></a>02659     <span class="keywordflow">if</span> ((fs-&gt;vlan_tag &amp; 0xEFFF) || (fs-&gt;vlan_tag_mask &amp; 0xEFFF)) {
<a name="l02660"></a>02660         input_struct.formatted.vlan_id = htons(fs-&gt;vlan_tag &amp; 0xEFFF);
<a name="l02661"></a>02661         <span class="keywordflow">if</span> (!fs-&gt;vlan_tag_mask) {
<a name="l02662"></a>02662             input_masks.vlan_id_mask = htons(0xEFFF);
<a name="l02663"></a>02663         } <span class="keywordflow">else</span> {
<a name="l02664"></a>02664             <span class="keywordflow">switch</span> (fs-&gt;vlan_tag_mask &amp; 0xEFFF) {
<a name="l02665"></a>02665             <span class="comment">/* all of these are valid vlan-mask values */</span>
<a name="l02666"></a>02666             <span class="keywordflow">case</span> 0xEFFF:
<a name="l02667"></a>02667             <span class="keywordflow">case</span> 0xE000:
<a name="l02668"></a>02668             <span class="keywordflow">case</span> 0x0FFF:
<a name="l02669"></a>02669             <span class="keywordflow">case</span> 0x0000:
<a name="l02670"></a>02670                 input_masks.vlan_id_mask =
<a name="l02671"></a>02671                     htons(fs-&gt;vlan_tag_mask);
<a name="l02672"></a>02672                 <span class="keywordflow">break</span>;
<a name="l02673"></a>02673             <span class="comment">/* exit with error if vlan-mask is invalid */</span>
<a name="l02674"></a>02674             <span class="keywordflow">default</span>:
<a name="l02675"></a>02675                 DPRINTK(DRV, ERR, <span class="stringliteral">&quot;Partial VLAN ID or &quot;</span>
<a name="l02676"></a>02676                     <span class="stringliteral">&quot;priority mask in vlan-mask is not &quot;</span>
<a name="l02677"></a>02677                     <span class="stringliteral">&quot;supported by hardware\n&quot;</span>);
<a name="l02678"></a>02678                 <span class="keywordflow">return</span> -1;
<a name="l02679"></a>02679             }
<a name="l02680"></a>02680         }
<a name="l02681"></a>02681     }
<a name="l02682"></a>02682 
<a name="l02683"></a>02683     <span class="comment">/* make sure we only use the first 2 bytes of user data */</span>
<a name="l02684"></a>02684     <span class="keywordflow">if</span> ((fs-&gt;data &amp; 0xFFFF) || (fs-&gt;data_mask &amp; 0xFFFF)) {
<a name="l02685"></a>02685         input_struct.formatted.flex_bytes = htons(fs-&gt;data &amp; 0xFFFF);
<a name="l02686"></a>02686         <span class="keywordflow">if</span> (!fs-&gt;data_mask) {
<a name="l02687"></a>02687             input_masks.flex_mask = 0xFFFF;
<a name="l02688"></a>02688         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(~fs-&gt;data_mask &amp; 0xFFFF)) {
<a name="l02689"></a>02689             input_masks.flex_mask = 0xFFFF;
<a name="l02690"></a>02690         } <span class="keywordflow">else</span> {
<a name="l02691"></a>02691             DPRINTK(DRV, ERR, <span class="stringliteral">&quot;Partial user-def-mask is not &quot;</span>
<a name="l02692"></a>02692                 <span class="stringliteral">&quot;supported by hardware\n&quot;</span>);
<a name="l02693"></a>02693             <span class="keywordflow">return</span> -1;
<a name="l02694"></a>02694         }
<a name="l02695"></a>02695     }
<a name="l02696"></a>02696 
<a name="l02697"></a>02697     <span class="comment">/*</span>
<a name="l02698"></a>02698 <span class="comment">     * Copy input into formatted structures</span>
<a name="l02699"></a>02699 <span class="comment">     *</span>
<a name="l02700"></a>02700 <span class="comment">     * These assignments are based on the following logic</span>
<a name="l02701"></a>02701 <span class="comment">     * If neither input or mask are set assume value is masked out.</span>
<a name="l02702"></a>02702 <span class="comment">     * If input is set, but mask is not mask should default to accept all.</span>
<a name="l02703"></a>02703 <span class="comment">     * If input is not set, but mask is set then mask likely results in 0.</span>
<a name="l02704"></a>02704 <span class="comment">     * If input is set and mask is set then assign both.</span>
<a name="l02705"></a>02705 <span class="comment">     */</span>
<a name="l02706"></a>02706     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.ip4src || fs-&gt;m_u.tcp_ip4_spec.ip4src) {
<a name="l02707"></a>02707         input_struct.formatted.src_ip[0] = fs-&gt;h_u.tcp_ip4_spec.ip4src;
<a name="l02708"></a>02708         <span class="keywordflow">if</span> (!fs-&gt;m_u.tcp_ip4_spec.ip4src)
<a name="l02709"></a>02709             input_masks.src_ip_mask[0] = 0xFFFFFFFF;
<a name="l02710"></a>02710         <span class="keywordflow">else</span>
<a name="l02711"></a>02711             input_masks.src_ip_mask[0] =
<a name="l02712"></a>02712                 fs-&gt;m_u.tcp_ip4_spec.ip4src;
<a name="l02713"></a>02713     }
<a name="l02714"></a>02714     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.ip4dst || fs-&gt;m_u.tcp_ip4_spec.ip4dst) {
<a name="l02715"></a>02715         input_struct.formatted.dst_ip[0] = fs-&gt;h_u.tcp_ip4_spec.ip4dst;
<a name="l02716"></a>02716         <span class="keywordflow">if</span> (!fs-&gt;m_u.tcp_ip4_spec.ip4dst)
<a name="l02717"></a>02717             input_masks.dst_ip_mask[0] = 0xFFFFFFFF;
<a name="l02718"></a>02718         <span class="keywordflow">else</span>
<a name="l02719"></a>02719             input_masks.dst_ip_mask[0] =
<a name="l02720"></a>02720                 fs-&gt;m_u.tcp_ip4_spec.ip4dst;
<a name="l02721"></a>02721     }
<a name="l02722"></a>02722     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.psrc || fs-&gt;m_u.tcp_ip4_spec.psrc) {
<a name="l02723"></a>02723         input_struct.formatted.src_port = fs-&gt;h_u.tcp_ip4_spec.psrc;
<a name="l02724"></a>02724         <span class="keywordflow">if</span> (!fs-&gt;m_u.tcp_ip4_spec.psrc)
<a name="l02725"></a>02725             input_masks.src_port_mask = 0xFFFF;
<a name="l02726"></a>02726         <span class="keywordflow">else</span>
<a name="l02727"></a>02727             input_masks.src_port_mask = fs-&gt;m_u.tcp_ip4_spec.psrc;
<a name="l02728"></a>02728     }
<a name="l02729"></a>02729     <span class="keywordflow">if</span> (fs-&gt;h_u.tcp_ip4_spec.pdst || fs-&gt;m_u.tcp_ip4_spec.pdst) {
<a name="l02730"></a>02730         input_struct.formatted.dst_port = fs-&gt;h_u.tcp_ip4_spec.pdst;
<a name="l02731"></a>02731         <span class="keywordflow">if</span> (!fs-&gt;m_u.tcp_ip4_spec.pdst)
<a name="l02732"></a>02732             input_masks.dst_port_mask = 0xFFFF;
<a name="l02733"></a>02733         <span class="keywordflow">else</span>
<a name="l02734"></a>02734             input_masks.dst_port_mask = fs-&gt;m_u.tcp_ip4_spec.pdst;
<a name="l02735"></a>02735     }
<a name="l02736"></a>02736 
<a name="l02737"></a>02737     <span class="comment">/* determine if we need to drop or route the packet */</span>
<a name="l02738"></a>02738     <span class="keywordflow">if</span> (fs-&gt;action == ETHTOOL_RXNTUPLE_ACTION_DROP)
<a name="l02739"></a>02739         target_queue = MAX_RX_QUEUES - 1;
<a name="l02740"></a>02740     <span class="keywordflow">else</span>
<a name="l02741"></a>02741         target_queue = fs-&gt;action;
<a name="l02742"></a>02742 
<a name="l02743"></a>02743     spin_lock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l02744"></a>02744     err = ixgbe_fdir_add_perfect_filter_82599(&amp;adapter-&gt;hw,
<a name="l02745"></a>02745                           &amp;input_struct,
<a name="l02746"></a>02746                           &amp;input_masks, 0,
<a name="l02747"></a>02747                           target_queue);
<a name="l02748"></a>02748     spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l02749"></a>02749 
<a name="l02750"></a>02750     <span class="keywordflow">return</span> err ? -1 : 0;
<a name="l02751"></a>02751 }
<a name="l02752"></a>02752 
<a name="l02753"></a>02753 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l02754"></a>02754 <span class="keyword">static</span> <span class="keyword">struct </span>ethtool_ops ixgbe_ethtool_ops = {
<a name="l02755"></a>02755     .get_settings           = ixgbe_get_settings,
<a name="l02756"></a>02756     .set_settings           = ixgbe_set_settings,
<a name="l02757"></a>02757     .get_drvinfo            = ixgbe_get_drvinfo,
<a name="l02758"></a>02758     .get_regs_len           = ixgbe_get_regs_len,
<a name="l02759"></a>02759     .get_regs               = ixgbe_get_regs,
<a name="l02760"></a>02760     .get_wol                = ixgbe_get_wol,
<a name="l02761"></a>02761     .set_wol                = ixgbe_set_wol,
<a name="l02762"></a>02762     .nway_reset             = ixgbe_nway_reset,
<a name="l02763"></a>02763     .get_link               = ethtool_op_get_link,
<a name="l02764"></a>02764     .get_eeprom_len         = ixgbe_get_eeprom_len,
<a name="l02765"></a>02765     .get_eeprom             = ixgbe_get_eeprom,
<a name="l02766"></a>02766     .set_eeprom             = ixgbe_set_eeprom,
<a name="l02767"></a>02767     .get_ringparam          = ixgbe_get_ringparam,
<a name="l02768"></a>02768     .set_ringparam          = ixgbe_set_ringparam,
<a name="l02769"></a>02769     .get_pauseparam         = ixgbe_get_pauseparam,
<a name="l02770"></a>02770     .set_pauseparam         = ixgbe_set_pauseparam,
<a name="l02771"></a>02771     .get_rx_csum            = ixgbe_get_rx_csum,
<a name="l02772"></a>02772     .set_rx_csum            = ixgbe_set_rx_csum,
<a name="l02773"></a>02773     .get_tx_csum            = ixgbe_get_tx_csum,
<a name="l02774"></a>02774     .set_tx_csum            = ixgbe_set_tx_csum,
<a name="l02775"></a>02775     .get_sg                 = ethtool_op_get_sg,
<a name="l02776"></a>02776     .set_sg                 = ethtool_op_set_sg,
<a name="l02777"></a>02777     .get_msglevel           = ixgbe_get_msglevel,
<a name="l02778"></a>02778     .set_msglevel           = ixgbe_set_msglevel,
<a name="l02779"></a>02779 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l02780"></a>02780 <span class="preprocessor"></span>    .get_tso                = ethtool_op_get_tso,
<a name="l02781"></a>02781     .set_tso                = ixgbe_set_tso,
<a name="l02782"></a>02782 <span class="preprocessor">#endif</span>
<a name="l02783"></a>02783 <span class="preprocessor"></span><span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l02784"></a>02784 <span class="preprocessor"></span>    .self_test_count    = ixgbe_diag_test_count,
<a name="l02785"></a>02785 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l02786"></a>02786     .self_test              = ixgbe_diag_test,
<a name="l02787"></a>02787     .get_strings            = ixgbe_get_strings,
<a name="l02788"></a>02788     .phys_id                = ixgbe_phys_id,
<a name="l02789"></a>02789 <span class="preprocessor">#ifndef HAVE_ETHTOOL_GET_SSET_COUNT</span>
<a name="l02790"></a>02790 <span class="preprocessor"></span>    .get_stats_count    = ixgbe_get_stats_count,
<a name="l02791"></a>02791 <span class="preprocessor">#else </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l02792"></a>02792     .get_sset_count         = ixgbe_get_sset_count,
<a name="l02793"></a>02793 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_ETHTOOL_GET_SSET_COUNT */</span>
<a name="l02794"></a>02794     .get_ethtool_stats      = ixgbe_get_ethtool_stats,
<a name="l02795"></a>02795 <span class="preprocessor">#ifdef HAVE_ETHTOOL_GET_PERM_ADDR</span>
<a name="l02796"></a>02796 <span class="preprocessor"></span>    .get_perm_addr          = ethtool_op_get_perm_addr,
<a name="l02797"></a>02797 <span class="preprocessor">#endif</span>
<a name="l02798"></a>02798 <span class="preprocessor"></span>    .get_coalesce           = ixgbe_get_coalesce,
<a name="l02799"></a>02799     .set_coalesce           = ixgbe_set_coalesce,
<a name="l02800"></a>02800 <span class="preprocessor">#ifdef ETHTOOL_GFLAGS</span>
<a name="l02801"></a>02801 <span class="preprocessor"></span>    .get_flags              = ethtool_op_get_flags,
<a name="l02802"></a>02802     .set_flags              = ixgbe_set_flags,
<a name="l02803"></a>02803 <span class="preprocessor">#endif</span>
<a name="l02804"></a>02804 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l02805"></a>02805 <span class="preprocessor"></span>    .set_rx_ntuple          = ixgbe_set_rx_ntuple,
<a name="l02806"></a>02806 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l02807"></a>02807 };
<a name="l02808"></a>02808 
<a name="l02809"></a>02809 <span class="keywordtype">void</span> ixgbe_set_ethtool_ops(<span class="keyword">struct</span> net_device *netdev)
<a name="l02810"></a>02810 {
<a name="l02811"></a>02811     SET_ETHTOOL_OPS(netdev, &amp;ixgbe_ethtool_ops);
<a name="l02812"></a>02812 }
<a name="l02813"></a>02813 <span class="preprocessor">#endif </span><span class="comment">/* SIOCETHTOOL */</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:27 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
