<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/userland/tcpdump-4.1.1/print-isoclns.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_e1ebd79ad454b9bb4e17c3fdb9c56974.html">userland</a>      </li>
      <li class="navelem"><a class="el" href="dir_9e16ba0a662b9e1dc74f25b43644e518.html">tcpdump-4.1.1</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">print-isoclns.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 1992, 1993, 1994, 1995, 1996</span>
<a name="l00003"></a>00003 <span class="comment"> *  The Regents of the University of California.  All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00006"></a>00006 <span class="comment"> * modification, are permitted provided that: (1) source code distributions</span>
<a name="l00007"></a>00007 <span class="comment"> * retain the above copyright notice and this paragraph in its entirety, (2)</span>
<a name="l00008"></a>00008 <span class="comment"> * distributions including binary code include the above copyright notice and</span>
<a name="l00009"></a>00009 <span class="comment"> * this paragraph in its entirety in the documentation or other materials</span>
<a name="l00010"></a>00010 <span class="comment"> * provided with the distribution, and (3) all advertising materials mentioning</span>
<a name="l00011"></a>00011 <span class="comment"> * features or use of this software display the following acknowledgement:</span>
<a name="l00012"></a>00012 <span class="comment"> * ``This product includes software developed by the University of California,</span>
<a name="l00013"></a>00013 <span class="comment"> * Lawrence Berkeley Laboratory and its contributors.&#39;&#39; Neither the name of</span>
<a name="l00014"></a>00014 <span class="comment"> * the University nor the names of its contributors may be used to endorse</span>
<a name="l00015"></a>00015 <span class="comment"> * or promote products derived from this software without specific prior</span>
<a name="l00016"></a>00016 <span class="comment"> * written permission.</span>
<a name="l00017"></a>00017 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR IMPLIED</span>
<a name="l00018"></a>00018 <span class="comment"> * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF</span>
<a name="l00019"></a>00019 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * Original code by Matt Thomas, Digital Equipment Corporation</span>
<a name="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023"></a>00023 <span class="comment"> * Extensively modified by Hannes Gredler (hannes@juniper.net) for more</span>
<a name="l00024"></a>00024 <span class="comment"> * complete IS-IS &amp; CLNP support.</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#ifndef lint</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> rcsid[] _U_ =
<a name="l00029"></a>00029     <span class="stringliteral">&quot;@(#) $Header: /tcpdump/master/tcpdump/print-isoclns.c,v 1.165 2008-08-16 13:38:15 hannes Exp $ (LBL)&quot;</span>;
<a name="l00030"></a>00030 <span class="preprocessor">#endif</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#include &quot;config.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;tcpdump-stdinc.h&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;interface.h&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;addrtoname.h&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;ethertype.h&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;ether.h&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;nlpid.h&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;extract.h&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;gmpls.h&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;oui.h&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;signature.h&quot;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">/*</span>
<a name="l00052"></a>00052 <span class="comment"> * IS-IS is defined in ISO 10589.  Look there for protocol definitions.</span>
<a name="l00053"></a>00053 <span class="comment"> */</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="preprocessor">#define SYSTEM_ID_LEN   ETHER_ADDR_LEN</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define NODE_ID_LEN     SYSTEM_ID_LEN+1</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#define LSP_ID_LEN      SYSTEM_ID_LEN+2</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00059"></a>00059 <span class="preprocessor">#define ISIS_VERSION    1</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define ESIS_VERSION    1</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_VERSION    1</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="preprocessor">#define ISIS_PDU_TYPE_MASK      0x1F</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define ESIS_PDU_TYPE_MASK      0x1F</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_PDU_TYPE_MASK      0x1F</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_FLAG_MASK          0xE0</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LAN_PRIORITY_MASK  0x7F</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a>00069 <span class="preprocessor">#define ISIS_PDU_L1_LAN_IIH 15</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_L2_LAN_IIH 16</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_PTP_IIH    17</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_L1_LSP         18</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_L2_LSP         20</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_L1_CSNP    24</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_L2_CSNP    25</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_L1_PSNP        26</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PDU_L2_PSNP        27</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_pdu_values[] = {
<a name="l00080"></a>00080     { ISIS_PDU_L1_LAN_IIH,       <span class="stringliteral">&quot;L1 Lan IIH&quot;</span>},
<a name="l00081"></a>00081     { ISIS_PDU_L2_LAN_IIH,       <span class="stringliteral">&quot;L2 Lan IIH&quot;</span>},
<a name="l00082"></a>00082     { ISIS_PDU_PTP_IIH,          <span class="stringliteral">&quot;p2p IIH&quot;</span>},
<a name="l00083"></a>00083     { ISIS_PDU_L1_LSP,           <span class="stringliteral">&quot;L1 LSP&quot;</span>},
<a name="l00084"></a>00084     { ISIS_PDU_L2_LSP,           <span class="stringliteral">&quot;L2 LSP&quot;</span>},
<a name="l00085"></a>00085     { ISIS_PDU_L1_CSNP,          <span class="stringliteral">&quot;L1 CSNP&quot;</span>},
<a name="l00086"></a>00086     { ISIS_PDU_L2_CSNP,          <span class="stringliteral">&quot;L2 CSNP&quot;</span>},
<a name="l00087"></a>00087     { ISIS_PDU_L1_PSNP,          <span class="stringliteral">&quot;L1 PSNP&quot;</span>},
<a name="l00088"></a>00088     { ISIS_PDU_L2_PSNP,          <span class="stringliteral">&quot;L2 PSNP&quot;</span>},
<a name="l00089"></a>00089     { 0, NULL}
<a name="l00090"></a>00090 };
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/*</span>
<a name="l00093"></a>00093 <span class="comment"> * A TLV is a tuple of a type, length and a value and is normally used for</span>
<a name="l00094"></a>00094 <span class="comment"> * encoding information in all sorts of places.  This is an enumeration of</span>
<a name="l00095"></a>00095 <span class="comment"> * the well known types.</span>
<a name="l00096"></a>00096 <span class="comment"> *</span>
<a name="l00097"></a>00097 <span class="comment"> * list taken from rfc3359 plus some memory from veterans ;-)</span>
<a name="l00098"></a>00098 <span class="comment"> */</span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="preprocessor">#define ISIS_TLV_AREA_ADDR           1   </span><span class="comment">/* iso10589 */</span>
<a name="l00101"></a>00101 <span class="preprocessor">#define ISIS_TLV_IS_REACH            2   </span><span class="comment">/* iso10589 */</span>
<a name="l00102"></a>00102 <span class="preprocessor">#define ISIS_TLV_ESNEIGH             3   </span><span class="comment">/* iso10589 */</span>
<a name="l00103"></a>00103 <span class="preprocessor">#define ISIS_TLV_PART_DIS            4   </span><span class="comment">/* iso10589 */</span>
<a name="l00104"></a>00104 <span class="preprocessor">#define ISIS_TLV_PREFIX_NEIGH        5   </span><span class="comment">/* iso10589 */</span>
<a name="l00105"></a>00105 <span class="preprocessor">#define ISIS_TLV_ISNEIGH             6   </span><span class="comment">/* iso10589 */</span>
<a name="l00106"></a>00106 <span class="preprocessor">#define ISIS_TLV_ISNEIGH_VARLEN      7   </span><span class="comment">/* iso10589 */</span>
<a name="l00107"></a>00107 <span class="preprocessor">#define ISIS_TLV_PADDING             8   </span><span class="comment">/* iso10589 */</span>
<a name="l00108"></a>00108 <span class="preprocessor">#define ISIS_TLV_LSP                 9   </span><span class="comment">/* iso10589 */</span>
<a name="l00109"></a>00109 <span class="preprocessor">#define ISIS_TLV_AUTH                10  </span><span class="comment">/* iso10589, rfc3567 */</span>
<a name="l00110"></a>00110 <span class="preprocessor">#define ISIS_TLV_CHECKSUM            12  </span><span class="comment">/* rfc3358 */</span>
<a name="l00111"></a>00111 <span class="preprocessor">#define ISIS_TLV_CHECKSUM_MINLEN 2</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_LSP_BUFFERSIZE      14  </span><span class="comment">/* iso10589 rev2 */</span>
<a name="l00113"></a>00113 <span class="preprocessor">#define ISIS_TLV_LSP_BUFFERSIZE_MINLEN 2</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_EXT_IS_REACH        22  </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00115"></a>00115 <span class="preprocessor">#define ISIS_TLV_IS_ALIAS_ID         24  </span><span class="comment">/* draft-ietf-isis-ext-lsp-frags-02 */</span>
<a name="l00116"></a>00116 <span class="preprocessor">#define ISIS_TLV_DECNET_PHASE4       42</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_LUCENT_PRIVATE      66</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_INT_IP_REACH        128 </span><span class="comment">/* rfc1195, rfc2966 */</span>
<a name="l00119"></a>00119 <span class="preprocessor">#define ISIS_TLV_PROTOCOLS           129 </span><span class="comment">/* rfc1195 */</span>
<a name="l00120"></a>00120 <span class="preprocessor">#define ISIS_TLV_EXT_IP_REACH        130 </span><span class="comment">/* rfc1195, rfc2966 */</span>
<a name="l00121"></a>00121 <span class="preprocessor">#define ISIS_TLV_IDRP_INFO           131 </span><span class="comment">/* rfc1195 */</span>
<a name="l00122"></a>00122 <span class="preprocessor">#define ISIS_TLV_IDRP_INFO_MINLEN      1</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_IPADDR              132 </span><span class="comment">/* rfc1195 */</span>
<a name="l00124"></a>00124 <span class="preprocessor">#define ISIS_TLV_IPAUTH              133 </span><span class="comment">/* rfc1195 */</span>
<a name="l00125"></a>00125 <span class="preprocessor">#define ISIS_TLV_TE_ROUTER_ID        134 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00126"></a>00126 <span class="preprocessor">#define ISIS_TLV_EXTD_IP_REACH       135 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00127"></a>00127 <span class="preprocessor">#define ISIS_TLV_HOSTNAME            137 </span><span class="comment">/* rfc2763 */</span>
<a name="l00128"></a>00128 <span class="preprocessor">#define ISIS_TLV_SHARED_RISK_GROUP   138 </span><span class="comment">/* draft-ietf-isis-gmpls-extensions */</span>
<a name="l00129"></a>00129 <span class="preprocessor">#define ISIS_TLV_NORTEL_PRIVATE1     176</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_NORTEL_PRIVATE2     177</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_RESTART_SIGNALING   211 </span><span class="comment">/* rfc3847 */</span>
<a name="l00132"></a>00132 <span class="preprocessor">#define ISIS_TLV_RESTART_SIGNALING_FLAGLEN 1</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN 2</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_MT_IS_REACH         222 </span><span class="comment">/* draft-ietf-isis-wg-multi-topology-05 */</span>
<a name="l00135"></a>00135 <span class="preprocessor">#define ISIS_TLV_MT_SUPPORTED        229 </span><span class="comment">/* draft-ietf-isis-wg-multi-topology-05 */</span>
<a name="l00136"></a>00136 <span class="preprocessor">#define ISIS_TLV_MT_SUPPORTED_MINLEN 2</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_IP6ADDR             232 </span><span class="comment">/* draft-ietf-isis-ipv6-02 */</span>
<a name="l00138"></a>00138 <span class="preprocessor">#define ISIS_TLV_MT_IP_REACH         235 </span><span class="comment">/* draft-ietf-isis-wg-multi-topology-05 */</span>
<a name="l00139"></a>00139 <span class="preprocessor">#define ISIS_TLV_IP6_REACH           236 </span><span class="comment">/* draft-ietf-isis-ipv6-02 */</span>
<a name="l00140"></a>00140 <span class="preprocessor">#define ISIS_TLV_MT_IP6_REACH        237 </span><span class="comment">/* draft-ietf-isis-wg-multi-topology-05 */</span>
<a name="l00141"></a>00141 <span class="preprocessor">#define ISIS_TLV_PTP_ADJ             240 </span><span class="comment">/* rfc3373 */</span>
<a name="l00142"></a>00142 <span class="preprocessor">#define ISIS_TLV_IIH_SEQNR           241 </span><span class="comment">/* draft-shen-isis-iih-sequence-00 */</span>
<a name="l00143"></a>00143 <span class="preprocessor">#define ISIS_TLV_IIH_SEQNR_MINLEN 4</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_TLV_VENDOR_PRIVATE      250 </span><span class="comment">/* draft-ietf-isis-experimental-tlv-01 */</span>
<a name="l00145"></a>00145 <span class="preprocessor">#define ISIS_TLV_VENDOR_PRIVATE_MINLEN 3</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span>
<a name="l00147"></a>00147 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_tlv_values[] = {
<a name="l00148"></a>00148     { ISIS_TLV_AREA_ADDR,      <span class="stringliteral">&quot;Area address(es)&quot;</span>},
<a name="l00149"></a>00149     { ISIS_TLV_IS_REACH,           <span class="stringliteral">&quot;IS Reachability&quot;</span>},
<a name="l00150"></a>00150     { ISIS_TLV_ESNEIGH,            <span class="stringliteral">&quot;ES Neighbor(s)&quot;</span>},
<a name="l00151"></a>00151     { ISIS_TLV_PART_DIS,           <span class="stringliteral">&quot;Partition DIS&quot;</span>},
<a name="l00152"></a>00152     { ISIS_TLV_PREFIX_NEIGH,       <span class="stringliteral">&quot;Prefix Neighbors&quot;</span>},
<a name="l00153"></a>00153     { ISIS_TLV_ISNEIGH,            <span class="stringliteral">&quot;IS Neighbor(s)&quot;</span>},
<a name="l00154"></a>00154     { ISIS_TLV_ISNEIGH_VARLEN,     <span class="stringliteral">&quot;IS Neighbor(s) (variable length)&quot;</span>},
<a name="l00155"></a>00155     { ISIS_TLV_PADDING,            <span class="stringliteral">&quot;Padding&quot;</span>},
<a name="l00156"></a>00156     { ISIS_TLV_LSP,                <span class="stringliteral">&quot;LSP entries&quot;</span>},
<a name="l00157"></a>00157     { ISIS_TLV_AUTH,               <span class="stringliteral">&quot;Authentication&quot;</span>},
<a name="l00158"></a>00158     { ISIS_TLV_CHECKSUM,           <span class="stringliteral">&quot;Checksum&quot;</span>},
<a name="l00159"></a>00159     { ISIS_TLV_LSP_BUFFERSIZE,     <span class="stringliteral">&quot;LSP Buffersize&quot;</span>},
<a name="l00160"></a>00160     { ISIS_TLV_EXT_IS_REACH,       <span class="stringliteral">&quot;Extended IS Reachability&quot;</span>},
<a name="l00161"></a>00161     { ISIS_TLV_IS_ALIAS_ID,        <span class="stringliteral">&quot;IS Alias ID&quot;</span>},
<a name="l00162"></a>00162     { ISIS_TLV_DECNET_PHASE4,      <span class="stringliteral">&quot;DECnet Phase IV&quot;</span>},
<a name="l00163"></a>00163     { ISIS_TLV_LUCENT_PRIVATE,     <span class="stringliteral">&quot;Lucent Proprietary&quot;</span>},
<a name="l00164"></a>00164     { ISIS_TLV_INT_IP_REACH,       <span class="stringliteral">&quot;IPv4 Internal Reachability&quot;</span>},
<a name="l00165"></a>00165     { ISIS_TLV_PROTOCOLS,          <span class="stringliteral">&quot;Protocols supported&quot;</span>},
<a name="l00166"></a>00166     { ISIS_TLV_EXT_IP_REACH,       <span class="stringliteral">&quot;IPv4 External Reachability&quot;</span>},
<a name="l00167"></a>00167     { ISIS_TLV_IDRP_INFO,          <span class="stringliteral">&quot;Inter-Domain Information Type&quot;</span>},
<a name="l00168"></a>00168     { ISIS_TLV_IPADDR,             <span class="stringliteral">&quot;IPv4 Interface address(es)&quot;</span>},
<a name="l00169"></a>00169     { ISIS_TLV_IPAUTH,             <span class="stringliteral">&quot;IPv4 authentication (deprecated)&quot;</span>},
<a name="l00170"></a>00170     { ISIS_TLV_TE_ROUTER_ID,       <span class="stringliteral">&quot;Traffic Engineering Router ID&quot;</span>},
<a name="l00171"></a>00171     { ISIS_TLV_EXTD_IP_REACH,      <span class="stringliteral">&quot;Extended IPv4 Reachability&quot;</span>},
<a name="l00172"></a>00172     { ISIS_TLV_SHARED_RISK_GROUP,  <span class="stringliteral">&quot;Shared Risk Link Group&quot;</span>},
<a name="l00173"></a>00173     { ISIS_TLV_NORTEL_PRIVATE1,    <span class="stringliteral">&quot;Nortel Proprietary&quot;</span>},
<a name="l00174"></a>00174     { ISIS_TLV_NORTEL_PRIVATE2,    <span class="stringliteral">&quot;Nortel Proprietary&quot;</span>},
<a name="l00175"></a>00175     { ISIS_TLV_HOSTNAME,           <span class="stringliteral">&quot;Hostname&quot;</span>},
<a name="l00176"></a>00176     { ISIS_TLV_RESTART_SIGNALING,  <span class="stringliteral">&quot;Restart Signaling&quot;</span>},
<a name="l00177"></a>00177     { ISIS_TLV_MT_IS_REACH,        <span class="stringliteral">&quot;Multi Topology IS Reachability&quot;</span>},
<a name="l00178"></a>00178     { ISIS_TLV_MT_SUPPORTED,       <span class="stringliteral">&quot;Multi Topology&quot;</span>},
<a name="l00179"></a>00179     { ISIS_TLV_IP6ADDR,            <span class="stringliteral">&quot;IPv6 Interface address(es)&quot;</span>},
<a name="l00180"></a>00180     { ISIS_TLV_MT_IP_REACH,        <span class="stringliteral">&quot;Multi-Topology IPv4 Reachability&quot;</span>},
<a name="l00181"></a>00181     { ISIS_TLV_IP6_REACH,          <span class="stringliteral">&quot;IPv6 reachability&quot;</span>},
<a name="l00182"></a>00182     { ISIS_TLV_MT_IP6_REACH,       <span class="stringliteral">&quot;Multi-Topology IP6 Reachability&quot;</span>},
<a name="l00183"></a>00183     { ISIS_TLV_PTP_ADJ,            <span class="stringliteral">&quot;Point-to-point Adjacency State&quot;</span>},
<a name="l00184"></a>00184     { ISIS_TLV_IIH_SEQNR,          <span class="stringliteral">&quot;Hello PDU Sequence Number&quot;</span>},
<a name="l00185"></a>00185     { ISIS_TLV_VENDOR_PRIVATE,     <span class="stringliteral">&quot;Vendor Private&quot;</span>},
<a name="l00186"></a>00186     { 0, NULL }
<a name="l00187"></a>00187 };
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="preprocessor">#define ESIS_OPTION_PROTOCOLS        129</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="preprocessor">#define ESIS_OPTION_QOS_MAINTENANCE  195 </span><span class="comment">/* iso9542 */</span>
<a name="l00191"></a>00191 <span class="preprocessor">#define ESIS_OPTION_SECURITY         197 </span><span class="comment">/* iso9542 */</span>
<a name="l00192"></a>00192 <span class="preprocessor">#define ESIS_OPTION_ES_CONF_TIME     198 </span><span class="comment">/* iso9542 */</span>
<a name="l00193"></a>00193 <span class="preprocessor">#define ESIS_OPTION_PRIORITY         205 </span><span class="comment">/* iso9542 */</span>
<a name="l00194"></a>00194 <span class="preprocessor">#define ESIS_OPTION_ADDRESS_MASK     225 </span><span class="comment">/* iso9542 */</span>
<a name="l00195"></a>00195 <span class="preprocessor">#define ESIS_OPTION_SNPA_MASK        226 </span><span class="comment">/* iso9542 */</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> esis_option_values[] = {
<a name="l00198"></a>00198     { ESIS_OPTION_PROTOCOLS,       <span class="stringliteral">&quot;Protocols supported&quot;</span>},
<a name="l00199"></a>00199     { ESIS_OPTION_QOS_MAINTENANCE, <span class="stringliteral">&quot;QoS Maintenance&quot;</span> },
<a name="l00200"></a>00200     { ESIS_OPTION_SECURITY,        <span class="stringliteral">&quot;Security&quot;</span> },
<a name="l00201"></a>00201     { ESIS_OPTION_ES_CONF_TIME,    <span class="stringliteral">&quot;ES Configuration Time&quot;</span> },
<a name="l00202"></a>00202     { ESIS_OPTION_PRIORITY,        <span class="stringliteral">&quot;Priority&quot;</span> },
<a name="l00203"></a>00203     { ESIS_OPTION_ADDRESS_MASK,    <span class="stringliteral">&quot;Addressk Mask&quot;</span> },
<a name="l00204"></a>00204     { ESIS_OPTION_SNPA_MASK,       <span class="stringliteral">&quot;SNPA Mask&quot;</span> },
<a name="l00205"></a>00205     { 0, NULL }
<a name="l00206"></a>00206 };
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="preprocessor">#define CLNP_OPTION_DISCARD_REASON   193</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_OPTION_QOS_MAINTENANCE  195 </span><span class="comment">/* iso8473 */</span>
<a name="l00210"></a>00210 <span class="preprocessor">#define CLNP_OPTION_SECURITY         197 </span><span class="comment">/* iso8473 */</span>
<a name="l00211"></a>00211 <span class="preprocessor">#define CLNP_OPTION_SOURCE_ROUTING   200 </span><span class="comment">/* iso8473 */</span>
<a name="l00212"></a>00212 <span class="preprocessor">#define CLNP_OPTION_ROUTE_RECORDING  203 </span><span class="comment">/* iso8473 */</span>
<a name="l00213"></a>00213 <span class="preprocessor">#define CLNP_OPTION_PADDING          204 </span><span class="comment">/* iso8473 */</span>
<a name="l00214"></a>00214 <span class="preprocessor">#define CLNP_OPTION_PRIORITY         205 </span><span class="comment">/* iso8473 */</span>
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_values[] = {
<a name="l00217"></a>00217     { CLNP_OPTION_DISCARD_REASON,  <span class="stringliteral">&quot;Discard Reason&quot;</span>},
<a name="l00218"></a>00218     { CLNP_OPTION_PRIORITY,        <span class="stringliteral">&quot;Priority&quot;</span>},
<a name="l00219"></a>00219     { CLNP_OPTION_QOS_MAINTENANCE, <span class="stringliteral">&quot;QoS Maintenance&quot;</span>},
<a name="l00220"></a>00220     { CLNP_OPTION_SECURITY, <span class="stringliteral">&quot;Security&quot;</span>},
<a name="l00221"></a>00221     { CLNP_OPTION_SOURCE_ROUTING, <span class="stringliteral">&quot;Source Routing&quot;</span>},
<a name="l00222"></a>00222     { CLNP_OPTION_ROUTE_RECORDING, <span class="stringliteral">&quot;Route Recording&quot;</span>},
<a name="l00223"></a>00223     { CLNP_OPTION_PADDING, <span class="stringliteral">&quot;Padding&quot;</span>},
<a name="l00224"></a>00224     { 0, NULL }
<a name="l00225"></a>00225 };
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_rfd_class_values[] = {
<a name="l00228"></a>00228     { 0x0, <span class="stringliteral">&quot;General&quot;</span>},
<a name="l00229"></a>00229     { 0x8, <span class="stringliteral">&quot;Address&quot;</span>},
<a name="l00230"></a>00230     { 0x9, <span class="stringliteral">&quot;Source Routeing&quot;</span>},
<a name="l00231"></a>00231     { 0xa, <span class="stringliteral">&quot;Lifetime&quot;</span>},
<a name="l00232"></a>00232     { 0xb, <span class="stringliteral">&quot;PDU Discarded&quot;</span>},
<a name="l00233"></a>00233     { 0xc, <span class="stringliteral">&quot;Reassembly&quot;</span>},
<a name="l00234"></a>00234     { 0, NULL }
<a name="l00235"></a>00235 };
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_rfd_general_values[] = {
<a name="l00238"></a>00238     { 0x0, <span class="stringliteral">&quot;Reason not specified&quot;</span>},
<a name="l00239"></a>00239     { 0x1, <span class="stringliteral">&quot;Protocol procedure error&quot;</span>},
<a name="l00240"></a>00240     { 0x2, <span class="stringliteral">&quot;Incorrect checksum&quot;</span>},
<a name="l00241"></a>00241     { 0x3, <span class="stringliteral">&quot;PDU discarded due to congestion&quot;</span>},
<a name="l00242"></a>00242     { 0x4, <span class="stringliteral">&quot;Header syntax error (cannot be parsed)&quot;</span>},
<a name="l00243"></a>00243     { 0x5, <span class="stringliteral">&quot;Segmentation needed but not permitted&quot;</span>},
<a name="l00244"></a>00244     { 0x6, <span class="stringliteral">&quot;Incomplete PDU received&quot;</span>},
<a name="l00245"></a>00245     { 0x7, <span class="stringliteral">&quot;Duplicate option&quot;</span>},
<a name="l00246"></a>00246     { 0, NULL }
<a name="l00247"></a>00247 };
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_rfd_address_values[] = {
<a name="l00250"></a>00250     { 0x0, <span class="stringliteral">&quot;Destination address unreachable&quot;</span>},
<a name="l00251"></a>00251     { 0x1, <span class="stringliteral">&quot;Destination address unknown&quot;</span>},
<a name="l00252"></a>00252     { 0, NULL }
<a name="l00253"></a>00253 };
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_rfd_source_routeing_values[] = {
<a name="l00256"></a>00256     { 0x0, <span class="stringliteral">&quot;Unspecified source routeing error&quot;</span>},
<a name="l00257"></a>00257     { 0x1, <span class="stringliteral">&quot;Syntax error in source routeing field&quot;</span>},
<a name="l00258"></a>00258     { 0x2, <span class="stringliteral">&quot;Unknown address in source routeing field&quot;</span>},
<a name="l00259"></a>00259     { 0x3, <span class="stringliteral">&quot;Path not acceptable&quot;</span>},
<a name="l00260"></a>00260     { 0, NULL }
<a name="l00261"></a>00261 };
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_rfd_lifetime_values[] = {
<a name="l00264"></a>00264     { 0x0, <span class="stringliteral">&quot;Lifetime expired while data unit in transit&quot;</span>},
<a name="l00265"></a>00265     { 0x1, <span class="stringliteral">&quot;Lifetime expired during reassembly&quot;</span>},
<a name="l00266"></a>00266     { 0, NULL }
<a name="l00267"></a>00267 };
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_rfd_pdu_discard_values[] = {
<a name="l00270"></a>00270     { 0x0, <span class="stringliteral">&quot;Unsupported option not specified&quot;</span>},
<a name="l00271"></a>00271     { 0x1, <span class="stringliteral">&quot;Unsupported protocol version&quot;</span>},
<a name="l00272"></a>00272     { 0x2, <span class="stringliteral">&quot;Unsupported security option&quot;</span>},
<a name="l00273"></a>00273     { 0x3, <span class="stringliteral">&quot;Unsupported source routeing option&quot;</span>},
<a name="l00274"></a>00274     { 0x4, <span class="stringliteral">&quot;Unsupported recording of route option&quot;</span>},
<a name="l00275"></a>00275     { 0, NULL }
<a name="l00276"></a>00276 };
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_rfd_reassembly_values[] = {
<a name="l00279"></a>00279     { 0x0, <span class="stringliteral">&quot;Reassembly interference&quot;</span>},
<a name="l00280"></a>00280     { 0, NULL }
<a name="l00281"></a>00281 };
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="comment">/* array of 16 error-classes */</span>
<a name="l00284"></a>00284 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> *clnp_option_rfd_error_class[] = {
<a name="l00285"></a>00285     clnp_option_rfd_general_values,
<a name="l00286"></a>00286     NULL,
<a name="l00287"></a>00287     NULL,
<a name="l00288"></a>00288     NULL,
<a name="l00289"></a>00289     NULL,
<a name="l00290"></a>00290     NULL,
<a name="l00291"></a>00291     NULL,
<a name="l00292"></a>00292     NULL,
<a name="l00293"></a>00293     clnp_option_rfd_address_values,
<a name="l00294"></a>00294     clnp_option_rfd_source_routeing_values,
<a name="l00295"></a>00295     clnp_option_rfd_lifetime_values,
<a name="l00296"></a>00296     clnp_option_rfd_pdu_discard_values,
<a name="l00297"></a>00297     clnp_option_rfd_reassembly_values,
<a name="l00298"></a>00298     NULL,
<a name="l00299"></a>00299     NULL,
<a name="l00300"></a>00300     NULL
<a name="l00301"></a>00301 };
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="preprocessor">#define CLNP_OPTION_OPTION_QOS_MASK 0x3f</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_OPTION_SCOPE_MASK      0xc0</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_OPTION_SCOPE_SA_SPEC   0x40</span>
<a name="l00306"></a>00306 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_OPTION_SCOPE_DA_SPEC   0x80</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_OPTION_SCOPE_GLOBAL    0xc0</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span>
<a name="l00309"></a>00309 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_scope_values[] = {
<a name="l00310"></a>00310     { CLNP_OPTION_SCOPE_SA_SPEC, <span class="stringliteral">&quot;Source Address Specific&quot;</span>},
<a name="l00311"></a>00311     { CLNP_OPTION_SCOPE_DA_SPEC, <span class="stringliteral">&quot;Destination Address Specific&quot;</span>},
<a name="l00312"></a>00312     { CLNP_OPTION_SCOPE_GLOBAL, <span class="stringliteral">&quot;Globally unique&quot;</span>},
<a name="l00313"></a>00313     { 0, NULL }
<a name="l00314"></a>00314 };
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_sr_rr_values[] = {
<a name="l00317"></a>00317     { 0x0, <span class="stringliteral">&quot;partial&quot;</span>},
<a name="l00318"></a>00318     { 0x1, <span class="stringliteral">&quot;complete&quot;</span>},
<a name="l00319"></a>00319     { 0, NULL }
<a name="l00320"></a>00320 };
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_sr_rr_string_values[] = {
<a name="l00323"></a>00323     { CLNP_OPTION_SOURCE_ROUTING, <span class="stringliteral">&quot;source routing&quot;</span>},
<a name="l00324"></a>00324     { CLNP_OPTION_ROUTE_RECORDING, <span class="stringliteral">&quot;recording of route in progress&quot;</span>},
<a name="l00325"></a>00325     { 0, NULL }
<a name="l00326"></a>00326 };
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_option_qos_global_values[] = {
<a name="l00329"></a>00329     { 0x20, <span class="stringliteral">&quot;reserved&quot;</span>},
<a name="l00330"></a>00330     { 0x10, <span class="stringliteral">&quot;sequencing vs. delay&quot;</span>},
<a name="l00331"></a>00331     { 0x08, <span class="stringliteral">&quot;congested&quot;</span>},
<a name="l00332"></a>00332     { 0x04, <span class="stringliteral">&quot;delay vs. cost&quot;</span>},
<a name="l00333"></a>00333     { 0x02, <span class="stringliteral">&quot;error vs. delay&quot;</span>},
<a name="l00334"></a>00334     { 0x01, <span class="stringliteral">&quot;error vs. cost&quot;</span>},
<a name="l00335"></a>00335     { 0, NULL }
<a name="l00336"></a>00336 };
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP           3 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00339"></a>00339 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID  4 </span><span class="comment">/* rfc4205 */</span>
<a name="l00340"></a>00340 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID        5 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00341"></a>00341 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR        6 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00342"></a>00342 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR    8 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00343"></a>00343 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW           9 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00344"></a>00344 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW        10 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00345"></a>00345 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW        11 </span><span class="comment">/* rfc4124 */</span>
<a name="l00346"></a>00346 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD   12 </span><span class="comment">/* draft-ietf-tewg-diff-te-proto-06 */</span>
<a name="l00347"></a>00347 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC            18 </span><span class="comment">/* draft-ietf-isis-traffic-05 */</span>
<a name="l00348"></a>00348 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE       19 </span><span class="comment">/* draft-ietf-isis-link-attr-01 */</span>
<a name="l00349"></a>00349 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE 20 </span><span class="comment">/* rfc4205 */</span>
<a name="l00350"></a>00350 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR    21 </span><span class="comment">/* rfc4205 */</span>
<a name="l00351"></a>00351 <span class="preprocessor">#define ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS       22 </span><span class="comment">/* rfc4124 */</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_ext_is_reach_subtlv_values[] = {
<a name="l00354"></a>00354     { ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP,            <span class="stringliteral">&quot;Administrative groups&quot;</span> },
<a name="l00355"></a>00355     { ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID,   <span class="stringliteral">&quot;Link Local/Remote Identifier&quot;</span> },
<a name="l00356"></a>00356     { ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID,         <span class="stringliteral">&quot;Link Remote Identifier&quot;</span> },
<a name="l00357"></a>00357     { ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR,         <span class="stringliteral">&quot;IPv4 interface address&quot;</span> },
<a name="l00358"></a>00358     { ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR,     <span class="stringliteral">&quot;IPv4 neighbor address&quot;</span> },
<a name="l00359"></a>00359     { ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW,            <span class="stringliteral">&quot;Maximum link bandwidth&quot;</span> },
<a name="l00360"></a>00360     { ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW,          <span class="stringliteral">&quot;Reservable link bandwidth&quot;</span> },
<a name="l00361"></a>00361     { ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW,          <span class="stringliteral">&quot;Unreserved bandwidth&quot;</span> },
<a name="l00362"></a>00362     { ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC,              <span class="stringliteral">&quot;Traffic Engineering Metric&quot;</span> },
<a name="l00363"></a>00363     { ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE,         <span class="stringliteral">&quot;Link Attribute&quot;</span> },
<a name="l00364"></a>00364     { ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE,   <span class="stringliteral">&quot;Link Protection Type&quot;</span> },
<a name="l00365"></a>00365     { ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR,      <span class="stringliteral">&quot;Interface Switching Capability&quot;</span> },
<a name="l00366"></a>00366     { ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD,     <span class="stringliteral">&quot;Bandwidth Constraints (old)&quot;</span> },
<a name="l00367"></a>00367     { ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS,         <span class="stringliteral">&quot;Bandwidth Constraints&quot;</span> },
<a name="l00368"></a>00368     { 250,                                             <span class="stringliteral">&quot;Reserved for cisco specific extensions&quot;</span> },
<a name="l00369"></a>00369     { 251,                                             <span class="stringliteral">&quot;Reserved for cisco specific extensions&quot;</span> },
<a name="l00370"></a>00370     { 252,                                             <span class="stringliteral">&quot;Reserved for cisco specific extensions&quot;</span> },
<a name="l00371"></a>00371     { 253,                                             <span class="stringliteral">&quot;Reserved for cisco specific extensions&quot;</span> },
<a name="l00372"></a>00372     { 254,                                             <span class="stringliteral">&quot;Reserved for cisco specific extensions&quot;</span> },
<a name="l00373"></a>00373     { 255,                                             <span class="stringliteral">&quot;Reserved for future expansion&quot;</span> },
<a name="l00374"></a>00374     { 0, NULL }
<a name="l00375"></a>00375 };
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="preprocessor">#define ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG32          1 </span><span class="comment">/* draft-ietf-isis-admin-tags-01 */</span>
<a name="l00378"></a>00378 <span class="preprocessor">#define ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG64          2 </span><span class="comment">/* draft-ietf-isis-admin-tags-01 */</span>
<a name="l00379"></a>00379 <span class="preprocessor">#define ISIS_SUBTLV_EXTD_IP_REACH_MGMT_PREFIX_COLOR  117 </span><span class="comment">/* draft-ietf-isis-wg-multi-topology-05 */</span>
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_ext_ip_reach_subtlv_values[] = {
<a name="l00382"></a>00382     { ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG32,           <span class="stringliteral">&quot;32-Bit Administrative tag&quot;</span> },
<a name="l00383"></a>00383     { ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG64,           <span class="stringliteral">&quot;64-Bit Administrative tag&quot;</span> },
<a name="l00384"></a>00384     { ISIS_SUBTLV_EXTD_IP_REACH_MGMT_PREFIX_COLOR,     <span class="stringliteral">&quot;Management Prefix Color&quot;</span> },
<a name="l00385"></a>00385     { 0, NULL }
<a name="l00386"></a>00386 };
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_subtlv_link_attribute_values[] = {
<a name="l00389"></a>00389     { 0x01, <span class="stringliteral">&quot;Local Protection Available&quot;</span> },
<a name="l00390"></a>00390     { 0x02, <span class="stringliteral">&quot;Link excluded from local protection path&quot;</span> },
<a name="l00391"></a>00391     { 0x04, <span class="stringliteral">&quot;Local maintenance required&quot;</span>},
<a name="l00392"></a>00392     { 0, NULL }
<a name="l00393"></a>00393 };
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="preprocessor">#define ISIS_SUBTLV_AUTH_SIMPLE        1</span>
<a name="l00396"></a>00396 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_SUBTLV_AUTH_MD5          54</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_SUBTLV_AUTH_MD5_LEN      16</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_SUBTLV_AUTH_PRIVATE     255</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>
<a name="l00400"></a>00400 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_subtlv_auth_values[] = {
<a name="l00401"></a>00401     { ISIS_SUBTLV_AUTH_SIMPLE,  <span class="stringliteral">&quot;simple text password&quot;</span>},
<a name="l00402"></a>00402     { ISIS_SUBTLV_AUTH_MD5, <span class="stringliteral">&quot;HMAC-MD5 password&quot;</span>},
<a name="l00403"></a>00403     { ISIS_SUBTLV_AUTH_PRIVATE, <span class="stringliteral">&quot;Routing Domain private password&quot;</span>},
<a name="l00404"></a>00404     { 0, NULL }
<a name="l00405"></a>00405 };
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="preprocessor">#define ISIS_SUBTLV_IDRP_RES           0</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_SUBTLV_IDRP_LOCAL         1</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_SUBTLV_IDRP_ASN           2</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span>
<a name="l00411"></a>00411 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_subtlv_idrp_values[] = {
<a name="l00412"></a>00412     { ISIS_SUBTLV_IDRP_RES,         <span class="stringliteral">&quot;Reserved&quot;</span>},
<a name="l00413"></a>00413     { ISIS_SUBTLV_IDRP_LOCAL,       <span class="stringliteral">&quot;Routing-Domain Specific&quot;</span>},
<a name="l00414"></a>00414     { ISIS_SUBTLV_IDRP_ASN,         <span class="stringliteral">&quot;AS Number Tag&quot;</span>},
<a name="l00415"></a>00415     { 0, NULL}
<a name="l00416"></a>00416 };
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="preprocessor">#define CLNP_SEGMENT_PART  0x80</span>
<a name="l00419"></a>00419 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_MORE_SEGMENTS 0x40</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_REQUEST_ER    0x20</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>
<a name="l00422"></a>00422 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_flag_values[] = {
<a name="l00423"></a>00423     { CLNP_SEGMENT_PART, <span class="stringliteral">&quot;Segmentation permitted&quot;</span>},
<a name="l00424"></a>00424     { CLNP_MORE_SEGMENTS, <span class="stringliteral">&quot;more Segments&quot;</span>},
<a name="l00425"></a>00425     { CLNP_REQUEST_ER, <span class="stringliteral">&quot;request Error Report&quot;</span>},
<a name="l00426"></a>00426     { 0, NULL}
<a name="l00427"></a>00427 };
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="preprocessor">#define ISIS_MASK_LSP_OL_BIT(x)            ((x)&amp;0x4)</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_LSP_ISTYPE_BITS(x)       ((x)&amp;0x3)</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_LSP_PARTITION_BIT(x)     ((x)&amp;0x80)</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_LSP_ATT_BITS(x)          ((x)&amp;0x78)</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_LSP_ATT_ERROR_BIT(x)     ((x)&amp;0x40)</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_LSP_ATT_EXPENSE_BIT(x)   ((x)&amp;0x20)</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_LSP_ATT_DELAY_BIT(x)     ((x)&amp;0x10)</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_LSP_ATT_DEFAULT_BIT(x)   ((x)&amp;0x8)</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span>
<a name="l00438"></a>00438 <span class="preprocessor">#define ISIS_MASK_MTID(x)                  ((x)&amp;0x0fff)</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_MTFLAGS(x)               ((x)&amp;0xf000)</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>
<a name="l00441"></a>00441 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_mt_flag_values[] = {
<a name="l00442"></a>00442     { 0x4000,                  <span class="stringliteral">&quot;sub-TLVs present&quot;</span>},
<a name="l00443"></a>00443     { 0x8000,                  <span class="stringliteral">&quot;ATT bit set&quot;</span>},
<a name="l00444"></a>00444     { 0, NULL}
<a name="l00445"></a>00445 };
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="preprocessor">#define ISIS_MASK_TLV_EXTD_IP_UPDOWN(x)     ((x)&amp;0x80)</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_TLV_EXTD_IP_SUBTLV(x)     ((x)&amp;0x40)</span>
<a name="l00449"></a>00449 <span class="preprocessor"></span>
<a name="l00450"></a>00450 <span class="preprocessor">#define ISIS_MASK_TLV_EXTD_IP6_IE(x)        ((x)&amp;0x40)</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_MASK_TLV_EXTD_IP6_SUBTLV(x)    ((x)&amp;0x20)</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>
<a name="l00453"></a>00453 <span class="preprocessor">#define ISIS_LSP_TLV_METRIC_SUPPORTED(x)   ((x)&amp;0x80)</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LSP_TLV_METRIC_IE(x)          ((x)&amp;0x40)</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LSP_TLV_METRIC_UPDOWN(x)      ((x)&amp;0x80)</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LSP_TLV_METRIC_VALUE(x)       ((x)&amp;0x3f)</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>
<a name="l00458"></a>00458 <span class="preprocessor">#define ISIS_MASK_TLV_SHARED_RISK_GROUP(x) ((x)&amp;0x1)</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>
<a name="l00460"></a>00460 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_mt_values[] = {
<a name="l00461"></a>00461     { 0,    <span class="stringliteral">&quot;IPv4 unicast&quot;</span>},
<a name="l00462"></a>00462     { 1,    <span class="stringliteral">&quot;In-Band Management&quot;</span>},
<a name="l00463"></a>00463     { 2,    <span class="stringliteral">&quot;IPv6 unicast&quot;</span>},
<a name="l00464"></a>00464     { 3,    <span class="stringliteral">&quot;Multicast&quot;</span>},
<a name="l00465"></a>00465     { 4095, <span class="stringliteral">&quot;Development, Experimental or Proprietary&quot;</span>},
<a name="l00466"></a>00466     { 0, NULL }
<a name="l00467"></a>00467 };
<a name="l00468"></a>00468 
<a name="l00469"></a>00469 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_iih_circuit_type_values[] = {
<a name="l00470"></a>00470     { 1,    <span class="stringliteral">&quot;Level 1 only&quot;</span>},
<a name="l00471"></a>00471     { 2,    <span class="stringliteral">&quot;Level 2 only&quot;</span>},
<a name="l00472"></a>00472     { 3,    <span class="stringliteral">&quot;Level 1, Level 2&quot;</span>},
<a name="l00473"></a>00473     { 0, NULL}
<a name="l00474"></a>00474 };
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="preprocessor">#define ISIS_LSP_TYPE_UNUSED0   0</span>
<a name="l00477"></a>00477 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LSP_TYPE_LEVEL_1   1</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LSP_TYPE_UNUSED2   2</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LSP_TYPE_LEVEL_2   3</span>
<a name="l00480"></a>00480 <span class="preprocessor"></span>
<a name="l00481"></a>00481 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_lsp_istype_values[] = {
<a name="l00482"></a>00482     { ISIS_LSP_TYPE_UNUSED0,    <span class="stringliteral">&quot;Unused 0x0 (invalid)&quot;</span>},
<a name="l00483"></a>00483     { ISIS_LSP_TYPE_LEVEL_1,    <span class="stringliteral">&quot;L1 IS&quot;</span>},
<a name="l00484"></a>00484     { ISIS_LSP_TYPE_UNUSED2,    <span class="stringliteral">&quot;Unused 0x2 (invalid)&quot;</span>},
<a name="l00485"></a>00485     { ISIS_LSP_TYPE_LEVEL_2,    <span class="stringliteral">&quot;L2 IS&quot;</span>},
<a name="l00486"></a>00486     { 0, NULL }
<a name="l00487"></a>00487 };
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="comment">/*</span>
<a name="l00490"></a>00490 <span class="comment"> * Katz&#39;s point to point adjacency TLV uses codes to tell us the state of</span>
<a name="l00491"></a>00491 <span class="comment"> * the remote adjacency.  Enumerate them.</span>
<a name="l00492"></a>00492 <span class="comment"> */</span>
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="preprocessor">#define ISIS_PTP_ADJ_UP   0</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PTP_ADJ_INIT 1</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PTP_ADJ_DOWN 2</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span>
<a name="l00498"></a>00498 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_ptp_adjancey_values[] = {
<a name="l00499"></a>00499     { ISIS_PTP_ADJ_UP,    <span class="stringliteral">&quot;Up&quot;</span> },
<a name="l00500"></a>00500     { ISIS_PTP_ADJ_INIT,  <span class="stringliteral">&quot;Initializing&quot;</span> },
<a name="l00501"></a>00501     { ISIS_PTP_ADJ_DOWN,  <span class="stringliteral">&quot;Down&quot;</span> },
<a name="l00502"></a>00502     { 0, NULL}
<a name="l00503"></a>00503 };
<a name="l00504"></a>00504 
<a name="l00505"></a><a class="code" href="structisis__tlv__ptp__adj.html">00505</a> <span class="keyword">struct </span><a class="code" href="structisis__tlv__ptp__adj.html">isis_tlv_ptp_adj</a> {
<a name="l00506"></a>00506     u_int8_t adjacency_state;
<a name="l00507"></a>00507     u_int8_t extd_local_circuit_id[4];
<a name="l00508"></a>00508     u_int8_t neighbor_sysid[SYSTEM_ID_LEN];
<a name="l00509"></a>00509     u_int8_t neighbor_extd_local_circuit_id[4];
<a name="l00510"></a>00510 };
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="keyword">static</span> <span class="keywordtype">void</span> osi_print_cksum(<span class="keyword">const</span> u_int8_t *pptr, u_int16_t checksum,
<a name="l00513"></a>00513                             u_int checksum_offset, u_int length);
<a name="l00514"></a>00514 <span class="keyword">static</span> <span class="keywordtype">int</span> clnp_print(<span class="keyword">const</span> u_int8_t *, u_int);
<a name="l00515"></a>00515 <span class="keyword">static</span> <span class="keywordtype">void</span> esis_print(<span class="keyword">const</span> u_int8_t *, u_int);
<a name="l00516"></a>00516 <span class="keyword">static</span> <span class="keywordtype">int</span> isis_print(<span class="keyword">const</span> u_int8_t *, u_int);
<a name="l00517"></a>00517 
<a name="l00518"></a><a class="code" href="structisis__metric__block.html">00518</a> <span class="keyword">struct </span><a class="code" href="structisis__metric__block.html">isis_metric_block</a> {
<a name="l00519"></a>00519     u_int8_t metric_default;
<a name="l00520"></a>00520     u_int8_t metric_delay;
<a name="l00521"></a>00521     u_int8_t metric_expense;
<a name="l00522"></a>00522     u_int8_t metric_error;
<a name="l00523"></a>00523 };
<a name="l00524"></a>00524 
<a name="l00525"></a><a class="code" href="structisis__tlv__is__reach.html">00525</a> <span class="keyword">struct </span><a class="code" href="structisis__tlv__is__reach.html">isis_tlv_is_reach</a> {
<a name="l00526"></a>00526     <span class="keyword">struct </span><a class="code" href="structisis__metric__block.html">isis_metric_block</a> isis_metric_block;
<a name="l00527"></a>00527     u_int8_t neighbor_nodeid[NODE_ID_LEN];
<a name="l00528"></a>00528 };
<a name="l00529"></a>00529 
<a name="l00530"></a><a class="code" href="structisis__tlv__es__reach.html">00530</a> <span class="keyword">struct </span><a class="code" href="structisis__tlv__es__reach.html">isis_tlv_es_reach</a> {
<a name="l00531"></a>00531     <span class="keyword">struct </span><a class="code" href="structisis__metric__block.html">isis_metric_block</a> isis_metric_block;
<a name="l00532"></a>00532     u_int8_t neighbor_sysid[SYSTEM_ID_LEN];
<a name="l00533"></a>00533 };
<a name="l00534"></a>00534 
<a name="l00535"></a><a class="code" href="structisis__tlv__ip__reach.html">00535</a> <span class="keyword">struct </span><a class="code" href="structisis__tlv__ip__reach.html">isis_tlv_ip_reach</a> {
<a name="l00536"></a>00536     <span class="keyword">struct </span><a class="code" href="structisis__metric__block.html">isis_metric_block</a> isis_metric_block;
<a name="l00537"></a>00537     u_int8_t prefix[4];
<a name="l00538"></a>00538     u_int8_t mask[4];
<a name="l00539"></a>00539 };
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_is_reach_virtual_values[] = {
<a name="l00542"></a>00542     { 0,    <span class="stringliteral">&quot;IsNotVirtual&quot;</span>},
<a name="l00543"></a>00543     { 1,    <span class="stringliteral">&quot;IsVirtual&quot;</span>},
<a name="l00544"></a>00544     { 0, NULL }
<a name="l00545"></a>00545 };
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> isis_restart_flag_values[] = {
<a name="l00548"></a>00548     { 0x1,  <span class="stringliteral">&quot;Restart Request&quot;</span>},
<a name="l00549"></a>00549     { 0x2,  <span class="stringliteral">&quot;Restart Acknowledgement&quot;</span>},
<a name="l00550"></a>00550     { 0x4,  <span class="stringliteral">&quot;Suppress adjacency advertisement&quot;</span>},
<a name="l00551"></a>00551     { 0, NULL }
<a name="l00552"></a>00552 };
<a name="l00553"></a>00553 
<a name="l00554"></a><a class="code" href="structisis__common__header.html">00554</a> <span class="keyword">struct </span><a class="code" href="structisis__common__header.html">isis_common_header</a> {
<a name="l00555"></a>00555     u_int8_t nlpid;
<a name="l00556"></a>00556     u_int8_t fixed_len;
<a name="l00557"></a>00557     u_int8_t version;           <span class="comment">/* Protocol version */</span>
<a name="l00558"></a>00558     u_int8_t id_length;
<a name="l00559"></a>00559     u_int8_t pdu_type;              <span class="comment">/* 3 MSbits are reserved */</span>
<a name="l00560"></a>00560     u_int8_t pdu_version;       <span class="comment">/* Packet format version */</span>
<a name="l00561"></a>00561     u_int8_t reserved;
<a name="l00562"></a>00562     u_int8_t max_area;
<a name="l00563"></a>00563 };
<a name="l00564"></a>00564 
<a name="l00565"></a><a class="code" href="structisis__iih__lan__header.html">00565</a> <span class="keyword">struct </span><a class="code" href="structisis__iih__lan__header.html">isis_iih_lan_header</a> {
<a name="l00566"></a>00566     u_int8_t circuit_type;
<a name="l00567"></a>00567     u_int8_t source_id[SYSTEM_ID_LEN];
<a name="l00568"></a>00568     u_int8_t holding_time[2];
<a name="l00569"></a>00569     u_int8_t pdu_len[2];
<a name="l00570"></a>00570     u_int8_t priority;
<a name="l00571"></a>00571     u_int8_t lan_id[NODE_ID_LEN];
<a name="l00572"></a>00572 };
<a name="l00573"></a>00573 
<a name="l00574"></a><a class="code" href="structisis__iih__ptp__header.html">00574</a> <span class="keyword">struct </span><a class="code" href="structisis__iih__ptp__header.html">isis_iih_ptp_header</a> {
<a name="l00575"></a>00575     u_int8_t circuit_type;
<a name="l00576"></a>00576     u_int8_t source_id[SYSTEM_ID_LEN];
<a name="l00577"></a>00577     u_int8_t holding_time[2];
<a name="l00578"></a>00578     u_int8_t pdu_len[2];
<a name="l00579"></a>00579     u_int8_t circuit_id;
<a name="l00580"></a>00580 };
<a name="l00581"></a>00581 
<a name="l00582"></a><a class="code" href="structisis__lsp__header.html">00582</a> <span class="keyword">struct </span><a class="code" href="structisis__lsp__header.html">isis_lsp_header</a> {
<a name="l00583"></a>00583     u_int8_t pdu_len[2];
<a name="l00584"></a>00584     u_int8_t remaining_lifetime[2];
<a name="l00585"></a>00585     u_int8_t lsp_id[LSP_ID_LEN];
<a name="l00586"></a>00586     u_int8_t sequence_number[4];
<a name="l00587"></a>00587     u_int8_t checksum[2];
<a name="l00588"></a>00588     u_int8_t typeblock;
<a name="l00589"></a>00589 };
<a name="l00590"></a>00590 
<a name="l00591"></a><a class="code" href="structisis__csnp__header.html">00591</a> <span class="keyword">struct </span><a class="code" href="structisis__csnp__header.html">isis_csnp_header</a> {
<a name="l00592"></a>00592     u_int8_t pdu_len[2];
<a name="l00593"></a>00593     u_int8_t source_id[NODE_ID_LEN];
<a name="l00594"></a>00594     u_int8_t start_lsp_id[LSP_ID_LEN];
<a name="l00595"></a>00595     u_int8_t end_lsp_id[LSP_ID_LEN];
<a name="l00596"></a>00596 };
<a name="l00597"></a>00597 
<a name="l00598"></a><a class="code" href="structisis__psnp__header.html">00598</a> <span class="keyword">struct </span><a class="code" href="structisis__psnp__header.html">isis_psnp_header</a> {
<a name="l00599"></a>00599     u_int8_t pdu_len[2];
<a name="l00600"></a>00600     u_int8_t source_id[NODE_ID_LEN];
<a name="l00601"></a>00601 };
<a name="l00602"></a>00602 
<a name="l00603"></a><a class="code" href="structisis__tlv__lsp.html">00603</a> <span class="keyword">struct </span><a class="code" href="structisis__tlv__lsp.html">isis_tlv_lsp</a> {
<a name="l00604"></a>00604     u_int8_t remaining_lifetime[2];
<a name="l00605"></a>00605     u_int8_t lsp_id[LSP_ID_LEN];
<a name="l00606"></a>00606     u_int8_t sequence_number[4];
<a name="l00607"></a>00607     u_int8_t checksum[2];
<a name="l00608"></a>00608 };
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="preprocessor">#define ISIS_COMMON_HEADER_SIZE (sizeof(struct isis_common_header))</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_IIH_LAN_HEADER_SIZE (sizeof(struct isis_iih_lan_header))</span>
<a name="l00612"></a>00612 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_IIH_PTP_HEADER_SIZE (sizeof(struct isis_iih_ptp_header))</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_LSP_HEADER_SIZE (sizeof(struct isis_lsp_header))</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_CSNP_HEADER_SIZE (sizeof(struct isis_csnp_header))</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span><span class="preprocessor">#define ISIS_PSNP_HEADER_SIZE (sizeof(struct isis_psnp_header))</span>
<a name="l00616"></a>00616 <span class="preprocessor"></span>
<a name="l00617"></a>00617 <span class="keywordtype">void</span> isoclns_print(<span class="keyword">const</span> u_int8_t *p, u_int length, u_int caplen)
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__common__header.html">isis_common_header</a> *header;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     header = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__common__header.html">isis_common_header</a> *)p;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623         <span class="keywordflow">if</span> (caplen &lt;= 1) { <span class="comment">/* enough bytes on the wire ? */</span>
<a name="l00624"></a>00624             printf(<span class="stringliteral">&quot;|OSI&quot;</span>);
<a name="l00625"></a>00625             <span class="keywordflow">return</span>;
<a name="l00626"></a>00626         }
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         <span class="keywordflow">if</span> (eflag)
<a name="l00629"></a>00629             printf(<span class="stringliteral">&quot;OSI NLPID %s (0x%02x): &quot;</span>,
<a name="l00630"></a>00630                    tok2str(nlpid_values,<span class="stringliteral">&quot;Unknown&quot;</span>,*p),
<a name="l00631"></a>00631                    *p);
<a name="l00632"></a>00632         
<a name="l00633"></a>00633     <span class="keywordflow">switch</span> (*p) {
<a name="l00634"></a>00634 
<a name="l00635"></a>00635     <span class="keywordflow">case</span> NLPID_CLNP:
<a name="l00636"></a>00636         <span class="keywordflow">if</span> (!clnp_print(p, length))
<a name="l00637"></a>00637                         print_unknown_data(p,<span class="stringliteral">&quot;\n\t&quot;</span>,caplen);
<a name="l00638"></a>00638         <span class="keywordflow">break</span>;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640     <span class="keywordflow">case</span> NLPID_ESIS:
<a name="l00641"></a>00641         esis_print(p, length);
<a name="l00642"></a>00642         <span class="keywordflow">return</span>;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     <span class="keywordflow">case</span> NLPID_ISIS:
<a name="l00645"></a>00645         <span class="keywordflow">if</span> (!isis_print(p, length))
<a name="l00646"></a>00646                         print_unknown_data(p,<span class="stringliteral">&quot;\n\t&quot;</span>,caplen);
<a name="l00647"></a>00647         <span class="keywordflow">break</span>;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="keywordflow">case</span> NLPID_NULLNS:
<a name="l00650"></a>00650         (void)printf(<span class="stringliteral">&quot;%slength: %u&quot;</span>,
<a name="l00651"></a>00651                      eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,
<a name="l00652"></a>00652                              length);
<a name="l00653"></a>00653         <span class="keywordflow">break</span>;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         <span class="keywordflow">case</span> NLPID_Q933:
<a name="l00656"></a>00656                 q933_print(p+1, length-1);
<a name="l00657"></a>00657                 <span class="keywordflow">break</span>;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         <span class="keywordflow">case</span> NLPID_IP:
<a name="l00660"></a>00660         ip_print(gndo, p+1, length-1);
<a name="l00661"></a>00661                 <span class="keywordflow">break</span>;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="preprocessor">#ifdef INET6</span>
<a name="l00664"></a>00664 <span class="preprocessor"></span>        <span class="keywordflow">case</span> NLPID_IP6:
<a name="l00665"></a>00665                 ip6_print(p+1, length-1);
<a name="l00666"></a>00666                 <span class="keywordflow">break</span>;
<a name="l00667"></a>00667 <span class="preprocessor">#endif</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span>
<a name="l00669"></a>00669         <span class="keywordflow">case</span> NLPID_PPP:
<a name="l00670"></a>00670                 ppp_print(p+1, length-1);
<a name="l00671"></a>00671                 <span class="keywordflow">break</span>;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="keywordflow">default</span>:
<a name="l00674"></a>00674                 <span class="keywordflow">if</span> (!eflag)
<a name="l00675"></a>00675                     printf(<span class="stringliteral">&quot;OSI NLPID 0x%02x unknown&quot;</span>,*p);
<a name="l00676"></a>00676         (void)printf(<span class="stringliteral">&quot;%slength: %u&quot;</span>,
<a name="l00677"></a>00677                      eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,
<a name="l00678"></a>00678                              length);
<a name="l00679"></a>00679         <span class="keywordflow">if</span> (caplen &gt; 1)
<a name="l00680"></a>00680                         print_unknown_data(p,<span class="stringliteral">&quot;\n\t&quot;</span>,caplen);
<a name="l00681"></a>00681         <span class="keywordflow">break</span>;
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="preprocessor">#define CLNP_PDU_ER  1</span>
<a name="l00686"></a>00686 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_PDU_DT 28</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_PDU_MD 29</span>
<a name="l00688"></a>00688 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_PDU_ERQ    30</span>
<a name="l00689"></a>00689 <span class="preprocessor"></span><span class="preprocessor">#define CLNP_PDU_ERP    31</span>
<a name="l00690"></a>00690 <span class="preprocessor"></span>
<a name="l00691"></a>00691 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> clnp_pdu_values[] = {
<a name="l00692"></a>00692     { CLNP_PDU_ER,  <span class="stringliteral">&quot;Error Report&quot;</span>},
<a name="l00693"></a>00693     { CLNP_PDU_MD,  <span class="stringliteral">&quot;MD&quot;</span>},
<a name="l00694"></a>00694     { CLNP_PDU_DT,  <span class="stringliteral">&quot;Data&quot;</span>},
<a name="l00695"></a>00695     { CLNP_PDU_ERQ, <span class="stringliteral">&quot;Echo Request&quot;</span>},
<a name="l00696"></a>00696     { CLNP_PDU_ERP, <span class="stringliteral">&quot;Echo Response&quot;</span>},
<a name="l00697"></a>00697     { 0, NULL }
<a name="l00698"></a>00698 };
<a name="l00699"></a>00699 
<a name="l00700"></a><a class="code" href="structclnp__header__t.html">00700</a> <span class="keyword">struct </span><a class="code" href="structclnp__header__t.html">clnp_header_t</a> {
<a name="l00701"></a>00701     u_int8_t nlpid;
<a name="l00702"></a>00702     u_int8_t length_indicator;
<a name="l00703"></a>00703     u_int8_t version;
<a name="l00704"></a>00704     u_int8_t lifetime; <span class="comment">/* units of 500ms */</span>
<a name="l00705"></a>00705     u_int8_t type;
<a name="l00706"></a>00706     u_int8_t segment_length[2];
<a name="l00707"></a>00707     u_int8_t cksum[2];
<a name="l00708"></a>00708 };
<a name="l00709"></a>00709 
<a name="l00710"></a><a class="code" href="structclnp__segment__header__t.html">00710</a> <span class="keyword">struct </span><a class="code" href="structclnp__segment__header__t.html">clnp_segment_header_t</a> {
<a name="l00711"></a>00711     u_int8_t data_unit_id[2];
<a name="l00712"></a>00712     u_int8_t segment_offset[2];
<a name="l00713"></a>00713     u_int8_t total_length[2];
<a name="l00714"></a>00714 };
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="comment">/*</span>
<a name="l00717"></a>00717 <span class="comment"> * clnp_print</span>
<a name="l00718"></a>00718 <span class="comment"> * Decode CLNP packets.  Return 0 on error.</span>
<a name="l00719"></a>00719 <span class="comment"> */</span>
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 <span class="keyword">static</span> <span class="keywordtype">int</span> clnp_print (<span class="keyword">const</span> u_int8_t *pptr, u_int length)
<a name="l00722"></a>00722 {
<a name="l00723"></a>00723     <span class="keyword">const</span> u_int8_t *optr,*source_address,*dest_address;
<a name="l00724"></a>00724         u_int li,tlen,nsap_offset,source_address_length,dest_address_length, clnp_pdu_type, clnp_flags;
<a name="l00725"></a>00725     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structclnp__header__t.html">clnp_header_t</a> *clnp_header;
<a name="l00726"></a>00726     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structclnp__segment__header__t.html">clnp_segment_header_t</a> *clnp_segment_header;
<a name="l00727"></a>00727         u_int8_t rfd_error_major,rfd_error_minor;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     clnp_header = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structclnp__header__t.html">clnp_header_t</a> *) pptr;
<a name="l00730"></a>00730         TCHECK(*clnp_header);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         li = clnp_header-&gt;length_indicator;
<a name="l00733"></a>00733         optr = pptr;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         <span class="keywordflow">if</span> (!eflag)
<a name="l00736"></a>00736             printf(<span class="stringliteral">&quot;CLNP&quot;</span>);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="comment">/*</span>
<a name="l00739"></a>00739 <span class="comment">         * Sanity checking of the header.</span>
<a name="l00740"></a>00740 <span class="comment">         */</span>
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         <span class="keywordflow">if</span> (clnp_header-&gt;version != CLNP_VERSION) {
<a name="l00743"></a>00743             printf(<span class="stringliteral">&quot;version %d packet not supported&quot;</span>, clnp_header-&gt;version);
<a name="l00744"></a>00744             <span class="keywordflow">return</span> (0);
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747         <span class="comment">/* FIXME further header sanity checking */</span>
<a name="l00748"></a>00748 
<a name="l00749"></a>00749         clnp_pdu_type = clnp_header-&gt;type &amp; CLNP_PDU_TYPE_MASK;
<a name="l00750"></a>00750         clnp_flags = clnp_header-&gt;type &amp; CLNP_FLAG_MASK;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752         pptr += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structclnp__header__t.html">clnp_header_t</a>);
<a name="l00753"></a>00753         li -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structclnp__header__t.html">clnp_header_t</a>);
<a name="l00754"></a>00754         dest_address_length = *pptr;
<a name="l00755"></a>00755         dest_address = pptr + 1;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         pptr += (1 + dest_address_length);
<a name="l00758"></a>00758         li -= (1 + dest_address_length);
<a name="l00759"></a>00759         source_address_length = *pptr;
<a name="l00760"></a>00760         source_address = pptr +1;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762         pptr += (1 + source_address_length);
<a name="l00763"></a>00763         li -= (1 + source_address_length);
<a name="l00764"></a>00764 
<a name="l00765"></a>00765         <span class="keywordflow">if</span> (vflag &lt; 1) {
<a name="l00766"></a>00766             printf(<span class="stringliteral">&quot;%s%s &gt; %s, %s, length %u&quot;</span>,
<a name="l00767"></a>00767                    eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,
<a name="l00768"></a>00768                    isonsap_string(source_address, source_address_length),
<a name="l00769"></a>00769                    isonsap_string(dest_address, dest_address_length),
<a name="l00770"></a>00770                    tok2str(clnp_pdu_values,<span class="stringliteral">&quot;unknown (%u)&quot;</span>,clnp_pdu_type),
<a name="l00771"></a>00771                    length);
<a name="l00772"></a>00772             <span class="keywordflow">return</span> (1);
<a name="l00773"></a>00773         }
<a name="l00774"></a>00774         printf(<span class="stringliteral">&quot;%slength %u&quot;</span>,eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,length);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         printf(<span class="stringliteral">&quot;\n\t%s PDU, hlen: %u, v: %u, lifetime: %u.%us, Segment PDU length: %u, checksum: 0x%04x&quot;</span>,
<a name="l00777"></a>00777                tok2str(clnp_pdu_values, <span class="stringliteral">&quot;unknown (%u)&quot;</span>,clnp_pdu_type),
<a name="l00778"></a>00778                clnp_header-&gt;length_indicator,
<a name="l00779"></a>00779                clnp_header-&gt;version,
<a name="l00780"></a>00780                clnp_header-&gt;lifetime/2,
<a name="l00781"></a>00781                (clnp_header-&gt;lifetime%2)*5,
<a name="l00782"></a>00782                EXTRACT_16BITS(clnp_header-&gt;segment_length),
<a name="l00783"></a>00783                EXTRACT_16BITS(clnp_header-&gt;cksum));
<a name="l00784"></a>00784 
<a name="l00785"></a>00785         osi_print_cksum(optr, EXTRACT_16BITS(clnp_header-&gt;cksum), 7,
<a name="l00786"></a>00786                         clnp_header-&gt;length_indicator);
<a name="l00787"></a>00787 
<a name="l00788"></a>00788         printf(<span class="stringliteral">&quot;\n\tFlags [%s]&quot;</span>,
<a name="l00789"></a>00789                bittok2str(clnp_flag_values,<span class="stringliteral">&quot;none&quot;</span>,clnp_flags));
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         printf(<span class="stringliteral">&quot;\n\tsource address (length %u): %s\n\tdest   address (length %u): %s&quot;</span>,
<a name="l00792"></a>00792                source_address_length,
<a name="l00793"></a>00793                isonsap_string(source_address, source_address_length),
<a name="l00794"></a>00794                dest_address_length,
<a name="l00795"></a>00795                isonsap_string(dest_address,dest_address_length));
<a name="l00796"></a>00796 
<a name="l00797"></a>00797         <span class="keywordflow">if</span> (clnp_flags &amp; CLNP_SEGMENT_PART) {
<a name="l00798"></a>00798                 clnp_segment_header = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structclnp__segment__header__t.html">clnp_segment_header_t</a> *) pptr;
<a name="l00799"></a>00799                 TCHECK(*clnp_segment_header);
<a name="l00800"></a>00800                 printf(<span class="stringliteral">&quot;\n\tData Unit ID: 0x%04x, Segment Offset: %u, Total PDU Length: %u&quot;</span>,
<a name="l00801"></a>00801                        EXTRACT_16BITS(clnp_segment_header-&gt;data_unit_id),
<a name="l00802"></a>00802                        EXTRACT_16BITS(clnp_segment_header-&gt;segment_offset),
<a name="l00803"></a>00803                        EXTRACT_16BITS(clnp_segment_header-&gt;total_length));
<a name="l00804"></a>00804                 pptr+=<span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structclnp__segment__header__t.html">clnp_segment_header_t</a>);
<a name="l00805"></a>00805                 li-=<span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structclnp__segment__header__t.html">clnp_segment_header_t</a>);
<a name="l00806"></a>00806         }
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         <span class="comment">/* now walk the options */</span>
<a name="l00809"></a>00809         <span class="keywordflow">while</span> (li &gt;= 2) {
<a name="l00810"></a>00810             u_int op, opli;
<a name="l00811"></a>00811             <span class="keyword">const</span> u_int8_t *tptr;
<a name="l00812"></a>00812             
<a name="l00813"></a>00813             TCHECK2(*pptr, 2);
<a name="l00814"></a>00814             <span class="keywordflow">if</span> (li &lt; 2) {
<a name="l00815"></a>00815                 printf(<span class="stringliteral">&quot;, bad opts/li&quot;</span>);
<a name="l00816"></a>00816                 <span class="keywordflow">return</span> (0);
<a name="l00817"></a>00817             }
<a name="l00818"></a>00818             op = *pptr++;
<a name="l00819"></a>00819             opli = *pptr++;
<a name="l00820"></a>00820             li -= 2;
<a name="l00821"></a>00821             TCHECK2(*pptr, opli);
<a name="l00822"></a>00822             <span class="keywordflow">if</span> (opli &gt; li) {
<a name="l00823"></a>00823                 printf(<span class="stringliteral">&quot;, opt (%d) too long&quot;</span>, op);
<a name="l00824"></a>00824                 <span class="keywordflow">return</span> (0);
<a name="l00825"></a>00825             }
<a name="l00826"></a>00826             li -= opli;
<a name="l00827"></a>00827             tptr = pptr;
<a name="l00828"></a>00828             tlen = opli;
<a name="l00829"></a>00829             
<a name="l00830"></a>00830             printf(<span class="stringliteral">&quot;\n\t  %s Option #%u, length %u, value: &quot;</span>,
<a name="l00831"></a>00831                    tok2str(clnp_option_values,<span class="stringliteral">&quot;Unknown&quot;</span>,op),
<a name="l00832"></a>00832                    op,
<a name="l00833"></a>00833                    opli);
<a name="l00834"></a>00834 
<a name="l00835"></a>00835             <span class="keywordflow">switch</span> (op) {
<a name="l00836"></a>00836 
<a name="l00837"></a>00837 
<a name="l00838"></a>00838             <span class="keywordflow">case</span> CLNP_OPTION_ROUTE_RECORDING: <span class="comment">/* those two options share the format */</span>
<a name="l00839"></a>00839             <span class="keywordflow">case</span> CLNP_OPTION_SOURCE_ROUTING:  
<a name="l00840"></a>00840                     printf(<span class="stringliteral">&quot;%s %s&quot;</span>,
<a name="l00841"></a>00841                            tok2str(clnp_option_sr_rr_values,<span class="stringliteral">&quot;Unknown&quot;</span>,*tptr),
<a name="l00842"></a>00842                            tok2str(clnp_option_sr_rr_string_values,<span class="stringliteral">&quot;Unknown Option %u&quot;</span>,op));
<a name="l00843"></a>00843                     nsap_offset=*(tptr+1);
<a name="l00844"></a>00844                     <span class="keywordflow">if</span> (nsap_offset == 0) {
<a name="l00845"></a>00845                             printf(<span class="stringliteral">&quot; Bad NSAP offset (0)&quot;</span>);
<a name="l00846"></a>00846                             <span class="keywordflow">break</span>;
<a name="l00847"></a>00847                     }
<a name="l00848"></a>00848                     nsap_offset-=1; <span class="comment">/* offset to nsap list */</span>
<a name="l00849"></a>00849                     <span class="keywordflow">if</span> (nsap_offset &gt; tlen) {
<a name="l00850"></a>00850                             printf(<span class="stringliteral">&quot; Bad NSAP offset (past end of option)&quot;</span>);
<a name="l00851"></a>00851                             <span class="keywordflow">break</span>;
<a name="l00852"></a>00852                     }
<a name="l00853"></a>00853                     tptr+=nsap_offset;
<a name="l00854"></a>00854                     tlen-=nsap_offset;
<a name="l00855"></a>00855                     <span class="keywordflow">while</span> (tlen &gt; 0) {
<a name="l00856"></a>00856                             source_address_length=*tptr;
<a name="l00857"></a>00857                             <span class="keywordflow">if</span> (tlen &lt; source_address_length+1) {
<a name="l00858"></a>00858                                     printf(<span class="stringliteral">&quot;\n\t    NSAP address goes past end of option&quot;</span>);
<a name="l00859"></a>00859                                     <span class="keywordflow">break</span>;
<a name="l00860"></a>00860                             }
<a name="l00861"></a>00861                             <span class="keywordflow">if</span> (source_address_length &gt; 0) {
<a name="l00862"></a>00862                                     source_address=(tptr+1);
<a name="l00863"></a>00863                                     TCHECK2(*source_address, source_address_length);
<a name="l00864"></a>00864                                     printf(<span class="stringliteral">&quot;\n\t    NSAP address (length %u): %s&quot;</span>,
<a name="l00865"></a>00865                                            source_address_length,
<a name="l00866"></a>00866                                            isonsap_string(source_address, source_address_length));
<a name="l00867"></a>00867                             }
<a name="l00868"></a>00868                             tlen-=source_address_length+1;
<a name="l00869"></a>00869                     }
<a name="l00870"></a>00870                     <span class="keywordflow">break</span>;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872             <span class="keywordflow">case</span> CLNP_OPTION_PRIORITY:
<a name="l00873"></a>00873                     printf(<span class="stringliteral">&quot;0x%1x&quot;</span>, *tptr&amp;0x0f);
<a name="l00874"></a>00874                     <span class="keywordflow">break</span>;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876             <span class="keywordflow">case</span> CLNP_OPTION_QOS_MAINTENANCE:
<a name="l00877"></a>00877                     printf(<span class="stringliteral">&quot;\n\t    Format Code: %s&quot;</span>,
<a name="l00878"></a>00878                            tok2str(clnp_option_scope_values,<span class="stringliteral">&quot;Reserved&quot;</span>,*tptr&amp;CLNP_OPTION_SCOPE_MASK));
<a name="l00879"></a>00879 
<a name="l00880"></a>00880                     <span class="keywordflow">if</span> ((*tptr&amp;CLNP_OPTION_SCOPE_MASK) == CLNP_OPTION_SCOPE_GLOBAL)
<a name="l00881"></a>00881                             printf(<span class="stringliteral">&quot;\n\t    QoS Flags [%s]&quot;</span>,
<a name="l00882"></a>00882                                    bittok2str(clnp_option_qos_global_values,
<a name="l00883"></a>00883                                               <span class="stringliteral">&quot;none&quot;</span>,
<a name="l00884"></a>00884                                               *tptr&amp;CLNP_OPTION_OPTION_QOS_MASK));
<a name="l00885"></a>00885                     <span class="keywordflow">break</span>;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887             <span class="keywordflow">case</span> CLNP_OPTION_SECURITY:
<a name="l00888"></a>00888                     printf(<span class="stringliteral">&quot;\n\t    Format Code: %s, Security-Level %u&quot;</span>,
<a name="l00889"></a>00889                            tok2str(clnp_option_scope_values,<span class="stringliteral">&quot;Reserved&quot;</span>,*tptr&amp;CLNP_OPTION_SCOPE_MASK),
<a name="l00890"></a>00890                            *(tptr+1));
<a name="l00891"></a>00891                     <span class="keywordflow">break</span>;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893             <span class="keywordflow">case</span> CLNP_OPTION_DISCARD_REASON:
<a name="l00894"></a>00894                 rfd_error_major = (*tptr&amp;0xf0) &gt;&gt; 4;
<a name="l00895"></a>00895                 rfd_error_minor = *tptr&amp;0x0f;
<a name="l00896"></a>00896                 printf(<span class="stringliteral">&quot;\n\t    Class: %s Error (0x%01x), %s (0x%01x)&quot;</span>,
<a name="l00897"></a>00897                        tok2str(clnp_option_rfd_class_values,<span class="stringliteral">&quot;Unknown&quot;</span>,rfd_error_major),
<a name="l00898"></a>00898                        rfd_error_major,
<a name="l00899"></a>00899                        tok2str(clnp_option_rfd_error_class[rfd_error_major],<span class="stringliteral">&quot;Unknown&quot;</span>,rfd_error_minor),
<a name="l00900"></a>00900                        rfd_error_minor);
<a name="l00901"></a>00901                 <span class="keywordflow">break</span>;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903             <span class="keywordflow">case</span> CLNP_OPTION_PADDING:
<a name="l00904"></a>00904                     printf(<span class="stringliteral">&quot;padding data&quot;</span>);
<a name="l00905"></a>00905                 <span class="keywordflow">break</span>;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907                 <span class="comment">/*</span>
<a name="l00908"></a>00908 <span class="comment">                 * FIXME those are the defined Options that lack a decoder</span>
<a name="l00909"></a>00909 <span class="comment">                 * you are welcome to contribute code ;-)</span>
<a name="l00910"></a>00910 <span class="comment">                 */</span>
<a name="l00911"></a>00911 
<a name="l00912"></a>00912             <span class="keywordflow">default</span>:
<a name="l00913"></a>00913                 print_unknown_data(tptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,opli);
<a name="l00914"></a>00914                 <span class="keywordflow">break</span>;
<a name="l00915"></a>00915             }
<a name="l00916"></a>00916             <span class="keywordflow">if</span> (vflag &gt; 1)
<a name="l00917"></a>00917                 print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,opli);
<a name="l00918"></a>00918             pptr += opli;
<a name="l00919"></a>00919         }
<a name="l00920"></a>00920 
<a name="l00921"></a>00921         <span class="keywordflow">switch</span> (clnp_pdu_type) {
<a name="l00922"></a>00922 
<a name="l00923"></a>00923         <span class="keywordflow">case</span>    CLNP_PDU_ER: <span class="comment">/* fall through */</span>
<a name="l00924"></a>00924         <span class="keywordflow">case</span>    CLNP_PDU_ERP:
<a name="l00925"></a>00925             TCHECK(*pptr);
<a name="l00926"></a>00926             <span class="keywordflow">if</span> (*(pptr) == NLPID_CLNP) {
<a name="l00927"></a>00927                 printf(<span class="stringliteral">&quot;\n\t-----original packet-----\n\t&quot;</span>);
<a name="l00928"></a>00928                 <span class="comment">/* FIXME recursion protection */</span>
<a name="l00929"></a>00929                 clnp_print(pptr, length-clnp_header-&gt;length_indicator);
<a name="l00930"></a>00930                 <span class="keywordflow">break</span>;
<a name="l00931"></a>00931             } 
<a name="l00932"></a>00932 
<a name="l00933"></a>00933         <span class="keywordflow">case</span>    CLNP_PDU_DT:
<a name="l00934"></a>00934         <span class="keywordflow">case</span>    CLNP_PDU_MD:
<a name="l00935"></a>00935         <span class="keywordflow">case</span>    CLNP_PDU_ERQ:
<a name="l00936"></a>00936             
<a name="l00937"></a>00937         <span class="keywordflow">default</span>:
<a name="l00938"></a>00938             <span class="comment">/* dump the PDU specific data */</span>
<a name="l00939"></a>00939             <span class="keywordflow">if</span> (length-(pptr-optr) &gt; 0) {
<a name="l00940"></a>00940                 printf(<span class="stringliteral">&quot;\n\t  undecoded non-header data, length %u&quot;</span>,length-clnp_header-&gt;length_indicator);
<a name="l00941"></a>00941                 print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,length-(pptr-optr));
<a name="l00942"></a>00942             }
<a name="l00943"></a>00943         }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945         <span class="keywordflow">return</span> (1);
<a name="l00946"></a>00946 
<a name="l00947"></a>00947  trunc:
<a name="l00948"></a>00948     fputs(<span class="stringliteral">&quot;[|clnp]&quot;</span>, stdout);
<a name="l00949"></a>00949     <span class="keywordflow">return</span> (1);
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 <span class="preprocessor">#define ESIS_PDU_REDIRECT   6</span>
<a name="l00955"></a>00955 <span class="preprocessor"></span><span class="preprocessor">#define ESIS_PDU_ESH            2</span>
<a name="l00956"></a>00956 <span class="preprocessor"></span><span class="preprocessor">#define ESIS_PDU_ISH            4</span>
<a name="l00957"></a>00957 <span class="preprocessor"></span>
<a name="l00958"></a>00958 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtok.html">tok</a> esis_pdu_values[] = {
<a name="l00959"></a>00959     { ESIS_PDU_REDIRECT, <span class="stringliteral">&quot;redirect&quot;</span>},
<a name="l00960"></a>00960     { ESIS_PDU_ESH,      <span class="stringliteral">&quot;ESH&quot;</span>},
<a name="l00961"></a>00961     { ESIS_PDU_ISH,      <span class="stringliteral">&quot;ISH&quot;</span>},
<a name="l00962"></a>00962     { 0, NULL }
<a name="l00963"></a>00963 };
<a name="l00964"></a>00964 
<a name="l00965"></a><a class="code" href="structesis__header__t.html">00965</a> <span class="keyword">struct </span><a class="code" href="structesis__header__t.html">esis_header_t</a> {
<a name="l00966"></a>00966     u_int8_t nlpid;
<a name="l00967"></a>00967     u_int8_t length_indicator;
<a name="l00968"></a>00968     u_int8_t version;
<a name="l00969"></a>00969     u_int8_t reserved;
<a name="l00970"></a>00970     u_int8_t type;
<a name="l00971"></a>00971     u_int8_t holdtime[2];
<a name="l00972"></a>00972     u_int8_t cksum[2];
<a name="l00973"></a>00973 };
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00976"></a>00976 esis_print(<span class="keyword">const</span> u_int8_t *pptr, u_int length)
<a name="l00977"></a>00977 {
<a name="l00978"></a>00978     <span class="keyword">const</span> u_int8_t *optr;
<a name="l00979"></a>00979     u_int li,esis_pdu_type,source_address_length, source_address_number;
<a name="l00980"></a>00980     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structesis__header__t.html">esis_header_t</a> *esis_header;
<a name="l00981"></a>00981 
<a name="l00982"></a>00982         <span class="keywordflow">if</span> (!eflag)
<a name="l00983"></a>00983             printf(<span class="stringliteral">&quot;ES-IS&quot;</span>);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985     <span class="keywordflow">if</span> (length &lt;= 2) {
<a name="l00986"></a>00986         <span class="keywordflow">if</span> (qflag)
<a name="l00987"></a>00987             printf(<span class="stringliteral">&quot;bad pkt!&quot;</span>);
<a name="l00988"></a>00988         <span class="keywordflow">else</span>
<a name="l00989"></a>00989             printf(<span class="stringliteral">&quot;no header at all!&quot;</span>);
<a name="l00990"></a>00990         <span class="keywordflow">return</span>;
<a name="l00991"></a>00991     }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     esis_header = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structesis__header__t.html">esis_header_t</a> *) pptr;
<a name="l00994"></a>00994         TCHECK(*esis_header);
<a name="l00995"></a>00995         li = esis_header-&gt;length_indicator;
<a name="l00996"></a>00996         optr = pptr;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         <span class="comment">/*</span>
<a name="l00999"></a>00999 <span class="comment">         * Sanity checking of the header.</span>
<a name="l01000"></a>01000 <span class="comment">         */</span>
<a name="l01001"></a>01001 
<a name="l01002"></a>01002         <span class="keywordflow">if</span> (esis_header-&gt;nlpid != NLPID_ESIS) {
<a name="l01003"></a>01003             printf(<span class="stringliteral">&quot; nlpid 0x%02x packet not supported&quot;</span>, esis_header-&gt;nlpid);
<a name="l01004"></a>01004             <span class="keywordflow">return</span>;
<a name="l01005"></a>01005         }
<a name="l01006"></a>01006 
<a name="l01007"></a>01007         <span class="keywordflow">if</span> (esis_header-&gt;version != ESIS_VERSION) {
<a name="l01008"></a>01008             printf(<span class="stringliteral">&quot; version %d packet not supported&quot;</span>, esis_header-&gt;version);
<a name="l01009"></a>01009             <span class="keywordflow">return</span>;
<a name="l01010"></a>01010         }
<a name="l01011"></a>01011                 
<a name="l01012"></a>01012     <span class="keywordflow">if</span> (li &gt; length) {
<a name="l01013"></a>01013             printf(<span class="stringliteral">&quot; length indicator(%d) &gt; PDU size (%d)!&quot;</span>, li, length);
<a name="l01014"></a>01014             <span class="keywordflow">return</span>;
<a name="l01015"></a>01015     }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017     <span class="keywordflow">if</span> (li &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structesis__header__t.html">esis_header_t</a>) + 2) {
<a name="l01018"></a>01018             printf(<span class="stringliteral">&quot; length indicator &lt; min PDU size %d:&quot;</span>, li);
<a name="l01019"></a>01019             <span class="keywordflow">while</span> (--length != 0)
<a name="l01020"></a>01020                 printf(<span class="stringliteral">&quot;%02X&quot;</span>, *pptr++);
<a name="l01021"></a>01021             <span class="keywordflow">return</span>;
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         esis_pdu_type = esis_header-&gt;type &amp; ESIS_PDU_TYPE_MASK;
<a name="l01025"></a>01025 
<a name="l01026"></a>01026         <span class="keywordflow">if</span> (vflag &lt; 1) {
<a name="l01027"></a>01027             printf(<span class="stringliteral">&quot;%s%s, length %u&quot;</span>,
<a name="l01028"></a>01028                    eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,
<a name="l01029"></a>01029                    tok2str(esis_pdu_values,<span class="stringliteral">&quot;unknown type (%u)&quot;</span>,esis_pdu_type),
<a name="l01030"></a>01030                    length);
<a name="l01031"></a>01031             <span class="keywordflow">return</span>;
<a name="l01032"></a>01032         } <span class="keywordflow">else</span>
<a name="l01033"></a>01033             printf(<span class="stringliteral">&quot;%slength %u\n\t%s (%u)&quot;</span>,
<a name="l01034"></a>01034                    eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,
<a name="l01035"></a>01035                    length,
<a name="l01036"></a>01036                    tok2str(esis_pdu_values,<span class="stringliteral">&quot;unknown type: %u&quot;</span>, esis_pdu_type),
<a name="l01037"></a>01037                    esis_pdu_type);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039         printf(<span class="stringliteral">&quot;, v: %u%s&quot;</span>, esis_header-&gt;version, esis_header-&gt;version == ESIS_VERSION ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;unsupported&quot;</span> );
<a name="l01040"></a>01040         printf(<span class="stringliteral">&quot;, checksum: 0x%04x&quot;</span>, EXTRACT_16BITS(esis_header-&gt;cksum));
<a name="l01041"></a>01041 
<a name="l01042"></a>01042         osi_print_cksum(pptr, EXTRACT_16BITS(esis_header-&gt;cksum), 7, li);
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         printf(<span class="stringliteral">&quot;, holding time: %us, length indicator: %u&quot;</span>,EXTRACT_16BITS(esis_header-&gt;holdtime),li);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="keywordflow">if</span> (vflag &gt; 1)
<a name="l01047"></a>01047             print_unknown_data(optr,<span class="stringliteral">&quot;\n\t&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structesis__header__t.html">esis_header_t</a>));
<a name="l01048"></a>01048 
<a name="l01049"></a>01049     pptr += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structesis__header__t.html">esis_header_t</a>);
<a name="l01050"></a>01050     li -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structesis__header__t.html">esis_header_t</a>);
<a name="l01051"></a>01051 
<a name="l01052"></a>01052     <span class="keywordflow">switch</span> (esis_pdu_type) {
<a name="l01053"></a>01053     <span class="keywordflow">case</span> ESIS_PDU_REDIRECT: {
<a name="l01054"></a>01054         <span class="keyword">const</span> u_int8_t *dst, *snpa, *neta;
<a name="l01055"></a>01055         u_int dstl, snpal, netal;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057         TCHECK(*pptr);
<a name="l01058"></a>01058         <span class="keywordflow">if</span> (li &lt; 1) {
<a name="l01059"></a>01059             printf(<span class="stringliteral">&quot;, bad redirect/li&quot;</span>);
<a name="l01060"></a>01060             <span class="keywordflow">return</span>;
<a name="l01061"></a>01061         }
<a name="l01062"></a>01062         dstl = *pptr;
<a name="l01063"></a>01063         pptr++;
<a name="l01064"></a>01064         li--;
<a name="l01065"></a>01065         TCHECK2(*pptr, dstl);
<a name="l01066"></a>01066         <span class="keywordflow">if</span> (li &lt; dstl) {
<a name="l01067"></a>01067             printf(<span class="stringliteral">&quot;, bad redirect/li&quot;</span>);
<a name="l01068"></a>01068             <span class="keywordflow">return</span>;
<a name="l01069"></a>01069         }
<a name="l01070"></a>01070         dst = pptr;
<a name="l01071"></a>01071         pptr += dstl;
<a name="l01072"></a>01072                 li -= dstl;
<a name="l01073"></a>01073         printf(<span class="stringliteral">&quot;\n\t  %s&quot;</span>, isonsap_string(dst,dstl));
<a name="l01074"></a>01074 
<a name="l01075"></a>01075         TCHECK(*pptr);
<a name="l01076"></a>01076         <span class="keywordflow">if</span> (li &lt; 1) {
<a name="l01077"></a>01077             printf(<span class="stringliteral">&quot;, bad redirect/li&quot;</span>);
<a name="l01078"></a>01078             <span class="keywordflow">return</span>;
<a name="l01079"></a>01079         }
<a name="l01080"></a>01080         snpal = *pptr;
<a name="l01081"></a>01081         pptr++;
<a name="l01082"></a>01082         li--;
<a name="l01083"></a>01083         TCHECK2(*pptr, snpal);
<a name="l01084"></a>01084         <span class="keywordflow">if</span> (li &lt; snpal) {
<a name="l01085"></a>01085             printf(<span class="stringliteral">&quot;, bad redirect/li&quot;</span>);
<a name="l01086"></a>01086             <span class="keywordflow">return</span>;
<a name="l01087"></a>01087         }
<a name="l01088"></a>01088         snpa = pptr;
<a name="l01089"></a>01089         pptr += snpal;
<a name="l01090"></a>01090                 li -= snpal;
<a name="l01091"></a>01091         TCHECK(*pptr);
<a name="l01092"></a>01092         <span class="keywordflow">if</span> (li &lt; 1) {
<a name="l01093"></a>01093             printf(<span class="stringliteral">&quot;, bad redirect/li&quot;</span>);
<a name="l01094"></a>01094             <span class="keywordflow">return</span>;
<a name="l01095"></a>01095         }
<a name="l01096"></a>01096         netal = *pptr;
<a name="l01097"></a>01097         pptr++;
<a name="l01098"></a>01098         TCHECK2(*pptr, netal);
<a name="l01099"></a>01099         <span class="keywordflow">if</span> (li &lt; netal) {
<a name="l01100"></a>01100             printf(<span class="stringliteral">&quot;, bad redirect/li&quot;</span>);
<a name="l01101"></a>01101             <span class="keywordflow">return</span>;
<a name="l01102"></a>01102         }
<a name="l01103"></a>01103         neta = pptr;
<a name="l01104"></a>01104         pptr += netal;
<a name="l01105"></a>01105                 li -= netal;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107         <span class="keywordflow">if</span> (netal == 0)
<a name="l01108"></a>01108             printf(<span class="stringliteral">&quot;\n\t  %s&quot;</span>, etheraddr_string(snpa));
<a name="l01109"></a>01109         <span class="keywordflow">else</span>
<a name="l01110"></a>01110             printf(<span class="stringliteral">&quot;\n\t  %s&quot;</span>, isonsap_string(neta,netal));
<a name="l01111"></a>01111         <span class="keywordflow">break</span>;
<a name="l01112"></a>01112     }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114     <span class="keywordflow">case</span> ESIS_PDU_ESH:
<a name="l01115"></a>01115             TCHECK(*pptr);
<a name="l01116"></a>01116             <span class="keywordflow">if</span> (li &lt; 1) {
<a name="l01117"></a>01117                 printf(<span class="stringliteral">&quot;, bad esh/li&quot;</span>);
<a name="l01118"></a>01118                 <span class="keywordflow">return</span>;
<a name="l01119"></a>01119             }
<a name="l01120"></a>01120             source_address_number = *pptr;
<a name="l01121"></a>01121             pptr++;
<a name="l01122"></a>01122             li--;
<a name="l01123"></a>01123 
<a name="l01124"></a>01124             printf(<span class="stringliteral">&quot;\n\t  Number of Source Addresses: %u&quot;</span>, source_address_number);
<a name="l01125"></a>01125            
<a name="l01126"></a>01126             <span class="keywordflow">while</span> (source_address_number &gt; 0) {
<a name="l01127"></a>01127                 TCHECK(*pptr);
<a name="l01128"></a>01128                 <span class="keywordflow">if</span> (li &lt; 1) {
<a name="l01129"></a>01129                     printf(<span class="stringliteral">&quot;, bad esh/li&quot;</span>);
<a name="l01130"></a>01130                     <span class="keywordflow">return</span>;
<a name="l01131"></a>01131                 }
<a name="l01132"></a>01132                 source_address_length = *pptr;
<a name="l01133"></a>01133                 pptr++;
<a name="l01134"></a>01134                 li--;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136                 TCHECK2(*pptr, source_address_length);
<a name="l01137"></a>01137                 <span class="keywordflow">if</span> (li &lt; source_address_length) {
<a name="l01138"></a>01138                     printf(<span class="stringliteral">&quot;, bad esh/li&quot;</span>);
<a name="l01139"></a>01139                     <span class="keywordflow">return</span>;
<a name="l01140"></a>01140                 }
<a name="l01141"></a>01141                 printf(<span class="stringliteral">&quot;\n\t  NET (length: %u): %s&quot;</span>,
<a name="l01142"></a>01142                        source_address_length,
<a name="l01143"></a>01143                        isonsap_string(pptr,source_address_length));
<a name="l01144"></a>01144                 pptr += source_address_length;
<a name="l01145"></a>01145                 li -= source_address_length;
<a name="l01146"></a>01146                 source_address_number--;
<a name="l01147"></a>01147             }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149             <span class="keywordflow">break</span>;
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     <span class="keywordflow">case</span> ESIS_PDU_ISH: {
<a name="l01152"></a>01152             TCHECK(*pptr);
<a name="l01153"></a>01153             <span class="keywordflow">if</span> (li &lt; 1) {
<a name="l01154"></a>01154                 printf(<span class="stringliteral">&quot;, bad ish/li&quot;</span>);
<a name="l01155"></a>01155                 <span class="keywordflow">return</span>;
<a name="l01156"></a>01156             }
<a name="l01157"></a>01157             source_address_length = *pptr;
<a name="l01158"></a>01158             pptr++;
<a name="l01159"></a>01159             li--;
<a name="l01160"></a>01160             TCHECK2(*pptr, source_address_length);
<a name="l01161"></a>01161             <span class="keywordflow">if</span> (li &lt; source_address_length) {
<a name="l01162"></a>01162                 printf(<span class="stringliteral">&quot;, bad ish/li&quot;</span>);
<a name="l01163"></a>01163                 <span class="keywordflow">return</span>;
<a name="l01164"></a>01164             }
<a name="l01165"></a>01165             printf(<span class="stringliteral">&quot;\n\t  NET (length: %u): %s&quot;</span>, source_address_length, isonsap_string(pptr, source_address_length));
<a name="l01166"></a>01166             pptr += source_address_length;
<a name="l01167"></a>01167             li -= source_address_length;
<a name="l01168"></a>01168             <span class="keywordflow">break</span>;
<a name="l01169"></a>01169     }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171     <span class="keywordflow">default</span>:
<a name="l01172"></a>01172             <span class="keywordflow">if</span> (vflag &lt;= 1) {
<a name="l01173"></a>01173             <span class="keywordflow">if</span> (pptr &lt; snapend) 
<a name="l01174"></a>01174                             print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,snapend-pptr);
<a name="l01175"></a>01175             }
<a name="l01176"></a>01176             <span class="keywordflow">return</span>;
<a name="l01177"></a>01177     }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179         <span class="comment">/* now walk the options */</span>
<a name="l01180"></a>01180         <span class="keywordflow">while</span> (li &gt;= 2) {
<a name="l01181"></a>01181             u_int op, opli;
<a name="l01182"></a>01182             <span class="keyword">const</span> u_int8_t *tptr;
<a name="l01183"></a>01183             
<a name="l01184"></a>01184             TCHECK2(*pptr, 2);
<a name="l01185"></a>01185             <span class="keywordflow">if</span> (li &lt; 2) {
<a name="l01186"></a>01186                 printf(<span class="stringliteral">&quot;, bad opts/li&quot;</span>);
<a name="l01187"></a>01187                 <span class="keywordflow">return</span>;
<a name="l01188"></a>01188             }
<a name="l01189"></a>01189             op = *pptr++;
<a name="l01190"></a>01190             opli = *pptr++;
<a name="l01191"></a>01191             li -= 2;
<a name="l01192"></a>01192             <span class="keywordflow">if</span> (opli &gt; li) {
<a name="l01193"></a>01193                 printf(<span class="stringliteral">&quot;, opt (%d) too long&quot;</span>, op);
<a name="l01194"></a>01194                 <span class="keywordflow">return</span>;
<a name="l01195"></a>01195             }
<a name="l01196"></a>01196             li -= opli;
<a name="l01197"></a>01197             tptr = pptr;
<a name="l01198"></a>01198             
<a name="l01199"></a>01199             printf(<span class="stringliteral">&quot;\n\t  %s Option #%u, length %u, value: &quot;</span>,
<a name="l01200"></a>01200                    tok2str(esis_option_values,<span class="stringliteral">&quot;Unknown&quot;</span>,op),
<a name="l01201"></a>01201                    op,
<a name="l01202"></a>01202                    opli);
<a name="l01203"></a>01203 
<a name="l01204"></a>01204             <span class="keywordflow">switch</span> (op) {
<a name="l01205"></a>01205 
<a name="l01206"></a>01206             <span class="keywordflow">case</span> ESIS_OPTION_ES_CONF_TIME:
<a name="l01207"></a>01207                 TCHECK2(*pptr, 2);
<a name="l01208"></a>01208                 printf(<span class="stringliteral">&quot;%us&quot;</span>, EXTRACT_16BITS(tptr));
<a name="l01209"></a>01209                 <span class="keywordflow">break</span>;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211             <span class="keywordflow">case</span> ESIS_OPTION_PROTOCOLS:
<a name="l01212"></a>01212                 <span class="keywordflow">while</span> (opli&gt;0) {
<a name="l01213"></a>01213                     TCHECK(*pptr);
<a name="l01214"></a>01214                     printf(<span class="stringliteral">&quot;%s (0x%02x)&quot;</span>,
<a name="l01215"></a>01215                            tok2str(nlpid_values,
<a name="l01216"></a>01216                                    <span class="stringliteral">&quot;unknown&quot;</span>,
<a name="l01217"></a>01217                                    *tptr),
<a name="l01218"></a>01218                            *tptr);
<a name="l01219"></a>01219                     <span class="keywordflow">if</span> (opli&gt;1) <span class="comment">/* further NPLIDs ? - put comma */</span>
<a name="l01220"></a>01220                         printf(<span class="stringliteral">&quot;, &quot;</span>);
<a name="l01221"></a>01221                     tptr++;
<a name="l01222"></a>01222                     opli--;
<a name="l01223"></a>01223                 }
<a name="l01224"></a>01224                 <span class="keywordflow">break</span>;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226                 <span class="comment">/*</span>
<a name="l01227"></a>01227 <span class="comment">                 * FIXME those are the defined Options that lack a decoder</span>
<a name="l01228"></a>01228 <span class="comment">                 * you are welcome to contribute code ;-)</span>
<a name="l01229"></a>01229 <span class="comment">                 */</span>
<a name="l01230"></a>01230 
<a name="l01231"></a>01231             <span class="keywordflow">case</span> ESIS_OPTION_QOS_MAINTENANCE:
<a name="l01232"></a>01232             <span class="keywordflow">case</span> ESIS_OPTION_SECURITY:
<a name="l01233"></a>01233             <span class="keywordflow">case</span> ESIS_OPTION_PRIORITY:
<a name="l01234"></a>01234             <span class="keywordflow">case</span> ESIS_OPTION_ADDRESS_MASK:
<a name="l01235"></a>01235             <span class="keywordflow">case</span> ESIS_OPTION_SNPA_MASK:
<a name="l01236"></a>01236 
<a name="l01237"></a>01237             <span class="keywordflow">default</span>:
<a name="l01238"></a>01238                 print_unknown_data(tptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,opli);
<a name="l01239"></a>01239                 <span class="keywordflow">break</span>;
<a name="l01240"></a>01240             }
<a name="l01241"></a>01241             <span class="keywordflow">if</span> (vflag &gt; 1)
<a name="l01242"></a>01242                 print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,opli);
<a name="l01243"></a>01243             pptr += opli;
<a name="l01244"></a>01244         }
<a name="l01245"></a>01245 trunc:
<a name="l01246"></a>01246     <span class="keywordflow">return</span>;
<a name="l01247"></a>01247 }   
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 <span class="comment">/* shared routine for printing system, node and lsp-ids */</span>
<a name="l01250"></a>01250 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l01251"></a>01251 isis_print_id(<span class="keyword">const</span> u_int8_t *cp, <span class="keywordtype">int</span> id_len)
<a name="l01252"></a>01252 {
<a name="l01253"></a>01253     <span class="keywordtype">int</span> i;
<a name="l01254"></a>01254     <span class="keyword">static</span> <span class="keywordtype">char</span> <span class="keywordtype">id</span>[<span class="keyword">sizeof</span>(<span class="stringliteral">&quot;xxxx.xxxx.xxxx.yy-zz&quot;</span>)];
<a name="l01255"></a>01255     <span class="keywordtype">char</span> *pos = id;
<a name="l01256"></a>01256 
<a name="l01257"></a>01257     <span class="keywordflow">for</span> (i = 1; i &lt;= SYSTEM_ID_LEN; i++) {
<a name="l01258"></a>01258         snprintf(pos, <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) - (pos - <span class="keywordtype">id</span>), <span class="stringliteral">&quot;%02x&quot;</span>, *cp++);
<a name="l01259"></a>01259     pos += strlen(pos);
<a name="l01260"></a>01260     <span class="keywordflow">if</span> (i == 2 || i == 4)
<a name="l01261"></a>01261         *pos++ = <span class="charliteral">&#39;.&#39;</span>;
<a name="l01262"></a>01262     }
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (id_len &gt;= NODE_ID_LEN) {
<a name="l01264"></a>01264         snprintf(pos, <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) - (pos - <span class="keywordtype">id</span>), <span class="stringliteral">&quot;.%02x&quot;</span>, *cp++);
<a name="l01265"></a>01265     pos += strlen(pos);
<a name="l01266"></a>01266     }
<a name="l01267"></a>01267     <span class="keywordflow">if</span> (id_len == LSP_ID_LEN)
<a name="l01268"></a>01268         snprintf(pos, <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>) - (pos - <span class="keywordtype">id</span>), <span class="stringliteral">&quot;-%02x&quot;</span>, *cp);
<a name="l01269"></a>01269     <span class="keywordflow">return</span> (<span class="keywordtype">id</span>);
<a name="l01270"></a>01270 }
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="comment">/* print the 4-byte metric block which is common found in the old-style TLVs */</span>
<a name="l01273"></a>01273 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01274"></a>01274 isis_print_metric_block (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structisis__metric__block.html">isis_metric_block</a> *<a class="code" href="structisis__metric__block.html">isis_metric_block</a>)
<a name="l01275"></a>01275 {
<a name="l01276"></a>01276     printf(<span class="stringliteral">&quot;, Default Metric: %d, %s&quot;</span>,
<a name="l01277"></a>01277            ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block-&gt;metric_default),
<a name="l01278"></a>01278            ISIS_LSP_TLV_METRIC_IE(isis_metric_block-&gt;metric_default) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01279"></a>01279     <span class="keywordflow">if</span> (!ISIS_LSP_TLV_METRIC_SUPPORTED(isis_metric_block-&gt;metric_delay))
<a name="l01280"></a>01280         printf(<span class="stringliteral">&quot;\n\t\t  Delay Metric: %d, %s&quot;</span>,
<a name="l01281"></a>01281                ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block-&gt;metric_delay),
<a name="l01282"></a>01282                ISIS_LSP_TLV_METRIC_IE(isis_metric_block-&gt;metric_delay) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01283"></a>01283     <span class="keywordflow">if</span> (!ISIS_LSP_TLV_METRIC_SUPPORTED(isis_metric_block-&gt;metric_expense))
<a name="l01284"></a>01284         printf(<span class="stringliteral">&quot;\n\t\t  Expense Metric: %d, %s&quot;</span>,
<a name="l01285"></a>01285                ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block-&gt;metric_expense),
<a name="l01286"></a>01286                ISIS_LSP_TLV_METRIC_IE(isis_metric_block-&gt;metric_expense) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01287"></a>01287     <span class="keywordflow">if</span> (!ISIS_LSP_TLV_METRIC_SUPPORTED(isis_metric_block-&gt;metric_error))
<a name="l01288"></a>01288         printf(<span class="stringliteral">&quot;\n\t\t  Error Metric: %d, %s&quot;</span>,
<a name="l01289"></a>01289                ISIS_LSP_TLV_METRIC_VALUE(isis_metric_block-&gt;metric_error),
<a name="l01290"></a>01290                ISIS_LSP_TLV_METRIC_IE(isis_metric_block-&gt;metric_error) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01291"></a>01291 
<a name="l01292"></a>01292     <span class="keywordflow">return</span>(1); <span class="comment">/* everything is ok */</span>
<a name="l01293"></a>01293 }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01296"></a>01296 isis_print_tlv_ip_reach (<span class="keyword">const</span> u_int8_t *cp, <span class="keyword">const</span> <span class="keywordtype">char</span> *ident, <span class="keywordtype">int</span> length)
<a name="l01297"></a>01297 {
<a name="l01298"></a>01298     <span class="keywordtype">int</span> prefix_len;
<a name="l01299"></a>01299     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__ip__reach.html">isis_tlv_ip_reach</a> *tlv_ip_reach;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     tlv_ip_reach = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__ip__reach.html">isis_tlv_ip_reach</a> *)cp;
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     <span class="keywordflow">while</span> (length &gt; 0) {
<a name="l01304"></a>01304         <span class="keywordflow">if</span> ((<span class="keywordtype">size_t</span>)length &lt; <span class="keyword">sizeof</span>(*tlv_ip_reach)) {
<a name="l01305"></a>01305             printf(<span class="stringliteral">&quot;short IPv4 Reachability (%d vs %lu)&quot;</span>,
<a name="l01306"></a>01306                                length,
<a name="l01307"></a>01307                                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<span class="keyword">sizeof</span>(*tlv_ip_reach));
<a name="l01308"></a>01308             <span class="keywordflow">return</span> (0);
<a name="l01309"></a>01309         }
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="keywordflow">if</span> (!TTEST(*tlv_ip_reach))
<a name="l01312"></a>01312             <span class="keywordflow">return</span> (0);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314         prefix_len = mask2plen(EXTRACT_32BITS(tlv_ip_reach-&gt;mask));
<a name="l01315"></a>01315 
<a name="l01316"></a>01316         <span class="keywordflow">if</span> (prefix_len == -1)
<a name="l01317"></a>01317             printf(<span class="stringliteral">&quot;%sIPv4 prefix: %s mask %s&quot;</span>,
<a name="l01318"></a>01318                                ident,
<a name="l01319"></a>01319                    ipaddr_string((tlv_ip_reach-&gt;prefix)),
<a name="l01320"></a>01320                    ipaddr_string((tlv_ip_reach-&gt;mask)));
<a name="l01321"></a>01321         <span class="keywordflow">else</span>
<a name="l01322"></a>01322             printf(<span class="stringliteral">&quot;%sIPv4 prefix: %15s/%u&quot;</span>,
<a name="l01323"></a>01323                                ident,
<a name="l01324"></a>01324                    ipaddr_string((tlv_ip_reach-&gt;prefix)),
<a name="l01325"></a>01325                    prefix_len);
<a name="l01326"></a>01326 
<a name="l01327"></a>01327         printf(<span class="stringliteral">&quot;, Distribution: %s, Metric: %u, %s&quot;</span>,
<a name="l01328"></a>01328                        ISIS_LSP_TLV_METRIC_UPDOWN(tlv_ip_reach-&gt;isis_metric_block.metric_default) ? <span class="stringliteral">&quot;down&quot;</span> : <span class="stringliteral">&quot;up&quot;</span>,
<a name="l01329"></a>01329                        ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach-&gt;isis_metric_block.metric_default),
<a name="l01330"></a>01330                        ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach-&gt;isis_metric_block.metric_default) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01331"></a>01331 
<a name="l01332"></a>01332         <span class="keywordflow">if</span> (!ISIS_LSP_TLV_METRIC_SUPPORTED(tlv_ip_reach-&gt;isis_metric_block.metric_delay))
<a name="l01333"></a>01333                     printf(<span class="stringliteral">&quot;%s  Delay Metric: %u, %s&quot;</span>,
<a name="l01334"></a>01334                            ident,
<a name="l01335"></a>01335                            ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach-&gt;isis_metric_block.metric_delay),
<a name="l01336"></a>01336                            ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach-&gt;isis_metric_block.metric_delay) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01337"></a>01337                 
<a name="l01338"></a>01338         <span class="keywordflow">if</span> (!ISIS_LSP_TLV_METRIC_SUPPORTED(tlv_ip_reach-&gt;isis_metric_block.metric_expense))
<a name="l01339"></a>01339                     printf(<span class="stringliteral">&quot;%s  Expense Metric: %u, %s&quot;</span>,
<a name="l01340"></a>01340                            ident,
<a name="l01341"></a>01341                            ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach-&gt;isis_metric_block.metric_expense),
<a name="l01342"></a>01342                            ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach-&gt;isis_metric_block.metric_expense) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01343"></a>01343                 
<a name="l01344"></a>01344         <span class="keywordflow">if</span> (!ISIS_LSP_TLV_METRIC_SUPPORTED(tlv_ip_reach-&gt;isis_metric_block.metric_error))
<a name="l01345"></a>01345                     printf(<span class="stringliteral">&quot;%s  Error Metric: %u, %s&quot;</span>,
<a name="l01346"></a>01346                            ident,
<a name="l01347"></a>01347                            ISIS_LSP_TLV_METRIC_VALUE(tlv_ip_reach-&gt;isis_metric_block.metric_error),
<a name="l01348"></a>01348                            ISIS_LSP_TLV_METRIC_IE(tlv_ip_reach-&gt;isis_metric_block.metric_error) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>);
<a name="l01349"></a>01349 
<a name="l01350"></a>01350         length -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structisis__tlv__ip__reach.html">isis_tlv_ip_reach</a>);
<a name="l01351"></a>01351         tlv_ip_reach++;
<a name="l01352"></a>01352     }
<a name="l01353"></a>01353     <span class="keywordflow">return</span> (1);
<a name="l01354"></a>01354 }
<a name="l01355"></a>01355 
<a name="l01356"></a>01356 <span class="comment">/*</span>
<a name="l01357"></a>01357 <span class="comment"> * this is the common IP-REACH subTLV decoder it is called</span>
<a name="l01358"></a>01358 <span class="comment"> * from various EXTD-IP REACH TLVs (135,235,236,237)</span>
<a name="l01359"></a>01359 <span class="comment"> */</span>
<a name="l01360"></a>01360 
<a name="l01361"></a>01361 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01362"></a>01362 isis_print_ip_reach_subtlv (<span class="keyword">const</span> u_int8_t *tptr,<span class="keywordtype">int</span> subt,<span class="keywordtype">int</span> subl,<span class="keyword">const</span> <span class="keywordtype">char</span> *ident) {
<a name="l01363"></a>01363 
<a name="l01364"></a>01364         <span class="comment">/* first lets see if we know the subTLVs name*/</span>
<a name="l01365"></a>01365     printf(<span class="stringliteral">&quot;%s%s subTLV #%u, length: %u&quot;</span>,
<a name="l01366"></a>01366            ident,
<a name="l01367"></a>01367                tok2str(isis_ext_ip_reach_subtlv_values,
<a name="l01368"></a>01368                        <span class="stringliteral">&quot;unknown&quot;</span>,
<a name="l01369"></a>01369                        subt),
<a name="l01370"></a>01370                subt,
<a name="l01371"></a>01371                subl);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373     <span class="keywordflow">if</span> (!TTEST2(*tptr,subl))
<a name="l01374"></a>01374         <span class="keywordflow">goto</span> trunctlv;
<a name="l01375"></a>01375 
<a name="l01376"></a>01376     <span class="keywordflow">switch</span>(subt) {
<a name="l01377"></a>01377     <span class="keywordflow">case</span> ISIS_SUBTLV_EXTD_IP_REACH_MGMT_PREFIX_COLOR: <span class="comment">/* fall through */</span>
<a name="l01378"></a>01378     <span class="keywordflow">case</span> ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG32:
<a name="l01379"></a>01379         <span class="keywordflow">while</span> (subl &gt;= 4) {
<a name="l01380"></a>01380         printf(<span class="stringliteral">&quot;, 0x%08x (=%u)&quot;</span>,
<a name="l01381"></a>01381            EXTRACT_32BITS(tptr),
<a name="l01382"></a>01382            EXTRACT_32BITS(tptr));
<a name="l01383"></a>01383         tptr+=4;
<a name="l01384"></a>01384         subl-=4;
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386     <span class="keywordflow">break</span>;
<a name="l01387"></a>01387     <span class="keywordflow">case</span> ISIS_SUBTLV_EXTD_IP_REACH_ADMIN_TAG64:
<a name="l01388"></a>01388         <span class="keywordflow">while</span> (subl &gt;= 8) {
<a name="l01389"></a>01389         printf(<span class="stringliteral">&quot;, 0x%08x%08x&quot;</span>,
<a name="l01390"></a>01390            EXTRACT_32BITS(tptr),
<a name="l01391"></a>01391            EXTRACT_32BITS(tptr+4));
<a name="l01392"></a>01392         tptr+=8;
<a name="l01393"></a>01393         subl-=8;
<a name="l01394"></a>01394     }
<a name="l01395"></a>01395     <span class="keywordflow">break</span>;
<a name="l01396"></a>01396     <span class="keywordflow">default</span>:
<a name="l01397"></a>01397     <span class="keywordflow">if</span>(!print_unknown_data(tptr,<span class="stringliteral">&quot;\n\t\t    &quot;</span>,
<a name="l01398"></a>01398                    subl))
<a name="l01399"></a>01399       <span class="keywordflow">return</span>(0);
<a name="l01400"></a>01400     <span class="keywordflow">break</span>;
<a name="l01401"></a>01401     }
<a name="l01402"></a>01402     <span class="keywordflow">return</span>(1);
<a name="l01403"></a>01403     
<a name="l01404"></a>01404 trunctlv:
<a name="l01405"></a>01405     printf(<span class="stringliteral">&quot;%spacket exceeded snapshot&quot;</span>,ident);
<a name="l01406"></a>01406     <span class="keywordflow">return</span>(0);
<a name="l01407"></a>01407 }
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 <span class="comment">/*</span>
<a name="l01410"></a>01410 <span class="comment"> * this is the common IS-REACH subTLV decoder it is called</span>
<a name="l01411"></a>01411 <span class="comment"> * from isis_print_ext_is_reach()</span>
<a name="l01412"></a>01412 <span class="comment"> */</span>
<a name="l01413"></a>01413 
<a name="l01414"></a>01414 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01415"></a>01415 isis_print_is_reach_subtlv (<span class="keyword">const</span> u_int8_t *tptr,u_int subt,u_int subl,<span class="keyword">const</span> <span class="keywordtype">char</span> *ident) {
<a name="l01416"></a>01416 
<a name="l01417"></a>01417         u_int te_class,priority_level,gmpls_switch_cap;
<a name="l01418"></a>01418         <span class="keyword">union </span>{ <span class="comment">/* int to float conversion buffer for several subTLVs */</span>
<a name="l01419"></a>01419             <span class="keywordtype">float</span> f; 
<a name="l01420"></a>01420             u_int32_t i;
<a name="l01421"></a>01421         } bw;
<a name="l01422"></a>01422 
<a name="l01423"></a>01423         <span class="comment">/* first lets see if we know the subTLVs name*/</span>
<a name="l01424"></a>01424     printf(<span class="stringliteral">&quot;%s%s subTLV #%u, length: %u&quot;</span>,
<a name="l01425"></a>01425            ident,
<a name="l01426"></a>01426                tok2str(isis_ext_is_reach_subtlv_values,
<a name="l01427"></a>01427                        <span class="stringliteral">&quot;unknown&quot;</span>,
<a name="l01428"></a>01428                        subt),
<a name="l01429"></a>01429                subt,
<a name="l01430"></a>01430                subl);
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     <span class="keywordflow">if</span> (!TTEST2(*tptr,subl))
<a name="l01433"></a>01433         <span class="keywordflow">goto</span> trunctlv;
<a name="l01434"></a>01434 
<a name="l01435"></a>01435         <span class="keywordflow">switch</span>(subt) {
<a name="l01436"></a>01436         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:      
<a name="l01437"></a>01437         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:
<a name="l01438"></a>01438         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:
<a name="l01439"></a>01439         <span class="keywordflow">if</span> (subl &gt;= 4) {
<a name="l01440"></a>01440           printf(<span class="stringliteral">&quot;, 0x%08x&quot;</span>, EXTRACT_32BITS(tptr));
<a name="l01441"></a>01441           <span class="keywordflow">if</span> (subl == 8) <span class="comment">/* rfc4205 */</span>
<a name="l01442"></a>01442             printf(<span class="stringliteral">&quot;, 0x%08x&quot;</span>, EXTRACT_32BITS(tptr+4));
<a name="l01443"></a>01443         }
<a name="l01444"></a>01444         <span class="keywordflow">break</span>;
<a name="l01445"></a>01445         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:
<a name="l01446"></a>01446         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:
<a name="l01447"></a>01447             <span class="keywordflow">if</span> (subl &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr))
<a name="l01448"></a>01448               printf(<span class="stringliteral">&quot;, %s&quot;</span>, ipaddr_string(tptr));
<a name="l01449"></a>01449             <span class="keywordflow">break</span>;
<a name="l01450"></a>01450         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :
<a name="l01451"></a>01451     <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:  
<a name="l01452"></a>01452             <span class="keywordflow">if</span> (subl &gt;= 4) {
<a name="l01453"></a>01453               bw.i = EXTRACT_32BITS(tptr);
<a name="l01454"></a>01454               printf(<span class="stringliteral">&quot;, %.3f Mbps&quot;</span>, bw.f*8/1000000 );
<a name="l01455"></a>01455             }
<a name="l01456"></a>01456             <span class="keywordflow">break</span>;
<a name="l01457"></a>01457         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :
<a name="l01458"></a>01458             <span class="keywordflow">if</span> (subl &gt;= 32) {
<a name="l01459"></a>01459               <span class="keywordflow">for</span> (te_class = 0; te_class &lt; 8; te_class++) {
<a name="l01460"></a>01460                 bw.i = EXTRACT_32BITS(tptr);
<a name="l01461"></a>01461                 printf(<span class="stringliteral">&quot;%s  TE-Class %u: %.3f Mbps&quot;</span>,
<a name="l01462"></a>01462                        ident,
<a name="l01463"></a>01463                        te_class,
<a name="l01464"></a>01464                        bw.f*8/1000000 );
<a name="l01465"></a>01465         tptr+=4;
<a name="l01466"></a>01466           }
<a name="l01467"></a>01467             }
<a name="l01468"></a>01468             <span class="keywordflow">break</span>;
<a name="l01469"></a>01469         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: <span class="comment">/* fall through */</span>
<a name="l01470"></a>01470         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:
<a name="l01471"></a>01471             printf(<span class="stringliteral">&quot;%sBandwidth Constraints Model ID: %s (%u)&quot;</span>,
<a name="l01472"></a>01472                    ident,
<a name="l01473"></a>01473                    tok2str(diffserv_te_bc_values, <span class="stringliteral">&quot;unknown&quot;</span>, *tptr),
<a name="l01474"></a>01474                    *tptr);
<a name="l01475"></a>01475             tptr++;
<a name="l01476"></a>01476             <span class="comment">/* decode BCs until the subTLV ends */</span>
<a name="l01477"></a>01477             <span class="keywordflow">for</span> (te_class = 0; te_class &lt; (subl-1)/4; te_class++) {
<a name="l01478"></a>01478                 bw.i = EXTRACT_32BITS(tptr);
<a name="l01479"></a>01479                 printf(<span class="stringliteral">&quot;%s  Bandwidth constraint CT%u: %.3f Mbps&quot;</span>,
<a name="l01480"></a>01480                        ident,
<a name="l01481"></a>01481                        te_class,
<a name="l01482"></a>01482                        bw.f*8/1000000 );
<a name="l01483"></a>01483         tptr+=4;
<a name="l01484"></a>01484             }
<a name="l01485"></a>01485             <span class="keywordflow">break</span>;
<a name="l01486"></a>01486         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:
<a name="l01487"></a>01487             <span class="keywordflow">if</span> (subl &gt;= 3)
<a name="l01488"></a>01488               printf(<span class="stringliteral">&quot;, %u&quot;</span>, EXTRACT_24BITS(tptr));
<a name="l01489"></a>01489             <span class="keywordflow">break</span>;
<a name="l01490"></a>01490         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:
<a name="l01491"></a>01491             <span class="keywordflow">if</span> (subl == 2) {
<a name="l01492"></a>01492                printf(<span class="stringliteral">&quot;, [ %s ] (0x%04x)&quot;</span>,
<a name="l01493"></a>01493                       bittok2str(isis_subtlv_link_attribute_values,
<a name="l01494"></a>01494                                  <span class="stringliteral">&quot;Unknown&quot;</span>,
<a name="l01495"></a>01495                                  EXTRACT_16BITS(tptr)),
<a name="l01496"></a>01496                       EXTRACT_16BITS(tptr));
<a name="l01497"></a>01497             }
<a name="l01498"></a>01498             <span class="keywordflow">break</span>;
<a name="l01499"></a>01499         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:
<a name="l01500"></a>01500             <span class="keywordflow">if</span> (subl &gt;= 2) {
<a name="l01501"></a>01501               printf(<span class="stringliteral">&quot;, %s, Priority %u&quot;</span>,
<a name="l01502"></a>01502            bittok2str(gmpls_link_prot_values, <span class="stringliteral">&quot;none&quot;</span>, *tptr),
<a name="l01503"></a>01503                    *(tptr+1));
<a name="l01504"></a>01504             }
<a name="l01505"></a>01505             <span class="keywordflow">break</span>;
<a name="l01506"></a>01506         <span class="keywordflow">case</span> ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:
<a name="l01507"></a>01507             <span class="keywordflow">if</span> (subl &gt;= 36) {
<a name="l01508"></a>01508               gmpls_switch_cap = *tptr;
<a name="l01509"></a>01509               printf(<span class="stringliteral">&quot;%s  Interface Switching Capability:%s&quot;</span>,
<a name="l01510"></a>01510                    ident,
<a name="l01511"></a>01511                    tok2str(gmpls_switch_cap_values, <span class="stringliteral">&quot;Unknown&quot;</span>, gmpls_switch_cap));
<a name="l01512"></a>01512               printf(<span class="stringliteral">&quot;, LSP Encoding: %s&quot;</span>,
<a name="l01513"></a>01513                    tok2str(gmpls_encoding_values, <span class="stringliteral">&quot;Unknown&quot;</span>, *(tptr+1)));
<a name="l01514"></a>01514           tptr+=4;
<a name="l01515"></a>01515               printf(<span class="stringliteral">&quot;%s  Max LSP Bandwidth:&quot;</span>,ident);
<a name="l01516"></a>01516               <span class="keywordflow">for</span> (priority_level = 0; priority_level &lt; 8; priority_level++) {
<a name="l01517"></a>01517                 bw.i = EXTRACT_32BITS(tptr);
<a name="l01518"></a>01518                 printf(<span class="stringliteral">&quot;%s    priority level %d: %.3f Mbps&quot;</span>,
<a name="l01519"></a>01519                        ident,
<a name="l01520"></a>01520                        priority_level,
<a name="l01521"></a>01521                        bw.f*8/1000000 );
<a name="l01522"></a>01522         tptr+=4;
<a name="l01523"></a>01523               }
<a name="l01524"></a>01524               subl-=36;
<a name="l01525"></a>01525               <span class="keywordflow">switch</span> (gmpls_switch_cap) {
<a name="l01526"></a>01526               <span class="keywordflow">case</span> GMPLS_PSC1:
<a name="l01527"></a>01527               <span class="keywordflow">case</span> GMPLS_PSC2:
<a name="l01528"></a>01528               <span class="keywordflow">case</span> GMPLS_PSC3:
<a name="l01529"></a>01529               <span class="keywordflow">case</span> GMPLS_PSC4:
<a name="l01530"></a>01530                 bw.i = EXTRACT_32BITS(tptr);
<a name="l01531"></a>01531                 printf(<span class="stringliteral">&quot;%s  Min LSP Bandwidth: %.3f Mbps&quot;</span>, ident, bw.f*8/1000000);
<a name="l01532"></a>01532                 printf(<span class="stringliteral">&quot;%s  Interface MTU: %u&quot;</span>, ident, EXTRACT_16BITS(tptr+4));
<a name="l01533"></a>01533                 <span class="keywordflow">break</span>;
<a name="l01534"></a>01534               <span class="keywordflow">case</span> GMPLS_TSC:
<a name="l01535"></a>01535                 bw.i = EXTRACT_32BITS(tptr);
<a name="l01536"></a>01536                 printf(<span class="stringliteral">&quot;%s  Min LSP Bandwidth: %.3f Mbps&quot;</span>, ident, bw.f*8/1000000);
<a name="l01537"></a>01537                 printf(<span class="stringliteral">&quot;%s  Indication %s&quot;</span>, ident,
<a name="l01538"></a>01538                        tok2str(gmpls_switch_cap_tsc_indication_values, <span class="stringliteral">&quot;Unknown (%u)&quot;</span>, *(tptr+4)));
<a name="l01539"></a>01539                 <span class="keywordflow">break</span>;
<a name="l01540"></a>01540               <span class="keywordflow">default</span>:
<a name="l01541"></a>01541                 <span class="comment">/* there is some optional stuff left to decode but this is as of yet</span>
<a name="l01542"></a>01542 <span class="comment">                   not specified so just lets hexdump what is left */</span>
<a name="l01543"></a>01543                 <span class="keywordflow">if</span>(subl&gt;0){
<a name="l01544"></a>01544                   <span class="keywordflow">if</span>(!print_unknown_data(tptr,<span class="stringliteral">&quot;\n\t\t    &quot;</span>,
<a name="l01545"></a>01545                                          subl))
<a name="l01546"></a>01546                     <span class="keywordflow">return</span>(0);
<a name="l01547"></a>01547                 }
<a name="l01548"></a>01548               }
<a name="l01549"></a>01549             }
<a name="l01550"></a>01550             <span class="keywordflow">break</span>;
<a name="l01551"></a>01551         <span class="keywordflow">default</span>:
<a name="l01552"></a>01552             <span class="keywordflow">if</span>(!print_unknown_data(tptr,<span class="stringliteral">&quot;\n\t\t    &quot;</span>,
<a name="l01553"></a>01553                    subl))
<a name="l01554"></a>01554                 <span class="keywordflow">return</span>(0);
<a name="l01555"></a>01555             <span class="keywordflow">break</span>;
<a name="l01556"></a>01556         }
<a name="l01557"></a>01557         <span class="keywordflow">return</span>(1);
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 trunctlv:
<a name="l01560"></a>01560     printf(<span class="stringliteral">&quot;%spacket exceeded snapshot&quot;</span>,ident);
<a name="l01561"></a>01561     <span class="keywordflow">return</span>(0);
<a name="l01562"></a>01562 }
<a name="l01563"></a>01563 
<a name="l01564"></a>01564 
<a name="l01565"></a>01565 <span class="comment">/*</span>
<a name="l01566"></a>01566 <span class="comment"> * this is the common IS-REACH decoder it is called</span>
<a name="l01567"></a>01567 <span class="comment"> * from various EXTD-IS REACH style TLVs (22,24,222)</span>
<a name="l01568"></a>01568 <span class="comment"> */</span>
<a name="l01569"></a>01569 
<a name="l01570"></a>01570 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01571"></a>01571 isis_print_ext_is_reach (<span class="keyword">const</span> u_int8_t *tptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *ident, <span class="keywordtype">int</span> tlv_type) {
<a name="l01572"></a>01572 
<a name="l01573"></a>01573     <span class="keywordtype">char</span> ident_buffer[20];
<a name="l01574"></a>01574     <span class="keywordtype">int</span> subtlv_type,subtlv_len,subtlv_sum_len;
<a name="l01575"></a>01575     <span class="keywordtype">int</span> proc_bytes = 0; <span class="comment">/* how many bytes did we process ? */</span>
<a name="l01576"></a>01576     
<a name="l01577"></a>01577     <span class="keywordflow">if</span> (!TTEST2(*tptr, NODE_ID_LEN))
<a name="l01578"></a>01578         <span class="keywordflow">return</span>(0);
<a name="l01579"></a>01579 
<a name="l01580"></a>01580     printf(<span class="stringliteral">&quot;%sIS Neighbor: %s&quot;</span>, ident, isis_print_id(tptr, NODE_ID_LEN));
<a name="l01581"></a>01581     tptr+=(NODE_ID_LEN);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583     <span class="keywordflow">if</span> (tlv_type != ISIS_TLV_IS_ALIAS_ID) { <span class="comment">/* the Alias TLV Metric field is implicit 0 */</span>
<a name="l01584"></a>01584         <span class="keywordflow">if</span> (!TTEST2(*tptr, 3))    <span class="comment">/* and is therefore skipped */</span>
<a name="l01585"></a>01585         <span class="keywordflow">return</span>(0);
<a name="l01586"></a>01586     printf(<span class="stringliteral">&quot;, Metric: %d&quot;</span>,EXTRACT_24BITS(tptr));
<a name="l01587"></a>01587     tptr+=3;
<a name="l01588"></a>01588     }
<a name="l01589"></a>01589         
<a name="l01590"></a>01590     <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l01591"></a>01591         <span class="keywordflow">return</span>(0);
<a name="l01592"></a>01592     subtlv_sum_len=*(tptr++); <span class="comment">/* read out subTLV length */</span>
<a name="l01593"></a>01593     proc_bytes=NODE_ID_LEN+3+1;
<a name="l01594"></a>01594     printf(<span class="stringliteral">&quot;, %ssub-TLVs present&quot;</span>,subtlv_sum_len ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;no &quot;</span>);
<a name="l01595"></a>01595     <span class="keywordflow">if</span> (subtlv_sum_len) {
<a name="l01596"></a>01596         printf(<span class="stringliteral">&quot; (%u)&quot;</span>,subtlv_sum_len);
<a name="l01597"></a>01597         <span class="keywordflow">while</span> (subtlv_sum_len&gt;0) {
<a name="l01598"></a>01598             <span class="keywordflow">if</span> (!TTEST2(*tptr,2))
<a name="l01599"></a>01599                 <span class="keywordflow">return</span>(0);
<a name="l01600"></a>01600             subtlv_type=*(tptr++);
<a name="l01601"></a>01601             subtlv_len=*(tptr++);
<a name="l01602"></a>01602             <span class="comment">/* prepend the ident string */</span>
<a name="l01603"></a>01603             snprintf(ident_buffer, <span class="keyword">sizeof</span>(ident_buffer), <span class="stringliteral">&quot;%s  &quot;</span>,ident);
<a name="l01604"></a>01604             <span class="keywordflow">if</span>(!isis_print_is_reach_subtlv(tptr,subtlv_type,subtlv_len,ident_buffer))
<a name="l01605"></a>01605                 <span class="keywordflow">return</span>(0);
<a name="l01606"></a>01606             tptr+=subtlv_len;
<a name="l01607"></a>01607             subtlv_sum_len-=(subtlv_len+2);
<a name="l01608"></a>01608             proc_bytes+=(subtlv_len+2);
<a name="l01609"></a>01609         }
<a name="l01610"></a>01610     }
<a name="l01611"></a>01611     <span class="keywordflow">return</span>(proc_bytes);
<a name="l01612"></a>01612 }
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 <span class="comment">/*</span>
<a name="l01615"></a>01615 <span class="comment"> * this is the common Multi Topology ID decoder</span>
<a name="l01616"></a>01616 <span class="comment"> * it is called from various MT-TLVs (222,229,235,237)</span>
<a name="l01617"></a>01617 <span class="comment"> */</span>
<a name="l01618"></a>01618 
<a name="l01619"></a>01619 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01620"></a>01620 isis_print_mtid (<span class="keyword">const</span> u_int8_t *tptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *ident) {
<a name="l01621"></a>01621     
<a name="l01622"></a>01622     <span class="keywordflow">if</span> (!TTEST2(*tptr, 2))
<a name="l01623"></a>01623         <span class="keywordflow">return</span>(0);
<a name="l01624"></a>01624 
<a name="l01625"></a>01625     printf(<span class="stringliteral">&quot;%s%s&quot;</span>,
<a name="l01626"></a>01626            ident,
<a name="l01627"></a>01627            tok2str(isis_mt_values,
<a name="l01628"></a>01628                    <span class="stringliteral">&quot;Reserved for IETF Consensus&quot;</span>,
<a name="l01629"></a>01629                    ISIS_MASK_MTID(EXTRACT_16BITS(tptr))));
<a name="l01630"></a>01630 
<a name="l01631"></a>01631     printf(<span class="stringliteral">&quot; Topology (0x%03x), Flags: [%s]&quot;</span>,
<a name="l01632"></a>01632            ISIS_MASK_MTID(EXTRACT_16BITS(tptr)),
<a name="l01633"></a>01633            bittok2str(isis_mt_flag_values, <span class="stringliteral">&quot;none&quot;</span>,ISIS_MASK_MTFLAGS(EXTRACT_16BITS(tptr))));
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     <span class="keywordflow">return</span>(2);
<a name="l01636"></a>01636 }
<a name="l01637"></a>01637 
<a name="l01638"></a>01638 <span class="comment">/*</span>
<a name="l01639"></a>01639 <span class="comment"> * this is the common extended IP reach decoder</span>
<a name="l01640"></a>01640 <span class="comment"> * it is called from TLVs (135,235,236,237)</span>
<a name="l01641"></a>01641 <span class="comment"> * we process the TLV and optional subTLVs and return</span>
<a name="l01642"></a>01642 <span class="comment"> * the amount of processed bytes</span>
<a name="l01643"></a>01643 <span class="comment"> */</span>
<a name="l01644"></a>01644 
<a name="l01645"></a>01645 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01646"></a>01646 isis_print_extd_ip_reach (<span class="keyword">const</span> u_int8_t *tptr, <span class="keyword">const</span> <span class="keywordtype">char</span> *ident, u_int16_t afi) {
<a name="l01647"></a>01647 
<a name="l01648"></a>01648     <span class="keywordtype">char</span> ident_buffer[20];
<a name="l01649"></a>01649 <span class="preprocessor">#ifdef INET6</span>
<a name="l01650"></a>01650 <span class="preprocessor"></span>    u_int8_t prefix[<span class="keyword">sizeof</span>(<span class="keyword">struct </span>in6_addr)]; <span class="comment">/* shared copy buffer for IPv4 and IPv6 prefixes */</span>
<a name="l01651"></a>01651 <span class="preprocessor">#else</span>
<a name="l01652"></a>01652 <span class="preprocessor"></span>    u_int8_t prefix[<span class="keyword">sizeof</span>(<span class="keyword">struct </span>in_addr)]; <span class="comment">/* shared copy buffer for IPv4 prefixes */</span>
<a name="l01653"></a>01653 <span class="preprocessor">#endif</span>
<a name="l01654"></a>01654 <span class="preprocessor"></span>    u_int metric, status_byte, bit_length, byte_length, sublen, processed, subtlvtype, subtlvlen;
<a name="l01655"></a>01655 
<a name="l01656"></a>01656     <span class="keywordflow">if</span> (!TTEST2(*tptr, 4))
<a name="l01657"></a>01657         <span class="keywordflow">return</span> (0);
<a name="l01658"></a>01658     metric = EXTRACT_32BITS(tptr);
<a name="l01659"></a>01659     processed=4;
<a name="l01660"></a>01660     tptr+=4;
<a name="l01661"></a>01661     
<a name="l01662"></a>01662     <span class="keywordflow">if</span> (afi == AF_INET) {
<a name="l01663"></a>01663         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1)) <span class="comment">/* fetch status byte */</span>
<a name="l01664"></a>01664             <span class="keywordflow">return</span> (0);
<a name="l01665"></a>01665         status_byte=*(tptr++);
<a name="l01666"></a>01666         bit_length = status_byte&amp;0x3f;
<a name="l01667"></a>01667         <span class="keywordflow">if</span> (bit_length &gt; 32) {
<a name="l01668"></a>01668             printf(<span class="stringliteral">&quot;%sIPv4 prefix: bad bit length %u&quot;</span>,
<a name="l01669"></a>01669                    ident,
<a name="l01670"></a>01670                    bit_length);
<a name="l01671"></a>01671             <span class="keywordflow">return</span> (0);
<a name="l01672"></a>01672         }
<a name="l01673"></a>01673         processed++;
<a name="l01674"></a>01674 <span class="preprocessor">#ifdef INET6</span>
<a name="l01675"></a>01675 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (afi == AF_INET6) {
<a name="l01676"></a>01676         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1)) <span class="comment">/* fetch status &amp; prefix_len byte */</span>
<a name="l01677"></a>01677             <span class="keywordflow">return</span> (0);
<a name="l01678"></a>01678         status_byte=*(tptr++);
<a name="l01679"></a>01679         bit_length=*(tptr++);
<a name="l01680"></a>01680         <span class="keywordflow">if</span> (bit_length &gt; 128) {
<a name="l01681"></a>01681             printf(<span class="stringliteral">&quot;%sIPv6 prefix: bad bit length %u&quot;</span>,
<a name="l01682"></a>01682                    ident,
<a name="l01683"></a>01683                    bit_length);
<a name="l01684"></a>01684             <span class="keywordflow">return</span> (0);
<a name="l01685"></a>01685         }
<a name="l01686"></a>01686         processed+=2;
<a name="l01687"></a>01687 <span class="preprocessor">#endif</span>
<a name="l01688"></a>01688 <span class="preprocessor"></span>    } <span class="keywordflow">else</span>
<a name="l01689"></a>01689         <span class="keywordflow">return</span> (0); <span class="comment">/* somebody is fooling us */</span>
<a name="l01690"></a>01690 
<a name="l01691"></a>01691     byte_length = (bit_length + 7) / 8; <span class="comment">/* prefix has variable length encoding */</span>
<a name="l01692"></a>01692    
<a name="l01693"></a>01693     <span class="keywordflow">if</span> (!TTEST2(*tptr, byte_length))
<a name="l01694"></a>01694         <span class="keywordflow">return</span> (0);
<a name="l01695"></a>01695     memset(prefix, 0, <span class="keyword">sizeof</span> prefix);   <span class="comment">/* clear the copy buffer */</span>
<a name="l01696"></a>01696     memcpy(prefix,tptr,byte_length);    <span class="comment">/* copy as much as is stored in the TLV */</span>
<a name="l01697"></a>01697     tptr+=byte_length;
<a name="l01698"></a>01698     processed+=byte_length;
<a name="l01699"></a>01699 
<a name="l01700"></a>01700     <span class="keywordflow">if</span> (afi == AF_INET)
<a name="l01701"></a>01701         printf(<span class="stringliteral">&quot;%sIPv4 prefix: %15s/%u&quot;</span>,
<a name="l01702"></a>01702                ident,
<a name="l01703"></a>01703                ipaddr_string(prefix),
<a name="l01704"></a>01704                bit_length);
<a name="l01705"></a>01705 <span class="preprocessor">#ifdef INET6</span>
<a name="l01706"></a>01706 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (afi == AF_INET6)
<a name="l01707"></a>01707         printf(<span class="stringliteral">&quot;%sIPv6 prefix: %s/%u&quot;</span>,
<a name="l01708"></a>01708                ident,
<a name="l01709"></a>01709                ip6addr_string(prefix),
<a name="l01710"></a>01710                bit_length);
<a name="l01711"></a>01711 <span class="preprocessor">#endif </span>
<a name="l01712"></a>01712 <span class="preprocessor"></span>   
<a name="l01713"></a>01713     printf(<span class="stringliteral">&quot;, Distribution: %s, Metric: %u&quot;</span>,
<a name="l01714"></a>01714            ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? <span class="stringliteral">&quot;down&quot;</span> : <span class="stringliteral">&quot;up&quot;</span>,
<a name="l01715"></a>01715            metric);
<a name="l01716"></a>01716 
<a name="l01717"></a>01717     <span class="keywordflow">if</span> (afi == AF_INET &amp;&amp; ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))
<a name="l01718"></a>01718         printf(<span class="stringliteral">&quot;, sub-TLVs present&quot;</span>);
<a name="l01719"></a>01719 <span class="preprocessor">#ifdef INET6</span>
<a name="l01720"></a>01720 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (afi == AF_INET6)
<a name="l01721"></a>01721         printf(<span class="stringliteral">&quot;, %s%s&quot;</span>,
<a name="l01722"></a>01722                ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? <span class="stringliteral">&quot;External&quot;</span> : <span class="stringliteral">&quot;Internal&quot;</span>,
<a name="l01723"></a>01723                ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? <span class="stringliteral">&quot;, sub-TLVs present&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l01724"></a>01724 <span class="preprocessor">#endif</span>
<a name="l01725"></a>01725 <span class="preprocessor"></span>    
<a name="l01726"></a>01726     <span class="keywordflow">if</span> ((afi == AF_INET  &amp;&amp; ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))
<a name="l01727"></a>01727 #ifdef INET6
<a name="l01728"></a>01728      || (afi == AF_INET6 &amp;&amp; ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte))
<a name="l01729"></a>01729 #endif
<a name="l01730"></a>01730     ) {
<a name="l01731"></a>01731         <span class="comment">/* assume that one prefix can hold more</span>
<a name="l01732"></a>01732 <span class="comment">           than one subTLV - therefore the first byte must reflect</span>
<a name="l01733"></a>01733 <span class="comment">           the aggregate bytecount of the subTLVs for this prefix</span>
<a name="l01734"></a>01734 <span class="comment">        */</span>
<a name="l01735"></a>01735         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l01736"></a>01736             <span class="keywordflow">return</span> (0);
<a name="l01737"></a>01737         sublen=*(tptr++);
<a name="l01738"></a>01738         processed+=sublen+1;
<a name="l01739"></a>01739         printf(<span class="stringliteral">&quot; (%u)&quot;</span>,sublen);   <span class="comment">/* print out subTLV length */</span>
<a name="l01740"></a>01740         
<a name="l01741"></a>01741         <span class="keywordflow">while</span> (sublen&gt;0) {
<a name="l01742"></a>01742             <span class="keywordflow">if</span> (!TTEST2(*tptr,2))
<a name="l01743"></a>01743                 <span class="keywordflow">return</span> (0);
<a name="l01744"></a>01744             subtlvtype=*(tptr++);
<a name="l01745"></a>01745             subtlvlen=*(tptr++);
<a name="l01746"></a>01746             <span class="comment">/* prepend the ident string */</span>
<a name="l01747"></a>01747             snprintf(ident_buffer, <span class="keyword">sizeof</span>(ident_buffer), <span class="stringliteral">&quot;%s  &quot;</span>,ident);
<a name="l01748"></a>01748             <span class="keywordflow">if</span>(!isis_print_ip_reach_subtlv(tptr,subtlvtype,subtlvlen,ident_buffer))
<a name="l01749"></a>01749                 <span class="keywordflow">return</span>(0);
<a name="l01750"></a>01750             tptr+=subtlvlen;
<a name="l01751"></a>01751             sublen-=(subtlvlen+2);
<a name="l01752"></a>01752         }
<a name="l01753"></a>01753     }
<a name="l01754"></a>01754     <span class="keywordflow">return</span> (processed);
<a name="l01755"></a>01755 }
<a name="l01756"></a>01756 
<a name="l01757"></a>01757 <span class="comment">/*</span>
<a name="l01758"></a>01758 <span class="comment"> * isis_print</span>
<a name="l01759"></a>01759 <span class="comment"> * Decode IS-IS packets.  Return 0 on error.</span>
<a name="l01760"></a>01760 <span class="comment"> */</span>
<a name="l01761"></a>01761 
<a name="l01762"></a>01762 <span class="keyword">static</span> <span class="keywordtype">int</span> isis_print (<span class="keyword">const</span> u_int8_t *p, u_int length)
<a name="l01763"></a>01763 {
<a name="l01764"></a>01764     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__common__header.html">isis_common_header</a> *isis_header;
<a name="l01765"></a>01765 
<a name="l01766"></a>01766     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__iih__lan__header.html">isis_iih_lan_header</a> *header_iih_lan;
<a name="l01767"></a>01767     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__iih__ptp__header.html">isis_iih_ptp_header</a> *header_iih_ptp;
<a name="l01768"></a>01768     <span class="keyword">struct </span><a class="code" href="structisis__lsp__header.html">isis_lsp_header</a> *header_lsp;
<a name="l01769"></a>01769     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__csnp__header.html">isis_csnp_header</a> *header_csnp;
<a name="l01770"></a>01770     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__psnp__header.html">isis_psnp_header</a> *header_psnp;
<a name="l01771"></a>01771 
<a name="l01772"></a>01772     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__lsp.html">isis_tlv_lsp</a> *tlv_lsp;
<a name="l01773"></a>01773     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__ptp__adj.html">isis_tlv_ptp_adj</a> *tlv_ptp_adj;
<a name="l01774"></a>01774     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__is__reach.html">isis_tlv_is_reach</a> *tlv_is_reach;
<a name="l01775"></a>01775     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__es__reach.html">isis_tlv_es_reach</a> *tlv_es_reach;
<a name="l01776"></a>01776 
<a name="l01777"></a>01777     u_int8_t pdu_type, max_area, id_length, tlv_type, tlv_len, tmp, alen, lan_alen, prefix_len;
<a name="l01778"></a>01778     u_int8_t ext_is_len, ext_ip_len, mt_len;
<a name="l01779"></a>01779     <span class="keyword">const</span> u_int8_t *optr, *pptr, *tptr;
<a name="l01780"></a>01780     u_short packet_len,pdu_len;
<a name="l01781"></a>01781     u_int i,vendor_id;
<a name="l01782"></a>01782     <span class="keywordtype">int</span> sigcheck;
<a name="l01783"></a>01783 
<a name="l01784"></a>01784     packet_len=length;
<a name="l01785"></a>01785     optr = p; <span class="comment">/* initialize the _o_riginal pointer to the packet start -</span>
<a name="l01786"></a>01786 <span class="comment">                 need it for parsing the checksum TLV and authentication</span>
<a name="l01787"></a>01787 <span class="comment">                 TLV verification */</span>
<a name="l01788"></a>01788     isis_header = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__common__header.html">isis_common_header</a> *)p;
<a name="l01789"></a>01789     TCHECK(*isis_header);
<a name="l01790"></a>01790     pptr = p+(ISIS_COMMON_HEADER_SIZE);
<a name="l01791"></a>01791     header_iih_lan = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__iih__lan__header.html">isis_iih_lan_header</a> *)pptr;
<a name="l01792"></a>01792     header_iih_ptp = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__iih__ptp__header.html">isis_iih_ptp_header</a> *)pptr;
<a name="l01793"></a>01793     header_lsp = (<span class="keyword">struct </span><a class="code" href="structisis__lsp__header.html">isis_lsp_header</a> *)pptr;
<a name="l01794"></a>01794     header_csnp = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__csnp__header.html">isis_csnp_header</a> *)pptr;
<a name="l01795"></a>01795     header_psnp = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__psnp__header.html">isis_psnp_header</a> *)pptr;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797     <span class="keywordflow">if</span> (!eflag)
<a name="l01798"></a>01798         printf(<span class="stringliteral">&quot;IS-IS&quot;</span>);
<a name="l01799"></a>01799 
<a name="l01800"></a>01800     <span class="comment">/*</span>
<a name="l01801"></a>01801 <span class="comment">     * Sanity checking of the header.</span>
<a name="l01802"></a>01802 <span class="comment">     */</span>
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     <span class="keywordflow">if</span> (isis_header-&gt;version != ISIS_VERSION) {
<a name="l01805"></a>01805     printf(<span class="stringliteral">&quot;version %d packet not supported&quot;</span>, isis_header-&gt;version);
<a name="l01806"></a>01806     <span class="keywordflow">return</span> (0);
<a name="l01807"></a>01807     }
<a name="l01808"></a>01808 
<a name="l01809"></a>01809     <span class="keywordflow">if</span> ((isis_header-&gt;id_length != SYSTEM_ID_LEN) &amp;&amp; (isis_header-&gt;id_length != 0)) {
<a name="l01810"></a>01810     printf(<span class="stringliteral">&quot;system ID length of %d is not supported&quot;</span>,
<a name="l01811"></a>01811            isis_header-&gt;id_length);
<a name="l01812"></a>01812     <span class="keywordflow">return</span> (0);
<a name="l01813"></a>01813     }
<a name="l01814"></a>01814 
<a name="l01815"></a>01815     <span class="keywordflow">if</span> (isis_header-&gt;pdu_version != ISIS_VERSION) {
<a name="l01816"></a>01816     printf(<span class="stringliteral">&quot;version %d packet not supported&quot;</span>, isis_header-&gt;pdu_version);
<a name="l01817"></a>01817     <span class="keywordflow">return</span> (0);
<a name="l01818"></a>01818     }
<a name="l01819"></a>01819 
<a name="l01820"></a>01820     max_area = isis_header-&gt;max_area;
<a name="l01821"></a>01821     <span class="keywordflow">switch</span>(max_area) {
<a name="l01822"></a>01822     <span class="keywordflow">case</span> 0:
<a name="l01823"></a>01823     max_area = 3;    <span class="comment">/* silly shit */</span>
<a name="l01824"></a>01824     <span class="keywordflow">break</span>;
<a name="l01825"></a>01825     <span class="keywordflow">case</span> 255:
<a name="l01826"></a>01826     printf(<span class="stringliteral">&quot;bad packet -- 255 areas&quot;</span>);
<a name="l01827"></a>01827     <span class="keywordflow">return</span> (0);
<a name="l01828"></a>01828     <span class="keywordflow">default</span>:
<a name="l01829"></a>01829     <span class="keywordflow">break</span>;
<a name="l01830"></a>01830     }
<a name="l01831"></a>01831 
<a name="l01832"></a>01832     id_length = isis_header-&gt;id_length;
<a name="l01833"></a>01833     <span class="keywordflow">switch</span>(id_length) {
<a name="l01834"></a>01834     <span class="keywordflow">case</span> 0:
<a name="l01835"></a>01835         id_length = 6;   <span class="comment">/* silly shit again */</span>
<a name="l01836"></a>01836     <span class="keywordflow">break</span>;
<a name="l01837"></a>01837     <span class="keywordflow">case</span> 1:              <span class="comment">/* 1-8 are valid sys-ID lenghts */</span>
<a name="l01838"></a>01838     <span class="keywordflow">case</span> 2:
<a name="l01839"></a>01839     <span class="keywordflow">case</span> 3:
<a name="l01840"></a>01840     <span class="keywordflow">case</span> 4:
<a name="l01841"></a>01841     <span class="keywordflow">case</span> 5:
<a name="l01842"></a>01842     <span class="keywordflow">case</span> 6:
<a name="l01843"></a>01843     <span class="keywordflow">case</span> 7:
<a name="l01844"></a>01844     <span class="keywordflow">case</span> 8:
<a name="l01845"></a>01845         <span class="keywordflow">break</span>;
<a name="l01846"></a>01846     <span class="keywordflow">case</span> 255:
<a name="l01847"></a>01847         id_length = 0;   <span class="comment">/* entirely useless */</span>
<a name="l01848"></a>01848     <span class="keywordflow">break</span>;
<a name="l01849"></a>01849     <span class="keywordflow">default</span>:
<a name="l01850"></a>01850         <span class="keywordflow">break</span>;
<a name="l01851"></a>01851     }
<a name="l01852"></a>01852 
<a name="l01853"></a>01853     <span class="comment">/* toss any non 6-byte sys-ID len PDUs */</span>
<a name="l01854"></a>01854     <span class="keywordflow">if</span> (id_length != 6 ) { 
<a name="l01855"></a>01855     printf(<span class="stringliteral">&quot;bad packet -- illegal sys-ID length (%u)&quot;</span>, id_length);
<a name="l01856"></a>01856     <span class="keywordflow">return</span> (0);
<a name="l01857"></a>01857     }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859     pdu_type=isis_header-&gt;pdu_type;
<a name="l01860"></a>01860 
<a name="l01861"></a>01861     <span class="comment">/* in non-verbose mode print the basic PDU Type plus PDU specific brief information*/</span>
<a name="l01862"></a>01862     <span class="keywordflow">if</span> (vflag &lt; 1) {
<a name="l01863"></a>01863         printf(<span class="stringliteral">&quot;%s%s&quot;</span>,
<a name="l01864"></a>01864                eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,
<a name="l01865"></a>01865                tok2str(isis_pdu_values,<span class="stringliteral">&quot;unknown PDU-Type %u&quot;</span>,pdu_type));
<a name="l01866"></a>01866 
<a name="l01867"></a>01867     <span class="keywordflow">switch</span> (pdu_type) {
<a name="l01868"></a>01868 
<a name="l01869"></a>01869     <span class="keywordflow">case</span> ISIS_PDU_L1_LAN_IIH:
<a name="l01870"></a>01870     <span class="keywordflow">case</span> ISIS_PDU_L2_LAN_IIH:
<a name="l01871"></a>01871         printf(<span class="stringliteral">&quot;, src-id %s&quot;</span>,
<a name="l01872"></a>01872                    isis_print_id(header_iih_lan-&gt;source_id,SYSTEM_ID_LEN));
<a name="l01873"></a>01873         printf(<span class="stringliteral">&quot;, lan-id %s, prio %u&quot;</span>,
<a name="l01874"></a>01874                    isis_print_id(header_iih_lan-&gt;lan_id,NODE_ID_LEN),
<a name="l01875"></a>01875                    header_iih_lan-&gt;priority);
<a name="l01876"></a>01876         <span class="keywordflow">break</span>;
<a name="l01877"></a>01877     <span class="keywordflow">case</span> ISIS_PDU_PTP_IIH:
<a name="l01878"></a>01878         printf(<span class="stringliteral">&quot;, src-id %s&quot;</span>, isis_print_id(header_iih_ptp-&gt;source_id,SYSTEM_ID_LEN));
<a name="l01879"></a>01879         <span class="keywordflow">break</span>;
<a name="l01880"></a>01880     <span class="keywordflow">case</span> ISIS_PDU_L1_LSP:
<a name="l01881"></a>01881     <span class="keywordflow">case</span> ISIS_PDU_L2_LSP:
<a name="l01882"></a>01882         printf(<span class="stringliteral">&quot;, lsp-id %s, seq 0x%08x, lifetime %5us&quot;</span>,
<a name="l01883"></a>01883            isis_print_id(header_lsp-&gt;lsp_id, LSP_ID_LEN),
<a name="l01884"></a>01884            EXTRACT_32BITS(header_lsp-&gt;sequence_number),
<a name="l01885"></a>01885            EXTRACT_16BITS(header_lsp-&gt;remaining_lifetime));
<a name="l01886"></a>01886         <span class="keywordflow">break</span>;
<a name="l01887"></a>01887     <span class="keywordflow">case</span> ISIS_PDU_L1_CSNP:
<a name="l01888"></a>01888     <span class="keywordflow">case</span> ISIS_PDU_L2_CSNP:
<a name="l01889"></a>01889         printf(<span class="stringliteral">&quot;, src-id %s&quot;</span>, isis_print_id(header_csnp-&gt;source_id,NODE_ID_LEN));
<a name="l01890"></a>01890         <span class="keywordflow">break</span>;
<a name="l01891"></a>01891     <span class="keywordflow">case</span> ISIS_PDU_L1_PSNP:
<a name="l01892"></a>01892     <span class="keywordflow">case</span> ISIS_PDU_L2_PSNP:
<a name="l01893"></a>01893         printf(<span class="stringliteral">&quot;, src-id %s&quot;</span>, isis_print_id(header_psnp-&gt;source_id,NODE_ID_LEN));
<a name="l01894"></a>01894         <span class="keywordflow">break</span>;
<a name="l01895"></a>01895 
<a name="l01896"></a>01896     }
<a name="l01897"></a>01897     printf(<span class="stringliteral">&quot;, length %u&quot;</span>, length);
<a name="l01898"></a>01898 
<a name="l01899"></a>01899         <span class="keywordflow">return</span>(1);
<a name="l01900"></a>01900     }
<a name="l01901"></a>01901 
<a name="l01902"></a>01902     <span class="comment">/* ok they seem to want to know everything - lets fully decode it */</span>
<a name="l01903"></a>01903     printf(<span class="stringliteral">&quot;%slength %u&quot;</span>, eflag ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,length);
<a name="l01904"></a>01904 
<a name="l01905"></a>01905     printf(<span class="stringliteral">&quot;\n\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)&quot;</span>,
<a name="l01906"></a>01906            tok2str(isis_pdu_values,
<a name="l01907"></a>01907                    <span class="stringliteral">&quot;unknown, type %u&quot;</span>,
<a name="l01908"></a>01908                    pdu_type),
<a name="l01909"></a>01909            isis_header-&gt;fixed_len,
<a name="l01910"></a>01910            isis_header-&gt;version,
<a name="l01911"></a>01911            isis_header-&gt;pdu_version,
<a name="l01912"></a>01912        id_length,
<a name="l01913"></a>01913        isis_header-&gt;id_length,
<a name="l01914"></a>01914            max_area,
<a name="l01915"></a>01915            isis_header-&gt;max_area);
<a name="l01916"></a>01916 
<a name="l01917"></a>01917     <span class="keywordflow">if</span> (vflag &gt; 1) {
<a name="l01918"></a>01918         <span class="keywordflow">if</span>(!print_unknown_data(optr,<span class="stringliteral">&quot;\n\t&quot;</span>,8)) <span class="comment">/* provide the _o_riginal pointer */</span>
<a name="l01919"></a>01919             <span class="keywordflow">return</span>(0);                         <span class="comment">/* for optionally debugging the common header */</span>
<a name="l01920"></a>01920     }
<a name="l01921"></a>01921 
<a name="l01922"></a>01922     <span class="keywordflow">switch</span> (pdu_type) {
<a name="l01923"></a>01923 
<a name="l01924"></a>01924     <span class="keywordflow">case</span> ISIS_PDU_L1_LAN_IIH:
<a name="l01925"></a>01925     <span class="keywordflow">case</span> ISIS_PDU_L2_LAN_IIH:
<a name="l01926"></a>01926     <span class="keywordflow">if</span> (isis_header-&gt;fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)) {
<a name="l01927"></a>01927         printf(<span class="stringliteral">&quot;, bogus fixed header length %u should be %lu&quot;</span>,
<a name="l01928"></a>01928            isis_header-&gt;fixed_len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)ISIS_IIH_LAN_HEADER_SIZE);
<a name="l01929"></a>01929         <span class="keywordflow">return</span> (0);
<a name="l01930"></a>01930     }
<a name="l01931"></a>01931 
<a name="l01932"></a>01932     pdu_len=EXTRACT_16BITS(header_iih_lan-&gt;pdu_len);
<a name="l01933"></a>01933     <span class="keywordflow">if</span> (packet_len&gt;pdu_len) {
<a name="l01934"></a>01934             packet_len=pdu_len; <span class="comment">/* do TLV decoding as long as it makes sense */</span>
<a name="l01935"></a>01935             length=pdu_len;
<a name="l01936"></a>01936     }
<a name="l01937"></a>01937 
<a name="l01938"></a>01938     TCHECK(*header_iih_lan);
<a name="l01939"></a>01939     printf(<span class="stringliteral">&quot;\n\t  source-id: %s,  holding time: %us, Flags: [%s]&quot;</span>,
<a name="l01940"></a>01940                isis_print_id(header_iih_lan-&gt;source_id,SYSTEM_ID_LEN),
<a name="l01941"></a>01941                EXTRACT_16BITS(header_iih_lan-&gt;holding_time),
<a name="l01942"></a>01942                tok2str(isis_iih_circuit_type_values,
<a name="l01943"></a>01943                        <span class="stringliteral">&quot;unknown circuit type 0x%02x&quot;</span>,
<a name="l01944"></a>01944                        header_iih_lan-&gt;circuit_type));
<a name="l01945"></a>01945 
<a name="l01946"></a>01946     printf(<span class="stringliteral">&quot;\n\t  lan-id:    %s, Priority: %u, PDU length: %u&quot;</span>,
<a name="l01947"></a>01947                isis_print_id(header_iih_lan-&gt;lan_id, NODE_ID_LEN),
<a name="l01948"></a>01948                (header_iih_lan-&gt;priority) &amp; ISIS_LAN_PRIORITY_MASK,
<a name="l01949"></a>01949                pdu_len);
<a name="l01950"></a>01950 
<a name="l01951"></a>01951         <span class="keywordflow">if</span> (vflag &gt; 1) {
<a name="l01952"></a>01952             <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,ISIS_IIH_LAN_HEADER_SIZE))
<a name="l01953"></a>01953                 <span class="keywordflow">return</span>(0);
<a name="l01954"></a>01954         }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956     packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
<a name="l01957"></a>01957     pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
<a name="l01958"></a>01958     <span class="keywordflow">break</span>;
<a name="l01959"></a>01959 
<a name="l01960"></a>01960     <span class="keywordflow">case</span> ISIS_PDU_PTP_IIH:
<a name="l01961"></a>01961     <span class="keywordflow">if</span> (isis_header-&gt;fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)) {
<a name="l01962"></a>01962         printf(<span class="stringliteral">&quot;, bogus fixed header length %u should be %lu&quot;</span>,
<a name="l01963"></a>01963            isis_header-&gt;fixed_len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)ISIS_IIH_PTP_HEADER_SIZE);
<a name="l01964"></a>01964         <span class="keywordflow">return</span> (0);
<a name="l01965"></a>01965     }
<a name="l01966"></a>01966 
<a name="l01967"></a>01967     pdu_len=EXTRACT_16BITS(header_iih_ptp-&gt;pdu_len);
<a name="l01968"></a>01968     <span class="keywordflow">if</span> (packet_len&gt;pdu_len) {
<a name="l01969"></a>01969             packet_len=pdu_len; <span class="comment">/* do TLV decoding as long as it makes sense */</span>
<a name="l01970"></a>01970             length=pdu_len;
<a name="l01971"></a>01971     }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973     TCHECK(*header_iih_ptp);
<a name="l01974"></a>01974     printf(<span class="stringliteral">&quot;\n\t  source-id: %s, holding time: %us, Flags: [%s]&quot;</span>,
<a name="l01975"></a>01975                isis_print_id(header_iih_ptp-&gt;source_id,SYSTEM_ID_LEN),
<a name="l01976"></a>01976                EXTRACT_16BITS(header_iih_ptp-&gt;holding_time),
<a name="l01977"></a>01977                tok2str(isis_iih_circuit_type_values,
<a name="l01978"></a>01978                        <span class="stringliteral">&quot;unknown circuit type 0x%02x&quot;</span>,
<a name="l01979"></a>01979                        header_iih_ptp-&gt;circuit_type));
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     printf(<span class="stringliteral">&quot;\n\t  circuit-id: 0x%02x, PDU length: %u&quot;</span>,
<a name="l01982"></a>01982                header_iih_ptp-&gt;circuit_id,
<a name="l01983"></a>01983                pdu_len);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985         <span class="keywordflow">if</span> (vflag &gt; 1) {
<a name="l01986"></a>01986             <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,ISIS_IIH_PTP_HEADER_SIZE))
<a name="l01987"></a>01987                 <span class="keywordflow">return</span>(0);
<a name="l01988"></a>01988         }
<a name="l01989"></a>01989 
<a name="l01990"></a>01990     packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);
<a name="l01991"></a>01991     pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);
<a name="l01992"></a>01992     <span class="keywordflow">break</span>;
<a name="l01993"></a>01993 
<a name="l01994"></a>01994     <span class="keywordflow">case</span> ISIS_PDU_L1_LSP:
<a name="l01995"></a>01995     <span class="keywordflow">case</span> ISIS_PDU_L2_LSP:
<a name="l01996"></a>01996     <span class="keywordflow">if</span> (isis_header-&gt;fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)) {
<a name="l01997"></a>01997         printf(<span class="stringliteral">&quot;, bogus fixed header length %u should be %lu&quot;</span>,
<a name="l01998"></a>01998            isis_header-&gt;fixed_len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)ISIS_LSP_HEADER_SIZE);
<a name="l01999"></a>01999         <span class="keywordflow">return</span> (0);
<a name="l02000"></a>02000     }
<a name="l02001"></a>02001 
<a name="l02002"></a>02002     pdu_len=EXTRACT_16BITS(header_lsp-&gt;pdu_len);
<a name="l02003"></a>02003     <span class="keywordflow">if</span> (packet_len&gt;pdu_len) {
<a name="l02004"></a>02004             packet_len=pdu_len; <span class="comment">/* do TLV decoding as long as it makes sense */</span>
<a name="l02005"></a>02005             length=pdu_len;
<a name="l02006"></a>02006     }
<a name="l02007"></a>02007 
<a name="l02008"></a>02008     TCHECK(*header_lsp);
<a name="l02009"></a>02009     printf(<span class="stringliteral">&quot;\n\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\n\t  chksum: 0x%04x&quot;</span>,
<a name="l02010"></a>02010                isis_print_id(header_lsp-&gt;lsp_id, LSP_ID_LEN),
<a name="l02011"></a>02011                EXTRACT_32BITS(header_lsp-&gt;sequence_number),
<a name="l02012"></a>02012                EXTRACT_16BITS(header_lsp-&gt;remaining_lifetime),
<a name="l02013"></a>02013                EXTRACT_16BITS(header_lsp-&gt;checksum));
<a name="l02014"></a>02014 
<a name="l02015"></a>02015 
<a name="l02016"></a>02016         osi_print_cksum((u_int8_t *)header_lsp-&gt;lsp_id,
<a name="l02017"></a>02017                         EXTRACT_16BITS(header_lsp-&gt;checksum), 12, length-12);
<a name="l02018"></a>02018 
<a name="l02019"></a>02019         <span class="comment">/*</span>
<a name="l02020"></a>02020 <span class="comment">         * Clear checksum and lifetime prior to signature verification.</span>
<a name="l02021"></a>02021 <span class="comment">         */</span>
<a name="l02022"></a>02022         header_lsp-&gt;checksum[0] = 0;
<a name="l02023"></a>02023         header_lsp-&gt;checksum[1] = 0;
<a name="l02024"></a>02024         header_lsp-&gt;remaining_lifetime[0] = 0;
<a name="l02025"></a>02025         header_lsp-&gt;remaining_lifetime[1] = 0;
<a name="l02026"></a>02026         
<a name="l02027"></a>02027 
<a name="l02028"></a>02028     printf(<span class="stringliteral">&quot;, PDU length: %u, Flags: [ %s&quot;</span>,
<a name="l02029"></a>02029                pdu_len,
<a name="l02030"></a>02030                ISIS_MASK_LSP_OL_BIT(header_lsp-&gt;typeblock) ? <span class="stringliteral">&quot;Overload bit set, &quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l02031"></a>02031 
<a name="l02032"></a>02032     <span class="keywordflow">if</span> (ISIS_MASK_LSP_ATT_BITS(header_lsp-&gt;typeblock)) {
<a name="l02033"></a>02033         printf(<span class="stringliteral">&quot;%s&quot;</span>, ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp-&gt;typeblock) ? <span class="stringliteral">&quot;default &quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l02034"></a>02034         printf(<span class="stringliteral">&quot;%s&quot;</span>, ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp-&gt;typeblock) ? <span class="stringliteral">&quot;delay &quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l02035"></a>02035         printf(<span class="stringliteral">&quot;%s&quot;</span>, ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp-&gt;typeblock) ? <span class="stringliteral">&quot;expense &quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l02036"></a>02036         printf(<span class="stringliteral">&quot;%s&quot;</span>, ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp-&gt;typeblock) ? <span class="stringliteral">&quot;error &quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l02037"></a>02037         printf(<span class="stringliteral">&quot;ATT bit set, &quot;</span>);
<a name="l02038"></a>02038     }
<a name="l02039"></a>02039     printf(<span class="stringliteral">&quot;%s&quot;</span>, ISIS_MASK_LSP_PARTITION_BIT(header_lsp-&gt;typeblock) ? <span class="stringliteral">&quot;P bit set, &quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l02040"></a>02040     printf(<span class="stringliteral">&quot;%s ]&quot;</span>, tok2str(isis_lsp_istype_values,<span class="stringliteral">&quot;Unknown(0x%x)&quot;</span>,ISIS_MASK_LSP_ISTYPE_BITS(header_lsp-&gt;typeblock)));
<a name="l02041"></a>02041 
<a name="l02042"></a>02042         <span class="keywordflow">if</span> (vflag &gt; 1) {
<a name="l02043"></a>02043             <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,ISIS_LSP_HEADER_SIZE))
<a name="l02044"></a>02044                 <span class="keywordflow">return</span>(0);
<a name="l02045"></a>02045         }
<a name="l02046"></a>02046 
<a name="l02047"></a>02047     packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);
<a name="l02048"></a>02048     pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);
<a name="l02049"></a>02049     <span class="keywordflow">break</span>;
<a name="l02050"></a>02050 
<a name="l02051"></a>02051     <span class="keywordflow">case</span> ISIS_PDU_L1_CSNP:
<a name="l02052"></a>02052     <span class="keywordflow">case</span> ISIS_PDU_L2_CSNP:
<a name="l02053"></a>02053     <span class="keywordflow">if</span> (isis_header-&gt;fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)) {
<a name="l02054"></a>02054         printf(<span class="stringliteral">&quot;, bogus fixed header length %u should be %lu&quot;</span>,
<a name="l02055"></a>02055            isis_header-&gt;fixed_len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)ISIS_CSNP_HEADER_SIZE);
<a name="l02056"></a>02056         <span class="keywordflow">return</span> (0);
<a name="l02057"></a>02057     }
<a name="l02058"></a>02058 
<a name="l02059"></a>02059     pdu_len=EXTRACT_16BITS(header_csnp-&gt;pdu_len);
<a name="l02060"></a>02060     <span class="keywordflow">if</span> (packet_len&gt;pdu_len) {
<a name="l02061"></a>02061             packet_len=pdu_len; <span class="comment">/* do TLV decoding as long as it makes sense */</span>
<a name="l02062"></a>02062             length=pdu_len;
<a name="l02063"></a>02063     }
<a name="l02064"></a>02064 
<a name="l02065"></a>02065     TCHECK(*header_csnp);
<a name="l02066"></a>02066     printf(<span class="stringliteral">&quot;\n\t  source-id:    %s, PDU length: %u&quot;</span>,
<a name="l02067"></a>02067                isis_print_id(header_csnp-&gt;source_id, NODE_ID_LEN),
<a name="l02068"></a>02068                pdu_len);
<a name="l02069"></a>02069     printf(<span class="stringliteral">&quot;\n\t  start lsp-id: %s&quot;</span>,
<a name="l02070"></a>02070                isis_print_id(header_csnp-&gt;start_lsp_id, LSP_ID_LEN));
<a name="l02071"></a>02071     printf(<span class="stringliteral">&quot;\n\t  end lsp-id:   %s&quot;</span>,
<a name="l02072"></a>02072                isis_print_id(header_csnp-&gt;end_lsp_id, LSP_ID_LEN));
<a name="l02073"></a>02073 
<a name="l02074"></a>02074         <span class="keywordflow">if</span> (vflag &gt; 1) {
<a name="l02075"></a>02075             <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,ISIS_CSNP_HEADER_SIZE))
<a name="l02076"></a>02076                 <span class="keywordflow">return</span>(0);
<a name="l02077"></a>02077         }
<a name="l02078"></a>02078 
<a name="l02079"></a>02079     packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);
<a name="l02080"></a>02080     pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);
<a name="l02081"></a>02081         <span class="keywordflow">break</span>;
<a name="l02082"></a>02082 
<a name="l02083"></a>02083     <span class="keywordflow">case</span> ISIS_PDU_L1_PSNP:
<a name="l02084"></a>02084     <span class="keywordflow">case</span> ISIS_PDU_L2_PSNP:
<a name="l02085"></a>02085     <span class="keywordflow">if</span> (isis_header-&gt;fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)) {
<a name="l02086"></a>02086         printf(<span class="stringliteral">&quot;- bogus fixed header length %u should be %lu&quot;</span>,
<a name="l02087"></a>02087            isis_header-&gt;fixed_len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)ISIS_PSNP_HEADER_SIZE);
<a name="l02088"></a>02088         <span class="keywordflow">return</span> (0);
<a name="l02089"></a>02089     }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091     pdu_len=EXTRACT_16BITS(header_psnp-&gt;pdu_len);
<a name="l02092"></a>02092     <span class="keywordflow">if</span> (packet_len&gt;pdu_len) {
<a name="l02093"></a>02093             packet_len=pdu_len; <span class="comment">/* do TLV decoding as long as it makes sense */</span>
<a name="l02094"></a>02094             length=pdu_len;
<a name="l02095"></a>02095     }
<a name="l02096"></a>02096 
<a name="l02097"></a>02097     TCHECK(*header_psnp);
<a name="l02098"></a>02098     printf(<span class="stringliteral">&quot;\n\t  source-id:    %s, PDU length: %u&quot;</span>,
<a name="l02099"></a>02099                isis_print_id(header_psnp-&gt;source_id, NODE_ID_LEN),
<a name="l02100"></a>02100                pdu_len);
<a name="l02101"></a>02101 
<a name="l02102"></a>02102         <span class="keywordflow">if</span> (vflag &gt; 1) {
<a name="l02103"></a>02103             <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,ISIS_PSNP_HEADER_SIZE))
<a name="l02104"></a>02104                 <span class="keywordflow">return</span>(0);
<a name="l02105"></a>02105         }
<a name="l02106"></a>02106 
<a name="l02107"></a>02107     packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
<a name="l02108"></a>02108     pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
<a name="l02109"></a>02109     <span class="keywordflow">break</span>;
<a name="l02110"></a>02110 
<a name="l02111"></a>02111     <span class="keywordflow">default</span>:
<a name="l02112"></a>02112     <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t  &quot;</span>,length))
<a name="l02113"></a>02113         <span class="keywordflow">return</span>(0);
<a name="l02114"></a>02114     <span class="keywordflow">return</span> (0);
<a name="l02115"></a>02115     }
<a name="l02116"></a>02116 
<a name="l02117"></a>02117     <span class="comment">/*</span>
<a name="l02118"></a>02118 <span class="comment">     * Now print the TLV&#39;s.</span>
<a name="l02119"></a>02119 <span class="comment">     */</span>
<a name="l02120"></a>02120 
<a name="l02121"></a>02121     <span class="keywordflow">while</span> (packet_len &gt;= 2) {
<a name="l02122"></a>02122         <span class="keywordflow">if</span> (pptr == snapend) {
<a name="l02123"></a>02123         <span class="keywordflow">return</span> (1);
<a name="l02124"></a>02124         }
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <span class="keywordflow">if</span> (!TTEST2(*pptr, 2)) {
<a name="l02127"></a>02127         printf(<span class="stringliteral">&quot;\n\t\t packet exceeded snapshot (%ld) bytes&quot;</span>,
<a name="l02128"></a>02128                    (<span class="keywordtype">long</span>)(pptr-snapend));
<a name="l02129"></a>02129         <span class="keywordflow">return</span> (1);
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131     tlv_type = *pptr++;
<a name="l02132"></a>02132     tlv_len = *pptr++;
<a name="l02133"></a>02133         tmp =tlv_len; <span class="comment">/* copy temporary len &amp; pointer to packet data */</span>
<a name="l02134"></a>02134         tptr = pptr;
<a name="l02135"></a>02135     packet_len -= 2;
<a name="l02136"></a>02136     <span class="keywordflow">if</span> (tlv_len &gt; packet_len) {
<a name="l02137"></a>02137         <span class="keywordflow">break</span>;
<a name="l02138"></a>02138     }
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         <span class="comment">/* first lets see if we know the TLVs name*/</span>
<a name="l02141"></a>02141     printf(<span class="stringliteral">&quot;\n\t    %s TLV #%u, length: %u&quot;</span>,
<a name="l02142"></a>02142                tok2str(isis_tlv_values,
<a name="l02143"></a>02143                        <span class="stringliteral">&quot;unknown&quot;</span>,
<a name="l02144"></a>02144                        tlv_type),
<a name="l02145"></a>02145                tlv_type,
<a name="l02146"></a>02146                tlv_len);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148         <span class="keywordflow">if</span> (tlv_len == 0) <span class="comment">/* something is malformed */</span>
<a name="l02149"></a>02149         <span class="keywordflow">continue</span>;
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         <span class="comment">/* now check if we have a decoder otherwise do a hexdump at the end*/</span>
<a name="l02152"></a>02152     <span class="keywordflow">switch</span> (tlv_type) {
<a name="l02153"></a>02153     <span class="keywordflow">case</span> ISIS_TLV_AREA_ADDR:
<a name="l02154"></a>02154         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l02155"></a>02155         <span class="keywordflow">goto</span> trunctlv;
<a name="l02156"></a>02156         alen = *tptr++;
<a name="l02157"></a>02157         <span class="keywordflow">while</span> (tmp &amp;&amp; alen &lt; tmp) {
<a name="l02158"></a>02158         printf(<span class="stringliteral">&quot;\n\t      Area address (length: %u): %s&quot;</span>,
<a name="l02159"></a>02159                        alen,
<a name="l02160"></a>02160                        isonsap_string(tptr,alen));
<a name="l02161"></a>02161         tptr += alen;
<a name="l02162"></a>02162         tmp -= alen + 1;
<a name="l02163"></a>02163         <span class="keywordflow">if</span> (tmp==0) <span class="comment">/* if this is the last area address do not attemt a boundary check */</span>
<a name="l02164"></a>02164                     <span class="keywordflow">break</span>;
<a name="l02165"></a>02165         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l02166"></a>02166             <span class="keywordflow">goto</span> trunctlv;
<a name="l02167"></a>02167         alen = *tptr++;
<a name="l02168"></a>02168         }
<a name="l02169"></a>02169         <span class="keywordflow">break</span>;
<a name="l02170"></a>02170     <span class="keywordflow">case</span> ISIS_TLV_ISNEIGH:
<a name="l02171"></a>02171         <span class="keywordflow">while</span> (tmp &gt;= ETHER_ADDR_LEN) {
<a name="l02172"></a>02172                 <span class="keywordflow">if</span> (!TTEST2(*tptr, ETHER_ADDR_LEN))
<a name="l02173"></a>02173                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02174"></a>02174                 printf(<span class="stringliteral">&quot;\n\t      SNPA: %s&quot;</span>,isis_print_id(tptr,ETHER_ADDR_LEN));
<a name="l02175"></a>02175                 tmp -= ETHER_ADDR_LEN;
<a name="l02176"></a>02176                 tptr += ETHER_ADDR_LEN;
<a name="l02177"></a>02177         }
<a name="l02178"></a>02178         <span class="keywordflow">break</span>;
<a name="l02179"></a>02179 
<a name="l02180"></a>02180         <span class="keywordflow">case</span> ISIS_TLV_ISNEIGH_VARLEN:
<a name="l02181"></a>02181             <span class="keywordflow">if</span> (!TTEST2(*tptr, 1) || tmp &lt; 3) <span class="comment">/* min. TLV length */</span>
<a name="l02182"></a>02182         <span class="keywordflow">goto</span> trunctlv;
<a name="l02183"></a>02183         lan_alen = *tptr++; <span class="comment">/* LAN address length */</span>
<a name="l02184"></a>02184         <span class="keywordflow">if</span> (lan_alen == 0) {
<a name="l02185"></a>02185                 printf(<span class="stringliteral">&quot;\n\t      LAN address length 0 bytes (invalid)&quot;</span>);
<a name="l02186"></a>02186                 <span class="keywordflow">break</span>;
<a name="l02187"></a>02187             }
<a name="l02188"></a>02188             tmp --;
<a name="l02189"></a>02189             printf(<span class="stringliteral">&quot;\n\t      LAN address length %u bytes &quot;</span>,lan_alen);
<a name="l02190"></a>02190         <span class="keywordflow">while</span> (tmp &gt;= lan_alen) {
<a name="l02191"></a>02191                 <span class="keywordflow">if</span> (!TTEST2(*tptr, lan_alen))
<a name="l02192"></a>02192                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02193"></a>02193                 printf(<span class="stringliteral">&quot;\n\t\tIS Neighbor: %s&quot;</span>,isis_print_id(tptr,lan_alen));
<a name="l02194"></a>02194                 tmp -= lan_alen;
<a name="l02195"></a>02195                 tptr +=lan_alen;
<a name="l02196"></a>02196             }
<a name="l02197"></a>02197             <span class="keywordflow">break</span>;
<a name="l02198"></a>02198 
<a name="l02199"></a>02199     <span class="keywordflow">case</span> ISIS_TLV_PADDING:
<a name="l02200"></a>02200         <span class="keywordflow">break</span>;
<a name="l02201"></a>02201 
<a name="l02202"></a>02202         <span class="keywordflow">case</span> ISIS_TLV_MT_IS_REACH:
<a name="l02203"></a>02203             mt_len = isis_print_mtid(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>);
<a name="l02204"></a>02204             <span class="keywordflow">if</span> (mt_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02205"></a>02205                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02206"></a>02206             tptr+=mt_len;
<a name="l02207"></a>02207             tmp-=mt_len;
<a name="l02208"></a>02208             <span class="keywordflow">while</span> (tmp &gt;= 2+NODE_ID_LEN+3+1) {
<a name="l02209"></a>02209                 ext_is_len = isis_print_ext_is_reach(tptr,<span class="stringliteral">&quot;\n\t      &quot;</span>,tlv_type);
<a name="l02210"></a>02210                 <span class="keywordflow">if</span> (ext_is_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02211"></a>02211                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02212"></a>02212                    
<a name="l02213"></a>02213                 tmp-=ext_is_len;
<a name="l02214"></a>02214                 tptr+=ext_is_len;
<a name="l02215"></a>02215             }
<a name="l02216"></a>02216             <span class="keywordflow">break</span>;
<a name="l02217"></a>02217 
<a name="l02218"></a>02218         <span class="keywordflow">case</span> ISIS_TLV_IS_ALIAS_ID:
<a name="l02219"></a>02219         <span class="keywordflow">while</span> (tmp &gt;= NODE_ID_LEN+1) { <span class="comment">/* is it worth attempting a decode ? */</span>
<a name="l02220"></a>02220             ext_is_len = isis_print_ext_is_reach(tptr,<span class="stringliteral">&quot;\n\t      &quot;</span>,tlv_type);
<a name="l02221"></a>02221         <span class="keywordflow">if</span> (ext_is_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02222"></a>02222                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02223"></a>02223         tmp-=ext_is_len;
<a name="l02224"></a>02224         tptr+=ext_is_len;
<a name="l02225"></a>02225         }
<a name="l02226"></a>02226         <span class="keywordflow">break</span>;
<a name="l02227"></a>02227 
<a name="l02228"></a>02228         <span class="keywordflow">case</span> ISIS_TLV_EXT_IS_REACH:
<a name="l02229"></a>02229             <span class="keywordflow">while</span> (tmp &gt;= NODE_ID_LEN+3+1) { <span class="comment">/* is it worth attempting a decode ? */</span>
<a name="l02230"></a>02230                 ext_is_len = isis_print_ext_is_reach(tptr,<span class="stringliteral">&quot;\n\t      &quot;</span>,tlv_type);
<a name="l02231"></a>02231                 <span class="keywordflow">if</span> (ext_is_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02232"></a>02232                     <span class="keywordflow">goto</span> trunctlv;                   
<a name="l02233"></a>02233                 tmp-=ext_is_len;
<a name="l02234"></a>02234                 tptr+=ext_is_len;
<a name="l02235"></a>02235             }
<a name="l02236"></a>02236             <span class="keywordflow">break</span>;
<a name="l02237"></a>02237         <span class="keywordflow">case</span> ISIS_TLV_IS_REACH:
<a name="l02238"></a>02238         <span class="keywordflow">if</span> (!TTEST2(*tptr,1))  <span class="comment">/* check if there is one byte left to read out the virtual flag */</span>
<a name="l02239"></a>02239                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02240"></a>02240             printf(<span class="stringliteral">&quot;\n\t      %s&quot;</span>,
<a name="l02241"></a>02241                    tok2str(isis_is_reach_virtual_values,
<a name="l02242"></a>02242                            <span class="stringliteral">&quot;bogus virtual flag 0x%02x&quot;</span>,
<a name="l02243"></a>02243                            *tptr++));
<a name="l02244"></a>02244         tlv_is_reach = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__is__reach.html">isis_tlv_is_reach</a> *)tptr;
<a name="l02245"></a>02245             <span class="keywordflow">while</span> (tmp &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structisis__tlv__is__reach.html">isis_tlv_is_reach</a>)) {
<a name="l02246"></a>02246         <span class="keywordflow">if</span> (!TTEST(*tlv_is_reach))
<a name="l02247"></a>02247             <span class="keywordflow">goto</span> trunctlv;
<a name="l02248"></a>02248         printf(<span class="stringliteral">&quot;\n\t      IS Neighbor: %s&quot;</span>,
<a name="l02249"></a>02249                isis_print_id(tlv_is_reach-&gt;neighbor_nodeid, NODE_ID_LEN));
<a name="l02250"></a>02250                 isis_print_metric_block(&amp;tlv_is_reach-&gt;isis_metric_block);
<a name="l02251"></a>02251         tmp -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structisis__tlv__is__reach.html">isis_tlv_is_reach</a>);
<a name="l02252"></a>02252         tlv_is_reach++;
<a name="l02253"></a>02253         }
<a name="l02254"></a>02254             <span class="keywordflow">break</span>;
<a name="l02255"></a>02255 
<a name="l02256"></a>02256         <span class="keywordflow">case</span> ISIS_TLV_ESNEIGH:
<a name="l02257"></a>02257         tlv_es_reach = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__es__reach.html">isis_tlv_es_reach</a> *)tptr;
<a name="l02258"></a>02258             <span class="keywordflow">while</span> (tmp &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structisis__tlv__es__reach.html">isis_tlv_es_reach</a>)) {
<a name="l02259"></a>02259         <span class="keywordflow">if</span> (!TTEST(*tlv_es_reach))
<a name="l02260"></a>02260             <span class="keywordflow">goto</span> trunctlv;
<a name="l02261"></a>02261         printf(<span class="stringliteral">&quot;\n\t      ES Neighbor: %s&quot;</span>,
<a name="l02262"></a>02262                        isis_print_id(tlv_es_reach-&gt;neighbor_sysid,SYSTEM_ID_LEN));
<a name="l02263"></a>02263                 isis_print_metric_block(&amp;tlv_es_reach-&gt;isis_metric_block);
<a name="l02264"></a>02264         tmp -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structisis__tlv__es__reach.html">isis_tlv_es_reach</a>);
<a name="l02265"></a>02265         tlv_es_reach++;
<a name="l02266"></a>02266         }
<a name="l02267"></a>02267             <span class="keywordflow">break</span>;
<a name="l02268"></a>02268 
<a name="l02269"></a>02269             <span class="comment">/* those two TLVs share the same format */</span>
<a name="l02270"></a>02270     <span class="keywordflow">case</span> ISIS_TLV_INT_IP_REACH:
<a name="l02271"></a>02271     <span class="keywordflow">case</span> ISIS_TLV_EXT_IP_REACH:
<a name="l02272"></a>02272         <span class="keywordflow">if</span> (!isis_print_tlv_ip_reach(pptr, <span class="stringliteral">&quot;\n\t      &quot;</span>, tlv_len))
<a name="l02273"></a>02273         <span class="keywordflow">return</span> (1);
<a name="l02274"></a>02274         <span class="keywordflow">break</span>;
<a name="l02275"></a>02275 
<a name="l02276"></a>02276     <span class="keywordflow">case</span> ISIS_TLV_EXTD_IP_REACH:
<a name="l02277"></a>02277         <span class="keywordflow">while</span> (tmp&gt;0) {
<a name="l02278"></a>02278                 ext_ip_len = isis_print_extd_ip_reach(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>, AF_INET);
<a name="l02279"></a>02279                 <span class="keywordflow">if</span> (ext_ip_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02280"></a>02280                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02281"></a>02281                 tptr+=ext_ip_len;
<a name="l02282"></a>02282         tmp-=ext_ip_len;
<a name="l02283"></a>02283         }
<a name="l02284"></a>02284         <span class="keywordflow">break</span>;
<a name="l02285"></a>02285 
<a name="l02286"></a>02286         <span class="keywordflow">case</span> ISIS_TLV_MT_IP_REACH:
<a name="l02287"></a>02287             mt_len = isis_print_mtid(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>);
<a name="l02288"></a>02288             <span class="keywordflow">if</span> (mt_len == 0) { <span class="comment">/* did something go wrong ? */</span>
<a name="l02289"></a>02289                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02290"></a>02290             }
<a name="l02291"></a>02291             tptr+=mt_len;
<a name="l02292"></a>02292             tmp-=mt_len;
<a name="l02293"></a>02293 
<a name="l02294"></a>02294             <span class="keywordflow">while</span> (tmp&gt;0) {
<a name="l02295"></a>02295                 ext_ip_len = isis_print_extd_ip_reach(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>, AF_INET);
<a name="l02296"></a>02296                 <span class="keywordflow">if</span> (ext_ip_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02297"></a>02297                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02298"></a>02298                 tptr+=ext_ip_len;
<a name="l02299"></a>02299         tmp-=ext_ip_len;
<a name="l02300"></a>02300         }
<a name="l02301"></a>02301         <span class="keywordflow">break</span>;
<a name="l02302"></a>02302 
<a name="l02303"></a>02303 <span class="preprocessor">#ifdef INET6</span>
<a name="l02304"></a>02304 <span class="preprocessor"></span>    <span class="keywordflow">case</span> ISIS_TLV_IP6_REACH:
<a name="l02305"></a>02305         <span class="keywordflow">while</span> (tmp&gt;0) {
<a name="l02306"></a>02306                 ext_ip_len = isis_print_extd_ip_reach(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>, AF_INET6);
<a name="l02307"></a>02307                 <span class="keywordflow">if</span> (ext_ip_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02308"></a>02308                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02309"></a>02309                 tptr+=ext_ip_len;
<a name="l02310"></a>02310         tmp-=ext_ip_len;
<a name="l02311"></a>02311         }
<a name="l02312"></a>02312         <span class="keywordflow">break</span>;
<a name="l02313"></a>02313 
<a name="l02314"></a>02314     <span class="keywordflow">case</span> ISIS_TLV_MT_IP6_REACH:
<a name="l02315"></a>02315             mt_len = isis_print_mtid(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>);
<a name="l02316"></a>02316             <span class="keywordflow">if</span> (mt_len == 0) { <span class="comment">/* did something go wrong ? */</span>
<a name="l02317"></a>02317                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02318"></a>02318             }
<a name="l02319"></a>02319             tptr+=mt_len;
<a name="l02320"></a>02320             tmp-=mt_len;
<a name="l02321"></a>02321 
<a name="l02322"></a>02322         <span class="keywordflow">while</span> (tmp&gt;0) {
<a name="l02323"></a>02323                 ext_ip_len = isis_print_extd_ip_reach(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>, AF_INET6);
<a name="l02324"></a>02324                 <span class="keywordflow">if</span> (ext_ip_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02325"></a>02325                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02326"></a>02326                 tptr+=ext_ip_len;
<a name="l02327"></a>02327         tmp-=ext_ip_len;
<a name="l02328"></a>02328         }
<a name="l02329"></a>02329         <span class="keywordflow">break</span>;
<a name="l02330"></a>02330 
<a name="l02331"></a>02331     <span class="keywordflow">case</span> ISIS_TLV_IP6ADDR:
<a name="l02332"></a>02332         <span class="keywordflow">while</span> (tmp&gt;=<span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr)) {
<a name="l02333"></a>02333         <span class="keywordflow">if</span> (!TTEST2(*tptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr)))
<a name="l02334"></a>02334             <span class="keywordflow">goto</span> trunctlv;
<a name="l02335"></a>02335 
<a name="l02336"></a>02336                 printf(<span class="stringliteral">&quot;\n\t      IPv6 interface address: %s&quot;</span>,
<a name="l02337"></a>02337                ip6addr_string(tptr));
<a name="l02338"></a>02338 
<a name="l02339"></a>02339         tptr += <span class="keyword">sizeof</span>(<span class="keyword">struct </span>in6_addr);
<a name="l02340"></a>02340         tmp -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>in6_addr);
<a name="l02341"></a>02341         }
<a name="l02342"></a>02342         <span class="keywordflow">break</span>;
<a name="l02343"></a>02343 <span class="preprocessor">#endif</span>
<a name="l02344"></a>02344 <span class="preprocessor"></span>    <span class="keywordflow">case</span> ISIS_TLV_AUTH:
<a name="l02345"></a>02345         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l02346"></a>02346         <span class="keywordflow">goto</span> trunctlv;
<a name="l02347"></a>02347 
<a name="l02348"></a>02348             printf(<span class="stringliteral">&quot;\n\t      %s: &quot;</span>,
<a name="l02349"></a>02349                    tok2str(isis_subtlv_auth_values,
<a name="l02350"></a>02350                            <span class="stringliteral">&quot;unknown Authentication type 0x%02x&quot;</span>,
<a name="l02351"></a>02351                            *tptr));
<a name="l02352"></a>02352 
<a name="l02353"></a>02353         <span class="keywordflow">switch</span> (*tptr) {
<a name="l02354"></a>02354         <span class="keywordflow">case</span> ISIS_SUBTLV_AUTH_SIMPLE:
<a name="l02355"></a>02355         <span class="keywordflow">for</span>(i=1;i&lt;tlv_len;i++) {
<a name="l02356"></a>02356             <span class="keywordflow">if</span> (!TTEST2(*(tptr+i), 1))
<a name="l02357"></a>02357             <span class="keywordflow">goto</span> trunctlv;
<a name="l02358"></a>02358             printf(<span class="stringliteral">&quot;%c&quot;</span>,*(tptr+i));
<a name="l02359"></a>02359         }
<a name="l02360"></a>02360         <span class="keywordflow">break</span>;
<a name="l02361"></a>02361         <span class="keywordflow">case</span> ISIS_SUBTLV_AUTH_MD5:
<a name="l02362"></a>02362         <span class="keywordflow">for</span>(i=1;i&lt;tlv_len;i++) {
<a name="l02363"></a>02363             <span class="keywordflow">if</span> (!TTEST2(*(tptr+i), 1))
<a name="l02364"></a>02364             <span class="keywordflow">goto</span> trunctlv;
<a name="l02365"></a>02365             printf(<span class="stringliteral">&quot;%02x&quot;</span>,*(tptr+i));
<a name="l02366"></a>02366         }
<a name="l02367"></a>02367         <span class="keywordflow">if</span> (tlv_len != ISIS_SUBTLV_AUTH_MD5_LEN+1)
<a name="l02368"></a>02368                     printf(<span class="stringliteral">&quot;, (malformed subTLV) &quot;</span>);
<a name="l02369"></a>02369 
<a name="l02370"></a>02370 <span class="preprocessor">#ifdef HAVE_LIBCRYPTO</span>
<a name="l02371"></a>02371 <span class="preprocessor"></span>                sigcheck = signature_verify(optr, length,
<a name="l02372"></a>02372                                             (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)tptr + 1);
<a name="l02373"></a>02373 <span class="preprocessor">#else</span>
<a name="l02374"></a>02374 <span class="preprocessor"></span>                sigcheck = CANT_CHECK_SIGNATURE;
<a name="l02375"></a>02375 <span class="preprocessor">#endif</span>
<a name="l02376"></a>02376 <span class="preprocessor"></span>                printf(<span class="stringliteral">&quot; (%s)&quot;</span>, tok2str(signature_check_values, <span class="stringliteral">&quot;Unknown&quot;</span>, sigcheck));
<a name="l02377"></a>02377 
<a name="l02378"></a>02378         <span class="keywordflow">break</span>;
<a name="l02379"></a>02379         <span class="keywordflow">case</span> ISIS_SUBTLV_AUTH_PRIVATE:
<a name="l02380"></a>02380         <span class="keywordflow">default</span>:
<a name="l02381"></a>02381         <span class="keywordflow">if</span>(!print_unknown_data(tptr+1,<span class="stringliteral">&quot;\n\t\t  &quot;</span>,tlv_len-1))
<a name="l02382"></a>02382             <span class="keywordflow">return</span>(0);
<a name="l02383"></a>02383         <span class="keywordflow">break</span>;
<a name="l02384"></a>02384         }
<a name="l02385"></a>02385         <span class="keywordflow">break</span>;
<a name="l02386"></a>02386 
<a name="l02387"></a>02387     <span class="keywordflow">case</span> ISIS_TLV_PTP_ADJ:
<a name="l02388"></a>02388         tlv_ptp_adj = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__ptp__adj.html">isis_tlv_ptp_adj</a> *)tptr;
<a name="l02389"></a>02389         <span class="keywordflow">if</span>(tmp&gt;=1) {
<a name="l02390"></a>02390         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l02391"></a>02391             <span class="keywordflow">goto</span> trunctlv;
<a name="l02392"></a>02392         printf(<span class="stringliteral">&quot;\n\t      Adjacency State: %s (%u)&quot;</span>,
<a name="l02393"></a>02393                tok2str(isis_ptp_adjancey_values, <span class="stringliteral">&quot;unknown&quot;</span>, *tptr),
<a name="l02394"></a>02394                         *tptr);
<a name="l02395"></a>02395         tmp--;
<a name="l02396"></a>02396         }
<a name="l02397"></a>02397         <span class="keywordflow">if</span>(tmp&gt;<span class="keyword">sizeof</span>(tlv_ptp_adj-&gt;extd_local_circuit_id)) {
<a name="l02398"></a>02398         <span class="keywordflow">if</span> (!TTEST2(tlv_ptp_adj-&gt;extd_local_circuit_id,
<a name="l02399"></a>02399                             <span class="keyword">sizeof</span>(tlv_ptp_adj-&gt;extd_local_circuit_id)))
<a name="l02400"></a>02400             <span class="keywordflow">goto</span> trunctlv;
<a name="l02401"></a>02401         printf(<span class="stringliteral">&quot;\n\t      Extended Local circuit-ID: 0x%08x&quot;</span>,
<a name="l02402"></a>02402                EXTRACT_32BITS(tlv_ptp_adj-&gt;extd_local_circuit_id));
<a name="l02403"></a>02403         tmp-=<span class="keyword">sizeof</span>(tlv_ptp_adj-&gt;extd_local_circuit_id);
<a name="l02404"></a>02404         }
<a name="l02405"></a>02405         <span class="keywordflow">if</span>(tmp&gt;=SYSTEM_ID_LEN) {
<a name="l02406"></a>02406         <span class="keywordflow">if</span> (!TTEST2(tlv_ptp_adj-&gt;neighbor_sysid, SYSTEM_ID_LEN))
<a name="l02407"></a>02407             <span class="keywordflow">goto</span> trunctlv;
<a name="l02408"></a>02408         printf(<span class="stringliteral">&quot;\n\t      Neighbor System-ID: %s&quot;</span>,
<a name="l02409"></a>02409                isis_print_id(tlv_ptp_adj-&gt;neighbor_sysid,SYSTEM_ID_LEN));
<a name="l02410"></a>02410         tmp-=SYSTEM_ID_LEN;
<a name="l02411"></a>02411         }
<a name="l02412"></a>02412         <span class="keywordflow">if</span>(tmp&gt;=<span class="keyword">sizeof</span>(tlv_ptp_adj-&gt;neighbor_extd_local_circuit_id)) {
<a name="l02413"></a>02413         <span class="keywordflow">if</span> (!TTEST2(tlv_ptp_adj-&gt;neighbor_extd_local_circuit_id,
<a name="l02414"></a>02414                             <span class="keyword">sizeof</span>(tlv_ptp_adj-&gt;neighbor_extd_local_circuit_id)))
<a name="l02415"></a>02415             <span class="keywordflow">goto</span> trunctlv;
<a name="l02416"></a>02416         printf(<span class="stringliteral">&quot;\n\t      Neighbor Extended Local circuit-ID: 0x%08x&quot;</span>,
<a name="l02417"></a>02417                EXTRACT_32BITS(tlv_ptp_adj-&gt;neighbor_extd_local_circuit_id));
<a name="l02418"></a>02418         }
<a name="l02419"></a>02419         <span class="keywordflow">break</span>;
<a name="l02420"></a>02420 
<a name="l02421"></a>02421     <span class="keywordflow">case</span> ISIS_TLV_PROTOCOLS:
<a name="l02422"></a>02422         printf(<span class="stringliteral">&quot;\n\t      NLPID(s): &quot;</span>);
<a name="l02423"></a>02423         <span class="keywordflow">while</span> (tmp&gt;0) {
<a name="l02424"></a>02424         <span class="keywordflow">if</span> (!TTEST2(*(tptr), 1))
<a name="l02425"></a>02425             <span class="keywordflow">goto</span> trunctlv;
<a name="l02426"></a>02426         printf(<span class="stringliteral">&quot;%s (0x%02x)&quot;</span>,
<a name="l02427"></a>02427                        tok2str(nlpid_values,
<a name="l02428"></a>02428                                <span class="stringliteral">&quot;unknown&quot;</span>,
<a name="l02429"></a>02429                                *tptr),
<a name="l02430"></a>02430                        *tptr);
<a name="l02431"></a>02431         <span class="keywordflow">if</span> (tmp&gt;1) <span class="comment">/* further NPLIDs ? - put comma */</span>
<a name="l02432"></a>02432             printf(<span class="stringliteral">&quot;, &quot;</span>);
<a name="l02433"></a>02433                 tptr++;
<a name="l02434"></a>02434                 tmp--;
<a name="l02435"></a>02435         }
<a name="l02436"></a>02436         <span class="keywordflow">break</span>;
<a name="l02437"></a>02437 
<a name="l02438"></a>02438     <span class="keywordflow">case</span> ISIS_TLV_TE_ROUTER_ID:
<a name="l02439"></a>02439         <span class="keywordflow">if</span> (!TTEST2(*pptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)))
<a name="l02440"></a>02440         <span class="keywordflow">goto</span> trunctlv;
<a name="l02441"></a>02441         printf(<span class="stringliteral">&quot;\n\t      Traffic Engineering Router ID: %s&quot;</span>, ipaddr_string(pptr));
<a name="l02442"></a>02442         <span class="keywordflow">break</span>;
<a name="l02443"></a>02443 
<a name="l02444"></a>02444     <span class="keywordflow">case</span> ISIS_TLV_IPADDR:
<a name="l02445"></a>02445         <span class="keywordflow">while</span> (tmp&gt;=<span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)) {
<a name="l02446"></a>02446         <span class="keywordflow">if</span> (!TTEST2(*tptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)))
<a name="l02447"></a>02447             <span class="keywordflow">goto</span> trunctlv;
<a name="l02448"></a>02448         printf(<span class="stringliteral">&quot;\n\t      IPv4 interface address: %s&quot;</span>, ipaddr_string(tptr));
<a name="l02449"></a>02449         tptr += <span class="keyword">sizeof</span>(<span class="keyword">struct </span>in_addr);
<a name="l02450"></a>02450         tmp -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>in_addr);
<a name="l02451"></a>02451         }
<a name="l02452"></a>02452         <span class="keywordflow">break</span>;
<a name="l02453"></a>02453 
<a name="l02454"></a>02454     <span class="keywordflow">case</span> ISIS_TLV_HOSTNAME:
<a name="l02455"></a>02455         printf(<span class="stringliteral">&quot;\n\t      Hostname: &quot;</span>);
<a name="l02456"></a>02456         <span class="keywordflow">while</span> (tmp&gt;0) {
<a name="l02457"></a>02457         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l02458"></a>02458             <span class="keywordflow">goto</span> trunctlv;
<a name="l02459"></a>02459         printf(<span class="stringliteral">&quot;%c&quot;</span>,*tptr++);
<a name="l02460"></a>02460                 tmp--;
<a name="l02461"></a>02461         }
<a name="l02462"></a>02462         <span class="keywordflow">break</span>;
<a name="l02463"></a>02463 
<a name="l02464"></a>02464     <span class="keywordflow">case</span> ISIS_TLV_SHARED_RISK_GROUP:
<a name="l02465"></a>02465         <span class="keywordflow">if</span> (tmp &lt; NODE_ID_LEN)
<a name="l02466"></a>02466             <span class="keywordflow">break</span>;
<a name="l02467"></a>02467         <span class="keywordflow">if</span> (!TTEST2(*tptr, NODE_ID_LEN))
<a name="l02468"></a>02468                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02469"></a>02469         printf(<span class="stringliteral">&quot;\n\t      IS Neighbor: %s&quot;</span>, isis_print_id(tptr, NODE_ID_LEN));
<a name="l02470"></a>02470         tptr+=(NODE_ID_LEN);
<a name="l02471"></a>02471         tmp-=(NODE_ID_LEN);
<a name="l02472"></a>02472 
<a name="l02473"></a>02473         <span class="keywordflow">if</span> (tmp &lt; 1)
<a name="l02474"></a>02474             <span class="keywordflow">break</span>;
<a name="l02475"></a>02475         <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l02476"></a>02476                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02477"></a>02477         printf(<span class="stringliteral">&quot;, Flags: [%s]&quot;</span>, ISIS_MASK_TLV_SHARED_RISK_GROUP(*tptr++) ? <span class="stringliteral">&quot;numbered&quot;</span> : <span class="stringliteral">&quot;unnumbered&quot;</span>);
<a name="l02478"></a>02478         tmp--;
<a name="l02479"></a>02479 
<a name="l02480"></a>02480         <span class="keywordflow">if</span> (tmp &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr))
<a name="l02481"></a>02481             <span class="keywordflow">break</span>;
<a name="l02482"></a>02482         <span class="keywordflow">if</span> (!TTEST2(*tptr,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)))
<a name="l02483"></a>02483                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02484"></a>02484         printf(<span class="stringliteral">&quot;\n\t      IPv4 interface address: %s&quot;</span>, ipaddr_string(tptr));
<a name="l02485"></a>02485         tptr+=<span class="keyword">sizeof</span>(<span class="keyword">struct </span>in_addr);
<a name="l02486"></a>02486         tmp-=<span class="keyword">sizeof</span>(<span class="keyword">struct </span>in_addr);
<a name="l02487"></a>02487 
<a name="l02488"></a>02488         <span class="keywordflow">if</span> (tmp &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr))
<a name="l02489"></a>02489             <span class="keywordflow">break</span>;
<a name="l02490"></a>02490         <span class="keywordflow">if</span> (!TTEST2(*tptr,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)))
<a name="l02491"></a>02491                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02492"></a>02492         printf(<span class="stringliteral">&quot;\n\t      IPv4 neighbor address: %s&quot;</span>, ipaddr_string(tptr));
<a name="l02493"></a>02493         tptr+=<span class="keyword">sizeof</span>(<span class="keyword">struct </span>in_addr);
<a name="l02494"></a>02494         tmp-=<span class="keyword">sizeof</span>(<span class="keyword">struct </span>in_addr);
<a name="l02495"></a>02495 
<a name="l02496"></a>02496         <span class="keywordflow">while</span> (tmp&gt;=4) {
<a name="l02497"></a>02497                 <span class="keywordflow">if</span> (!TTEST2(*tptr, 4))
<a name="l02498"></a>02498                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02499"></a>02499                 printf(<span class="stringliteral">&quot;\n\t      Link-ID: 0x%08x&quot;</span>, EXTRACT_32BITS(tptr));
<a name="l02500"></a>02500                 tptr+=4;
<a name="l02501"></a>02501                 tmp-=4;
<a name="l02502"></a>02502         }
<a name="l02503"></a>02503         <span class="keywordflow">break</span>;
<a name="l02504"></a>02504 
<a name="l02505"></a>02505     <span class="keywordflow">case</span> ISIS_TLV_LSP:
<a name="l02506"></a>02506         tlv_lsp = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structisis__tlv__lsp.html">isis_tlv_lsp</a> *)tptr;
<a name="l02507"></a>02507         <span class="keywordflow">while</span>(tmp&gt;=<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structisis__tlv__lsp.html">isis_tlv_lsp</a>)) {
<a name="l02508"></a>02508         <span class="keywordflow">if</span> (!TTEST((tlv_lsp-&gt;lsp_id)[LSP_ID_LEN-1]))
<a name="l02509"></a>02509             <span class="keywordflow">goto</span> trunctlv;
<a name="l02510"></a>02510         printf(<span class="stringliteral">&quot;\n\t      lsp-id: %s&quot;</span>,
<a name="l02511"></a>02511                        isis_print_id(tlv_lsp-&gt;lsp_id, LSP_ID_LEN));
<a name="l02512"></a>02512         <span class="keywordflow">if</span> (!TTEST2(tlv_lsp-&gt;sequence_number, 4))
<a name="l02513"></a>02513             <span class="keywordflow">goto</span> trunctlv;
<a name="l02514"></a>02514         printf(<span class="stringliteral">&quot;, seq: 0x%08x&quot;</span>,EXTRACT_32BITS(tlv_lsp-&gt;sequence_number));
<a name="l02515"></a>02515         <span class="keywordflow">if</span> (!TTEST2(tlv_lsp-&gt;remaining_lifetime, 2))
<a name="l02516"></a>02516             <span class="keywordflow">goto</span> trunctlv;
<a name="l02517"></a>02517         printf(<span class="stringliteral">&quot;, lifetime: %5ds&quot;</span>,EXTRACT_16BITS(tlv_lsp-&gt;remaining_lifetime));
<a name="l02518"></a>02518         <span class="keywordflow">if</span> (!TTEST2(tlv_lsp-&gt;checksum, 2))
<a name="l02519"></a>02519             <span class="keywordflow">goto</span> trunctlv;
<a name="l02520"></a>02520         printf(<span class="stringliteral">&quot;, chksum: 0x%04x&quot;</span>,EXTRACT_16BITS(tlv_lsp-&gt;checksum));
<a name="l02521"></a>02521         tmp-=<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structisis__tlv__lsp.html">isis_tlv_lsp</a>);
<a name="l02522"></a>02522         tlv_lsp++;
<a name="l02523"></a>02523         }
<a name="l02524"></a>02524         <span class="keywordflow">break</span>;
<a name="l02525"></a>02525 
<a name="l02526"></a>02526     <span class="keywordflow">case</span> ISIS_TLV_CHECKSUM:
<a name="l02527"></a>02527         <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_CHECKSUM_MINLEN)
<a name="l02528"></a>02528             <span class="keywordflow">break</span>;
<a name="l02529"></a>02529         <span class="keywordflow">if</span> (!TTEST2(*tptr, ISIS_TLV_CHECKSUM_MINLEN))
<a name="l02530"></a>02530         <span class="keywordflow">goto</span> trunctlv;
<a name="l02531"></a>02531         printf(<span class="stringliteral">&quot;\n\t      checksum: 0x%04x &quot;</span>, EXTRACT_16BITS(tptr));
<a name="l02532"></a>02532             <span class="comment">/* do not attempt to verify the checksum if it is zero</span>
<a name="l02533"></a>02533 <span class="comment">             * most likely a HMAC-MD5 TLV is also present and</span>
<a name="l02534"></a>02534 <span class="comment">             * to avoid conflicts the checksum TLV is zeroed.</span>
<a name="l02535"></a>02535 <span class="comment">             * see rfc3358 for details</span>
<a name="l02536"></a>02536 <span class="comment">             */</span>
<a name="l02537"></a>02537             osi_print_cksum(optr, EXTRACT_16BITS(tptr), tptr-optr, length);
<a name="l02538"></a>02538         <span class="keywordflow">break</span>;
<a name="l02539"></a>02539 
<a name="l02540"></a>02540     <span class="keywordflow">case</span> ISIS_TLV_MT_SUPPORTED:
<a name="l02541"></a>02541             <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_MT_SUPPORTED_MINLEN)
<a name="l02542"></a>02542                 <span class="keywordflow">break</span>;
<a name="l02543"></a>02543         <span class="keywordflow">while</span> (tmp&gt;1) {
<a name="l02544"></a>02544         <span class="comment">/* length can only be a multiple of 2, otherwise there is</span>
<a name="l02545"></a>02545 <span class="comment">           something broken -&gt; so decode down until length is 1 */</span>
<a name="l02546"></a>02546         <span class="keywordflow">if</span> (tmp!=1) {
<a name="l02547"></a>02547                     mt_len = isis_print_mtid(tptr, <span class="stringliteral">&quot;\n\t      &quot;</span>);
<a name="l02548"></a>02548                     <span class="keywordflow">if</span> (mt_len == 0) <span class="comment">/* did something go wrong ? */</span>
<a name="l02549"></a>02549                         <span class="keywordflow">goto</span> trunctlv;
<a name="l02550"></a>02550                     tptr+=mt_len;
<a name="l02551"></a>02551                     tmp-=mt_len;
<a name="l02552"></a>02552         } <span class="keywordflow">else</span> {
<a name="l02553"></a>02553             printf(<span class="stringliteral">&quot;\n\t      malformed MT-ID&quot;</span>);
<a name="l02554"></a>02554             <span class="keywordflow">break</span>;
<a name="l02555"></a>02555         }
<a name="l02556"></a>02556         }
<a name="l02557"></a>02557         <span class="keywordflow">break</span>;
<a name="l02558"></a>02558 
<a name="l02559"></a>02559     <span class="keywordflow">case</span> ISIS_TLV_RESTART_SIGNALING:
<a name="l02560"></a>02560             <span class="comment">/* first attempt to decode the flags */</span>
<a name="l02561"></a>02561             <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_RESTART_SIGNALING_FLAGLEN)
<a name="l02562"></a>02562                 <span class="keywordflow">break</span>;
<a name="l02563"></a>02563             <span class="keywordflow">if</span> (!TTEST2(*tptr, ISIS_TLV_RESTART_SIGNALING_FLAGLEN))
<a name="l02564"></a>02564                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02565"></a>02565             printf(<span class="stringliteral">&quot;\n\t      Flags [%s]&quot;</span>,
<a name="l02566"></a>02566                    bittok2str(isis_restart_flag_values, <span class="stringliteral">&quot;none&quot;</span>, *tptr));
<a name="l02567"></a>02567             tptr+=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;
<a name="l02568"></a>02568             tmp-=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;
<a name="l02569"></a>02569 
<a name="l02570"></a>02570             <span class="comment">/* is there anything other than the flags field? */</span>
<a name="l02571"></a>02571             <span class="keywordflow">if</span> (tmp == 0)
<a name="l02572"></a>02572                 <span class="keywordflow">break</span>;
<a name="l02573"></a>02573 
<a name="l02574"></a>02574             <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN)
<a name="l02575"></a>02575                 <span class="keywordflow">break</span>;
<a name="l02576"></a>02576             <span class="keywordflow">if</span> (!TTEST2(*tptr, ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN))
<a name="l02577"></a>02577                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02578"></a>02578 
<a name="l02579"></a>02579             printf(<span class="stringliteral">&quot;, Remaining holding time %us&quot;</span>, EXTRACT_16BITS(tptr));
<a name="l02580"></a>02580             tptr+=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;
<a name="l02581"></a>02581             tmp-=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;
<a name="l02582"></a>02582 
<a name="l02583"></a>02583             <span class="comment">/* is there an additional sysid field present ?*/</span>
<a name="l02584"></a>02584             <span class="keywordflow">if</span> (tmp == SYSTEM_ID_LEN) {
<a name="l02585"></a>02585                     <span class="keywordflow">if</span> (!TTEST2(*tptr, SYSTEM_ID_LEN))
<a name="l02586"></a>02586                             <span class="keywordflow">goto</span> trunctlv;
<a name="l02587"></a>02587                     printf(<span class="stringliteral">&quot;, for %s&quot;</span>,isis_print_id(tptr,SYSTEM_ID_LEN));
<a name="l02588"></a>02588             } 
<a name="l02589"></a>02589         <span class="keywordflow">break</span>;
<a name="l02590"></a>02590 
<a name="l02591"></a>02591         <span class="keywordflow">case</span> ISIS_TLV_IDRP_INFO:
<a name="l02592"></a>02592         <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_IDRP_INFO_MINLEN)
<a name="l02593"></a>02593             <span class="keywordflow">break</span>;
<a name="l02594"></a>02594             <span class="keywordflow">if</span> (!TTEST2(*tptr, ISIS_TLV_IDRP_INFO_MINLEN))
<a name="l02595"></a>02595                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02596"></a>02596             printf(<span class="stringliteral">&quot;\n\t      Inter-Domain Information Type: %s&quot;</span>,
<a name="l02597"></a>02597                    tok2str(isis_subtlv_idrp_values,
<a name="l02598"></a>02598                            <span class="stringliteral">&quot;Unknown (0x%02x)&quot;</span>,
<a name="l02599"></a>02599                            *tptr));
<a name="l02600"></a>02600             <span class="keywordflow">switch</span> (*tptr++) {
<a name="l02601"></a>02601             <span class="keywordflow">case</span> ISIS_SUBTLV_IDRP_ASN:
<a name="l02602"></a>02602                 <span class="keywordflow">if</span> (!TTEST2(*tptr, 2)) <span class="comment">/* fetch AS number */</span>
<a name="l02603"></a>02603                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02604"></a>02604                 printf(<span class="stringliteral">&quot;AS Number: %u&quot;</span>,EXTRACT_16BITS(tptr));
<a name="l02605"></a>02605                 <span class="keywordflow">break</span>;
<a name="l02606"></a>02606             <span class="keywordflow">case</span> ISIS_SUBTLV_IDRP_LOCAL:
<a name="l02607"></a>02607             <span class="keywordflow">case</span> ISIS_SUBTLV_IDRP_RES:
<a name="l02608"></a>02608             <span class="keywordflow">default</span>:
<a name="l02609"></a>02609                 <span class="keywordflow">if</span>(!print_unknown_data(tptr,<span class="stringliteral">&quot;\n\t      &quot;</span>,tlv_len-1))
<a name="l02610"></a>02610                     <span class="keywordflow">return</span>(0);
<a name="l02611"></a>02611                 <span class="keywordflow">break</span>;
<a name="l02612"></a>02612             }
<a name="l02613"></a>02613             <span class="keywordflow">break</span>;
<a name="l02614"></a>02614 
<a name="l02615"></a>02615         <span class="keywordflow">case</span> ISIS_TLV_LSP_BUFFERSIZE:
<a name="l02616"></a>02616         <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_LSP_BUFFERSIZE_MINLEN)
<a name="l02617"></a>02617             <span class="keywordflow">break</span>;
<a name="l02618"></a>02618             <span class="keywordflow">if</span> (!TTEST2(*tptr, ISIS_TLV_LSP_BUFFERSIZE_MINLEN))
<a name="l02619"></a>02619                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02620"></a>02620             printf(<span class="stringliteral">&quot;\n\t      LSP Buffersize: %u&quot;</span>,EXTRACT_16BITS(tptr));
<a name="l02621"></a>02621             <span class="keywordflow">break</span>;
<a name="l02622"></a>02622 
<a name="l02623"></a>02623         <span class="keywordflow">case</span> ISIS_TLV_PART_DIS:
<a name="l02624"></a>02624             <span class="keywordflow">while</span> (tmp &gt;= SYSTEM_ID_LEN) {
<a name="l02625"></a>02625                 <span class="keywordflow">if</span> (!TTEST2(*tptr, SYSTEM_ID_LEN))
<a name="l02626"></a>02626                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02627"></a>02627                 printf(<span class="stringliteral">&quot;\n\t      %s&quot;</span>,isis_print_id(tptr,SYSTEM_ID_LEN));
<a name="l02628"></a>02628                 tptr+=SYSTEM_ID_LEN;
<a name="l02629"></a>02629                 tmp-=SYSTEM_ID_LEN;
<a name="l02630"></a>02630             }
<a name="l02631"></a>02631             <span class="keywordflow">break</span>;
<a name="l02632"></a>02632 
<a name="l02633"></a>02633         <span class="keywordflow">case</span> ISIS_TLV_PREFIX_NEIGH:
<a name="l02634"></a>02634         <span class="keywordflow">if</span> (tmp &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> isis_metric_block))
<a name="l02635"></a>02635             <span class="keywordflow">break</span>;
<a name="l02636"></a>02636             <span class="keywordflow">if</span> (!TTEST2(*tptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> isis_metric_block)))
<a name="l02637"></a>02637                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02638"></a>02638             printf(<span class="stringliteral">&quot;\n\t      Metric Block&quot;</span>);
<a name="l02639"></a>02639             isis_print_metric_block((<span class="keyword">const</span> <span class="keyword">struct</span> isis_metric_block *)tptr);
<a name="l02640"></a>02640             tptr+=<span class="keyword">sizeof</span>(<span class="keyword">struct </span>isis_metric_block);
<a name="l02641"></a>02641             tmp-=<span class="keyword">sizeof</span>(<span class="keyword">struct </span>isis_metric_block);
<a name="l02642"></a>02642 
<a name="l02643"></a>02643             <span class="keywordflow">while</span>(tmp&gt;0) {
<a name="l02644"></a>02644                 <span class="keywordflow">if</span> (!TTEST2(*tptr, 1))
<a name="l02645"></a>02645                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02646"></a>02646                 prefix_len=*tptr++; <span class="comment">/* read out prefix length in semioctets*/</span>
<a name="l02647"></a>02647                 <span class="keywordflow">if</span> (prefix_len &lt; 2) {
<a name="l02648"></a>02648                     printf(<span class="stringliteral">&quot;\n\t\tAddress: prefix length %u &lt; 2&quot;</span>, prefix_len);
<a name="l02649"></a>02649                     <span class="keywordflow">break</span>;
<a name="l02650"></a>02650                 }
<a name="l02651"></a>02651                 tmp--;
<a name="l02652"></a>02652                 <span class="keywordflow">if</span> (tmp &lt; prefix_len/2)
<a name="l02653"></a>02653                     <span class="keywordflow">break</span>;
<a name="l02654"></a>02654                 <span class="keywordflow">if</span> (!TTEST2(*tptr, prefix_len/2))
<a name="l02655"></a>02655                     <span class="keywordflow">goto</span> trunctlv;
<a name="l02656"></a>02656                 printf(<span class="stringliteral">&quot;\n\t\tAddress: %s/%u&quot;</span>,
<a name="l02657"></a>02657                        isonsap_string(tptr,prefix_len/2),
<a name="l02658"></a>02658                        prefix_len*4);
<a name="l02659"></a>02659                 tptr+=prefix_len/2;
<a name="l02660"></a>02660                 tmp-=prefix_len/2;
<a name="l02661"></a>02661             }
<a name="l02662"></a>02662             <span class="keywordflow">break</span>;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664         <span class="keywordflow">case</span> ISIS_TLV_IIH_SEQNR:
<a name="l02665"></a>02665         <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_IIH_SEQNR_MINLEN)
<a name="l02666"></a>02666             <span class="keywordflow">break</span>;
<a name="l02667"></a>02667             <span class="keywordflow">if</span> (!TTEST2(*tptr, ISIS_TLV_IIH_SEQNR_MINLEN)) <span class="comment">/* check if four bytes are on the wire */</span>
<a name="l02668"></a>02668                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02669"></a>02669             printf(<span class="stringliteral">&quot;\n\t      Sequence number: %u&quot;</span>, EXTRACT_32BITS(tptr) );
<a name="l02670"></a>02670             <span class="keywordflow">break</span>;
<a name="l02671"></a>02671 
<a name="l02672"></a>02672         <span class="keywordflow">case</span> ISIS_TLV_VENDOR_PRIVATE:
<a name="l02673"></a>02673         <span class="keywordflow">if</span> (tmp &lt; ISIS_TLV_VENDOR_PRIVATE_MINLEN)
<a name="l02674"></a>02674             <span class="keywordflow">break</span>;
<a name="l02675"></a>02675             <span class="keywordflow">if</span> (!TTEST2(*tptr, ISIS_TLV_VENDOR_PRIVATE_MINLEN)) <span class="comment">/* check if enough byte for a full oui */</span>
<a name="l02676"></a>02676                 <span class="keywordflow">goto</span> trunctlv;
<a name="l02677"></a>02677             vendor_id = EXTRACT_24BITS(tptr);
<a name="l02678"></a>02678             printf(<span class="stringliteral">&quot;\n\t      Vendor: %s (%u)&quot;</span>,
<a name="l02679"></a>02679                    tok2str(oui_values,<span class="stringliteral">&quot;Unknown&quot;</span>,vendor_id),
<a name="l02680"></a>02680                    vendor_id);
<a name="l02681"></a>02681             tptr+=3;
<a name="l02682"></a>02682             tmp-=3;
<a name="l02683"></a>02683             <span class="keywordflow">if</span> (tmp &gt; 0) <span class="comment">/* hexdump the rest */</span>
<a name="l02684"></a>02684                 <span class="keywordflow">if</span>(!print_unknown_data(tptr,<span class="stringliteral">&quot;\n\t\t&quot;</span>,tmp))
<a name="l02685"></a>02685                     <span class="keywordflow">return</span>(0);
<a name="l02686"></a>02686             <span class="keywordflow">break</span>;
<a name="l02687"></a>02687             <span class="comment">/*</span>
<a name="l02688"></a>02688 <span class="comment">             * FIXME those are the defined TLVs that lack a decoder</span>
<a name="l02689"></a>02689 <span class="comment">             * you are welcome to contribute code ;-)</span>
<a name="l02690"></a>02690 <span class="comment">             */</span>
<a name="l02691"></a>02691 
<a name="l02692"></a>02692         <span class="keywordflow">case</span> ISIS_TLV_DECNET_PHASE4:
<a name="l02693"></a>02693         <span class="keywordflow">case</span> ISIS_TLV_LUCENT_PRIVATE:
<a name="l02694"></a>02694         <span class="keywordflow">case</span> ISIS_TLV_IPAUTH:
<a name="l02695"></a>02695         <span class="keywordflow">case</span> ISIS_TLV_NORTEL_PRIVATE1:
<a name="l02696"></a>02696         <span class="keywordflow">case</span> ISIS_TLV_NORTEL_PRIVATE2:
<a name="l02697"></a>02697 
<a name="l02698"></a>02698     <span class="keywordflow">default</span>:
<a name="l02699"></a>02699             <span class="keywordflow">if</span> (vflag &lt;= 1) {
<a name="l02700"></a>02700                 <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t\t&quot;</span>,tlv_len))
<a name="l02701"></a>02701                     <span class="keywordflow">return</span>(0);
<a name="l02702"></a>02702             }
<a name="l02703"></a>02703         <span class="keywordflow">break</span>;
<a name="l02704"></a>02704     }
<a name="l02705"></a>02705         <span class="comment">/* do we want to see an additionally hexdump ? */</span>
<a name="l02706"></a>02706         <span class="keywordflow">if</span> (vflag&gt; 1) {
<a name="l02707"></a>02707         <span class="keywordflow">if</span>(!print_unknown_data(pptr,<span class="stringliteral">&quot;\n\t      &quot;</span>,tlv_len))
<a name="l02708"></a>02708             <span class="keywordflow">return</span>(0);
<a name="l02709"></a>02709         }
<a name="l02710"></a>02710 
<a name="l02711"></a>02711     pptr += tlv_len;
<a name="l02712"></a>02712     packet_len -= tlv_len;
<a name="l02713"></a>02713     }
<a name="l02714"></a>02714 
<a name="l02715"></a>02715     <span class="keywordflow">if</span> (packet_len != 0) {
<a name="l02716"></a>02716     printf(<span class="stringliteral">&quot;\n\t      %u straggler bytes&quot;</span>, packet_len);
<a name="l02717"></a>02717     }
<a name="l02718"></a>02718     <span class="keywordflow">return</span> (1);
<a name="l02719"></a>02719 
<a name="l02720"></a>02720  trunc:
<a name="l02721"></a>02721     fputs(<span class="stringliteral">&quot;[|isis]&quot;</span>, stdout);
<a name="l02722"></a>02722     <span class="keywordflow">return</span> (1);
<a name="l02723"></a>02723 
<a name="l02724"></a>02724  trunctlv:
<a name="l02725"></a>02725     printf(<span class="stringliteral">&quot;\n\t\t packet exceeded snapshot&quot;</span>);
<a name="l02726"></a>02726     <span class="keywordflow">return</span>(1);
<a name="l02727"></a>02727 }
<a name="l02728"></a>02728 
<a name="l02729"></a>02729 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02730"></a>02730 osi_print_cksum (<span class="keyword">const</span> u_int8_t *pptr, u_int16_t checksum,
<a name="l02731"></a>02731                     u_int checksum_offset, u_int length)
<a name="l02732"></a>02732 {
<a name="l02733"></a>02733         u_int16_t calculated_checksum;
<a name="l02734"></a>02734 
<a name="l02735"></a>02735         <span class="comment">/* do not attempt to verify the checksum if it is zero */</span>
<a name="l02736"></a>02736         <span class="keywordflow">if</span> (!checksum) {
<a name="l02737"></a>02737                 printf(<span class="stringliteral">&quot;(unverified)&quot;</span>);
<a name="l02738"></a>02738         } <span class="keywordflow">else</span> {
<a name="l02739"></a>02739                 calculated_checksum = create_osi_cksum(pptr, checksum_offset, length);
<a name="l02740"></a>02740                 <span class="keywordflow">if</span> (checksum == calculated_checksum) {
<a name="l02741"></a>02741                         printf(<span class="stringliteral">&quot; (correct)&quot;</span>);
<a name="l02742"></a>02742                 } <span class="keywordflow">else</span> {
<a name="l02743"></a>02743                         printf(<span class="stringliteral">&quot; (incorrect should be 0x%04x)&quot;</span>, calculated_checksum);
<a name="l02744"></a>02744                 }
<a name="l02745"></a>02745         }
<a name="l02746"></a>02746 }
<a name="l02747"></a>02747 
<a name="l02748"></a>02748 <span class="comment">/*</span>
<a name="l02749"></a>02749 <span class="comment"> * Local Variables:</span>
<a name="l02750"></a>02750 <span class="comment"> * c-style: whitesmith</span>
<a name="l02751"></a>02751 <span class="comment"> * c-basic-offset: 8</span>
<a name="l02752"></a>02752 <span class="comment"> * End:</span>
<a name="l02753"></a>02753 <span class="comment"> */</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:32 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
