<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/e1000e/e1000e-1.3.10a/src/netdev.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_33bbd4e9a1db5491349331105196bbee.html">e1000e</a>      </li>
      <li class="navelem"><a class="el" href="dir_e9c869938a0832b04ec490da333bf951.html">e1000e-1.3.10a</a>      </li>
      <li class="navelem"><a class="el" href="dir_488f12860e061e4531795fd261b21425.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">netdev.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Intel PRO/1000 Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">  Copyright(c) 1999 - 2011 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">  under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">  version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">  more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">  The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<a name="l00024"></a>00024 <span class="comment">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00025"></a>00025 <span class="comment">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">*******************************************************************************/</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;linux/init.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;linux/pci.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;linux/vmalloc.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;linux/pagemap.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;linux/delay.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;linux/netdevice.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;linux/tcp.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;linux/ipv6.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;linux/slab.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/checksum.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/ip6_checksum.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/mii.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;linux/ethtool.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/if_vlan.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#endif</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;e1000.h&quot;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#define DRV_EXTRAVERSION  &quot;-NAPI&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#define DRV_EXTRAVERSION </span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span>
<a name="l00062"></a>00062 <span class="preprocessor">#define HAVE_PF_RING</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#include &quot;../../../../../kernel/linux/pf_ring.h&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#endif</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068 <span class="preprocessor">#define DRV_VERSION &quot;1.3.10a&quot; DRV_EXTRAVERSION</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="keywordtype">char</span> e1000e_driver_name[] = <span class="stringliteral">&quot;e1000e&quot;</span>;
<a name="l00070"></a>00070 <span class="keyword">const</span> <span class="keywordtype">char</span> e1000e_driver_version[] = DRV_VERSION;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_disable_aspm(<span class="keyword">struct</span> pci_dev *pdev, u16 <a class="code" href="structstate.html">state</a>);
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="keyword">static</span> s32 e1000_get_variants_82571(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00077"></a>00077     <span class="keyword">static</span> <span class="keywordtype">int</span> global_quad_port_a; <span class="comment">/* global port a indication */</span>
<a name="l00078"></a>00078     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l00079"></a>00079     <span class="keywordtype">int</span> is_port_b = er32(STATUS) &amp; E1000_STATUS_FUNC_1;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081     <span class="comment">/* tag quad port adapters first, it&#39;s used below */</span>
<a name="l00082"></a>00082     <span class="keywordflow">switch</span> (pdev-&gt;device) {
<a name="l00083"></a>00083     <span class="keywordflow">case</span> E1000_DEV_ID_82571EB_QUAD_COPPER:
<a name="l00084"></a>00084     <span class="keywordflow">case</span> E1000_DEV_ID_82571EB_QUAD_FIBER:
<a name="l00085"></a>00085     <span class="keywordflow">case</span> E1000_DEV_ID_82571EB_QUAD_COPPER_LP:
<a name="l00086"></a>00086     <span class="keywordflow">case</span> E1000_DEV_ID_82571PT_QUAD_COPPER:
<a name="l00087"></a>00087         adapter-&gt;flags |= FLAG_IS_QUAD_PORT;
<a name="l00088"></a>00088         <span class="comment">/* mark the first port */</span>
<a name="l00089"></a>00089         <span class="keywordflow">if</span> (global_quad_port_a == 0)
<a name="l00090"></a>00090             adapter-&gt;flags |= FLAG_IS_QUAD_PORT_A;
<a name="l00091"></a>00091         <span class="comment">/* Reset for multiple quad port adapters */</span>
<a name="l00092"></a>00092         global_quad_port_a++;
<a name="l00093"></a>00093         <span class="keywordflow">if</span> (global_quad_port_a == 4)
<a name="l00094"></a>00094             global_quad_port_a = 0;
<a name="l00095"></a>00095         <span class="keywordflow">break</span>;
<a name="l00096"></a>00096     <span class="keywordflow">default</span>:
<a name="l00097"></a>00097         <span class="keywordflow">break</span>;
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l00101"></a>00101     <span class="keywordflow">case</span> e1000_82571:
<a name="l00102"></a>00102         <span class="comment">/* these dual ports don&#39;t have WoL on port B at all */</span>
<a name="l00103"></a>00103         <span class="keywordflow">if</span> (((pdev-&gt;device == E1000_DEV_ID_82571EB_FIBER) ||
<a name="l00104"></a>00104              (pdev-&gt;device == E1000_DEV_ID_82571EB_SERDES) ||
<a name="l00105"></a>00105              (pdev-&gt;device == E1000_DEV_ID_82571EB_COPPER)) &amp;&amp;
<a name="l00106"></a>00106             (is_port_b))
<a name="l00107"></a>00107             adapter-&gt;flags &amp;= ~FLAG_HAS_WOL;
<a name="l00108"></a>00108         <span class="comment">/* quad ports only support WoL on port A */</span>
<a name="l00109"></a>00109         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_IS_QUAD_PORT &amp;&amp;
<a name="l00110"></a>00110             (!(adapter-&gt;flags &amp; FLAG_IS_QUAD_PORT_A)))
<a name="l00111"></a>00111             adapter-&gt;flags &amp;= ~FLAG_HAS_WOL;
<a name="l00112"></a>00112         <span class="comment">/* Does not support WoL on any port */</span>
<a name="l00113"></a>00113         <span class="keywordflow">if</span> (pdev-&gt;device == E1000_DEV_ID_82571EB_SERDES_QUAD)
<a name="l00114"></a>00114             adapter-&gt;flags &amp;= ~FLAG_HAS_WOL;
<a name="l00115"></a>00115         <span class="keywordflow">break</span>;
<a name="l00116"></a>00116     <span class="keywordflow">case</span> e1000_82573:
<a name="l00117"></a>00117     <span class="keywordflow">case</span> e1000_82574:
<a name="l00118"></a>00118     <span class="keywordflow">case</span> e1000_82583:
<a name="l00119"></a>00119         <span class="comment">/* Disable ASPM L0s due to hardware errata */</span>
<a name="l00120"></a>00120         e1000e_disable_aspm(adapter-&gt;pdev, PCIE_LINK_STATE_L0S);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="keywordflow">if</span> (pdev-&gt;device == E1000_DEV_ID_82573L) {
<a name="l00123"></a>00123             adapter-&gt;flags |= FLAG_HAS_JUMBO_FRAMES;
<a name="l00124"></a>00124             adapter-&gt;max_hw_frame_size = DEFAULT_JUMBO;
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126         <span class="keywordflow">break</span>;
<a name="l00127"></a>00127     <span class="keywordflow">default</span>:
<a name="l00128"></a>00128         <span class="keywordflow">break</span>;
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordflow">return</span> 0;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_82571_info = {
<a name="l00135"></a>00135     .mac            = e1000_82571,
<a name="l00136"></a>00136     .flags          = FLAG_HAS_HW_VLAN_FILTER
<a name="l00137"></a>00137                   | FLAG_HAS_JUMBO_FRAMES
<a name="l00138"></a>00138                   | FLAG_HAS_WOL
<a name="l00139"></a>00139                   | FLAG_APME_IN_CTRL3
<a name="l00140"></a>00140                   | FLAG_RX_CSUM_ENABLED
<a name="l00141"></a>00141                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00142"></a>00142                   | FLAG_HAS_SMART_POWER_DOWN
<a name="l00143"></a>00143                   | FLAG_RESET_OVERWRITES_LAA <span class="comment">/* errata */</span>
<a name="l00144"></a>00144                   | FLAG_TARC_SPEED_MODE_BIT <span class="comment">/* errata */</span>
<a name="l00145"></a>00145                   | FLAG_APME_CHECK_PORT_B,
<a name="l00146"></a>00146     .flags2         = FLAG2_DISABLE_ASPM_L1 <span class="comment">/* errata 13 */</span>
<a name="l00147"></a>00147                   | FLAG2_DMA_BURST,
<a name="l00148"></a>00148     .pba            = 38,
<a name="l00149"></a>00149     .max_hw_frame_size  = DEFAULT_JUMBO,
<a name="l00150"></a>00150     .init_ops       = e1000_init_function_pointers_82571,
<a name="l00151"></a>00151     .get_variants       = e1000_get_variants_82571,
<a name="l00152"></a>00152 };
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_82572_info = {
<a name="l00155"></a>00155     .mac            = e1000_82572,
<a name="l00156"></a>00156     .flags          = FLAG_HAS_HW_VLAN_FILTER
<a name="l00157"></a>00157                   | FLAG_HAS_JUMBO_FRAMES
<a name="l00158"></a>00158                   | FLAG_HAS_WOL
<a name="l00159"></a>00159                   | FLAG_APME_IN_CTRL3
<a name="l00160"></a>00160                   | FLAG_RX_CSUM_ENABLED
<a name="l00161"></a>00161                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00162"></a>00162                   | FLAG_TARC_SPEED_MODE_BIT, <span class="comment">/* errata */</span>
<a name="l00163"></a>00163     .flags2         = FLAG2_DISABLE_ASPM_L1 <span class="comment">/* errata 13 */</span>
<a name="l00164"></a>00164                   | FLAG2_DMA_BURST,
<a name="l00165"></a>00165     .pba            = 38,
<a name="l00166"></a>00166     .max_hw_frame_size  = DEFAULT_JUMBO,
<a name="l00167"></a>00167     .init_ops       = e1000_init_function_pointers_82571,
<a name="l00168"></a>00168     .get_variants       = e1000_get_variants_82571,
<a name="l00169"></a>00169 };
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_82573_info = {
<a name="l00172"></a>00172     .mac            = e1000_82573,
<a name="l00173"></a>00173     .flags          = FLAG_HAS_HW_VLAN_FILTER
<a name="l00174"></a>00174                   | FLAG_HAS_WOL
<a name="l00175"></a>00175                   | FLAG_APME_IN_CTRL3
<a name="l00176"></a>00176                   | FLAG_RX_CSUM_ENABLED
<a name="l00177"></a>00177                   | FLAG_HAS_SMART_POWER_DOWN
<a name="l00178"></a>00178                   | FLAG_HAS_AMT
<a name="l00179"></a>00179                   | FLAG_HAS_SWSM_ON_LOAD,
<a name="l00180"></a>00180     .flags2         = FLAG2_DISABLE_ASPM_L1,
<a name="l00181"></a>00181     .pba            = 20,
<a name="l00182"></a>00182     .max_hw_frame_size  = ETH_FRAME_LEN + ETH_FCS_LEN,
<a name="l00183"></a>00183     .init_ops       = e1000_init_function_pointers_82571,
<a name="l00184"></a>00184     .get_variants       = e1000_get_variants_82571,
<a name="l00185"></a>00185 };
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_82574_info = {
<a name="l00188"></a>00188     .mac            = e1000_82574,
<a name="l00189"></a>00189     .flags          = FLAG_HAS_HW_VLAN_FILTER
<a name="l00190"></a>00190 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span>                  | FLAG_HAS_MSIX
<a name="l00192"></a>00192 <span class="preprocessor">#endif</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span>                  | FLAG_HAS_JUMBO_FRAMES
<a name="l00194"></a>00194                   | FLAG_HAS_WOL
<a name="l00195"></a>00195                   | FLAG_APME_IN_CTRL3
<a name="l00196"></a>00196                   | FLAG_RX_CSUM_ENABLED
<a name="l00197"></a>00197                   | FLAG_HAS_SMART_POWER_DOWN
<a name="l00198"></a>00198                   | FLAG_HAS_AMT
<a name="l00199"></a>00199                   | FLAG_HAS_CTRLEXT_ON_LOAD,
<a name="l00200"></a>00200     .flags2         = FLAG2_CHECK_PHY_HANG, <span class="comment">/* errata */</span>
<a name="l00201"></a>00201     .pba            = 32,
<a name="l00202"></a>00202     .max_hw_frame_size  = DEFAULT_JUMBO,
<a name="l00203"></a>00203     .init_ops       = e1000_init_function_pointers_82571,
<a name="l00204"></a>00204     .get_variants       = e1000_get_variants_82571,
<a name="l00205"></a>00205 };
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_82583_info = {
<a name="l00208"></a>00208     .mac            = e1000_82583,
<a name="l00209"></a>00209     .flags          = FLAG_HAS_HW_VLAN_FILTER
<a name="l00210"></a>00210                   | FLAG_HAS_WOL
<a name="l00211"></a>00211                   | FLAG_APME_IN_CTRL3
<a name="l00212"></a>00212                   | FLAG_RX_CSUM_ENABLED
<a name="l00213"></a>00213                   | FLAG_HAS_SMART_POWER_DOWN
<a name="l00214"></a>00214                   | FLAG_HAS_AMT
<a name="l00215"></a>00215                   | FLAG_HAS_CTRLEXT_ON_LOAD,
<a name="l00216"></a>00216     .pba            = 32,
<a name="l00217"></a>00217     .max_hw_frame_size  = ETH_FRAME_LEN + ETH_FCS_LEN,
<a name="l00218"></a>00218     .init_ops       = e1000_init_function_pointers_82571,
<a name="l00219"></a>00219     .get_variants       = e1000_get_variants_82571,
<a name="l00220"></a>00220 };
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_es2_info = {
<a name="l00223"></a>00223     .mac            = e1000_80003es2lan,
<a name="l00224"></a>00224     .flags          = FLAG_HAS_HW_VLAN_FILTER
<a name="l00225"></a>00225                   | FLAG_HAS_JUMBO_FRAMES
<a name="l00226"></a>00226                   | FLAG_HAS_WOL
<a name="l00227"></a>00227                   | FLAG_APME_IN_CTRL3
<a name="l00228"></a>00228                   | FLAG_RX_CSUM_ENABLED
<a name="l00229"></a>00229                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00230"></a>00230                   | FLAG_RX_NEEDS_RESTART <span class="comment">/* errata */</span>
<a name="l00231"></a>00231                   | FLAG_TARC_SET_BIT_ZERO <span class="comment">/* errata */</span>
<a name="l00232"></a>00232                   | FLAG_APME_CHECK_PORT_B
<a name="l00233"></a>00233                   | FLAG_DISABLE_FC_PAUSE_TIME <span class="comment">/* errata */</span>
<a name="l00234"></a>00234                   | FLAG_TIPG_MEDIUM_FOR_80003ESLAN,
<a name="l00235"></a>00235     .flags2         = FLAG2_DMA_BURST,
<a name="l00236"></a>00236     .pba            = 38,
<a name="l00237"></a>00237     .max_hw_frame_size  = DEFAULT_JUMBO,
<a name="l00238"></a>00238     .init_ops       = e1000_init_function_pointers_80003es2lan,
<a name="l00239"></a>00239     .get_variants       = NULL,
<a name="l00240"></a>00240 };
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="keyword">static</span> s32 e1000_get_variants_ich8lan(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="comment">/*</span>
<a name="l00247"></a>00247 <span class="comment">     * Disable Jumbo Frame support on parts with Intel 10/100 PHY or</span>
<a name="l00248"></a>00248 <span class="comment">     * on parts with MACsec enabled in NVM (reflected in CTRL_EXT).</span>
<a name="l00249"></a>00249 <span class="comment">     */</span>
<a name="l00250"></a>00250     <span class="keywordflow">if</span> ((adapter-&gt;hw.phy.type == e1000_phy_ife) ||
<a name="l00251"></a>00251         ((adapter-&gt;hw.mac.type &gt;= e1000_pch2lan) &amp;&amp;
<a name="l00252"></a>00252          (!(er32(CTRL_EXT) &amp; E1000_CTRL_EXT_LSECCK)))) {
<a name="l00253"></a>00253         adapter-&gt;flags &amp;= ~FLAG_HAS_JUMBO_FRAMES;
<a name="l00254"></a>00254         adapter-&gt;max_hw_frame_size = ETH_FRAME_LEN + ETH_FCS_LEN;
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="keywordflow">if</span> ((adapter-&gt;hw.mac.type == e1000_ich8lan) &amp;&amp;
<a name="l00258"></a>00258         (adapter-&gt;hw.phy.type == e1000_phy_igp_3))
<a name="l00259"></a>00259         adapter-&gt;flags |= FLAG_LSC_GIG_SPEED_DROP;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="keywordflow">return</span> 0;
<a name="l00262"></a>00262 }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_ich8_info = {
<a name="l00265"></a>00265     .mac            = e1000_ich8lan,
<a name="l00266"></a>00266     .flags          = FLAG_HAS_WOL
<a name="l00267"></a>00267                   | FLAG_IS_ICH
<a name="l00268"></a>00268                   | FLAG_RX_CSUM_ENABLED
<a name="l00269"></a>00269                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00270"></a>00270                   | FLAG_HAS_AMT
<a name="l00271"></a>00271                   | FLAG_HAS_FLASH
<a name="l00272"></a>00272                   | FLAG_APME_IN_WUC,
<a name="l00273"></a>00273     .pba            = 8,
<a name="l00274"></a>00274     .max_hw_frame_size  = ETH_FRAME_LEN + ETH_FCS_LEN,
<a name="l00275"></a>00275     .init_ops       = e1000_init_function_pointers_ich8lan,
<a name="l00276"></a>00276     .get_variants       = e1000_get_variants_ich8lan,
<a name="l00277"></a>00277 };
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_ich9_info = {
<a name="l00280"></a>00280     .mac            = e1000_ich9lan,
<a name="l00281"></a>00281     .flags          = FLAG_HAS_JUMBO_FRAMES
<a name="l00282"></a>00282                   | FLAG_IS_ICH
<a name="l00283"></a>00283                   | FLAG_HAS_WOL
<a name="l00284"></a>00284                   | FLAG_RX_CSUM_ENABLED
<a name="l00285"></a>00285                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00286"></a>00286                   | FLAG_HAS_AMT
<a name="l00287"></a>00287                   | FLAG_HAS_ERT
<a name="l00288"></a>00288                   | FLAG_HAS_FLASH
<a name="l00289"></a>00289                   | FLAG_APME_IN_WUC,
<a name="l00290"></a>00290     .pba            = 10,
<a name="l00291"></a>00291     .max_hw_frame_size  = DEFAULT_JUMBO,
<a name="l00292"></a>00292     .init_ops       = e1000_init_function_pointers_ich8lan,
<a name="l00293"></a>00293     .get_variants       = e1000_get_variants_ich8lan,
<a name="l00294"></a>00294 };
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_ich10_info = {
<a name="l00297"></a>00297     .mac            = e1000_ich10lan,
<a name="l00298"></a>00298     .flags          = FLAG_HAS_JUMBO_FRAMES
<a name="l00299"></a>00299                   | FLAG_IS_ICH
<a name="l00300"></a>00300                   | FLAG_HAS_WOL
<a name="l00301"></a>00301                   | FLAG_RX_CSUM_ENABLED
<a name="l00302"></a>00302                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00303"></a>00303                   | FLAG_HAS_AMT
<a name="l00304"></a>00304                   | FLAG_HAS_ERT
<a name="l00305"></a>00305                   | FLAG_HAS_FLASH
<a name="l00306"></a>00306                   | FLAG_APME_IN_WUC,
<a name="l00307"></a>00307     .pba            = 10,
<a name="l00308"></a>00308     .max_hw_frame_size  = DEFAULT_JUMBO,
<a name="l00309"></a>00309     .init_ops       = e1000_init_function_pointers_ich8lan,
<a name="l00310"></a>00310     .get_variants       = e1000_get_variants_ich8lan,
<a name="l00311"></a>00311 };
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_pch_info = {
<a name="l00314"></a>00314     .mac            = e1000_pchlan,
<a name="l00315"></a>00315     .flags          = FLAG_IS_ICH
<a name="l00316"></a>00316                   | FLAG_HAS_WOL
<a name="l00317"></a>00317                   | FLAG_RX_CSUM_ENABLED
<a name="l00318"></a>00318                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00319"></a>00319                   | FLAG_HAS_AMT
<a name="l00320"></a>00320                   | FLAG_HAS_FLASH
<a name="l00321"></a>00321                   | FLAG_HAS_JUMBO_FRAMES
<a name="l00322"></a>00322                   | FLAG_DISABLE_FC_PAUSE_TIME <span class="comment">/* errata */</span>
<a name="l00323"></a>00323                   | FLAG_APME_IN_WUC,
<a name="l00324"></a>00324     .flags2         = FLAG2_HAS_PHY_STATS,
<a name="l00325"></a>00325     .pba            = 26,
<a name="l00326"></a>00326     .max_hw_frame_size  = 4096,
<a name="l00327"></a>00327     .init_ops       = e1000_init_function_pointers_ich8lan,
<a name="l00328"></a>00328     .get_variants       = e1000_get_variants_ich8lan,
<a name="l00329"></a>00329 };
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> e1000_pch2_info = {
<a name="l00332"></a>00332     .mac            = e1000_pch2lan,
<a name="l00333"></a>00333     .flags          = FLAG_IS_ICH
<a name="l00334"></a>00334                   | FLAG_HAS_WOL
<a name="l00335"></a>00335                   | FLAG_RX_CSUM_ENABLED
<a name="l00336"></a>00336                   | FLAG_HAS_CTRLEXT_ON_LOAD
<a name="l00337"></a>00337                   | FLAG_HAS_AMT
<a name="l00338"></a>00338                   | FLAG_HAS_FLASH
<a name="l00339"></a>00339                   | FLAG_HAS_JUMBO_FRAMES
<a name="l00340"></a>00340                   | FLAG_APME_IN_WUC,
<a name="l00341"></a>00341     .flags2         = FLAG2_HAS_PHY_STATS
<a name="l00342"></a>00342                   | FLAG2_HAS_EEE,
<a name="l00343"></a>00343     .pba            = 26,
<a name="l00344"></a>00344     .max_hw_frame_size  = DEFAULT_JUMBO,
<a name="l00345"></a>00345     .init_ops       = e1000_init_function_pointers_ich8lan,
<a name="l00346"></a>00346     .get_variants       = e1000_get_variants_ich8lan,
<a name="l00347"></a>00347 };
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> *e1000_info_tbl[] = {
<a name="l00350"></a>00350     [board_82571]       = &amp;e1000_82571_info,
<a name="l00351"></a>00351     [board_82572]       = &amp;e1000_82572_info,
<a name="l00352"></a>00352     [board_82573]       = &amp;e1000_82573_info,
<a name="l00353"></a>00353     [board_82574]       = &amp;e1000_82574_info,
<a name="l00354"></a>00354     [board_82583]       = &amp;e1000_82583_info,
<a name="l00355"></a>00355     [board_80003es2lan] = &amp;e1000_es2_info,
<a name="l00356"></a>00356     [board_ich8lan]     = &amp;e1000_ich8_info,
<a name="l00357"></a>00357     [board_ich9lan]     = &amp;e1000_ich9_info,
<a name="l00358"></a>00358     [board_ich10lan]    = &amp;e1000_ich10_info,
<a name="l00359"></a>00359     [board_pchlan]      = &amp;e1000_pch_info,
<a name="l00360"></a>00360     [board_pch2lan]     = &amp;e1000_pch2_info,
<a name="l00361"></a>00361 };
<a name="l00362"></a>00362 
<a name="l00363"></a><a class="code" href="structe1000__reg__info.html">00363</a> <span class="keyword">struct </span><a class="code" href="structe1000__reg__info.html">e1000_reg_info</a> {
<a name="l00364"></a>00364     u32 ofs;
<a name="l00365"></a>00365     <span class="keywordtype">char</span> *name;
<a name="l00366"></a>00366 };
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="preprocessor">#define E1000_RDFH  0x02410 </span><span class="comment">/* Rx Data FIFO Head - RW */</span>
<a name="l00369"></a>00369 <span class="preprocessor">#define E1000_RDFT  0x02418 </span><span class="comment">/* Rx Data FIFO Tail - RW */</span>
<a name="l00370"></a>00370 <span class="preprocessor">#define E1000_RDFHS 0x02420 </span><span class="comment">/* Rx Data FIFO Head Saved - RW */</span>
<a name="l00371"></a>00371 <span class="preprocessor">#define E1000_RDFTS 0x02428 </span><span class="comment">/* Rx Data FIFO Tail Saved - RW */</span>
<a name="l00372"></a>00372 <span class="preprocessor">#define E1000_RDFPC 0x02430 </span><span class="comment">/* Rx Data FIFO Packet Count - RW */</span>
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="preprocessor">#define E1000_TDFH  0x03410 </span><span class="comment">/* Tx Data FIFO Head - RW */</span>
<a name="l00375"></a>00375 <span class="preprocessor">#define E1000_TDFT  0x03418 </span><span class="comment">/* Tx Data FIFO Tail - RW */</span>
<a name="l00376"></a>00376 <span class="preprocessor">#define E1000_TDFHS 0x03420 </span><span class="comment">/* Tx Data FIFO Head Saved - RW */</span>
<a name="l00377"></a>00377 <span class="preprocessor">#define E1000_TDFTS 0x03428 </span><span class="comment">/* Tx Data FIFO Tail Saved - RW */</span>
<a name="l00378"></a>00378 <span class="preprocessor">#define E1000_TDFPC 0x03430 </span><span class="comment">/* Tx Data FIFO Packet Count - RW */</span>
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structe1000__reg__info.html">e1000_reg_info</a> e1000_reg_info_tbl[] = {
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     <span class="comment">/* General Registers */</span>
<a name="l00383"></a>00383     {E1000_CTRL, <span class="stringliteral">&quot;CTRL&quot;</span>},
<a name="l00384"></a>00384     {E1000_STATUS, <span class="stringliteral">&quot;STATUS&quot;</span>},
<a name="l00385"></a>00385     {E1000_CTRL_EXT, <span class="stringliteral">&quot;CTRL_EXT&quot;</span>},
<a name="l00386"></a>00386 
<a name="l00387"></a>00387     <span class="comment">/* Interrupt Registers */</span>
<a name="l00388"></a>00388     {E1000_ICR, <span class="stringliteral">&quot;ICR&quot;</span>},
<a name="l00389"></a>00389 
<a name="l00390"></a>00390     <span class="comment">/* Rx Registers */</span>
<a name="l00391"></a>00391     {E1000_RCTL, <span class="stringliteral">&quot;RCTL&quot;</span>},
<a name="l00392"></a>00392     {E1000_RDLEN(0), <span class="stringliteral">&quot;RDLEN&quot;</span>},
<a name="l00393"></a>00393     {E1000_RDH(0), <span class="stringliteral">&quot;RDH&quot;</span>},
<a name="l00394"></a>00394     {E1000_RDT(0), <span class="stringliteral">&quot;RDT&quot;</span>},
<a name="l00395"></a>00395     {E1000_RDTR, <span class="stringliteral">&quot;RDTR&quot;</span>},
<a name="l00396"></a>00396     {E1000_RXDCTL(0), <span class="stringliteral">&quot;RXDCTL&quot;</span>},
<a name="l00397"></a>00397     {E1000_ERT, <span class="stringliteral">&quot;ERT&quot;</span>},
<a name="l00398"></a>00398     {E1000_RDBAL(0), <span class="stringliteral">&quot;RDBAL&quot;</span>},
<a name="l00399"></a>00399     {E1000_RDBAH(0), <span class="stringliteral">&quot;RDBAH&quot;</span>},
<a name="l00400"></a>00400     {E1000_RDFH, <span class="stringliteral">&quot;RDFH&quot;</span>},
<a name="l00401"></a>00401     {E1000_RDFT, <span class="stringliteral">&quot;RDFT&quot;</span>},
<a name="l00402"></a>00402     {E1000_RDFHS, <span class="stringliteral">&quot;RDFHS&quot;</span>},
<a name="l00403"></a>00403     {E1000_RDFTS, <span class="stringliteral">&quot;RDFTS&quot;</span>},
<a name="l00404"></a>00404     {E1000_RDFPC, <span class="stringliteral">&quot;RDFPC&quot;</span>},
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="comment">/* Tx Registers */</span>
<a name="l00407"></a>00407     {E1000_TCTL, <span class="stringliteral">&quot;TCTL&quot;</span>},
<a name="l00408"></a>00408     {E1000_TDBAL(0), <span class="stringliteral">&quot;TDBAL&quot;</span>},
<a name="l00409"></a>00409     {E1000_TDBAH(0), <span class="stringliteral">&quot;TDBAH&quot;</span>},
<a name="l00410"></a>00410     {E1000_TDLEN(0), <span class="stringliteral">&quot;TDLEN&quot;</span>},
<a name="l00411"></a>00411     {E1000_TDH(0), <span class="stringliteral">&quot;TDH&quot;</span>},
<a name="l00412"></a>00412     {E1000_TDT(0), <span class="stringliteral">&quot;TDT&quot;</span>},
<a name="l00413"></a>00413     {E1000_TIDV, <span class="stringliteral">&quot;TIDV&quot;</span>},
<a name="l00414"></a>00414     {E1000_TXDCTL(0), <span class="stringliteral">&quot;TXDCTL&quot;</span>},
<a name="l00415"></a>00415     {E1000_TADV, <span class="stringliteral">&quot;TADV&quot;</span>},
<a name="l00416"></a>00416     {E1000_TARC(0), <span class="stringliteral">&quot;TARC&quot;</span>},
<a name="l00417"></a>00417     {E1000_TDFH, <span class="stringliteral">&quot;TDFH&quot;</span>},
<a name="l00418"></a>00418     {E1000_TDFT, <span class="stringliteral">&quot;TDFT&quot;</span>},
<a name="l00419"></a>00419     {E1000_TDFHS, <span class="stringliteral">&quot;TDFHS&quot;</span>},
<a name="l00420"></a>00420     {E1000_TDFTS, <span class="stringliteral">&quot;TDFTS&quot;</span>},
<a name="l00421"></a>00421     {E1000_TDFPC, <span class="stringliteral">&quot;TDFPC&quot;</span>},
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">/* List Terminator */</span>
<a name="l00424"></a>00424     {}
<a name="l00425"></a>00425 };
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="comment">/*</span>
<a name="l00428"></a>00428 <span class="comment"> * e1000_regdump - register printout routine</span>
<a name="l00429"></a>00429 <span class="comment"> */</span>
<a name="l00430"></a>00430 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_regdump(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keyword">struct</span> <a class="code" href="structe1000__reg__info.html">e1000_reg_info</a> *reginfo)
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432     <span class="keywordtype">int</span> n = 0;
<a name="l00433"></a>00433     <span class="keywordtype">char</span> rname[16];
<a name="l00434"></a>00434     u32 regs[8];
<a name="l00435"></a>00435 
<a name="l00436"></a>00436     <span class="keywordflow">switch</span> (reginfo-&gt;ofs) {
<a name="l00437"></a>00437     <span class="keywordflow">case</span> E1000_RXDCTL(0):
<a name="l00438"></a>00438         for (n = 0; n &lt; 2; n++)
<a name="l00439"></a>00439             regs[n] = __er32(hw, E1000_RXDCTL(n));
<a name="l00440"></a>00440         <span class="keywordflow">break</span>;
<a name="l00441"></a>00441     <span class="keywordflow">case</span> E1000_TXDCTL(0):
<a name="l00442"></a>00442         for (n = 0; n &lt; 2; n++)
<a name="l00443"></a>00443             regs[n] = __er32(hw, E1000_TXDCTL(n));
<a name="l00444"></a>00444         <span class="keywordflow">break</span>;
<a name="l00445"></a>00445     <span class="keywordflow">case</span> E1000_TARC(0):
<a name="l00446"></a>00446         for (n = 0; n &lt; 2; n++)
<a name="l00447"></a>00447             regs[n] = __er32(hw, E1000_TARC(n));
<a name="l00448"></a>00448         <span class="keywordflow">break</span>;
<a name="l00449"></a>00449     <span class="keywordflow">default</span>:
<a name="l00450"></a>00450         printk(KERN_INFO <span class="stringliteral">&quot;%-15s %08x\n&quot;</span>,
<a name="l00451"></a>00451             reginfo-&gt;name, __er32(hw, reginfo-&gt;ofs));
<a name="l00452"></a>00452         <span class="keywordflow">return</span>;
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     snprintf(rname, 16, <span class="stringliteral">&quot;%s%s&quot;</span>, reginfo-&gt;name, <span class="stringliteral">&quot;[0-1]&quot;</span>);
<a name="l00456"></a>00456     printk(KERN_INFO <span class="stringliteral">&quot;%-15s &quot;</span>, rname);
<a name="l00457"></a>00457     <span class="keywordflow">for</span> (n = 0; n &lt; 2; n++)
<a name="l00458"></a>00458         printk(KERN_CONT <span class="stringliteral">&quot;%08x &quot;</span>, regs[n]);
<a name="l00459"></a>00459     printk(KERN_CONT <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00460"></a>00460 }
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="comment">/*</span>
<a name="l00463"></a>00463 <span class="comment"> * e1000e_dump - Print registers, Tx-ring and Rx-ring</span>
<a name="l00464"></a>00464 <span class="comment"> */</span>
<a name="l00465"></a>00465 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_dump(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l00468"></a>00468     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00469"></a>00469     <span class="keyword">struct </span><a class="code" href="structe1000__reg__info.html">e1000_reg_info</a> *reginfo;
<a name="l00470"></a>00470     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l00471"></a>00471     <span class="keyword">struct </span><a class="code" href="structe1000__tx__desc.html">e1000_tx_desc</a> *tx_desc;
<a name="l00472"></a>00472     <span class="keyword">struct </span>my_u0 {
<a name="l00473"></a>00473         u64 a;
<a name="l00474"></a>00474         u64 b;
<a name="l00475"></a>00475     } *u0;
<a name="l00476"></a>00476     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l00477"></a>00477     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l00478"></a>00478     <span class="keyword">union </span><a class="code" href="unione1000__rx__desc__packet__split.html">e1000_rx_desc_packet_split</a> *rx_desc_ps;
<a name="l00479"></a>00479     <span class="keyword">struct </span><a class="code" href="structe1000__rx__desc.html">e1000_rx_desc</a> *rx_desc;
<a name="l00480"></a>00480     <span class="keyword">struct </span>my_u1 {
<a name="l00481"></a>00481         u64 a;
<a name="l00482"></a>00482         u64 b;
<a name="l00483"></a>00483         u64 c;
<a name="l00484"></a>00484         u64 d;
<a name="l00485"></a>00485     } *u1;
<a name="l00486"></a>00486     u32 staterr;
<a name="l00487"></a>00487     <span class="keywordtype">int</span> i = 0;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489     <span class="keywordflow">if</span> (!netif_msg_hw(adapter))
<a name="l00490"></a>00490         <span class="keywordflow">return</span>;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492     <span class="comment">/* Print netdevice Info */</span>
<a name="l00493"></a>00493     <span class="keywordflow">if</span> (netdev) {
<a name="l00494"></a>00494         dev_info(pci_dev_to_dev(adapter-&gt;pdev), <span class="stringliteral">&quot;Net device Info\n&quot;</span>);
<a name="l00495"></a>00495         printk(KERN_INFO <span class="stringliteral">&quot;Device Name     state            &quot;</span>
<a name="l00496"></a>00496                <span class="stringliteral">&quot;trans_start      last_rx\n&quot;</span>);
<a name="l00497"></a>00497         printk(KERN_INFO <span class="stringliteral">&quot;%-15s %016lX %016lX %016lX\n&quot;</span>,
<a name="l00498"></a>00498                netdev-&gt;name, netdev-&gt;state, netdev-&gt;trans_start,
<a name="l00499"></a>00499                netdev-&gt;last_rx);
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="comment">/* Print Registers */</span>
<a name="l00503"></a>00503     dev_info(pci_dev_to_dev(adapter-&gt;pdev), <span class="stringliteral">&quot;Register Dump\n&quot;</span>);
<a name="l00504"></a>00504     printk(KERN_INFO <span class="stringliteral">&quot; Register Name   Value\n&quot;</span>);
<a name="l00505"></a>00505     <span class="keywordflow">for</span> (reginfo = (<span class="keyword">struct</span> <a class="code" href="structe1000__reg__info.html">e1000_reg_info</a> *)e1000_reg_info_tbl;
<a name="l00506"></a>00506          reginfo-&gt;name; reginfo++) {
<a name="l00507"></a>00507         e1000_regdump(hw, reginfo);
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     <span class="comment">/* Print Tx Ring Summary */</span>
<a name="l00511"></a>00511     <span class="keywordflow">if</span> (!netdev || !netif_running(netdev))
<a name="l00512"></a>00512         <span class="keywordflow">goto</span> exit;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514     dev_info(pci_dev_to_dev(adapter-&gt;pdev), <span class="stringliteral">&quot;Tx Ring Summary\n&quot;</span>);
<a name="l00515"></a>00515     printk(KERN_INFO <span class="stringliteral">&quot;Queue [NTU] [NTC] [bi(ntc)-&gt;dma  ]&quot;</span>
<a name="l00516"></a>00516            <span class="stringliteral">&quot; leng ntw timestamp\n&quot;</span>);
<a name="l00517"></a>00517     buffer_info = &amp;tx_ring-&gt;buffer_info[tx_ring-&gt;next_to_clean];
<a name="l00518"></a>00518     printk(KERN_INFO <span class="stringliteral">&quot; %5d %5X %5X %016llX %04X %3X %016llX\n&quot;</span>,
<a name="l00519"></a>00519            0, tx_ring-&gt;next_to_use, tx_ring-&gt;next_to_clean,
<a name="l00520"></a>00520            (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)buffer_info-&gt;dma,
<a name="l00521"></a>00521            buffer_info-&gt;length,
<a name="l00522"></a>00522            buffer_info-&gt;next_to_watch,
<a name="l00523"></a>00523            (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)buffer_info-&gt;time_stamp);
<a name="l00524"></a>00524 
<a name="l00525"></a>00525     <span class="comment">/* Print Tx Ring */</span>
<a name="l00526"></a>00526     <span class="keywordflow">if</span> (!netif_msg_tx_done(adapter))
<a name="l00527"></a>00527         <span class="keywordflow">goto</span> rx_ring_summary;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     dev_info(pci_dev_to_dev(adapter-&gt;pdev), <span class="stringliteral">&quot;Tx Ring Dump\n&quot;</span>);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     <span class="comment">/* Transmit Descriptor Formats - DEXT[29] is 0 (Legacy) or 1 (Extended)</span>
<a name="l00532"></a>00532 <span class="comment">     *</span>
<a name="l00533"></a>00533 <span class="comment">     * Legacy Transmit Descriptor</span>
<a name="l00534"></a>00534 <span class="comment">     *   +--------------------------------------------------------------+</span>
<a name="l00535"></a>00535 <span class="comment">     * 0 |         Buffer Address [63:0] (Reserved on Write Back)       |</span>
<a name="l00536"></a>00536 <span class="comment">     *   +--------------------------------------------------------------+</span>
<a name="l00537"></a>00537 <span class="comment">     * 8 | Special  |    CSS     | Status |  CMD    |  CSO   |  Length  |</span>
<a name="l00538"></a>00538 <span class="comment">     *   +--------------------------------------------------------------+</span>
<a name="l00539"></a>00539 <span class="comment">     *   63       48 47        36 35    32 31     24 23    16 15        0</span>
<a name="l00540"></a>00540 <span class="comment">     *</span>
<a name="l00541"></a>00541 <span class="comment">     * Extended Context Descriptor (DTYP=0x0) for TSO or checksum offload</span>
<a name="l00542"></a>00542 <span class="comment">     *   63      48 47    40 39       32 31             16 15    8 7      0</span>
<a name="l00543"></a>00543 <span class="comment">     *   +----------------------------------------------------------------+</span>
<a name="l00544"></a>00544 <span class="comment">     * 0 |  TUCSE  | TUCS0  |   TUCSS   |     IPCSE       | IPCS0 | IPCSS |</span>
<a name="l00545"></a>00545 <span class="comment">     *   +----------------------------------------------------------------+</span>
<a name="l00546"></a>00546 <span class="comment">     * 8 |   MSS   | HDRLEN | RSV | STA | TUCMD | DTYP |      PAYLEN      |</span>
<a name="l00547"></a>00547 <span class="comment">     *   +----------------------------------------------------------------+</span>
<a name="l00548"></a>00548 <span class="comment">     *   63      48 47    40 39 36 35 32 31   24 23  20 19                0</span>
<a name="l00549"></a>00549 <span class="comment">     *</span>
<a name="l00550"></a>00550 <span class="comment">     * Extended Data Descriptor (DTYP=0x1)</span>
<a name="l00551"></a>00551 <span class="comment">     *   +----------------------------------------------------------------+</span>
<a name="l00552"></a>00552 <span class="comment">     * 0 |                     Buffer Address [63:0]                      |</span>
<a name="l00553"></a>00553 <span class="comment">     *   +----------------------------------------------------------------+</span>
<a name="l00554"></a>00554 <span class="comment">     * 8 | VLAN tag |  POPTS  | Rsvd | Status | Command | DTYP |  DTALEN  |</span>
<a name="l00555"></a>00555 <span class="comment">     *   +----------------------------------------------------------------+</span>
<a name="l00556"></a>00556 <span class="comment">     *   63       48 47     40 39  36 35    32 31     24 23  20 19        0</span>
<a name="l00557"></a>00557 <span class="comment">     */</span>
<a name="l00558"></a>00558     printk(KERN_INFO <span class="stringliteral">&quot;Tl[desc]     [address 63:0  ] [SpeCssSCmCsLen]&quot;</span>
<a name="l00559"></a>00559            <span class="stringliteral">&quot; [bi-&gt;dma       ] leng  ntw timestamp        bi-&gt;skb &quot;</span>
<a name="l00560"></a>00560            <span class="stringliteral">&quot;&lt;-- Legacy format\n&quot;</span>);
<a name="l00561"></a>00561     printk(KERN_INFO <span class="stringliteral">&quot;Tc[desc]     [Ce CoCsIpceCoS] [MssHlRSCm0Plen]&quot;</span>
<a name="l00562"></a>00562            <span class="stringliteral">&quot; [bi-&gt;dma       ] leng  ntw timestamp        bi-&gt;skb &quot;</span>
<a name="l00563"></a>00563            <span class="stringliteral">&quot;&lt;-- Ext Context format\n&quot;</span>);
<a name="l00564"></a>00564     printk(KERN_INFO <span class="stringliteral">&quot;Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen]&quot;</span>
<a name="l00565"></a>00565            <span class="stringliteral">&quot; [bi-&gt;dma       ] leng  ntw timestamp        bi-&gt;skb &quot;</span>
<a name="l00566"></a>00566            <span class="stringliteral">&quot;&lt;-- Ext Data format\n&quot;</span>);
<a name="l00567"></a>00567     <span class="keywordflow">for</span> (i = 0; tx_ring-&gt;desc &amp;&amp; (i &lt; tx_ring-&gt;count); i++) {
<a name="l00568"></a>00568         tx_desc = E1000_TX_DESC(*tx_ring, i);
<a name="l00569"></a>00569         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l00570"></a>00570         u0 = (<span class="keyword">struct </span>my_u0 *)tx_desc;
<a name="l00571"></a>00571         printk(KERN_INFO <span class="stringliteral">&quot;T%c[0x%03X]    %016llX %016llX %016llX &quot;</span>
<a name="l00572"></a>00572                <span class="stringliteral">&quot;%04X  %3X %016llX %p&quot;</span>,
<a name="l00573"></a>00573                (!(le64_to_cpu(u0-&gt;b) &amp; (1&lt;&lt;29)) ? <span class="charliteral">&#39;l&#39;</span> :
<a name="l00574"></a>00574             ((le64_to_cpu(u0-&gt;b) &amp; (1&lt;&lt;20)) ? <span class="charliteral">&#39;d&#39;</span> : <span class="charliteral">&#39;c&#39;</span>)), i,
<a name="l00575"></a>00575                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u0-&gt;a),
<a name="l00576"></a>00576                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u0-&gt;b),
<a name="l00577"></a>00577                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)buffer_info-&gt;dma,
<a name="l00578"></a>00578                buffer_info-&gt;length, buffer_info-&gt;next_to_watch,
<a name="l00579"></a>00579                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)buffer_info-&gt;time_stamp,
<a name="l00580"></a>00580                buffer_info-&gt;skb);
<a name="l00581"></a>00581         <span class="keywordflow">if</span> (i == tx_ring-&gt;next_to_use &amp;&amp; i == tx_ring-&gt;next_to_clean)
<a name="l00582"></a>00582             printk(KERN_CONT <span class="stringliteral">&quot; NTC/U\n&quot;</span>);
<a name="l00583"></a>00583         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == tx_ring-&gt;next_to_use)
<a name="l00584"></a>00584             printk(KERN_CONT <span class="stringliteral">&quot; NTU\n&quot;</span>);
<a name="l00585"></a>00585         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == tx_ring-&gt;next_to_clean)
<a name="l00586"></a>00586             printk(KERN_CONT <span class="stringliteral">&quot; NTC\n&quot;</span>);
<a name="l00587"></a>00587         <span class="keywordflow">else</span>
<a name="l00588"></a>00588             printk(KERN_CONT <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         <span class="keywordflow">if</span> (netif_msg_pktdata(adapter) &amp;&amp; buffer_info-&gt;dma != 0)
<a name="l00591"></a>00591             print_hex_dump(KERN_INFO, <span class="stringliteral">&quot;&quot;</span>, DUMP_PREFIX_ADDRESS,
<a name="l00592"></a>00592                        16, 1, phys_to_virt(buffer_info-&gt;dma),
<a name="l00593"></a>00593                        buffer_info-&gt;length, <span class="keyword">true</span>);
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596     <span class="comment">/* Print Rx Ring Summary */</span>
<a name="l00597"></a>00597 rx_ring_summary:
<a name="l00598"></a>00598     dev_info(pci_dev_to_dev(adapter-&gt;pdev), <span class="stringliteral">&quot;Rx Ring Summary\n&quot;</span>);
<a name="l00599"></a>00599     printk(KERN_INFO <span class="stringliteral">&quot;Queue [NTU] [NTC]\n&quot;</span>);
<a name="l00600"></a>00600     printk(KERN_INFO <span class="stringliteral">&quot; %5d %5X %5X\n&quot;</span>, 0,
<a name="l00601"></a>00601            rx_ring-&gt;next_to_use, rx_ring-&gt;next_to_clean);
<a name="l00602"></a>00602 
<a name="l00603"></a>00603     <span class="comment">/* Print Rx Ring */</span>
<a name="l00604"></a>00604     <span class="keywordflow">if</span> (!netif_msg_rx_status(adapter))
<a name="l00605"></a>00605         <span class="keywordflow">goto</span> exit;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     dev_info(pci_dev_to_dev(adapter-&gt;pdev), <span class="stringliteral">&quot;Rx Ring Dump\n&quot;</span>);
<a name="l00608"></a>00608     <span class="keywordflow">switch</span> (adapter-&gt;rx_ps_pages) {
<a name="l00609"></a>00609     <span class="keywordflow">case</span> 1:
<a name="l00610"></a>00610     <span class="keywordflow">case</span> 2:
<a name="l00611"></a>00611     <span class="keywordflow">case</span> 3:
<a name="l00612"></a>00612         <span class="comment">/* [Extended] Packet Split Receive Descriptor Format</span>
<a name="l00613"></a>00613 <span class="comment">         *</span>
<a name="l00614"></a>00614 <span class="comment">         *    +-----------------------------------------------------+</span>
<a name="l00615"></a>00615 <span class="comment">         *  0 |                Buffer Address 0 [63:0]              |</span>
<a name="l00616"></a>00616 <span class="comment">         *    +-----------------------------------------------------+</span>
<a name="l00617"></a>00617 <span class="comment">         *  8 |                Buffer Address 1 [63:0]              |</span>
<a name="l00618"></a>00618 <span class="comment">         *    +-----------------------------------------------------+</span>
<a name="l00619"></a>00619 <span class="comment">         * 16 |                Buffer Address 2 [63:0]              |</span>
<a name="l00620"></a>00620 <span class="comment">         *    +-----------------------------------------------------+</span>
<a name="l00621"></a>00621 <span class="comment">         * 24 |                Buffer Address 3 [63:0]              |</span>
<a name="l00622"></a>00622 <span class="comment">         *    +-----------------------------------------------------+</span>
<a name="l00623"></a>00623 <span class="comment">         */</span>
<a name="l00624"></a>00624         printk(KERN_INFO <span class="stringliteral">&quot;R  [desc]      [buffer 0 63:0 ] &quot;</span>
<a name="l00625"></a>00625                <span class="stringliteral">&quot;[buffer 1 63:0 ] &quot;</span>
<a name="l00626"></a>00626                <span class="stringliteral">&quot;[buffer 2 63:0 ] [buffer 3 63:0 ] [bi-&gt;dma       ] &quot;</span>
<a name="l00627"></a>00627                <span class="stringliteral">&quot;[bi-&gt;skb] &lt;-- Ext Pkt Split format\n&quot;</span>);
<a name="l00628"></a>00628         <span class="comment">/* [Extended] Receive Descriptor (Write-Back) Format</span>
<a name="l00629"></a>00629 <span class="comment">         *</span>
<a name="l00630"></a>00630 <span class="comment">         *   63       48 47    32 31     13 12    8 7    4 3        0</span>
<a name="l00631"></a>00631 <span class="comment">         *   +------------------------------------------------------+</span>
<a name="l00632"></a>00632 <span class="comment">         * 0 | Packet   | IP     |  Rsvd   | MRQ   | Rsvd | MRQ RSS |</span>
<a name="l00633"></a>00633 <span class="comment">         *   | Checksum | Ident  |         | Queue |      |  Type   |</span>
<a name="l00634"></a>00634 <span class="comment">         *   +------------------------------------------------------+</span>
<a name="l00635"></a>00635 <span class="comment">         * 8 | VLAN Tag | Length | Extended Error | Extended Status |</span>
<a name="l00636"></a>00636 <span class="comment">         *   +------------------------------------------------------+</span>
<a name="l00637"></a>00637 <span class="comment">         *   63       48 47    32 31            20 19               0</span>
<a name="l00638"></a>00638 <span class="comment">         */</span>
<a name="l00639"></a>00639         printk(KERN_INFO <span class="stringliteral">&quot;RWB[desc]      [ck ipid mrqhsh] &quot;</span>
<a name="l00640"></a>00640                <span class="stringliteral">&quot;[vl   l0 ee  es] &quot;</span>
<a name="l00641"></a>00641                <span class="stringliteral">&quot;[ l3  l2  l1 hs] [reserved      ] ---------------- &quot;</span>
<a name="l00642"></a>00642                <span class="stringliteral">&quot;[bi-&gt;skb] &lt;-- Ext Rx Write-Back format\n&quot;</span>);
<a name="l00643"></a>00643         <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++) {
<a name="l00644"></a>00644             buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l00645"></a>00645             rx_desc_ps = E1000_RX_DESC_PS(*rx_ring, i);
<a name="l00646"></a>00646             u1 = (<span class="keyword">struct </span>my_u1 *)rx_desc_ps;
<a name="l00647"></a>00647             staterr =
<a name="l00648"></a>00648                 le32_to_cpu(rx_desc_ps-&gt;wb.middle.status_error);
<a name="l00649"></a>00649             <span class="keywordflow">if</span> (staterr &amp; E1000_RXD_STAT_DD) {
<a name="l00650"></a>00650                 <span class="comment">/* Descriptor Done */</span>
<a name="l00651"></a>00651                 printk(KERN_INFO <span class="stringliteral">&quot;RWB[0x%03X]     %016llX &quot;</span>
<a name="l00652"></a>00652                        <span class="stringliteral">&quot;%016llX %016llX %016llX &quot;</span>
<a name="l00653"></a>00653                        <span class="stringliteral">&quot;---------------- %p&quot;</span>, i,
<a name="l00654"></a>00654                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;a),
<a name="l00655"></a>00655                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;b),
<a name="l00656"></a>00656                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;c),
<a name="l00657"></a>00657                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;d),
<a name="l00658"></a>00658                        buffer_info-&gt;skb);
<a name="l00659"></a>00659             } <span class="keywordflow">else</span> {
<a name="l00660"></a>00660                 printk(KERN_INFO <span class="stringliteral">&quot;R  [0x%03X]     %016llX &quot;</span>
<a name="l00661"></a>00661                        <span class="stringliteral">&quot;%016llX %016llX %016llX %016llX %p&quot;</span>, i,
<a name="l00662"></a>00662                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;a),
<a name="l00663"></a>00663                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;b),
<a name="l00664"></a>00664                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;c),
<a name="l00665"></a>00665                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u1-&gt;d),
<a name="l00666"></a>00666                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)buffer_info-&gt;dma,
<a name="l00667"></a>00667                        buffer_info-&gt;skb);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669                 <span class="keywordflow">if</span> (netif_msg_pktdata(adapter))
<a name="l00670"></a>00670                     print_hex_dump(KERN_INFO, <span class="stringliteral">&quot;&quot;</span>,
<a name="l00671"></a>00671                         DUMP_PREFIX_ADDRESS, 16, 1,
<a name="l00672"></a>00672                         phys_to_virt(buffer_info-&gt;dma),
<a name="l00673"></a>00673                         adapter-&gt;rx_ps_bsize0, <span class="keyword">true</span>);
<a name="l00674"></a>00674             }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676             <span class="keywordflow">if</span> (i == rx_ring-&gt;next_to_use)
<a name="l00677"></a>00677                 printk(KERN_CONT <span class="stringliteral">&quot; NTU\n&quot;</span>);
<a name="l00678"></a>00678             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == rx_ring-&gt;next_to_clean)
<a name="l00679"></a>00679                 printk(KERN_CONT <span class="stringliteral">&quot; NTC\n&quot;</span>);
<a name="l00680"></a>00680             <span class="keywordflow">else</span>
<a name="l00681"></a>00681                 printk(KERN_CONT <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00682"></a>00682         }
<a name="l00683"></a>00683         <span class="keywordflow">break</span>;
<a name="l00684"></a>00684     <span class="keywordflow">default</span>:
<a name="l00685"></a>00685     <span class="keywordflow">case</span> 0:
<a name="l00686"></a>00686         <span class="comment">/* Legacy Receive Descriptor Format</span>
<a name="l00687"></a>00687 <span class="comment">         *</span>
<a name="l00688"></a>00688 <span class="comment">         * +-----------------------------------------------------+</span>
<a name="l00689"></a>00689 <span class="comment">         * |                Buffer Address [63:0]                |</span>
<a name="l00690"></a>00690 <span class="comment">         * +-----------------------------------------------------+</span>
<a name="l00691"></a>00691 <span class="comment">         * | VLAN Tag | Errors | Status 0 | Packet csum | Length |</span>
<a name="l00692"></a>00692 <span class="comment">         * +-----------------------------------------------------+</span>
<a name="l00693"></a>00693 <span class="comment">         * 63       48 47    40 39      32 31         16 15      0</span>
<a name="l00694"></a>00694 <span class="comment">         */</span>
<a name="l00695"></a>00695         printk(KERN_INFO <span class="stringliteral">&quot;Rl[desc]     [address 63:0  ] &quot;</span>
<a name="l00696"></a>00696                <span class="stringliteral">&quot;[vl er S cks ln] [bi-&gt;dma       ] [bi-&gt;skb] &quot;</span>
<a name="l00697"></a>00697                <span class="stringliteral">&quot;&lt;-- Legacy format\n&quot;</span>);
<a name="l00698"></a>00698         <span class="keywordflow">for</span> (i = 0; rx_ring-&gt;desc &amp;&amp; (i &lt; rx_ring-&gt;count); i++) {
<a name="l00699"></a>00699             rx_desc = E1000_RX_DESC(*rx_ring, i);
<a name="l00700"></a>00700             buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l00701"></a>00701             u0 = (<span class="keyword">struct </span>my_u0 *)rx_desc;
<a name="l00702"></a>00702             printk(KERN_INFO <span class="stringliteral">&quot;Rl[0x%03X]    %016llX %016llX &quot;</span>
<a name="l00703"></a>00703                    <span class="stringliteral">&quot;%016llX %p&quot;</span>, i,
<a name="l00704"></a>00704                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u0-&gt;a),
<a name="l00705"></a>00705                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)le64_to_cpu(u0-&gt;b),
<a name="l00706"></a>00706                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)buffer_info-&gt;dma,
<a name="l00707"></a>00707                    buffer_info-&gt;skb);
<a name="l00708"></a>00708             <span class="keywordflow">if</span> (i == rx_ring-&gt;next_to_use)
<a name="l00709"></a>00709                 printk(KERN_CONT <span class="stringliteral">&quot; NTU\n&quot;</span>);
<a name="l00710"></a>00710             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == rx_ring-&gt;next_to_clean)
<a name="l00711"></a>00711                 printk(KERN_CONT <span class="stringliteral">&quot; NTC\n&quot;</span>);
<a name="l00712"></a>00712             <span class="keywordflow">else</span>
<a name="l00713"></a>00713                 printk(KERN_CONT <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715             <span class="keywordflow">if</span> (netif_msg_pktdata(adapter))
<a name="l00716"></a>00716                 print_hex_dump(KERN_INFO, <span class="stringliteral">&quot;&quot;</span>,
<a name="l00717"></a>00717                            DUMP_PREFIX_ADDRESS,
<a name="l00718"></a>00718                            16, 1,
<a name="l00719"></a>00719                            phys_to_virt(buffer_info-&gt;dma),
<a name="l00720"></a>00720                            adapter-&gt;rx_buffer_len, <span class="keyword">true</span>);
<a name="l00721"></a>00721         }
<a name="l00722"></a>00722     }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 exit:
<a name="l00725"></a>00725     <span class="keywordflow">return</span>;
<a name="l00726"></a>00726 }
<a name="l00727"></a>00727 
<a name="l00731"></a>00731 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_desc_unused(<span class="keyword">struct</span> <a class="code" href="structe1000__ring.html">e1000_ring</a> *ring)
<a name="l00732"></a>00732 {
<a name="l00733"></a>00733     <span class="keywordflow">if</span> (ring-&gt;next_to_clean &gt; ring-&gt;next_to_use)
<a name="l00734"></a>00734         <span class="keywordflow">return</span> ring-&gt;next_to_clean - ring-&gt;next_to_use - 1;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="keywordflow">return</span> ring-&gt;count + ring-&gt;next_to_clean - ring-&gt;next_to_use - 1;
<a name="l00737"></a>00737 }
<a name="l00738"></a>00738 
<a name="l00746"></a>00746 <span class="keyword">static</span>
<a name="l00747"></a>00747 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00748"></a>00748 <span class="preprocessor"></span><span class="keywordtype">int</span>
<a name="l00749"></a>00749 <span class="preprocessor">#else</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span><span class="keywordtype">void</span>
<a name="l00751"></a>00751 <span class="preprocessor">#endif</span>
<a name="l00752"></a>00752 <span class="preprocessor"></span>e1000_receive_skb(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l00753"></a>00753                   <span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> sk_buff *skb,
<a name="l00754"></a>00754                   u8 status, __le16 vlan)
<a name="l00755"></a>00755 {
<a name="l00756"></a>00756 <span class="preprocessor">#ifndef CONFIG_E1000E_NAPI</span>
<a name="l00757"></a>00757 <span class="preprocessor"></span>    <span class="keywordtype">int</span> ret;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="preprocessor">#endif</span>
<a name="l00760"></a>00760 <span class="preprocessor"></span>    skb-&gt;protocol = eth_type_trans(skb, netdev);
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00763"></a>00763 <span class="preprocessor"></span>    {
<a name="l00764"></a>00764       <span class="keywordtype">int</span> debug = 0;
<a name="l00765"></a>00765       <span class="keyword">struct </span>pfring_hooks *hook = (<span class="keyword">struct </span>pfring_hooks*)netdev-&gt;pfring_ptr;
<a name="l00766"></a>00766       
<a name="l00767"></a>00767       <span class="keywordflow">if</span>(hook &amp;&amp; (hook-&gt;magic == PF_RING)) {
<a name="l00768"></a>00768         <span class="comment">/* Wow: PF_RING is alive &amp; kickin&#39; ! */</span>
<a name="l00769"></a>00769         <span class="keywordtype">int</span> rc;
<a name="l00770"></a>00770 
<a name="l00771"></a>00771         <span class="keywordflow">if</span>(debug) 
<a name="l00772"></a>00772           printk(KERN_INFO <span class="stringliteral">&quot;[PF_RING] alive [%s][len=%d]\n&quot;</span>, 
<a name="l00773"></a>00773              netdev-&gt;name, skb-&gt;len);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775         <span class="keywordflow">if</span>(*hook-&gt;transparent_mode != standard_linux_path) {
<a name="l00776"></a>00776           <span class="keywordflow">if</span>(0) {
<a name="l00777"></a>00777         kfree_skb(skb);
<a name="l00778"></a>00778         <span class="keywordflow">return</span>(1);
<a name="l00779"></a>00779           }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781           rc = hook-&gt;ring_handler(skb, 1, 1, -1, 1);
<a name="l00782"></a>00782           
<a name="l00783"></a>00783           <span class="keywordflow">if</span>(rc &gt; 0 <span class="comment">/* Packet handled by PF_RING */</span>) {
<a name="l00784"></a>00784         <span class="keywordflow">if</span>(*hook-&gt;transparent_mode == driver2pf_ring_non_transparent) {
<a name="l00785"></a>00785           <span class="comment">/* PF_RING has already freed the memory */</span>
<a name="l00786"></a>00786           <span class="keywordflow">return</span>(rc);
<a name="l00787"></a>00787         }
<a name="l00788"></a>00788           }
<a name="l00789"></a>00789         } <span class="keywordflow">else</span> {
<a name="l00790"></a>00790           <span class="keywordflow">if</span>(debug) printk(KERN_INFO <span class="stringliteral">&quot;[PF_RING] not present on %s\n&quot;</span>, 
<a name="l00791"></a>00791                    netdev-&gt;name);
<a name="l00792"></a>00792         }
<a name="l00793"></a>00793       }
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795 <span class="preprocessor">#endif</span>
<a name="l00796"></a>00796 <span class="preprocessor"></span>
<a name="l00797"></a>00797 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l00799"></a>00799 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;vlgrp &amp;&amp; (status &amp; E1000_RXD_STAT_VP))
<a name="l00800"></a>00800         vlan_gro_receive(&amp;adapter-&gt;napi, adapter-&gt;vlgrp,
<a name="l00801"></a>00801                  le16_to_cpu(vlan), skb);
<a name="l00802"></a>00802     <span class="keywordflow">else</span>
<a name="l00803"></a>00803 <span class="preprocessor">#endif</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_GRO</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>        napi_gro_receive(&amp;adapter-&gt;napi, skb);
<a name="l00806"></a>00806 <span class="preprocessor">#else</span>
<a name="l00807"></a>00807 <span class="preprocessor"></span>        netif_receive_skb(skb);
<a name="l00808"></a>00808 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_GRO */</span>
<a name="l00809"></a>00809 <span class="preprocessor">#else</span>
<a name="l00810"></a>00810 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;vlgrp &amp;&amp; (status &amp; E1000_RXD_STAT_VP))
<a name="l00812"></a>00812         ret = vlan_hwaccel_rx(skb, adapter-&gt;vlgrp, le16_to_cpu(vlan));
<a name="l00813"></a>00813     <span class="keywordflow">else</span>
<a name="l00814"></a>00814 <span class="preprocessor">#endif</span>
<a name="l00815"></a>00815 <span class="preprocessor"></span>        ret = netif_rx(skb);
<a name="l00816"></a>00816     <span class="keywordflow">if</span> (unlikely(ret == NET_RX_DROP))
<a name="l00817"></a>00817         adapter-&gt;rx_dropped_backlog++;
<a name="l00818"></a>00818 <span class="preprocessor">#endif</span>
<a name="l00819"></a>00819 <span class="preprocessor"></span><span class="preprocessor">#ifndef NETIF_F_GRO</span>
<a name="l00820"></a>00820 <span class="preprocessor"></span>
<a name="l00821"></a>00821     netdev-&gt;last_rx = jiffies;
<a name="l00822"></a>00822 <span class="preprocessor">#endif</span>
<a name="l00823"></a>00823 <span class="preprocessor"></span>
<a name="l00824"></a>00824 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00825"></a>00825 <span class="preprocessor"></span>    <span class="keywordflow">return</span>(1);
<a name="l00826"></a>00826 <span class="preprocessor">#endif</span>
<a name="l00827"></a>00827 <span class="preprocessor"></span>}
<a name="l00828"></a>00828 
<a name="l00836"></a>00836 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_rx_checksum(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter, u32 status_err,
<a name="l00837"></a>00837                   u32 csum, <span class="keyword">struct</span> sk_buff *skb)
<a name="l00838"></a>00838 {
<a name="l00839"></a>00839     u16 status = (u16)status_err;
<a name="l00840"></a>00840     u8 errors = (u8)(status_err &gt;&gt; 24);
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     skb_checksum_none_assert(skb);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     <span class="comment">/* Ignore Checksum bit is set */</span>
<a name="l00845"></a>00845     <span class="keywordflow">if</span> (status &amp; E1000_RXD_STAT_IXSM)
<a name="l00846"></a>00846         <span class="keywordflow">return</span>;
<a name="l00847"></a>00847     <span class="comment">/* TCP/UDP checksum error bit is set */</span>
<a name="l00848"></a>00848     <span class="keywordflow">if</span> (errors &amp; E1000_RXD_ERR_TCPE) {
<a name="l00849"></a>00849         <span class="comment">/* let the stack verify checksum errors */</span>
<a name="l00850"></a>00850         adapter-&gt;hw_csum_err++;
<a name="l00851"></a>00851         <span class="keywordflow">return</span>;
<a name="l00852"></a>00852     }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854     <span class="comment">/* TCP/UDP Checksum has not been calculated */</span>
<a name="l00855"></a>00855     <span class="keywordflow">if</span> (!(status &amp; (E1000_RXD_STAT_TCPCS | E1000_RXD_STAT_UDPCS)))
<a name="l00856"></a>00856         <span class="keywordflow">return</span>;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     <span class="comment">/* It must be a TCP or UDP packet with a valid checksum */</span>
<a name="l00859"></a>00859     <span class="keywordflow">if</span> (status &amp; E1000_RXD_STAT_TCPCS) {
<a name="l00860"></a>00860         <span class="comment">/* TCP checksum is good */</span>
<a name="l00861"></a>00861         skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<a name="l00862"></a>00862     } <span class="keywordflow">else</span> {
<a name="l00863"></a>00863         <span class="comment">/*</span>
<a name="l00864"></a>00864 <span class="comment">         * IP fragment with UDP payload</span>
<a name="l00865"></a>00865 <span class="comment">         * Hardware complements the payload checksum, so we undo it</span>
<a name="l00866"></a>00866 <span class="comment">         * and then put the value in host order for further stack use.</span>
<a name="l00867"></a>00867 <span class="comment">         */</span>
<a name="l00868"></a>00868         csum = ntohl(csum ^ 0xFFFF);
<a name="l00869"></a>00869         skb-&gt;csum = csum;
<a name="l00870"></a>00870         skb-&gt;ip_summed = CHECKSUM_COMPLETE;
<a name="l00871"></a>00871     }
<a name="l00872"></a>00872     adapter-&gt;hw_csum_good++;
<a name="l00873"></a>00873 }
<a name="l00874"></a>00874 
<a name="l00879"></a>00879 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_alloc_rx_buffers(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l00880"></a>00880                    <span class="keywordtype">int</span> cleaned_count)
<a name="l00881"></a>00881 {
<a name="l00882"></a>00882     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l00883"></a>00883     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l00884"></a>00884     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l00885"></a>00885     <span class="keyword">struct </span><a class="code" href="structe1000__rx__desc.html">e1000_rx_desc</a> *rx_desc;
<a name="l00886"></a>00886     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l00887"></a>00887     <span class="keyword">struct </span>sk_buff *skb;
<a name="l00888"></a>00888     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00889"></a>00889     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufsz = adapter-&gt;rx_buffer_len;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     i = rx_ring-&gt;next_to_use;
<a name="l00892"></a>00892     buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l00893"></a>00893 
<a name="l00894"></a>00894     <span class="keywordflow">while</span> (cleaned_count--) {
<a name="l00895"></a>00895         skb = buffer_info-&gt;skb;
<a name="l00896"></a>00896         <span class="keywordflow">if</span> (skb) {
<a name="l00897"></a>00897             skb_trim(skb, 0);
<a name="l00898"></a>00898             <span class="keywordflow">goto</span> map_skb;
<a name="l00899"></a>00899         }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901         skb = netdev_alloc_skb_ip_align(netdev, bufsz);
<a name="l00902"></a>00902         <span class="keywordflow">if</span> (!skb) {
<a name="l00903"></a>00903             <span class="comment">/* Better luck next round */</span>
<a name="l00904"></a>00904             adapter-&gt;alloc_rx_buff_failed++;
<a name="l00905"></a>00905             <span class="keywordflow">break</span>;
<a name="l00906"></a>00906         }
<a name="l00907"></a>00907 
<a name="l00908"></a>00908         buffer_info-&gt;skb = skb;
<a name="l00909"></a>00909 map_skb:
<a name="l00910"></a>00910         buffer_info-&gt;dma = dma_map_single(pci_dev_to_dev(pdev), skb-&gt;data,
<a name="l00911"></a>00911                           adapter-&gt;rx_buffer_len,
<a name="l00912"></a>00912                           DMA_FROM_DEVICE);
<a name="l00913"></a>00913         <span class="keywordflow">if</span> (dma_mapping_error(pci_dev_to_dev(pdev), buffer_info-&gt;dma)) {
<a name="l00914"></a>00914             dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Rx DMA map failed\n&quot;</span>);
<a name="l00915"></a>00915             adapter-&gt;rx_dma_failed++;
<a name="l00916"></a>00916             <span class="keywordflow">break</span>;
<a name="l00917"></a>00917         }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         rx_desc = E1000_RX_DESC(*rx_ring, i);
<a name="l00920"></a>00920         rx_desc-&gt;buffer_addr = cpu_to_le64(buffer_info-&gt;dma);
<a name="l00921"></a>00921 
<a name="l00922"></a>00922         <span class="keywordflow">if</span> (unlikely(!(i &amp; (E1000_RX_BUFFER_WRITE - 1)))) {
<a name="l00923"></a>00923             <span class="comment">/*</span>
<a name="l00924"></a>00924 <span class="comment">             * Force memory writes to complete before letting h/w</span>
<a name="l00925"></a>00925 <span class="comment">             * know there are new descriptors to fetch.  (Only</span>
<a name="l00926"></a>00926 <span class="comment">             * applicable for weak-ordered memory model archs,</span>
<a name="l00927"></a>00927 <span class="comment">             * such as IA-64).</span>
<a name="l00928"></a>00928 <span class="comment">             */</span>
<a name="l00929"></a>00929             wmb();
<a name="l00930"></a>00930             writel(i, adapter-&gt;hw.hw_addr + rx_ring-&gt;tail);
<a name="l00931"></a>00931         }
<a name="l00932"></a>00932         i++;
<a name="l00933"></a>00933         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l00934"></a>00934             i = 0;
<a name="l00935"></a>00935         buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938     rx_ring-&gt;next_to_use = i;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00945"></a>00945 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_alloc_rx_buffers_ps(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l00946"></a>00946                       <span class="keywordtype">int</span> cleaned_count)
<a name="l00947"></a>00947 {
<a name="l00948"></a>00948     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l00949"></a>00949     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l00950"></a>00950     <span class="keyword">union </span><a class="code" href="unione1000__rx__desc__packet__split.html">e1000_rx_desc_packet_split</a> *rx_desc;
<a name="l00951"></a>00951     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l00952"></a>00952     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l00953"></a>00953     <span class="keyword">struct </span><a class="code" href="structe1000__ps__page.html">e1000_ps_page</a> *ps_page;
<a name="l00954"></a>00954     <span class="keyword">struct </span>sk_buff *skb;
<a name="l00955"></a>00955     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957     i = rx_ring-&gt;next_to_use;
<a name="l00958"></a>00958     buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="keywordflow">while</span> (cleaned_count--) {
<a name="l00961"></a>00961         rx_desc = E1000_RX_DESC_PS(*rx_ring, i);
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         <span class="keywordflow">for</span> (j = 0; j &lt; PS_PAGE_BUFFERS; j++) {
<a name="l00964"></a>00964             ps_page = &amp;buffer_info-&gt;ps_pages[j];
<a name="l00965"></a>00965             <span class="keywordflow">if</span> (j &gt;= adapter-&gt;rx_ps_pages) {
<a name="l00966"></a>00966                 <span class="comment">/* all unused desc entries get hw null ptr */</span>
<a name="l00967"></a>00967                 rx_desc-&gt;read.buffer_addr[j + 1] =
<a name="l00968"></a>00968                     ~cpu_to_le64(0);
<a name="l00969"></a>00969                 <span class="keywordflow">continue</span>;
<a name="l00970"></a>00970             }
<a name="l00971"></a>00971             <span class="keywordflow">if</span> (!ps_page-&gt;page) {
<a name="l00972"></a>00972                 ps_page-&gt;page = alloc_pages_node(adapter-&gt;node,
<a name="l00973"></a>00973                                  GFP_ATOMIC, 0);
<a name="l00974"></a>00974                 <span class="keywordflow">if</span> (!ps_page-&gt;page) {
<a name="l00975"></a>00975                     adapter-&gt;alloc_rx_buff_failed++;
<a name="l00976"></a>00976                     <span class="keywordflow">goto</span> no_buffers;
<a name="l00977"></a>00977                 }
<a name="l00978"></a>00978             }
<a name="l00979"></a>00979             <span class="keywordflow">if</span> (!ps_page-&gt;dma) {
<a name="l00980"></a>00980                 ps_page-&gt;dma = dma_map_page(pci_dev_to_dev(pdev),
<a name="l00981"></a>00981                                 ps_page-&gt;page,
<a name="l00982"></a>00982                                 0, PAGE_SIZE,
<a name="l00983"></a>00983                                 DMA_FROM_DEVICE);
<a name="l00984"></a>00984                 <span class="keywordflow">if</span> (dma_mapping_error(pci_dev_to_dev(pdev),
<a name="l00985"></a>00985                               ps_page-&gt;dma)) {
<a name="l00986"></a>00986                     dev_err(pci_dev_to_dev(adapter-&gt;pdev),
<a name="l00987"></a>00987                       <span class="stringliteral">&quot;Rx DMA page map failed\n&quot;</span>);
<a name="l00988"></a>00988                     ps_page-&gt;dma = 0;
<a name="l00989"></a>00989                     adapter-&gt;rx_dma_failed++;
<a name="l00990"></a>00990                     <span class="keywordflow">goto</span> no_buffers;
<a name="l00991"></a>00991                 }
<a name="l00992"></a>00992             }
<a name="l00993"></a>00993             <span class="comment">/*</span>
<a name="l00994"></a>00994 <span class="comment">             * Refresh the desc even if buffer_addrs</span>
<a name="l00995"></a>00995 <span class="comment">             * didn&#39;t change because each write-back</span>
<a name="l00996"></a>00996 <span class="comment">             * erases this info.</span>
<a name="l00997"></a>00997 <span class="comment">             */</span>
<a name="l00998"></a>00998             rx_desc-&gt;read.buffer_addr[j + 1] =
<a name="l00999"></a>00999                 cpu_to_le64(ps_page-&gt;dma);
<a name="l01000"></a>01000         }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002         skb = buffer_info-&gt;skb;
<a name="l01003"></a>01003         <span class="keywordflow">if</span> (skb) {
<a name="l01004"></a>01004             skb_trim(skb, 0);
<a name="l01005"></a>01005             <span class="keywordflow">goto</span> map_skb;
<a name="l01006"></a>01006         }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008         skb = netdev_alloc_skb_ip_align(netdev,
<a name="l01009"></a>01009                         adapter-&gt;rx_ps_bsize0);
<a name="l01010"></a>01010 
<a name="l01011"></a>01011         <span class="keywordflow">if</span> (!skb) {
<a name="l01012"></a>01012             adapter-&gt;alloc_rx_buff_failed++;
<a name="l01013"></a>01013             <span class="keywordflow">break</span>;
<a name="l01014"></a>01014         }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016         buffer_info-&gt;skb = skb;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 map_skb:
<a name="l01019"></a>01019         buffer_info-&gt;dma = dma_map_single(pci_dev_to_dev(pdev), skb-&gt;data,
<a name="l01020"></a>01020                           adapter-&gt;rx_ps_bsize0,
<a name="l01021"></a>01021                           DMA_FROM_DEVICE);
<a name="l01022"></a>01022         <span class="keywordflow">if</span> (dma_mapping_error(pci_dev_to_dev(pdev), buffer_info-&gt;dma)) {
<a name="l01023"></a>01023             dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Rx DMA map failed\n&quot;</span>);
<a name="l01024"></a>01024             adapter-&gt;rx_dma_failed++;
<a name="l01025"></a>01025             <span class="comment">/* cleanup skb */</span>
<a name="l01026"></a>01026             dev_kfree_skb_any(skb);
<a name="l01027"></a>01027             buffer_info-&gt;skb = NULL;
<a name="l01028"></a>01028             <span class="keywordflow">break</span>;
<a name="l01029"></a>01029         }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         rx_desc-&gt;read.buffer_addr[0] = cpu_to_le64(buffer_info-&gt;dma);
<a name="l01032"></a>01032 
<a name="l01033"></a>01033         <span class="keywordflow">if</span> (unlikely(!(i &amp; (E1000_RX_BUFFER_WRITE - 1)))) {
<a name="l01034"></a>01034             <span class="comment">/*</span>
<a name="l01035"></a>01035 <span class="comment">             * Force memory writes to complete before letting h/w</span>
<a name="l01036"></a>01036 <span class="comment">             * know there are new descriptors to fetch.  (Only</span>
<a name="l01037"></a>01037 <span class="comment">             * applicable for weak-ordered memory model archs,</span>
<a name="l01038"></a>01038 <span class="comment">             * such as IA-64).</span>
<a name="l01039"></a>01039 <span class="comment">             */</span>
<a name="l01040"></a>01040             wmb();
<a name="l01041"></a>01041             writel(i &lt;&lt; 1, adapter-&gt;hw.hw_addr + rx_ring-&gt;tail);
<a name="l01042"></a>01042         }
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         i++;
<a name="l01045"></a>01045         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l01046"></a>01046             i = 0;
<a name="l01047"></a>01047         buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 no_buffers:
<a name="l01051"></a>01051     rx_ring-&gt;next_to_use = i;
<a name="l01052"></a>01052 }
<a name="l01053"></a>01053 
<a name="l01054"></a>01054 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01055"></a>01055 <span class="preprocessor"></span>
<a name="l01061"></a>01061 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_alloc_jumbo_rx_buffers(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l01062"></a>01062                                          <span class="keywordtype">int</span> cleaned_count)
<a name="l01063"></a>01063 {
<a name="l01064"></a>01064     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01065"></a>01065     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01066"></a>01066     <span class="keyword">struct </span><a class="code" href="structe1000__rx__desc.html">e1000_rx_desc</a> *rx_desc;
<a name="l01067"></a>01067     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l01068"></a>01068     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l01069"></a>01069     <span class="keyword">struct </span>sk_buff *skb;
<a name="l01070"></a>01070     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l01071"></a>01071     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufsz = 256 - 16 <span class="comment">/* for skb_reserve */</span>;
<a name="l01072"></a>01072 
<a name="l01073"></a>01073     i = rx_ring-&gt;next_to_use;
<a name="l01074"></a>01074     buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01075"></a>01075 
<a name="l01076"></a>01076     <span class="keywordflow">while</span> (cleaned_count--) {
<a name="l01077"></a>01077         skb = buffer_info-&gt;skb;
<a name="l01078"></a>01078         <span class="keywordflow">if</span> (skb) {
<a name="l01079"></a>01079             skb_trim(skb, 0);
<a name="l01080"></a>01080             <span class="keywordflow">goto</span> check_page;
<a name="l01081"></a>01081         }
<a name="l01082"></a>01082 
<a name="l01083"></a>01083         skb = netdev_alloc_skb_ip_align(netdev, bufsz);
<a name="l01084"></a>01084         <span class="keywordflow">if</span> (unlikely(!skb)) {
<a name="l01085"></a>01085             <span class="comment">/* Better luck next round */</span>
<a name="l01086"></a>01086             adapter-&gt;alloc_rx_buff_failed++;
<a name="l01087"></a>01087             <span class="keywordflow">break</span>;
<a name="l01088"></a>01088         }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090         buffer_info-&gt;skb = skb;
<a name="l01091"></a>01091 check_page:
<a name="l01092"></a>01092         <span class="comment">/* allocate a new page if necessary */</span>
<a name="l01093"></a>01093         <span class="keywordflow">if</span> (!buffer_info-&gt;page) {
<a name="l01094"></a>01094             buffer_info-&gt;page = alloc_pages_node(adapter-&gt;node,
<a name="l01095"></a>01095                                  GFP_ATOMIC, 0);
<a name="l01096"></a>01096             <span class="keywordflow">if</span> (unlikely(!buffer_info-&gt;page)) {
<a name="l01097"></a>01097                 adapter-&gt;alloc_rx_buff_failed++;
<a name="l01098"></a>01098                 <span class="keywordflow">break</span>;
<a name="l01099"></a>01099             }
<a name="l01100"></a>01100         }
<a name="l01101"></a>01101 
<a name="l01102"></a>01102         <span class="keywordflow">if</span> (!buffer_info-&gt;dma)
<a name="l01103"></a>01103             buffer_info-&gt;dma = dma_map_page(pci_dev_to_dev(pdev),
<a name="l01104"></a>01104                             buffer_info-&gt;page, 0,
<a name="l01105"></a>01105                             PAGE_SIZE,
<a name="l01106"></a>01106                             DMA_FROM_DEVICE);
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         rx_desc = E1000_RX_DESC(*rx_ring, i);
<a name="l01109"></a>01109         rx_desc-&gt;buffer_addr = cpu_to_le64(buffer_info-&gt;dma);
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="keywordflow">if</span> (unlikely(++i == rx_ring-&gt;count))
<a name="l01112"></a>01112             i = 0;
<a name="l01113"></a>01113         buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="keywordflow">if</span> (likely(rx_ring-&gt;next_to_use != i)) {
<a name="l01117"></a>01117         rx_ring-&gt;next_to_use = i;
<a name="l01118"></a>01118         <span class="keywordflow">if</span> (unlikely(i-- == 0))
<a name="l01119"></a>01119             i = (rx_ring-&gt;count - 1);
<a name="l01120"></a>01120 
<a name="l01121"></a>01121         <span class="comment">/* Force memory writes to complete before letting h/w</span>
<a name="l01122"></a>01122 <span class="comment">         * know there are new descriptors to fetch.  (Only</span>
<a name="l01123"></a>01123 <span class="comment">         * applicable for weak-ordered memory model archs,</span>
<a name="l01124"></a>01124 <span class="comment">         * such as IA-64). */</span>
<a name="l01125"></a>01125         wmb();
<a name="l01126"></a>01126         writel(i, adapter-&gt;hw.hw_addr + rx_ring-&gt;tail);
<a name="l01127"></a>01127     }
<a name="l01128"></a>01128 }
<a name="l01129"></a>01129 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_NAPI */</span>
<a name="l01130"></a>01130 
<a name="l01138"></a>01138 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01139"></a>01139 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_clean_rx_irq(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l01140"></a>01140                    <span class="keywordtype">int</span> *work_done, <span class="keywordtype">int</span> work_to_do)
<a name="l01141"></a>01141 <span class="preprocessor">#else</span>
<a name="l01142"></a>01142 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_clean_rx_irq(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l01143"></a>01143 <span class="preprocessor">#endif</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>{
<a name="l01145"></a>01145     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01146"></a>01146     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01147"></a>01147     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01148"></a>01148     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l01149"></a>01149     <span class="keyword">struct </span><a class="code" href="structe1000__rx__desc.html">e1000_rx_desc</a> *rx_desc, *next_rxd;
<a name="l01150"></a>01150     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info, *next_buffer;
<a name="l01151"></a>01151     u32 length;
<a name="l01152"></a>01152     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l01153"></a>01153     <span class="keywordtype">int</span> cleaned_count = 0;
<a name="l01154"></a>01154     <span class="keywordtype">bool</span> cleaned = 0;
<a name="l01155"></a>01155     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_rx_bytes = 0, total_rx_packets = 0;
<a name="l01156"></a>01156 
<a name="l01157"></a>01157     i = rx_ring-&gt;next_to_clean;
<a name="l01158"></a>01158     rx_desc = E1000_RX_DESC(*rx_ring, i);
<a name="l01159"></a>01159     buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01160"></a>01160 
<a name="l01161"></a>01161     <span class="keywordflow">while</span> (rx_desc-&gt;status &amp; E1000_RXD_STAT_DD) {
<a name="l01162"></a>01162         <span class="keyword">struct </span>sk_buff *skb;
<a name="l01163"></a>01163         u8 status;
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01166"></a>01166 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (*work_done &gt;= work_to_do)
<a name="l01167"></a>01167             <span class="keywordflow">break</span>;
<a name="l01168"></a>01168         (*work_done)++;
<a name="l01169"></a>01169 <span class="preprocessor">#endif</span>
<a name="l01170"></a>01170 <span class="preprocessor"></span>        rmb();  <span class="comment">/* read descriptor and rx_buffer_info after status DD */</span>
<a name="l01171"></a>01171 
<a name="l01172"></a>01172         status = rx_desc-&gt;status;
<a name="l01173"></a>01173         skb = buffer_info-&gt;skb;
<a name="l01174"></a>01174         buffer_info-&gt;skb = NULL;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176         prefetch(skb-&gt;data - NET_IP_ALIGN);
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         i++;
<a name="l01179"></a>01179         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l01180"></a>01180             i = 0;
<a name="l01181"></a>01181         next_rxd = E1000_RX_DESC(*rx_ring, i);
<a name="l01182"></a>01182         prefetch(next_rxd);
<a name="l01183"></a>01183 
<a name="l01184"></a>01184         next_buffer = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01185"></a>01185 
<a name="l01186"></a>01186         cleaned = 1;
<a name="l01187"></a>01187         cleaned_count++;
<a name="l01188"></a>01188         dma_unmap_single(pci_dev_to_dev(pdev),
<a name="l01189"></a>01189                  buffer_info-&gt;dma,
<a name="l01190"></a>01190                  adapter-&gt;rx_buffer_len,
<a name="l01191"></a>01191                  DMA_FROM_DEVICE);
<a name="l01192"></a>01192         buffer_info-&gt;dma = 0;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         length = le16_to_cpu(rx_desc-&gt;length);
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         <span class="comment">/*</span>
<a name="l01197"></a>01197 <span class="comment">         * !EOP means multiple descriptors were used to store a single</span>
<a name="l01198"></a>01198 <span class="comment">         * packet, if that&#39;s the case we need to toss it.  In fact, we</span>
<a name="l01199"></a>01199 <span class="comment">         * need to toss every packet with the EOP bit clear and the</span>
<a name="l01200"></a>01200 <span class="comment">         * next frame that _does_ have the EOP bit set, as it is by</span>
<a name="l01201"></a>01201 <span class="comment">         * definition only a frame fragment</span>
<a name="l01202"></a>01202 <span class="comment">         */</span>
<a name="l01203"></a>01203         <span class="keywordflow">if</span> (unlikely(!(status &amp; E1000_RXD_STAT_EOP)))
<a name="l01204"></a>01204             adapter-&gt;flags2 |= FLAG2_IS_DISCARDING;
<a name="l01205"></a>01205 
<a name="l01206"></a>01206         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_IS_DISCARDING) {
<a name="l01207"></a>01207             <span class="comment">/* All receives must fit into a single buffer */</span>
<a name="l01208"></a>01208             e_dbg(<span class="stringliteral">&quot;Receive packet consumed multiple buffers\n&quot;</span>);
<a name="l01209"></a>01209             <span class="comment">/* recycle */</span>
<a name="l01210"></a>01210             buffer_info-&gt;skb = skb;
<a name="l01211"></a>01211             <span class="keywordflow">if</span> (status &amp; E1000_RXD_STAT_EOP)
<a name="l01212"></a>01212                 adapter-&gt;flags2 &amp;= ~FLAG2_IS_DISCARDING;
<a name="l01213"></a>01213             <span class="keywordflow">goto</span> next_desc;
<a name="l01214"></a>01214         }
<a name="l01215"></a>01215 
<a name="l01216"></a>01216         <span class="keywordflow">if</span> (rx_desc-&gt;errors &amp; E1000_RXD_ERR_FRAME_ERR_MASK) {
<a name="l01217"></a>01217             <span class="comment">/* recycle */</span>
<a name="l01218"></a>01218             buffer_info-&gt;skb = skb;
<a name="l01219"></a>01219             <span class="keywordflow">goto</span> next_desc;
<a name="l01220"></a>01220         }
<a name="l01221"></a>01221 
<a name="l01222"></a>01222         <span class="comment">/* adjust length to remove Ethernet CRC */</span>
<a name="l01223"></a>01223         <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; FLAG2_CRC_STRIPPING))
<a name="l01224"></a>01224             length -= 4;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226         total_rx_bytes += length;
<a name="l01227"></a>01227         total_rx_packets++;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229         <span class="comment">/*</span>
<a name="l01230"></a>01230 <span class="comment">         * code added for copybreak, this should improve</span>
<a name="l01231"></a>01231 <span class="comment">         * performance for small packets with large amounts</span>
<a name="l01232"></a>01232 <span class="comment">         * of reassembly being done in the stack</span>
<a name="l01233"></a>01233 <span class="comment">         */</span>
<a name="l01234"></a>01234         <span class="keywordflow">if</span> (length &lt; copybreak) {
<a name="l01235"></a>01235             <span class="keyword">struct </span>sk_buff *new_skb =
<a name="l01236"></a>01236                 netdev_alloc_skb_ip_align(netdev, length);
<a name="l01237"></a>01237             <span class="keywordflow">if</span> (new_skb) {
<a name="l01238"></a>01238                 skb_copy_to_linear_data_offset(new_skb,
<a name="l01239"></a>01239                                    -NET_IP_ALIGN,
<a name="l01240"></a>01240                                    (skb-&gt;data -
<a name="l01241"></a>01241                                 NET_IP_ALIGN),
<a name="l01242"></a>01242                                    (length +
<a name="l01243"></a>01243                                 NET_IP_ALIGN));
<a name="l01244"></a>01244                 <span class="comment">/* save the skb in buffer_info as good */</span>
<a name="l01245"></a>01245                 buffer_info-&gt;skb = skb;
<a name="l01246"></a>01246                 skb = new_skb;
<a name="l01247"></a>01247             }
<a name="l01248"></a>01248             <span class="comment">/* else just continue with the old one */</span>
<a name="l01249"></a>01249         }
<a name="l01250"></a>01250         <span class="comment">/* end copybreak code */</span>
<a name="l01251"></a>01251         skb_put(skb, length);
<a name="l01252"></a>01252 
<a name="l01253"></a>01253         <span class="comment">/* Receive Checksum Offload */</span>
<a name="l01254"></a>01254         e1000_rx_checksum(adapter,
<a name="l01255"></a>01255                   (u32)(status) |
<a name="l01256"></a>01256                   ((u32)(rx_desc-&gt;errors) &lt;&lt; 24),
<a name="l01257"></a>01257                   le16_to_cpu(rx_desc-&gt;csum), skb);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l01260"></a>01260 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(e1000_receive_skb(adapter, netdev, skb, status, rx_desc-&gt;special) == 2) {
<a name="l01261"></a>01261           <span class="comment">/* Force adapter to stop polling as we have no room for packets */</span>
<a name="l01262"></a>01262           <span class="comment">/* printk(&quot;[PF_RING] No room for packets\n&quot;);  */</span>
<a name="l01263"></a>01263           *work_done = work_to_do;
<a name="l01264"></a>01264           <span class="comment">/* schedule(); */</span>
<a name="l01265"></a>01265         }
<a name="l01266"></a>01266 <span class="preprocessor">#else</span>
<a name="l01267"></a>01267 <span class="preprocessor"></span>        e1000_receive_skb(adapter, netdev, skb, status, rx_desc-&gt;special);
<a name="l01268"></a>01268 <span class="preprocessor">#endif</span>
<a name="l01269"></a>01269 <span class="preprocessor"></span>
<a name="l01270"></a>01270 next_desc:
<a name="l01271"></a>01271         rx_desc-&gt;status = 0;
<a name="l01272"></a>01272 
<a name="l01273"></a>01273         <span class="comment">/* return some buffers to hardware, one at a time is too slow */</span>
<a name="l01274"></a>01274         <span class="keywordflow">if</span> (cleaned_count &gt;= E1000_RX_BUFFER_WRITE) {
<a name="l01275"></a>01275             adapter-&gt;alloc_rx_buf(adapter, cleaned_count);
<a name="l01276"></a>01276             cleaned_count = 0;
<a name="l01277"></a>01277         }
<a name="l01278"></a>01278 
<a name="l01279"></a>01279         <span class="comment">/* use prefetched values */</span>
<a name="l01280"></a>01280         rx_desc = next_rxd;
<a name="l01281"></a>01281         buffer_info = next_buffer;
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283     rx_ring-&gt;next_to_clean = i;
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     cleaned_count = e1000_desc_unused(rx_ring);
<a name="l01286"></a>01286     <span class="keywordflow">if</span> (cleaned_count)
<a name="l01287"></a>01287         adapter-&gt;alloc_rx_buf(adapter, cleaned_count);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     adapter-&gt;total_rx_bytes += total_rx_bytes;
<a name="l01290"></a>01290     adapter-&gt;total_rx_packets += total_rx_packets;
<a name="l01291"></a>01291 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l01292"></a>01292 <span class="preprocessor"></span>    netdev-&gt;stats.rx_bytes += total_rx_bytes;
<a name="l01293"></a>01293     netdev-&gt;stats.rx_packets += total_rx_packets;
<a name="l01294"></a>01294 <span class="preprocessor">#else</span>
<a name="l01295"></a>01295 <span class="preprocessor"></span>    adapter-&gt;net_stats.rx_bytes += total_rx_bytes;
<a name="l01296"></a>01296     adapter-&gt;net_stats.rx_packets += total_rx_packets;
<a name="l01297"></a>01297 <span class="preprocessor">#endif</span>
<a name="l01298"></a>01298 <span class="preprocessor"></span>    <span class="keywordflow">return</span> cleaned;
<a name="l01299"></a>01299 }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_put_txbuf(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l01302"></a>01302                  <span class="keyword">struct</span> <a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info)
<a name="l01303"></a>01303 {
<a name="l01304"></a>01304     <span class="keywordflow">if</span> (buffer_info-&gt;dma) {
<a name="l01305"></a>01305         <span class="keywordflow">if</span> (buffer_info-&gt;mapped_as_page)
<a name="l01306"></a>01306             dma_unmap_page(pci_dev_to_dev(adapter-&gt;pdev), buffer_info-&gt;dma,
<a name="l01307"></a>01307                        buffer_info-&gt;length, DMA_TO_DEVICE);
<a name="l01308"></a>01308         <span class="keywordflow">else</span>
<a name="l01309"></a>01309             dma_unmap_single(pci_dev_to_dev(adapter-&gt;pdev), buffer_info-&gt;dma,
<a name="l01310"></a>01310                      buffer_info-&gt;length, DMA_TO_DEVICE);
<a name="l01311"></a>01311         buffer_info-&gt;dma = 0;
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313     <span class="keywordflow">if</span> (buffer_info-&gt;skb) {
<a name="l01314"></a>01314         dev_kfree_skb_any(buffer_info-&gt;skb);
<a name="l01315"></a>01315         buffer_info-&gt;skb = NULL;
<a name="l01316"></a>01316     }
<a name="l01317"></a>01317 }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_print_hw_hang(<span class="keyword">struct</span> work_struct *work)
<a name="l01320"></a>01320 {
<a name="l01321"></a>01321     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = container_of(work,
<a name="l01322"></a>01322                                                  <span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a>,
<a name="l01323"></a>01323                                                  print_hang_task);
<a name="l01324"></a>01324     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l01325"></a>01325     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = tx_ring-&gt;next_to_clean;
<a name="l01326"></a>01326     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eop = tx_ring-&gt;buffer_info[i].next_to_watch;
<a name="l01327"></a>01327     <span class="keyword">struct </span><a class="code" href="structe1000__tx__desc.html">e1000_tx_desc</a> *eop_desc = E1000_TX_DESC(*tx_ring, eop);
<a name="l01328"></a>01328     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01329"></a>01329     u16 phy_status, phy_1000t_status, phy_ext_status;
<a name="l01330"></a>01330     u16 pci_status;
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="keywordflow">if</span> (test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l01333"></a>01333         <span class="keywordflow">return</span>;
<a name="l01334"></a>01334 
<a name="l01335"></a>01335     e1e_rphy(hw, PHY_STATUS, &amp;phy_status);
<a name="l01336"></a>01336     e1e_rphy(hw, PHY_1000T_STATUS, &amp;phy_1000t_status);
<a name="l01337"></a>01337     e1e_rphy(hw, PHY_EXT_STATUS, &amp;phy_ext_status);
<a name="l01338"></a>01338 
<a name="l01339"></a>01339     pci_read_config_word(adapter-&gt;pdev, PCI_STATUS, &amp;pci_status);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341     <span class="comment">/* detected Hardware unit hang */</span>
<a name="l01342"></a>01342     e_err(<span class="stringliteral">&quot;Detected Hardware Unit Hang:\n&quot;</span>
<a name="l01343"></a>01343           <span class="stringliteral">&quot;  TDH                  &lt;%x&gt;\n&quot;</span>
<a name="l01344"></a>01344           <span class="stringliteral">&quot;  TDT                  &lt;%x&gt;\n&quot;</span>
<a name="l01345"></a>01345           <span class="stringliteral">&quot;  next_to_use          &lt;%x&gt;\n&quot;</span>
<a name="l01346"></a>01346           <span class="stringliteral">&quot;  next_to_clean        &lt;%x&gt;\n&quot;</span>
<a name="l01347"></a>01347           <span class="stringliteral">&quot;buffer_info[next_to_clean]:\n&quot;</span>
<a name="l01348"></a>01348           <span class="stringliteral">&quot;  time_stamp           &lt;%lx&gt;\n&quot;</span>
<a name="l01349"></a>01349           <span class="stringliteral">&quot;  next_to_watch        &lt;%x&gt;\n&quot;</span>
<a name="l01350"></a>01350           <span class="stringliteral">&quot;  jiffies              &lt;%lx&gt;\n&quot;</span>
<a name="l01351"></a>01351           <span class="stringliteral">&quot;  next_to_watch.status &lt;%x&gt;\n&quot;</span>
<a name="l01352"></a>01352           <span class="stringliteral">&quot;MAC Status             &lt;%x&gt;\n&quot;</span>
<a name="l01353"></a>01353           <span class="stringliteral">&quot;PHY Status             &lt;%x&gt;\n&quot;</span>
<a name="l01354"></a>01354           <span class="stringliteral">&quot;PHY 1000BASE-T Status  &lt;%x&gt;\n&quot;</span>
<a name="l01355"></a>01355           <span class="stringliteral">&quot;PHY Extended Status    &lt;%x&gt;\n&quot;</span>
<a name="l01356"></a>01356           <span class="stringliteral">&quot;PCI Status             &lt;%x&gt;\n&quot;</span>,
<a name="l01357"></a>01357           readl(adapter-&gt;hw.hw_addr + tx_ring-&gt;head),
<a name="l01358"></a>01358           readl(adapter-&gt;hw.hw_addr + tx_ring-&gt;tail),
<a name="l01359"></a>01359           tx_ring-&gt;next_to_use,
<a name="l01360"></a>01360           tx_ring-&gt;next_to_clean,
<a name="l01361"></a>01361           tx_ring-&gt;buffer_info[eop].time_stamp,
<a name="l01362"></a>01362           eop,
<a name="l01363"></a>01363           jiffies,
<a name="l01364"></a>01364           eop_desc-&gt;upper.fields.status,
<a name="l01365"></a>01365           er32(STATUS),
<a name="l01366"></a>01366           phy_status,
<a name="l01367"></a>01367           phy_1000t_status,
<a name="l01368"></a>01368           phy_ext_status,
<a name="l01369"></a>01369           pci_status);
<a name="l01370"></a>01370 
<a name="l01371"></a>01371     <span class="comment">/* Suggest workaround for known h/w issue */</span>
<a name="l01372"></a>01372     <span class="keywordflow">if</span> ((hw-&gt;mac.type == e1000_pchlan) &amp;&amp; (er32(CTRL) &amp; E1000_CTRL_TFCE))
<a name="l01373"></a>01373         e_err(<span class="stringliteral">&quot;Try turning off Tx pause (flow control) via ethtool\n&quot;</span>);
<a name="l01374"></a>01374 }
<a name="l01375"></a>01375 
<a name="l01382"></a>01382 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_clean_tx_irq(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l01383"></a>01383 {
<a name="l01384"></a>01384     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01385"></a>01385     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01386"></a>01386     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l01387"></a>01387     <span class="keyword">struct </span><a class="code" href="structe1000__tx__desc.html">e1000_tx_desc</a> *tx_desc, *eop_desc;
<a name="l01388"></a>01388     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l01389"></a>01389     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, eop;
<a name="l01390"></a>01390     <span class="keywordtype">bool</span> cleaned = 0, retval = 1;
<a name="l01391"></a>01391     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_tx_bytes = 0, total_tx_packets = 0;
<a name="l01392"></a>01392 
<a name="l01393"></a>01393     i = tx_ring-&gt;next_to_clean;
<a name="l01394"></a>01394     eop = tx_ring-&gt;buffer_info[i].next_to_watch;
<a name="l01395"></a>01395     eop_desc = E1000_TX_DESC(*tx_ring, eop);
<a name="l01396"></a>01396 
<a name="l01397"></a>01397     <span class="keywordflow">while</span> (eop_desc-&gt;upper.data &amp; cpu_to_le32(E1000_TXD_STAT_DD)) {
<a name="l01398"></a>01398         rmb(); <span class="comment">/* read buffer_info after eop_desc */</span>
<a name="l01399"></a>01399         <span class="keywordflow">for</span> (cleaned = 0; !cleaned; ) {
<a name="l01400"></a>01400             tx_desc = E1000_TX_DESC(*tx_ring, i);
<a name="l01401"></a>01401             buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l01402"></a>01402             cleaned = (i == eop);
<a name="l01403"></a>01403 
<a name="l01404"></a>01404             <span class="keywordflow">if</span> (cleaned) {
<a name="l01405"></a>01405                 total_tx_packets += buffer_info-&gt;segs;
<a name="l01406"></a>01406                 total_tx_bytes += buffer_info-&gt;bytecount;
<a name="l01407"></a>01407             }
<a name="l01408"></a>01408 
<a name="l01409"></a>01409             e1000_put_txbuf(adapter, buffer_info);
<a name="l01410"></a>01410             tx_desc-&gt;upper.data = 0;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412             i++;
<a name="l01413"></a>01413             <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l01414"></a>01414                 i = 0;
<a name="l01415"></a>01415 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01416"></a>01416 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (total_tx_packets &gt;= tx_ring-&gt;count) {
<a name="l01417"></a>01417                 retval = 0;
<a name="l01418"></a>01418                 <span class="keywordflow">goto</span> done_cleaning;
<a name="l01419"></a>01419             }
<a name="l01420"></a>01420 <span class="preprocessor">#endif</span>
<a name="l01421"></a>01421 <span class="preprocessor"></span>        }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423         <span class="keywordflow">if</span> (i == tx_ring-&gt;next_to_use)
<a name="l01424"></a>01424             <span class="keywordflow">break</span>;
<a name="l01425"></a>01425         eop = tx_ring-&gt;buffer_info[i].next_to_watch;
<a name="l01426"></a>01426         eop_desc = E1000_TX_DESC(*tx_ring, eop);
<a name="l01427"></a>01427     }
<a name="l01428"></a>01428 
<a name="l01429"></a>01429 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01430"></a>01430 <span class="preprocessor"></span>done_cleaning:
<a name="l01431"></a>01431 <span class="preprocessor">#endif</span>
<a name="l01432"></a>01432 <span class="preprocessor"></span>    tx_ring-&gt;next_to_clean = i;
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="preprocessor">#define TX_WAKE_THRESHOLD 32</span>
<a name="l01435"></a>01435 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (cleaned &amp;&amp; netif_carrier_ok(netdev) &amp;&amp;
<a name="l01436"></a>01436              e1000_desc_unused(tx_ring) &gt;= TX_WAKE_THRESHOLD) {
<a name="l01437"></a>01437         <span class="comment">/* Make sure that anybody stopping the queue after this</span>
<a name="l01438"></a>01438 <span class="comment">         * sees the new next_to_clean.</span>
<a name="l01439"></a>01439 <span class="comment">         */</span>
<a name="l01440"></a>01440         smp_mb();
<a name="l01441"></a>01441 
<a name="l01442"></a>01442         <span class="keywordflow">if</span> (netif_queue_stopped(netdev) &amp;&amp;
<a name="l01443"></a>01443             !(test_bit(__E1000_DOWN, &amp;adapter-&gt;state))) {
<a name="l01444"></a>01444             netif_wake_queue(netdev);
<a name="l01445"></a>01445             ++adapter-&gt;restart_queue;
<a name="l01446"></a>01446         }
<a name="l01447"></a>01447     }
<a name="l01448"></a>01448 
<a name="l01449"></a>01449     <span class="keywordflow">if</span> (adapter-&gt;detect_tx_hung) {
<a name="l01450"></a>01450         <span class="comment">/*</span>
<a name="l01451"></a>01451 <span class="comment">         * Detect a transmit hang in hardware, this serializes the</span>
<a name="l01452"></a>01452 <span class="comment">         * check with the clearing of time_stamp and movement of i</span>
<a name="l01453"></a>01453 <span class="comment">         */</span>
<a name="l01454"></a>01454         adapter-&gt;detect_tx_hung = 0;
<a name="l01455"></a>01455         <span class="keywordflow">if</span> (tx_ring-&gt;buffer_info[eop].dma &amp;&amp;
<a name="l01456"></a>01456             time_after(jiffies, tx_ring-&gt;buffer_info[eop].time_stamp
<a name="l01457"></a>01457                    + (adapter-&gt;tx_timeout_factor * HZ)) &amp;&amp;
<a name="l01458"></a>01458             !(er32(STATUS) &amp; E1000_STATUS_TXOFF)) {
<a name="l01459"></a>01459             schedule_work(&amp;adapter-&gt;print_hang_task);
<a name="l01460"></a>01460             netif_stop_queue(netdev);
<a name="l01461"></a>01461         }
<a name="l01462"></a>01462     }
<a name="l01463"></a>01463     adapter-&gt;total_tx_bytes += total_tx_bytes;
<a name="l01464"></a>01464     adapter-&gt;total_tx_packets += total_tx_packets;
<a name="l01465"></a>01465 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l01466"></a>01466 <span class="preprocessor"></span>    netdev-&gt;stats.tx_bytes += total_tx_bytes;
<a name="l01467"></a>01467     netdev-&gt;stats.tx_packets += total_tx_packets;
<a name="l01468"></a>01468 <span class="preprocessor">#else</span>
<a name="l01469"></a>01469 <span class="preprocessor"></span>    adapter-&gt;net_stats.tx_bytes += total_tx_bytes;
<a name="l01470"></a>01470     adapter-&gt;net_stats.tx_packets += total_tx_packets;
<a name="l01471"></a>01471 <span class="preprocessor">#endif</span>
<a name="l01472"></a>01472 <span class="preprocessor"></span>    <span class="keywordflow">return</span> retval;
<a name="l01473"></a>01473 }
<a name="l01474"></a>01474 
<a name="l01482"></a>01482 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01483"></a>01483 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_clean_rx_irq_ps(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l01484"></a>01484                   <span class="keywordtype">int</span> *work_done, <span class="keywordtype">int</span> work_to_do)
<a name="l01485"></a>01485 <span class="preprocessor">#else</span>
<a name="l01486"></a>01486 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_clean_rx_irq_ps(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l01487"></a>01487 <span class="preprocessor">#endif</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span>{
<a name="l01489"></a>01489     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01490"></a>01490     <span class="keyword">union </span><a class="code" href="unione1000__rx__desc__packet__split.html">e1000_rx_desc_packet_split</a> *rx_desc, *next_rxd;
<a name="l01491"></a>01491     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01492"></a>01492     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01493"></a>01493     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l01494"></a>01494     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info, *next_buffer;
<a name="l01495"></a>01495     <span class="keyword">struct </span><a class="code" href="structe1000__ps__page.html">e1000_ps_page</a> *ps_page;
<a name="l01496"></a>01496     <span class="keyword">struct </span>sk_buff *skb;
<a name="l01497"></a>01497     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l01498"></a>01498     u32 length, staterr;
<a name="l01499"></a>01499     <span class="keywordtype">int</span> cleaned_count = 0;
<a name="l01500"></a>01500     <span class="keywordtype">bool</span> cleaned = 0;
<a name="l01501"></a>01501     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_rx_bytes = 0, total_rx_packets = 0;
<a name="l01502"></a>01502 
<a name="l01503"></a>01503     i = rx_ring-&gt;next_to_clean;
<a name="l01504"></a>01504     rx_desc = E1000_RX_DESC_PS(*rx_ring, i);
<a name="l01505"></a>01505     staterr = le32_to_cpu(rx_desc-&gt;wb.middle.status_error);
<a name="l01506"></a>01506     buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01507"></a>01507 
<a name="l01508"></a>01508     <span class="keywordflow">while</span> (staterr &amp; E1000_RXD_STAT_DD) {
<a name="l01509"></a>01509 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01510"></a>01510 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (*work_done &gt;= work_to_do)
<a name="l01511"></a>01511             <span class="keywordflow">break</span>;
<a name="l01512"></a>01512         (*work_done)++;
<a name="l01513"></a>01513 <span class="preprocessor">#endif</span>
<a name="l01514"></a>01514 <span class="preprocessor"></span>        skb = buffer_info-&gt;skb;
<a name="l01515"></a>01515         rmb();  <span class="comment">/* read descriptor and rx_buffer_info after status DD */</span>
<a name="l01516"></a>01516 
<a name="l01517"></a>01517         <span class="comment">/* in the packet split case this is header only */</span>
<a name="l01518"></a>01518         prefetch(skb-&gt;data - NET_IP_ALIGN);
<a name="l01519"></a>01519 
<a name="l01520"></a>01520         i++;
<a name="l01521"></a>01521         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l01522"></a>01522             i = 0;
<a name="l01523"></a>01523         next_rxd = E1000_RX_DESC_PS(*rx_ring, i);
<a name="l01524"></a>01524         prefetch(next_rxd);
<a name="l01525"></a>01525 
<a name="l01526"></a>01526         next_buffer = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01527"></a>01527 
<a name="l01528"></a>01528         cleaned = 1;
<a name="l01529"></a>01529         cleaned_count++;
<a name="l01530"></a>01530         dma_unmap_single(pci_dev_to_dev(pdev), buffer_info-&gt;dma,
<a name="l01531"></a>01531                  adapter-&gt;rx_ps_bsize0, DMA_FROM_DEVICE);
<a name="l01532"></a>01532         buffer_info-&gt;dma = 0;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534         <span class="comment">/* see !EOP comment in other Rx routine */</span>
<a name="l01535"></a>01535         <span class="keywordflow">if</span> (!(staterr &amp; E1000_RXD_STAT_EOP))
<a name="l01536"></a>01536             adapter-&gt;flags2 |= FLAG2_IS_DISCARDING;
<a name="l01537"></a>01537 
<a name="l01538"></a>01538         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_IS_DISCARDING) {
<a name="l01539"></a>01539             e_dbg(<span class="stringliteral">&quot;Packet Split buffers didn&#39;t pick up the full &quot;</span>
<a name="l01540"></a>01540                   <span class="stringliteral">&quot;packet\n&quot;</span>);
<a name="l01541"></a>01541             dev_kfree_skb_irq(skb);
<a name="l01542"></a>01542             <span class="keywordflow">if</span> (staterr &amp; E1000_RXD_STAT_EOP)
<a name="l01543"></a>01543                 adapter-&gt;flags2 &amp;= ~FLAG2_IS_DISCARDING;
<a name="l01544"></a>01544             <span class="keywordflow">goto</span> next_desc;
<a name="l01545"></a>01545         }
<a name="l01546"></a>01546 
<a name="l01547"></a>01547         <span class="keywordflow">if</span> (staterr &amp; E1000_RXDEXT_ERR_FRAME_ERR_MASK) {
<a name="l01548"></a>01548             dev_kfree_skb_irq(skb);
<a name="l01549"></a>01549             <span class="keywordflow">goto</span> next_desc;
<a name="l01550"></a>01550         }
<a name="l01551"></a>01551 
<a name="l01552"></a>01552         length = le16_to_cpu(rx_desc-&gt;wb.middle.length0);
<a name="l01553"></a>01553 
<a name="l01554"></a>01554         <span class="keywordflow">if</span> (!length) {
<a name="l01555"></a>01555             e_dbg(<span class="stringliteral">&quot;Last part of the packet spanning multiple &quot;</span>
<a name="l01556"></a>01556                   <span class="stringliteral">&quot;descriptors\n&quot;</span>);
<a name="l01557"></a>01557             dev_kfree_skb_irq(skb);
<a name="l01558"></a>01558             <span class="keywordflow">goto</span> next_desc;
<a name="l01559"></a>01559         }
<a name="l01560"></a>01560 
<a name="l01561"></a>01561         <span class="comment">/* Good Receive */</span>
<a name="l01562"></a>01562         skb_put(skb, length);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01565"></a>01565 <span class="preprocessor"></span>        {
<a name="l01566"></a>01566         <span class="comment">/*</span>
<a name="l01567"></a>01567 <span class="comment">         * this looks ugly, but it seems compiler issues make it</span>
<a name="l01568"></a>01568 <span class="comment">         * more efficient than reusing j</span>
<a name="l01569"></a>01569 <span class="comment">         */</span>
<a name="l01570"></a>01570         <span class="keywordtype">int</span> l1 = le16_to_cpu(rx_desc-&gt;wb.upper.length[0]);
<a name="l01571"></a>01571 
<a name="l01572"></a>01572         <span class="comment">/*</span>
<a name="l01573"></a>01573 <span class="comment">         * page alloc/put takes too long and effects small packet</span>
<a name="l01574"></a>01574 <span class="comment">         * throughput, so unsplit small packets and save the alloc/put</span>
<a name="l01575"></a>01575 <span class="comment">         * only valid in softirq (napi) context to call kmap_*</span>
<a name="l01576"></a>01576 <span class="comment">         */</span>
<a name="l01577"></a>01577         <span class="keywordflow">if</span> (l1 &amp;&amp; (l1 &lt;= copybreak) &amp;&amp;
<a name="l01578"></a>01578             ((length + l1) &lt;= adapter-&gt;rx_ps_bsize0)) {
<a name="l01579"></a>01579             u8 *vaddr;
<a name="l01580"></a>01580 
<a name="l01581"></a>01581             ps_page = &amp;buffer_info-&gt;ps_pages[0];
<a name="l01582"></a>01582 
<a name="l01583"></a>01583             <span class="comment">/*</span>
<a name="l01584"></a>01584 <span class="comment">             * there is no documentation about how to call</span>
<a name="l01585"></a>01585 <span class="comment">             * kmap_atomic, so we can&#39;t hold the mapping</span>
<a name="l01586"></a>01586 <span class="comment">             * very long</span>
<a name="l01587"></a>01587 <span class="comment">             */</span>
<a name="l01588"></a>01588             dma_sync_single_for_cpu(pci_dev_to_dev(pdev), ps_page-&gt;dma,
<a name="l01589"></a>01589                         PAGE_SIZE, DMA_FROM_DEVICE);
<a name="l01590"></a>01590             vaddr = kmap_atomic(ps_page-&gt;page, KM_SKB_DATA_SOFTIRQ);
<a name="l01591"></a>01591             memcpy(skb_tail_pointer(skb), vaddr, l1);
<a name="l01592"></a>01592             kunmap_atomic(vaddr, KM_SKB_DATA_SOFTIRQ);
<a name="l01593"></a>01593             dma_sync_single_for_device(pci_dev_to_dev(pdev), ps_page-&gt;dma,
<a name="l01594"></a>01594                            PAGE_SIZE, DMA_FROM_DEVICE);
<a name="l01595"></a>01595 
<a name="l01596"></a>01596             <span class="comment">/* remove the CRC */</span>
<a name="l01597"></a>01597             <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; FLAG2_CRC_STRIPPING))
<a name="l01598"></a>01598                 l1 -= 4;
<a name="l01599"></a>01599 
<a name="l01600"></a>01600             skb_put(skb, l1);
<a name="l01601"></a>01601             <span class="keywordflow">goto</span> copydone;
<a name="l01602"></a>01602         } <span class="comment">/* if */</span>
<a name="l01603"></a>01603         }
<a name="l01604"></a>01604 <span class="preprocessor">#endif</span>
<a name="l01605"></a>01605 <span class="preprocessor"></span>
<a name="l01606"></a>01606         <span class="keywordflow">for</span> (j = 0; j &lt; PS_PAGE_BUFFERS; j++) {
<a name="l01607"></a>01607             length = le16_to_cpu(rx_desc-&gt;wb.upper.length[j]);
<a name="l01608"></a>01608             <span class="keywordflow">if</span> (!length)
<a name="l01609"></a>01609                 <span class="keywordflow">break</span>;
<a name="l01610"></a>01610 
<a name="l01611"></a>01611             ps_page = &amp;buffer_info-&gt;ps_pages[j];
<a name="l01612"></a>01612             dma_unmap_page(pci_dev_to_dev(pdev), ps_page-&gt;dma, PAGE_SIZE,
<a name="l01613"></a>01613                        DMA_FROM_DEVICE);
<a name="l01614"></a>01614             ps_page-&gt;dma = 0;
<a name="l01615"></a>01615             skb_fill_page_desc(skb, j, ps_page-&gt;page, 0, length);
<a name="l01616"></a>01616             ps_page-&gt;page = NULL;
<a name="l01617"></a>01617             skb-&gt;len += length;
<a name="l01618"></a>01618             skb-&gt;data_len += length;
<a name="l01619"></a>01619             skb-&gt;truesize += length;
<a name="l01620"></a>01620         }
<a name="l01621"></a>01621 
<a name="l01622"></a>01622         <span class="comment">/* strip the ethernet crc, problem is we&#39;re using pages now so</span>
<a name="l01623"></a>01623 <span class="comment">         * this whole operation can get a little cpu intensive</span>
<a name="l01624"></a>01624 <span class="comment">         */</span>
<a name="l01625"></a>01625         <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; FLAG2_CRC_STRIPPING))
<a name="l01626"></a>01626             pskb_trim(skb, skb-&gt;len - 4);
<a name="l01627"></a>01627 
<a name="l01628"></a>01628 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01629"></a>01629 <span class="preprocessor"></span>copydone:
<a name="l01630"></a>01630 <span class="preprocessor">#endif</span>
<a name="l01631"></a>01631 <span class="preprocessor"></span>        total_rx_bytes += skb-&gt;len;
<a name="l01632"></a>01632         total_rx_packets++;
<a name="l01633"></a>01633 
<a name="l01634"></a>01634         e1000_rx_checksum(adapter, staterr, le16_to_cpu(
<a name="l01635"></a>01635             rx_desc-&gt;wb.lower.hi_dword.csum_ip.csum), skb);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637         <span class="keywordflow">if</span> (rx_desc-&gt;wb.upper.header_status &amp;
<a name="l01638"></a>01638                cpu_to_le16(E1000_RXDPS_HDRSTAT_HDRSP))
<a name="l01639"></a>01639             adapter-&gt;rx_hdr_split++;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641         e1000_receive_skb(adapter, netdev, skb,
<a name="l01642"></a>01642                   staterr, rx_desc-&gt;wb.middle.vlan);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 next_desc:
<a name="l01645"></a>01645         rx_desc-&gt;wb.middle.status_error &amp;= cpu_to_le32(~0xFF);
<a name="l01646"></a>01646         buffer_info-&gt;skb = NULL;
<a name="l01647"></a>01647 
<a name="l01648"></a>01648         <span class="comment">/* return some buffers to hardware, one at a time is too slow */</span>
<a name="l01649"></a>01649         <span class="keywordflow">if</span> (cleaned_count &gt;= E1000_RX_BUFFER_WRITE) {
<a name="l01650"></a>01650             adapter-&gt;alloc_rx_buf(adapter, cleaned_count);
<a name="l01651"></a>01651             cleaned_count = 0;
<a name="l01652"></a>01652         }
<a name="l01653"></a>01653 
<a name="l01654"></a>01654         <span class="comment">/* use prefetched values */</span>
<a name="l01655"></a>01655         rx_desc = next_rxd;
<a name="l01656"></a>01656         buffer_info = next_buffer;
<a name="l01657"></a>01657 
<a name="l01658"></a>01658         staterr = le32_to_cpu(rx_desc-&gt;wb.middle.status_error);
<a name="l01659"></a>01659     }
<a name="l01660"></a>01660     rx_ring-&gt;next_to_clean = i;
<a name="l01661"></a>01661 
<a name="l01662"></a>01662     cleaned_count = e1000_desc_unused(rx_ring);
<a name="l01663"></a>01663     <span class="keywordflow">if</span> (cleaned_count)
<a name="l01664"></a>01664         adapter-&gt;alloc_rx_buf(adapter, cleaned_count);
<a name="l01665"></a>01665 
<a name="l01666"></a>01666     adapter-&gt;total_rx_bytes += total_rx_bytes;
<a name="l01667"></a>01667     adapter-&gt;total_rx_packets += total_rx_packets;
<a name="l01668"></a>01668 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l01669"></a>01669 <span class="preprocessor"></span>    netdev-&gt;stats.rx_bytes += total_rx_bytes;
<a name="l01670"></a>01670     netdev-&gt;stats.rx_packets += total_rx_packets;
<a name="l01671"></a>01671 <span class="preprocessor">#else</span>
<a name="l01672"></a>01672 <span class="preprocessor"></span>    adapter-&gt;net_stats.rx_bytes += total_rx_bytes;
<a name="l01673"></a>01673     adapter-&gt;net_stats.rx_packets += total_rx_packets;
<a name="l01674"></a>01674 <span class="preprocessor">#endif</span>
<a name="l01675"></a>01675 <span class="preprocessor"></span>    <span class="keywordflow">return</span> cleaned;
<a name="l01676"></a>01676 }
<a name="l01677"></a>01677 
<a name="l01678"></a>01678 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01679"></a>01679 <span class="preprocessor"></span>
<a name="l01682"></a>01682 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_consume_page(<span class="keyword">struct</span> <a class="code" href="structe1000__buffer.html">e1000_buffer</a> *bi, <span class="keyword">struct</span> sk_buff *skb,
<a name="l01683"></a>01683                                u16 length)
<a name="l01684"></a>01684 {
<a name="l01685"></a>01685     bi-&gt;page = NULL;
<a name="l01686"></a>01686     skb-&gt;len += length;
<a name="l01687"></a>01687     skb-&gt;data_len += length;
<a name="l01688"></a>01688     skb-&gt;truesize += length;
<a name="l01689"></a>01689 }
<a name="l01690"></a>01690 
<a name="l01699"></a>01699 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_clean_jumbo_rx_irq(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l01700"></a>01700                                      <span class="keywordtype">int</span> *work_done, <span class="keywordtype">int</span> work_to_do)
<a name="l01701"></a>01701 {
<a name="l01702"></a>01702     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l01703"></a>01703     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01704"></a>01704     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l01705"></a>01705     <span class="keyword">struct </span><a class="code" href="structe1000__rx__desc.html">e1000_rx_desc</a> *rx_desc, *next_rxd;
<a name="l01706"></a>01706     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info, *next_buffer;
<a name="l01707"></a>01707     u32 length;
<a name="l01708"></a>01708     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l01709"></a>01709     <span class="keywordtype">int</span> cleaned_count = 0;
<a name="l01710"></a>01710     <span class="keywordtype">bool</span> cleaned = <span class="keyword">false</span>;
<a name="l01711"></a>01711     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_rx_bytes = 0, total_rx_packets = 0;
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     i = rx_ring-&gt;next_to_clean;
<a name="l01714"></a>01714     rx_desc = E1000_RX_DESC(*rx_ring, i);
<a name="l01715"></a>01715     buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01716"></a>01716 
<a name="l01717"></a>01717     <span class="keywordflow">while</span> (rx_desc-&gt;status &amp; E1000_RXD_STAT_DD) {
<a name="l01718"></a>01718         <span class="keyword">struct </span>sk_buff *skb;
<a name="l01719"></a>01719         u8 status;
<a name="l01720"></a>01720 
<a name="l01721"></a>01721         <span class="keywordflow">if</span> (*work_done &gt;= work_to_do)
<a name="l01722"></a>01722             <span class="keywordflow">break</span>;
<a name="l01723"></a>01723         (*work_done)++;
<a name="l01724"></a>01724         rmb();  <span class="comment">/* read descriptor and rx_buffer_info after status DD */</span>
<a name="l01725"></a>01725 
<a name="l01726"></a>01726         status = rx_desc-&gt;status;
<a name="l01727"></a>01727         skb = buffer_info-&gt;skb;
<a name="l01728"></a>01728         buffer_info-&gt;skb = NULL;
<a name="l01729"></a>01729 
<a name="l01730"></a>01730         ++i;
<a name="l01731"></a>01731         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l01732"></a>01732             i = 0;
<a name="l01733"></a>01733         next_rxd = E1000_RX_DESC(*rx_ring, i);
<a name="l01734"></a>01734         prefetch(next_rxd);
<a name="l01735"></a>01735 
<a name="l01736"></a>01736         next_buffer = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01737"></a>01737 
<a name="l01738"></a>01738         cleaned = <span class="keyword">true</span>;
<a name="l01739"></a>01739         cleaned_count++;
<a name="l01740"></a>01740         dma_unmap_page(pci_dev_to_dev(pdev), buffer_info-&gt;dma, PAGE_SIZE,
<a name="l01741"></a>01741                    DMA_FROM_DEVICE);
<a name="l01742"></a>01742         buffer_info-&gt;dma = 0;
<a name="l01743"></a>01743 
<a name="l01744"></a>01744         length = le16_to_cpu(rx_desc-&gt;length);
<a name="l01745"></a>01745 
<a name="l01746"></a>01746         <span class="comment">/* errors is only valid for DD + EOP descriptors */</span>
<a name="l01747"></a>01747         <span class="keywordflow">if</span> (unlikely((status &amp; E1000_RXD_STAT_EOP) &amp;&amp;
<a name="l01748"></a>01748             (rx_desc-&gt;errors &amp; E1000_RXD_ERR_FRAME_ERR_MASK))) {
<a name="l01749"></a>01749                 <span class="comment">/* recycle both page and skb */</span>
<a name="l01750"></a>01750                 buffer_info-&gt;skb = skb;
<a name="l01751"></a>01751                 <span class="comment">/* an error means any chain goes out the window</span>
<a name="l01752"></a>01752 <span class="comment">                 * too */</span>
<a name="l01753"></a>01753                 <span class="keywordflow">if</span> (rx_ring-&gt;rx_skb_top)
<a name="l01754"></a>01754                     dev_kfree_skb(rx_ring-&gt;rx_skb_top);
<a name="l01755"></a>01755                 rx_ring-&gt;rx_skb_top = NULL;
<a name="l01756"></a>01756                 <span class="keywordflow">goto</span> next_desc;
<a name="l01757"></a>01757         }
<a name="l01758"></a>01758 
<a name="l01759"></a>01759 <span class="preprocessor">#define rxtop (rx_ring-&gt;rx_skb_top)</span>
<a name="l01760"></a>01760 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!(status &amp; E1000_RXD_STAT_EOP)) {
<a name="l01761"></a>01761             <span class="comment">/* this descriptor is only the beginning (or middle) */</span>
<a name="l01762"></a>01762             <span class="keywordflow">if</span> (!rxtop) {
<a name="l01763"></a>01763                 <span class="comment">/* this is the beginning of a chain */</span>
<a name="l01764"></a>01764                 rxtop = skb;
<a name="l01765"></a>01765                 skb_fill_page_desc(rxtop, 0, buffer_info-&gt;page,
<a name="l01766"></a>01766                                    0, length);
<a name="l01767"></a>01767             } <span class="keywordflow">else</span> {
<a name="l01768"></a>01768                 <span class="comment">/* this is the middle of a chain */</span>
<a name="l01769"></a>01769                 skb_fill_page_desc(rxtop,
<a name="l01770"></a>01770                     skb_shinfo(rxtop)-&gt;nr_frags,
<a name="l01771"></a>01771                     buffer_info-&gt;page, 0, length);
<a name="l01772"></a>01772                 <span class="comment">/* re-use the skb, only consumed the page */</span>
<a name="l01773"></a>01773                 buffer_info-&gt;skb = skb;
<a name="l01774"></a>01774             }
<a name="l01775"></a>01775             e1000_consume_page(buffer_info, rxtop, length);
<a name="l01776"></a>01776             <span class="keywordflow">goto</span> next_desc;
<a name="l01777"></a>01777         } <span class="keywordflow">else</span> {
<a name="l01778"></a>01778             <span class="keywordflow">if</span> (rxtop) {
<a name="l01779"></a>01779                 <span class="comment">/* end of the chain */</span>
<a name="l01780"></a>01780                 skb_fill_page_desc(rxtop,
<a name="l01781"></a>01781                     skb_shinfo(rxtop)-&gt;nr_frags,
<a name="l01782"></a>01782                     buffer_info-&gt;page, 0, length);
<a name="l01783"></a>01783                 <span class="comment">/* re-use the current skb, we only consumed the</span>
<a name="l01784"></a>01784 <span class="comment">                 * page */</span>
<a name="l01785"></a>01785                 buffer_info-&gt;skb = skb;
<a name="l01786"></a>01786                 skb = rxtop;
<a name="l01787"></a>01787                 rxtop = NULL;
<a name="l01788"></a>01788                 e1000_consume_page(buffer_info, skb, length);
<a name="l01789"></a>01789             } <span class="keywordflow">else</span> {
<a name="l01790"></a>01790                 <span class="comment">/* no chain, got EOP, this buf is the packet</span>
<a name="l01791"></a>01791 <span class="comment">                 * copybreak to save the put_page/alloc_page */</span>
<a name="l01792"></a>01792                 <span class="keywordflow">if</span> (length &lt;= copybreak &amp;&amp;
<a name="l01793"></a>01793                     skb_tailroom(skb) &gt;= length) {
<a name="l01794"></a>01794                     u8 *vaddr;
<a name="l01795"></a>01795                     vaddr = kmap_atomic(buffer_info-&gt;page,
<a name="l01796"></a>01796                                        KM_SKB_DATA_SOFTIRQ);
<a name="l01797"></a>01797                     memcpy(skb_tail_pointer(skb), vaddr,
<a name="l01798"></a>01798                            length);
<a name="l01799"></a>01799                     kunmap_atomic(vaddr,
<a name="l01800"></a>01800                                   KM_SKB_DATA_SOFTIRQ);
<a name="l01801"></a>01801                     <span class="comment">/* re-use the page, so don&#39;t erase</span>
<a name="l01802"></a>01802 <span class="comment">                     * buffer_info-&gt;page */</span>
<a name="l01803"></a>01803                     skb_put(skb, length);
<a name="l01804"></a>01804                 } <span class="keywordflow">else</span> {
<a name="l01805"></a>01805                     skb_fill_page_desc(skb, 0,
<a name="l01806"></a>01806                                        buffer_info-&gt;page, 0,
<a name="l01807"></a>01807                                            length);
<a name="l01808"></a>01808                     e1000_consume_page(buffer_info, skb,
<a name="l01809"></a>01809                                        length);
<a name="l01810"></a>01810                 }
<a name="l01811"></a>01811             }
<a name="l01812"></a>01812         }
<a name="l01813"></a>01813 
<a name="l01814"></a>01814         <span class="comment">/* Receive Checksum Offload XXX recompute due to CRC strip? */</span>
<a name="l01815"></a>01815         e1000_rx_checksum(adapter,
<a name="l01816"></a>01816                           (u32)(status) |
<a name="l01817"></a>01817                           ((u32)(rx_desc-&gt;errors) &lt;&lt; 24),
<a name="l01818"></a>01818                           le16_to_cpu(rx_desc-&gt;csum), skb);
<a name="l01819"></a>01819 
<a name="l01820"></a>01820         <span class="comment">/* probably a little skewed due to removing CRC */</span>
<a name="l01821"></a>01821         total_rx_bytes += skb-&gt;len;
<a name="l01822"></a>01822         total_rx_packets++;
<a name="l01823"></a>01823 
<a name="l01824"></a>01824         <span class="comment">/* eth type trans needs skb-&gt;data to point to something */</span>
<a name="l01825"></a>01825         <span class="keywordflow">if</span> (!pskb_may_pull(skb, ETH_HLEN)) {
<a name="l01826"></a>01826             e_err(<span class="stringliteral">&quot;pskb_may_pull failed.\n&quot;</span>);
<a name="l01827"></a>01827             dev_kfree_skb(skb);
<a name="l01828"></a>01828             <span class="keywordflow">goto</span> next_desc;
<a name="l01829"></a>01829         }
<a name="l01830"></a>01830 
<a name="l01831"></a>01831         e1000_receive_skb(adapter, netdev, skb, status,
<a name="l01832"></a>01832                           rx_desc-&gt;special);
<a name="l01833"></a>01833 
<a name="l01834"></a>01834 next_desc:
<a name="l01835"></a>01835         rx_desc-&gt;status = 0;
<a name="l01836"></a>01836 
<a name="l01837"></a>01837         <span class="comment">/* return some buffers to hardware, one at a time is too slow */</span>
<a name="l01838"></a>01838         <span class="keywordflow">if</span> (unlikely(cleaned_count &gt;= E1000_RX_BUFFER_WRITE)) {
<a name="l01839"></a>01839             adapter-&gt;alloc_rx_buf(adapter, cleaned_count);
<a name="l01840"></a>01840             cleaned_count = 0;
<a name="l01841"></a>01841         }
<a name="l01842"></a>01842 
<a name="l01843"></a>01843         <span class="comment">/* use prefetched values */</span>
<a name="l01844"></a>01844         rx_desc = next_rxd;
<a name="l01845"></a>01845         buffer_info = next_buffer;
<a name="l01846"></a>01846     }
<a name="l01847"></a>01847     rx_ring-&gt;next_to_clean = i;
<a name="l01848"></a>01848 
<a name="l01849"></a>01849     cleaned_count = e1000_desc_unused(rx_ring);
<a name="l01850"></a>01850     <span class="keywordflow">if</span> (cleaned_count)
<a name="l01851"></a>01851         adapter-&gt;alloc_rx_buf(adapter, cleaned_count);
<a name="l01852"></a>01852 
<a name="l01853"></a>01853     adapter-&gt;total_rx_bytes += total_rx_bytes;
<a name="l01854"></a>01854     adapter-&gt;total_rx_packets += total_rx_packets;
<a name="l01855"></a>01855 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l01856"></a>01856 <span class="preprocessor"></span>    netdev-&gt;stats.rx_bytes += total_rx_bytes;
<a name="l01857"></a>01857     netdev-&gt;stats.rx_packets += total_rx_packets;
<a name="l01858"></a>01858 <span class="preprocessor">#else</span>
<a name="l01859"></a>01859 <span class="preprocessor"></span>    adapter-&gt;net_stats.rx_bytes += total_rx_bytes;
<a name="l01860"></a>01860     adapter-&gt;net_stats.rx_packets += total_rx_packets;
<a name="l01861"></a>01861 <span class="preprocessor">#endif</span>
<a name="l01862"></a>01862 <span class="preprocessor"></span>    <span class="keywordflow">return</span> cleaned;
<a name="l01863"></a>01863 }
<a name="l01864"></a>01864 
<a name="l01865"></a>01865 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_NAPI */</span>
<a name="l01866"></a>01866 
<a name="l01870"></a>01870 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_clean_rx_ring(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l01871"></a>01871 {
<a name="l01872"></a>01872     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l01873"></a>01873     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l01874"></a>01874     <span class="keyword">struct </span><a class="code" href="structe1000__ps__page.html">e1000_ps_page</a> *ps_page;
<a name="l01875"></a>01875     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l01876"></a>01876     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l01877"></a>01877 
<a name="l01878"></a>01878     <span class="comment">/* Free all the Rx ring sk_buffs */</span>
<a name="l01879"></a>01879     <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++) {
<a name="l01880"></a>01880         buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l01881"></a>01881         <span class="keywordflow">if</span> (buffer_info-&gt;dma) {
<a name="l01882"></a>01882             <span class="keywordflow">if</span> (adapter-&gt;clean_rx == e1000_clean_rx_irq)
<a name="l01883"></a>01883                 dma_unmap_single(pci_dev_to_dev(pdev), buffer_info-&gt;dma,
<a name="l01884"></a>01884                          adapter-&gt;rx_buffer_len,
<a name="l01885"></a>01885                          DMA_FROM_DEVICE);
<a name="l01886"></a>01886 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01887"></a>01887 <span class="preprocessor"></span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;clean_rx == e1000_clean_jumbo_rx_irq)
<a name="l01888"></a>01888                 dma_unmap_page(pci_dev_to_dev(pdev), buffer_info-&gt;dma,
<a name="l01889"></a>01889                                PAGE_SIZE,
<a name="l01890"></a>01890                            DMA_FROM_DEVICE);
<a name="l01891"></a>01891 <span class="preprocessor">#endif</span>
<a name="l01892"></a>01892 <span class="preprocessor"></span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;clean_rx == e1000_clean_rx_irq_ps)
<a name="l01893"></a>01893                 dma_unmap_single(pci_dev_to_dev(pdev), buffer_info-&gt;dma,
<a name="l01894"></a>01894                          adapter-&gt;rx_ps_bsize0,
<a name="l01895"></a>01895                          DMA_FROM_DEVICE);
<a name="l01896"></a>01896             buffer_info-&gt;dma = 0;
<a name="l01897"></a>01897         }
<a name="l01898"></a>01898 
<a name="l01899"></a>01899         <span class="keywordflow">if</span> (buffer_info-&gt;page) {
<a name="l01900"></a>01900             put_page(buffer_info-&gt;page);
<a name="l01901"></a>01901             buffer_info-&gt;page = NULL;
<a name="l01902"></a>01902         }
<a name="l01903"></a>01903 
<a name="l01904"></a>01904         <span class="keywordflow">if</span> (buffer_info-&gt;skb) {
<a name="l01905"></a>01905             dev_kfree_skb(buffer_info-&gt;skb);
<a name="l01906"></a>01906             buffer_info-&gt;skb = NULL;
<a name="l01907"></a>01907         }
<a name="l01908"></a>01908 
<a name="l01909"></a>01909         <span class="keywordflow">for</span> (j = 0; j &lt; PS_PAGE_BUFFERS; j++) {
<a name="l01910"></a>01910             ps_page = &amp;buffer_info-&gt;ps_pages[j];
<a name="l01911"></a>01911             <span class="keywordflow">if</span> (!ps_page-&gt;page)
<a name="l01912"></a>01912                 <span class="keywordflow">break</span>;
<a name="l01913"></a>01913             dma_unmap_page(pci_dev_to_dev(pdev), ps_page-&gt;dma, PAGE_SIZE,
<a name="l01914"></a>01914                        DMA_FROM_DEVICE);
<a name="l01915"></a>01915             ps_page-&gt;dma = 0;
<a name="l01916"></a>01916             put_page(ps_page-&gt;page);
<a name="l01917"></a>01917             ps_page-&gt;page = NULL;
<a name="l01918"></a>01918         }
<a name="l01919"></a>01919     }
<a name="l01920"></a>01920 
<a name="l01921"></a>01921 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l01922"></a>01922 <span class="preprocessor"></span>    <span class="comment">/* there also may be some cached data from a chained receive */</span>
<a name="l01923"></a>01923     <span class="keywordflow">if</span> (rx_ring-&gt;rx_skb_top) {
<a name="l01924"></a>01924         dev_kfree_skb(rx_ring-&gt;rx_skb_top);
<a name="l01925"></a>01925         rx_ring-&gt;rx_skb_top = NULL;
<a name="l01926"></a>01926     }
<a name="l01927"></a>01927 <span class="preprocessor">#endif</span>
<a name="l01928"></a>01928 <span class="preprocessor"></span>
<a name="l01929"></a>01929     <span class="comment">/* Zero out the descriptor ring */</span>
<a name="l01930"></a>01930     memset(rx_ring-&gt;desc, 0, rx_ring-&gt;size);
<a name="l01931"></a>01931 
<a name="l01932"></a>01932     rx_ring-&gt;next_to_clean = 0;
<a name="l01933"></a>01933     rx_ring-&gt;next_to_use = 0;
<a name="l01934"></a>01934     adapter-&gt;flags2 &amp;= ~FLAG2_IS_DISCARDING;
<a name="l01935"></a>01935 
<a name="l01936"></a>01936     writel(0, adapter-&gt;hw.hw_addr + rx_ring-&gt;head);
<a name="l01937"></a>01937     writel(0, adapter-&gt;hw.hw_addr + rx_ring-&gt;tail);
<a name="l01938"></a>01938 }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_downshift_workaround(<span class="keyword">struct</span> work_struct *work)
<a name="l01941"></a>01941 {
<a name="l01942"></a>01942     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = container_of(work,
<a name="l01943"></a>01943                     <span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a>, downshift_task);
<a name="l01944"></a>01944 
<a name="l01945"></a>01945     <span class="keywordflow">if</span> (test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l01946"></a>01946         <span class="keywordflow">return</span>;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948     e1000e_gig_downshift_workaround_ich8lan(&amp;adapter-&gt;hw);
<a name="l01949"></a>01949 }
<a name="l01950"></a>01950 
<a name="l01951"></a>01951 <span class="preprocessor">#ifndef CONFIG_E1000E_NAPI</span>
<a name="l01952"></a>01952 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> e1000_set_itr(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter);
<a name="l01953"></a>01953 <span class="preprocessor">#endif</span>
<a name="l01954"></a>01954 <span class="preprocessor"></span>
<a name="l01959"></a>01959 <span class="keyword">static</span> irqreturn_t e1000_intr_msi(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l01960"></a>01960 {
<a name="l01961"></a>01961     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l01962"></a>01962     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l01963"></a>01963     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01964"></a>01964 <span class="preprocessor">#ifndef CONFIG_E1000E_NAPI</span>
<a name="l01965"></a>01965 <span class="preprocessor"></span>    <span class="keywordtype">int</span> i;
<a name="l01966"></a>01966 <span class="preprocessor">#endif</span>
<a name="l01967"></a>01967 <span class="preprocessor"></span>    u32 icr = er32(ICR);
<a name="l01968"></a>01968 
<a name="l01969"></a>01969     <span class="comment">/*</span>
<a name="l01970"></a>01970 <span class="comment">     * read ICR disables interrupts using IAM</span>
<a name="l01971"></a>01971 <span class="comment">     */</span>
<a name="l01972"></a>01972 
<a name="l01973"></a>01973     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_LSC) {
<a name="l01974"></a>01974         hw-&gt;mac.get_link_status = 1;
<a name="l01975"></a>01975         <span class="comment">/*</span>
<a name="l01976"></a>01976 <span class="comment">         * ICH8 workaround-- Call gig speed drop workaround on cable</span>
<a name="l01977"></a>01977 <span class="comment">         * disconnect (LSC) before accessing any PHY registers</span>
<a name="l01978"></a>01978 <span class="comment">         */</span>
<a name="l01979"></a>01979         <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_LSC_GIG_SPEED_DROP) &amp;&amp;
<a name="l01980"></a>01980             (!(er32(STATUS) &amp; E1000_STATUS_LU)))
<a name="l01981"></a>01981             schedule_work(&amp;adapter-&gt;downshift_task);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983         <span class="comment">/*</span>
<a name="l01984"></a>01984 <span class="comment">         * 80003ES2LAN workaround-- For packet buffer work-around on</span>
<a name="l01985"></a>01985 <span class="comment">         * link down event; disable receives here in the ISR and reset</span>
<a name="l01986"></a>01986 <span class="comment">         * adapter in watchdog</span>
<a name="l01987"></a>01987 <span class="comment">         */</span>
<a name="l01988"></a>01988         <span class="keywordflow">if</span> (netif_carrier_ok(netdev) &amp;&amp;
<a name="l01989"></a>01989             adapter-&gt;flags &amp; FLAG_RX_NEEDS_RESTART) {
<a name="l01990"></a>01990             <span class="comment">/* disable receives */</span>
<a name="l01991"></a>01991             u32 rctl = er32(RCTL);
<a name="l01992"></a>01992             ew32(RCTL, rctl &amp; ~E1000_RCTL_EN);
<a name="l01993"></a>01993             adapter-&gt;flags |= FLAG_RX_RESTART_NOW;
<a name="l01994"></a>01994         }
<a name="l01995"></a>01995         <span class="comment">/* guard against interrupt when we&#39;re going down */</span>
<a name="l01996"></a>01996         <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l01997"></a>01997             mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);
<a name="l01998"></a>01998     }
<a name="l01999"></a>01999 
<a name="l02000"></a>02000 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l02001"></a>02001 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (napi_schedule_prep(&amp;adapter-&gt;napi)) {
<a name="l02002"></a>02002         adapter-&gt;total_tx_bytes = 0;
<a name="l02003"></a>02003         adapter-&gt;total_tx_packets = 0;
<a name="l02004"></a>02004         adapter-&gt;total_rx_bytes = 0;
<a name="l02005"></a>02005         adapter-&gt;total_rx_packets = 0;
<a name="l02006"></a>02006         __napi_schedule(&amp;adapter-&gt;napi);
<a name="l02007"></a>02007     }
<a name="l02008"></a>02008 <span class="preprocessor">#else</span>
<a name="l02009"></a>02009 <span class="preprocessor"></span>    adapter-&gt;total_tx_bytes = 0;
<a name="l02010"></a>02010     adapter-&gt;total_rx_bytes = 0;
<a name="l02011"></a>02011     adapter-&gt;total_tx_packets = 0;
<a name="l02012"></a>02012     adapter-&gt;total_rx_packets = 0;
<a name="l02013"></a>02013 
<a name="l02014"></a>02014     <span class="keywordflow">for</span> (i = 0; i &lt; E1000_MAX_INTR; i++) {
<a name="l02015"></a>02015         <span class="keywordtype">int</span> rx_cleaned = adapter-&gt;clean_rx(adapter);
<a name="l02016"></a>02016         <span class="keywordtype">int</span> tx_cleaned_complete = e1000_clean_tx_irq(adapter);
<a name="l02017"></a>02017         <span class="keywordflow">if</span> (!rx_cleaned &amp;&amp; tx_cleaned_complete)
<a name="l02018"></a>02018             <span class="keywordflow">break</span>;
<a name="l02019"></a>02019     }
<a name="l02020"></a>02020 
<a name="l02021"></a>02021     <span class="keywordflow">if</span> (likely(adapter-&gt;itr_setting &amp; 3))
<a name="l02022"></a>02022         e1000_set_itr(adapter);
<a name="l02023"></a>02023 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_NAPI */</span>
<a name="l02024"></a>02024 
<a name="l02025"></a>02025     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02026"></a>02026 }
<a name="l02027"></a>02027 
<a name="l02033"></a>02033 <span class="keyword">static</span> irqreturn_t e1000_intr(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02034"></a>02034 {
<a name="l02035"></a>02035     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l02036"></a>02036     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02037"></a>02037     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02038"></a>02038 <span class="preprocessor">#ifndef CONFIG_E1000E_NAPI</span>
<a name="l02039"></a>02039 <span class="preprocessor"></span>    <span class="keywordtype">int</span> i;
<a name="l02040"></a>02040     <span class="keywordtype">int</span> rx_cleaned, tx_cleaned_complete;
<a name="l02041"></a>02041 <span class="preprocessor">#endif</span>
<a name="l02042"></a>02042 <span class="preprocessor"></span>    u32 rctl, icr = er32(ICR);
<a name="l02043"></a>02043 
<a name="l02044"></a>02044     <span class="keywordflow">if</span> (!icr || test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l02045"></a>02045         <span class="keywordflow">return</span> IRQ_NONE;  <span class="comment">/* Not our interrupt */</span>
<a name="l02046"></a>02046 
<a name="l02047"></a>02047 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l02048"></a>02048 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l02049"></a>02049 <span class="comment">     * IMS will not auto-mask if INT_ASSERTED is not set, and if it is</span>
<a name="l02050"></a>02050 <span class="comment">     * not set, then the adapter didn&#39;t send an interrupt</span>
<a name="l02051"></a>02051 <span class="comment">     */</span>
<a name="l02052"></a>02052     <span class="keywordflow">if</span> (!(icr &amp; E1000_ICR_INT_ASSERTED))
<a name="l02053"></a>02053         <span class="keywordflow">return</span> IRQ_NONE;
<a name="l02054"></a>02054 
<a name="l02055"></a>02055 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_NAPI */</span>
<a name="l02056"></a>02056     <span class="comment">/*</span>
<a name="l02057"></a>02057 <span class="comment">     * Interrupt Auto-Mask...upon reading ICR,</span>
<a name="l02058"></a>02058 <span class="comment">     * interrupts are masked.  No need for the</span>
<a name="l02059"></a>02059 <span class="comment">     * IMC write</span>
<a name="l02060"></a>02060 <span class="comment">     */</span>
<a name="l02061"></a>02061 
<a name="l02062"></a>02062     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_LSC) {
<a name="l02063"></a>02063         hw-&gt;mac.get_link_status = 1;
<a name="l02064"></a>02064         <span class="comment">/*</span>
<a name="l02065"></a>02065 <span class="comment">         * ICH8 workaround-- Call gig speed drop workaround on cable</span>
<a name="l02066"></a>02066 <span class="comment">         * disconnect (LSC) before accessing any PHY registers</span>
<a name="l02067"></a>02067 <span class="comment">         */</span>
<a name="l02068"></a>02068         <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_LSC_GIG_SPEED_DROP) &amp;&amp;
<a name="l02069"></a>02069             (!(er32(STATUS) &amp; E1000_STATUS_LU)))
<a name="l02070"></a>02070             schedule_work(&amp;adapter-&gt;downshift_task);
<a name="l02071"></a>02071 
<a name="l02072"></a>02072         <span class="comment">/*</span>
<a name="l02073"></a>02073 <span class="comment">         * 80003ES2LAN workaround--</span>
<a name="l02074"></a>02074 <span class="comment">         * For packet buffer work-around on link down event;</span>
<a name="l02075"></a>02075 <span class="comment">         * disable receives here in the ISR and</span>
<a name="l02076"></a>02076 <span class="comment">         * reset adapter in watchdog</span>
<a name="l02077"></a>02077 <span class="comment">         */</span>
<a name="l02078"></a>02078         <span class="keywordflow">if</span> (netif_carrier_ok(netdev) &amp;&amp;
<a name="l02079"></a>02079             (adapter-&gt;flags &amp; FLAG_RX_NEEDS_RESTART)) {
<a name="l02080"></a>02080             <span class="comment">/* disable receives */</span>
<a name="l02081"></a>02081             rctl = er32(RCTL);
<a name="l02082"></a>02082             ew32(RCTL, rctl &amp; ~E1000_RCTL_EN);
<a name="l02083"></a>02083             adapter-&gt;flags |= FLAG_RX_RESTART_NOW;
<a name="l02084"></a>02084         }
<a name="l02085"></a>02085         <span class="comment">/* guard against interrupt when we&#39;re going down */</span>
<a name="l02086"></a>02086         <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l02087"></a>02087             mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);
<a name="l02088"></a>02088     }
<a name="l02089"></a>02089 
<a name="l02090"></a>02090 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l02091"></a>02091 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (napi_schedule_prep(&amp;adapter-&gt;napi)) {
<a name="l02092"></a>02092         adapter-&gt;total_tx_bytes = 0;
<a name="l02093"></a>02093         adapter-&gt;total_tx_packets = 0;
<a name="l02094"></a>02094         adapter-&gt;total_rx_bytes = 0;
<a name="l02095"></a>02095         adapter-&gt;total_rx_packets = 0;
<a name="l02096"></a>02096         __napi_schedule(&amp;adapter-&gt;napi);
<a name="l02097"></a>02097     }
<a name="l02098"></a>02098 <span class="preprocessor">#else</span>
<a name="l02099"></a>02099 <span class="preprocessor"></span>    adapter-&gt;total_tx_bytes = 0;
<a name="l02100"></a>02100     adapter-&gt;total_rx_bytes = 0;
<a name="l02101"></a>02101     adapter-&gt;total_tx_packets = 0;
<a name="l02102"></a>02102     adapter-&gt;total_rx_packets = 0;
<a name="l02103"></a>02103 
<a name="l02104"></a>02104     <span class="keywordflow">for</span> (i = 0; i &lt; E1000_MAX_INTR; i++) {
<a name="l02105"></a>02105         rx_cleaned = adapter-&gt;clean_rx(adapter);
<a name="l02106"></a>02106         tx_cleaned_complete = e1000_clean_tx_irq(adapter);
<a name="l02107"></a>02107         <span class="keywordflow">if</span> (!rx_cleaned &amp;&amp; tx_cleaned_complete)
<a name="l02108"></a>02108             <span class="keywordflow">break</span>;
<a name="l02109"></a>02109     }
<a name="l02110"></a>02110 
<a name="l02111"></a>02111     <span class="keywordflow">if</span> (likely(adapter-&gt;itr_setting &amp; 3))
<a name="l02112"></a>02112         e1000_set_itr(adapter);
<a name="l02113"></a>02113 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_NAPI */</span>
<a name="l02114"></a>02114 
<a name="l02115"></a>02115     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02116"></a>02116 }
<a name="l02117"></a>02117 
<a name="l02118"></a>02118 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02119"></a>02119 <span class="preprocessor"></span><span class="keyword">static</span> irqreturn_t e1000_msix_other(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02120"></a>02120 {
<a name="l02121"></a>02121     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l02122"></a>02122     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02123"></a>02123     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02124"></a>02124     u32 icr = er32(ICR);
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <span class="keywordflow">if</span> (!(icr &amp; E1000_ICR_INT_ASSERTED)) {
<a name="l02127"></a>02127         <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l02128"></a>02128             ew32(IMS, E1000_IMS_OTHER);
<a name="l02129"></a>02129         <span class="keywordflow">return</span> IRQ_NONE;
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131 
<a name="l02132"></a>02132     <span class="keywordflow">if</span> (icr &amp; adapter-&gt;eiac_mask)
<a name="l02133"></a>02133         ew32(ICS, (icr &amp; adapter-&gt;eiac_mask));
<a name="l02134"></a>02134 
<a name="l02135"></a>02135     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_OTHER) {
<a name="l02136"></a>02136         <span class="keywordflow">if</span> (!(icr &amp; E1000_ICR_LSC))
<a name="l02137"></a>02137             <span class="keywordflow">goto</span> no_link_interrupt;
<a name="l02138"></a>02138         hw-&gt;mac.get_link_status = 1;
<a name="l02139"></a>02139         <span class="comment">/* guard against interrupt when we&#39;re going down */</span>
<a name="l02140"></a>02140         <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l02141"></a>02141             mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);
<a name="l02142"></a>02142     }
<a name="l02143"></a>02143 
<a name="l02144"></a>02144 no_link_interrupt:
<a name="l02145"></a>02145     <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l02146"></a>02146         ew32(IMS, E1000_IMS_LSC | E1000_IMS_OTHER);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02149"></a>02149 }
<a name="l02150"></a>02150 
<a name="l02151"></a>02151 
<a name="l02152"></a>02152 <span class="preprocessor">#ifdef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02153"></a>02153 <span class="preprocessor"></span><span class="keyword">static</span> irqreturn_t e1000_intr_msix_tx(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02154"></a>02154 {
<a name="l02155"></a>02155     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l02156"></a>02156     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02157"></a>02157     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02158"></a>02158     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l02159"></a>02159 
<a name="l02160"></a>02160 
<a name="l02161"></a>02161     adapter-&gt;total_tx_bytes = 0;
<a name="l02162"></a>02162     adapter-&gt;total_tx_packets = 0;
<a name="l02163"></a>02163 
<a name="l02164"></a>02164     <span class="keywordflow">if</span> (!e1000_clean_tx_irq(adapter))
<a name="l02165"></a>02165         <span class="comment">/* Ring was not completely cleaned, so fire another interrupt */</span>
<a name="l02166"></a>02166         ew32(ICS, tx_ring-&gt;ims_val);
<a name="l02167"></a>02167 
<a name="l02168"></a>02168     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02169"></a>02169 }
<a name="l02170"></a>02170 
<a name="l02171"></a>02171 <span class="preprocessor">#endif  </span><span class="comment">/* CONFIG_E1000E_SEPARATE_TX_HANDLER */</span>
<a name="l02172"></a>02172 <span class="keyword">static</span> irqreturn_t e1000_intr_msix_rx(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02173"></a>02173 {
<a name="l02174"></a>02174     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l02175"></a>02175     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02176"></a>02176 <span class="preprocessor">#ifndef CONFIG_E1000E_NAPI</span>
<a name="l02177"></a>02177 <span class="preprocessor"></span>    <span class="keywordtype">int</span> i;
<a name="l02178"></a>02178     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02179"></a>02179 <span class="preprocessor">#endif</span>
<a name="l02180"></a>02180 <span class="preprocessor"></span>
<a name="l02181"></a>02181     <span class="comment">/* Write the ITR value calculated at the end of the</span>
<a name="l02182"></a>02182 <span class="comment">     * previous interrupt.</span>
<a name="l02183"></a>02183 <span class="comment">     */</span>
<a name="l02184"></a>02184     <span class="keywordflow">if</span> (adapter-&gt;rx_ring-&gt;set_itr) {
<a name="l02185"></a>02185         writel(1000000000 / (adapter-&gt;rx_ring-&gt;itr_val * 256),
<a name="l02186"></a>02186                adapter-&gt;hw.hw_addr + adapter-&gt;rx_ring-&gt;itr_register);
<a name="l02187"></a>02187         adapter-&gt;rx_ring-&gt;set_itr = 0;
<a name="l02188"></a>02188     }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l02191"></a>02191 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (napi_schedule_prep(&amp;adapter-&gt;napi)) {
<a name="l02192"></a>02192         adapter-&gt;total_rx_bytes = 0;
<a name="l02193"></a>02193         adapter-&gt;total_rx_packets = 0;
<a name="l02194"></a>02194 <span class="preprocessor">#ifndef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02195"></a>02195 <span class="preprocessor"></span>        adapter-&gt;total_tx_bytes = 0;
<a name="l02196"></a>02196         adapter-&gt;total_tx_packets = 0;
<a name="l02197"></a>02197 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_SEPARATE_TX_HANDLER */</span>
<a name="l02198"></a>02198         __napi_schedule(&amp;adapter-&gt;napi);
<a name="l02199"></a>02199     }
<a name="l02200"></a>02200 <span class="preprocessor">#else</span>
<a name="l02201"></a>02201 <span class="preprocessor"></span>    adapter-&gt;total_rx_bytes = 0;
<a name="l02202"></a>02202     adapter-&gt;total_rx_packets = 0;
<a name="l02203"></a>02203 <span class="preprocessor">#ifndef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02204"></a>02204 <span class="preprocessor"></span>    adapter-&gt;total_tx_bytes = 0;
<a name="l02205"></a>02205     adapter-&gt;total_tx_packets = 0;
<a name="l02206"></a>02206 <span class="preprocessor">#endif</span>
<a name="l02207"></a>02207 <span class="preprocessor"></span>
<a name="l02208"></a>02208     <span class="keywordflow">for</span> (i = 0; i &lt; E1000_MAX_INTR; i++) {
<a name="l02209"></a>02209         <span class="keywordtype">int</span> rx_cleaned = adapter-&gt;clean_rx(adapter);
<a name="l02210"></a>02210 <span class="preprocessor">#ifndef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02211"></a>02211 <span class="preprocessor"></span>        <span class="keywordtype">int</span> tx_cleaned_complete = e1000_clean_tx_irq(adapter);
<a name="l02212"></a>02212         <span class="keywordflow">if</span> (!rx_cleaned &amp;&amp; tx_cleaned_complete)
<a name="l02213"></a>02213 <span class="preprocessor">#else</span>
<a name="l02214"></a>02214 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!rx_cleaned)
<a name="l02215"></a>02215 <span class="preprocessor">#endif</span>
<a name="l02216"></a>02216 <span class="preprocessor"></span>            <span class="keywordflow">goto</span> out;
<a name="l02217"></a>02217     }
<a name="l02218"></a>02218     <span class="comment">/* If we got here, the ring was not completely cleaned,</span>
<a name="l02219"></a>02219 <span class="comment">     * so fire another interrupt.</span>
<a name="l02220"></a>02220 <span class="comment">     */</span>
<a name="l02221"></a>02221     ew32(ICS, adapter-&gt;rx_ring-&gt;ims_val);
<a name="l02222"></a>02222 
<a name="l02223"></a>02223 out:
<a name="l02224"></a>02224 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_NAPI */</span>
<a name="l02225"></a>02225     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02226"></a>02226 }
<a name="l02227"></a>02227 
<a name="l02234"></a>02234 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_configure_msix(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02235"></a>02235 {
<a name="l02236"></a>02236     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02237"></a>02237     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l02238"></a>02238     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l02239"></a>02239     <span class="keywordtype">int</span> vector = 0;
<a name="l02240"></a>02240     u32 ctrl_ext, ivar = 0;
<a name="l02241"></a>02241 
<a name="l02242"></a>02242     adapter-&gt;eiac_mask = 0;
<a name="l02243"></a>02243 
<a name="l02244"></a>02244     <span class="comment">/* Workaround issue with spurious interrupts on 82574 in MSI-X mode */</span>
<a name="l02245"></a>02245     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82574) {
<a name="l02246"></a>02246         u32 rfctl = er32(RFCTL);
<a name="l02247"></a>02247         rfctl |= E1000_RFCTL_ACK_DIS;
<a name="l02248"></a>02248         ew32(RFCTL, rfctl);
<a name="l02249"></a>02249     }
<a name="l02250"></a>02250 
<a name="l02251"></a>02251 <span class="preprocessor">#define E1000_IVAR_INT_ALLOC_VALID  0x8</span>
<a name="l02252"></a>02252 <span class="preprocessor"></span>    <span class="comment">/* Configure Rx vector */</span>
<a name="l02253"></a>02253     rx_ring-&gt;ims_val = E1000_IMS_RXQ0;
<a name="l02254"></a>02254     adapter-&gt;eiac_mask |= rx_ring-&gt;ims_val;
<a name="l02255"></a>02255     <span class="keywordflow">if</span> (rx_ring-&gt;itr_val)
<a name="l02256"></a>02256         writel(1000000000 / (rx_ring-&gt;itr_val * 256),
<a name="l02257"></a>02257                hw-&gt;hw_addr + rx_ring-&gt;itr_register);
<a name="l02258"></a>02258     <span class="keywordflow">else</span>
<a name="l02259"></a>02259         writel(1, hw-&gt;hw_addr + rx_ring-&gt;itr_register);
<a name="l02260"></a>02260     ivar = E1000_IVAR_INT_ALLOC_VALID | vector;
<a name="l02261"></a>02261 
<a name="l02262"></a>02262     <span class="comment">/* Configure Tx vector */</span>
<a name="l02263"></a>02263     tx_ring-&gt;ims_val = E1000_IMS_TXQ0;
<a name="l02264"></a>02264 <span class="preprocessor">#ifdef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02265"></a>02265 <span class="preprocessor"></span>    vector++;
<a name="l02266"></a>02266     <span class="keywordflow">if</span> (tx_ring-&gt;itr_val)
<a name="l02267"></a>02267         writel(1000000000 / (tx_ring-&gt;itr_val * 256),
<a name="l02268"></a>02268                hw-&gt;hw_addr + tx_ring-&gt;itr_register);
<a name="l02269"></a>02269     <span class="keywordflow">else</span>
<a name="l02270"></a>02270         writel(1, hw-&gt;hw_addr + tx_ring-&gt;itr_register);
<a name="l02271"></a>02271 <span class="preprocessor">#else</span>
<a name="l02272"></a>02272 <span class="preprocessor"></span>    rx_ring-&gt;ims_val |= tx_ring-&gt;ims_val;
<a name="l02273"></a>02273 <span class="preprocessor">#endif</span>
<a name="l02274"></a>02274 <span class="preprocessor"></span>    adapter-&gt;eiac_mask |= tx_ring-&gt;ims_val;
<a name="l02275"></a>02275     ivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) &lt;&lt; 8);
<a name="l02276"></a>02276 
<a name="l02277"></a>02277     <span class="comment">/* set vector for Other Causes, e.g. link changes */</span>
<a name="l02278"></a>02278     vector++;
<a name="l02279"></a>02279     ivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) &lt;&lt; 16);
<a name="l02280"></a>02280     <span class="keywordflow">if</span> (rx_ring-&gt;itr_val)
<a name="l02281"></a>02281         writel(1000000000 / (rx_ring-&gt;itr_val * 256),
<a name="l02282"></a>02282                hw-&gt;hw_addr + E1000_EITR_82574(vector));
<a name="l02283"></a>02283     <span class="keywordflow">else</span>
<a name="l02284"></a>02284         writel(1, hw-&gt;hw_addr + E1000_EITR_82574(vector));
<a name="l02285"></a>02285 
<a name="l02286"></a>02286     <span class="comment">/* Cause Tx interrupts on every write back */</span>
<a name="l02287"></a>02287     ivar |= (1 &lt;&lt; 31);
<a name="l02288"></a>02288 
<a name="l02289"></a>02289     ew32(IVAR, ivar);
<a name="l02290"></a>02290 
<a name="l02291"></a>02291     <span class="comment">/* enable MSI-X PBA support */</span>
<a name="l02292"></a>02292     ctrl_ext = er32(CTRL_EXT);
<a name="l02293"></a>02293     ctrl_ext |= E1000_CTRL_EXT_PBA_CLR;
<a name="l02294"></a>02294 
<a name="l02295"></a>02295     <span class="comment">/* Auto-Mask Other interrupts upon ICR read */</span>
<a name="l02296"></a>02296     ew32(IAM, ~E1000_EIAC_MASK_82574 | E1000_IMS_OTHER);
<a name="l02297"></a>02297     ctrl_ext |= E1000_CTRL_EXT_EIAME;
<a name="l02298"></a>02298     ew32(CTRL_EXT, ctrl_ext);
<a name="l02299"></a>02299     e1e_flush();
<a name="l02300"></a>02300 }
<a name="l02301"></a>02301 
<a name="l02302"></a>02302 <span class="keywordtype">void</span> e1000e_reset_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02303"></a>02303 {
<a name="l02304"></a>02304     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l02305"></a>02305         pci_disable_msix(adapter-&gt;pdev);
<a name="l02306"></a>02306         kfree(adapter-&gt;msix_entries);
<a name="l02307"></a>02307         adapter-&gt;msix_entries = NULL;
<a name="l02308"></a>02308     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_MSI_ENABLED) {
<a name="l02309"></a>02309         pci_disable_msi(adapter-&gt;pdev);
<a name="l02310"></a>02310         adapter-&gt;flags &amp;= ~FLAG_MSI_ENABLED;
<a name="l02311"></a>02311     }
<a name="l02312"></a>02312 }
<a name="l02313"></a>02313 
<a name="l02320"></a>02320 <span class="keywordtype">void</span> e1000e_set_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02321"></a>02321 {
<a name="l02322"></a>02322     <span class="keywordtype">int</span> err;
<a name="l02323"></a>02323     <span class="keywordtype">int</span> i;
<a name="l02324"></a>02324 
<a name="l02325"></a>02325     <span class="keywordflow">switch</span> (adapter-&gt;int_mode) {
<a name="l02326"></a>02326     <span class="keywordflow">case</span> E1000E_INT_MODE_MSIX:
<a name="l02327"></a>02327         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_MSIX) {
<a name="l02328"></a>02328 <span class="preprocessor">#ifdef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02329"></a>02329 <span class="preprocessor"></span>            adapter-&gt;num_vectors = 3; <span class="comment">/* RxQ0, TxQ0 and other */</span>
<a name="l02330"></a>02330 <span class="preprocessor">#else</span>
<a name="l02331"></a>02331 <span class="preprocessor"></span>            adapter-&gt;num_vectors = 2; <span class="comment">/* RxQ0/TxQ0 and other */</span>
<a name="l02332"></a>02332 <span class="preprocessor">#endif</span>
<a name="l02333"></a>02333 <span class="preprocessor"></span>            adapter-&gt;msix_entries = kzalloc_node(
<a name="l02334"></a>02334                              adapter-&gt;num_vectors *
<a name="l02335"></a>02335                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msix_entry),
<a name="l02336"></a>02336                              GFP_KERNEL, adapter-&gt;node);
<a name="l02337"></a>02337             <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l02338"></a>02338                 <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vectors; i++)
<a name="l02339"></a>02339                     adapter-&gt;msix_entries[i].entry = i;
<a name="l02340"></a>02340 
<a name="l02341"></a>02341                 err = pci_enable_msix(adapter-&gt;pdev,
<a name="l02342"></a>02342                               adapter-&gt;msix_entries,
<a name="l02343"></a>02343                               adapter-&gt;num_vectors);
<a name="l02344"></a>02344                 <span class="keywordflow">if</span> (err == 0)
<a name="l02345"></a>02345                     <span class="keywordflow">return</span>;
<a name="l02346"></a>02346             }
<a name="l02347"></a>02347             <span class="comment">/* MSI-X failed, so fall through and try MSI */</span>
<a name="l02348"></a>02348             e_err(<span class="stringliteral">&quot;Failed to initialize MSI-X interrupts.  &quot;</span>
<a name="l02349"></a>02349                   <span class="stringliteral">&quot;Falling back to MSI interrupts.\n&quot;</span>);
<a name="l02350"></a>02350             e1000e_reset_interrupt_capability(adapter);
<a name="l02351"></a>02351         }
<a name="l02352"></a>02352         adapter-&gt;int_mode = E1000E_INT_MODE_MSI;
<a name="l02353"></a>02353         <span class="comment">/* Fall through */</span>
<a name="l02354"></a>02354     <span class="keywordflow">case</span> E1000E_INT_MODE_MSI:
<a name="l02355"></a>02355         <span class="keywordflow">if</span> (!pci_enable_msi(adapter-&gt;pdev)) {
<a name="l02356"></a>02356             adapter-&gt;flags |= FLAG_MSI_ENABLED;
<a name="l02357"></a>02357         } <span class="keywordflow">else</span> {
<a name="l02358"></a>02358             adapter-&gt;int_mode = E1000E_INT_MODE_LEGACY;
<a name="l02359"></a>02359             e_err(<span class="stringliteral">&quot;Failed to initialize MSI interrupts.  Falling &quot;</span>
<a name="l02360"></a>02360                   <span class="stringliteral">&quot;back to legacy interrupts.\n&quot;</span>);
<a name="l02361"></a>02361         }
<a name="l02362"></a>02362         <span class="comment">/* Fall through */</span>
<a name="l02363"></a>02363     <span class="keywordflow">case</span> E1000E_INT_MODE_LEGACY:
<a name="l02364"></a>02364         <span class="comment">/* Don&#39;t do anything; this is the system default */</span>
<a name="l02365"></a>02365         <span class="keywordflow">break</span>;
<a name="l02366"></a>02366     }
<a name="l02367"></a>02367 
<a name="l02368"></a>02368     <span class="comment">/* store the number of vectors being used */</span>
<a name="l02369"></a>02369     adapter-&gt;num_vectors = 1;
<a name="l02370"></a>02370 }
<a name="l02371"></a>02371 
<a name="l02378"></a>02378 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_request_msix(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02379"></a>02379 {
<a name="l02380"></a>02380     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02381"></a>02381     <span class="keywordtype">int</span> err = 0, vector = 0;
<a name="l02382"></a>02382 
<a name="l02383"></a>02383     <span class="keywordflow">if</span> (strlen(netdev-&gt;name) &lt; (IFNAMSIZ - 5))
<a name="l02384"></a>02384 <span class="preprocessor">#ifdef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02385"></a>02385 <span class="preprocessor"></span>        snprintf(adapter-&gt;rx_ring-&gt;name,
<a name="l02386"></a>02386              <span class="keyword">sizeof</span>(adapter-&gt;rx_ring-&gt;name) - 1,
<a name="l02387"></a>02387              <span class="stringliteral">&quot;%s-rx-0&quot;</span>, netdev-&gt;name);
<a name="l02388"></a>02388 <span class="preprocessor">#else</span>
<a name="l02389"></a>02389 <span class="preprocessor"></span>        snprintf(adapter-&gt;rx_ring-&gt;name,
<a name="l02390"></a>02390              <span class="keyword">sizeof</span>(adapter-&gt;rx_ring-&gt;name) - 1,
<a name="l02391"></a>02391              <span class="stringliteral">&quot;%s-Q0&quot;</span>, netdev-&gt;name);
<a name="l02392"></a>02392 <span class="preprocessor">#endif</span>
<a name="l02393"></a>02393 <span class="preprocessor"></span>    <span class="keywordflow">else</span>
<a name="l02394"></a>02394         memcpy(adapter-&gt;rx_ring-&gt;name, netdev-&gt;name, IFNAMSIZ);
<a name="l02395"></a>02395     err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02396"></a>02396               e1000_intr_msix_rx, 0, adapter-&gt;rx_ring-&gt;name,
<a name="l02397"></a>02397               netdev);
<a name="l02398"></a>02398     <span class="keywordflow">if</span> (err)
<a name="l02399"></a>02399         <span class="keywordflow">goto</span> out;
<a name="l02400"></a>02400     adapter-&gt;rx_ring-&gt;itr_register = E1000_EITR_82574(vector);
<a name="l02401"></a>02401     adapter-&gt;rx_ring-&gt;itr_val = adapter-&gt;itr;
<a name="l02402"></a>02402     vector++;
<a name="l02403"></a>02403 
<a name="l02404"></a>02404 <span class="preprocessor">#ifdef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02405"></a>02405 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (strlen(netdev-&gt;name) &lt; (IFNAMSIZ - 5))
<a name="l02406"></a>02406         snprintf(adapter-&gt;tx_ring-&gt;name,
<a name="l02407"></a>02407              <span class="keyword">sizeof</span>(adapter-&gt;tx_ring-&gt;name) - 1,
<a name="l02408"></a>02408              <span class="stringliteral">&quot;%s-tx-0&quot;</span>, netdev-&gt;name);
<a name="l02409"></a>02409     <span class="keywordflow">else</span>
<a name="l02410"></a>02410         memcpy(adapter-&gt;tx_ring-&gt;name, netdev-&gt;name, IFNAMSIZ);
<a name="l02411"></a>02411     err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02412"></a>02412               e1000_intr_msix_tx, 0, adapter-&gt;tx_ring-&gt;name,
<a name="l02413"></a>02413               netdev);
<a name="l02414"></a>02414     <span class="keywordflow">if</span> (err)
<a name="l02415"></a>02415         <span class="keywordflow">goto</span> out;
<a name="l02416"></a>02416     adapter-&gt;tx_ring-&gt;itr_register = E1000_EITR_82574(vector);
<a name="l02417"></a>02417     adapter-&gt;tx_ring-&gt;itr_val = adapter-&gt;itr;
<a name="l02418"></a>02418     vector++;
<a name="l02419"></a>02419 
<a name="l02420"></a>02420 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_SEPARATE_TX_HANDLER */</span>
<a name="l02421"></a>02421     err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02422"></a>02422               e1000_msix_other, 0, netdev-&gt;name, netdev);
<a name="l02423"></a>02423     <span class="keywordflow">if</span> (err)
<a name="l02424"></a>02424         <span class="keywordflow">goto</span> out;
<a name="l02425"></a>02425 
<a name="l02426"></a>02426     e1000_configure_msix(adapter);
<a name="l02427"></a>02427     <span class="keywordflow">return</span> 0;
<a name="l02428"></a>02428 out:
<a name="l02429"></a>02429     <span class="keywordflow">return</span> err;
<a name="l02430"></a>02430 }
<a name="l02431"></a>02431 
<a name="l02432"></a>02432 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l02433"></a>02433 
<a name="l02439"></a>02439 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_request_irq(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02440"></a>02440 {
<a name="l02441"></a>02441     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02442"></a>02442 <span class="preprocessor">#ifndef CONFIG_E1000E_MSIX</span>
<a name="l02443"></a>02443 <span class="preprocessor"></span>    <span class="keywordtype">int</span> irq_flags = IRQF_SHARED;
<a name="l02444"></a>02444 <span class="preprocessor">#endif</span>
<a name="l02445"></a>02445 <span class="preprocessor"></span>    <span class="keywordtype">int</span> err;
<a name="l02446"></a>02446 
<a name="l02447"></a>02447 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02448"></a>02448 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l02449"></a>02449         err = e1000_request_msix(adapter);
<a name="l02450"></a>02450         <span class="keywordflow">if</span> (!err)
<a name="l02451"></a>02451             <span class="keywordflow">return</span> err;
<a name="l02452"></a>02452         <span class="comment">/* fall back to MSI */</span>
<a name="l02453"></a>02453         e1000e_reset_interrupt_capability(adapter);
<a name="l02454"></a>02454         adapter-&gt;int_mode = E1000E_INT_MODE_MSI;
<a name="l02455"></a>02455         e1000e_set_interrupt_capability(adapter);
<a name="l02456"></a>02456     }
<a name="l02457"></a>02457     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_MSI_ENABLED) {
<a name="l02458"></a>02458         err = request_irq(adapter-&gt;pdev-&gt;irq, e1000_intr_msi, 0,
<a name="l02459"></a>02459                   netdev-&gt;name, netdev);
<a name="l02460"></a>02460         <span class="keywordflow">if</span> (!err)
<a name="l02461"></a>02461             <span class="keywordflow">return</span> err;
<a name="l02462"></a>02462 
<a name="l02463"></a>02463         <span class="comment">/* fall back to legacy interrupt */</span>
<a name="l02464"></a>02464         e1000e_reset_interrupt_capability(adapter);
<a name="l02465"></a>02465         adapter-&gt;int_mode = E1000E_INT_MODE_LEGACY;
<a name="l02466"></a>02466     }
<a name="l02467"></a>02467 
<a name="l02468"></a>02468     err = request_irq(adapter-&gt;pdev-&gt;irq, e1000_intr, IRQF_SHARED,
<a name="l02469"></a>02469               netdev-&gt;name, netdev);
<a name="l02470"></a>02470     <span class="keywordflow">if</span> (err)
<a name="l02471"></a>02471         e_err(<span class="stringliteral">&quot;Unable to allocate interrupt, Error: %d\n&quot;</span>, err);
<a name="l02472"></a>02472 <span class="preprocessor">#else</span>
<a name="l02473"></a>02473 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_MSI_TEST_FAILED)) {
<a name="l02474"></a>02474         err = pci_enable_msi(adapter-&gt;pdev);
<a name="l02475"></a>02475         <span class="keywordflow">if</span> (!err) {
<a name="l02476"></a>02476             adapter-&gt;flags |= FLAG_MSI_ENABLED;
<a name="l02477"></a>02477             irq_flags = 0;
<a name="l02478"></a>02478         }
<a name="l02479"></a>02479     }
<a name="l02480"></a>02480 
<a name="l02481"></a>02481     err = request_irq(adapter-&gt;pdev-&gt;irq,
<a name="l02482"></a>02482               ((adapter-&gt;flags &amp; FLAG_MSI_ENABLED) ?
<a name="l02483"></a>02483                 e1000_intr_msi : e1000_intr),
<a name="l02484"></a>02484               irq_flags, netdev-&gt;name, netdev);
<a name="l02485"></a>02485     <span class="keywordflow">if</span> (err) {
<a name="l02486"></a>02486         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_MSI_ENABLED) {
<a name="l02487"></a>02487             pci_disable_msi(adapter-&gt;pdev);
<a name="l02488"></a>02488             adapter-&gt;flags &amp;= ~FLAG_MSI_ENABLED;
<a name="l02489"></a>02489         }
<a name="l02490"></a>02490         e_err(<span class="stringliteral">&quot;Unable to allocate interrupt, Error: %d\n&quot;</span>, err);
<a name="l02491"></a>02491     }
<a name="l02492"></a>02492 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l02493"></a>02493 
<a name="l02494"></a>02494     <span class="keywordflow">return</span> err;
<a name="l02495"></a>02495 }
<a name="l02496"></a>02496 
<a name="l02497"></a>02497 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_free_irq(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02498"></a>02498 {
<a name="l02499"></a>02499     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02500"></a>02500 
<a name="l02501"></a>02501 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02502"></a>02502 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l02503"></a>02503         <span class="keywordtype">int</span> vector = 0;
<a name="l02504"></a>02504 
<a name="l02505"></a>02505         free_irq(adapter-&gt;msix_entries[vector].vector, netdev);
<a name="l02506"></a>02506         vector++;
<a name="l02507"></a>02507 
<a name="l02508"></a>02508 <span class="preprocessor">#ifdef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l02509"></a>02509 <span class="preprocessor"></span>        free_irq(adapter-&gt;msix_entries[vector].vector, netdev);
<a name="l02510"></a>02510         vector++;
<a name="l02511"></a>02511 
<a name="l02512"></a>02512 <span class="preprocessor">#endif</span>
<a name="l02513"></a>02513 <span class="preprocessor"></span>        <span class="comment">/* Other Causes interrupt vector */</span>
<a name="l02514"></a>02514         free_irq(adapter-&gt;msix_entries[vector].vector, netdev);
<a name="l02515"></a>02515         <span class="keywordflow">return</span>;
<a name="l02516"></a>02516     }
<a name="l02517"></a>02517 
<a name="l02518"></a>02518 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l02519"></a>02519     free_irq(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l02520"></a>02520 <span class="preprocessor">#ifndef CONFIG_E1000E_MSIX</span>
<a name="l02521"></a>02521 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_MSI_ENABLED) {
<a name="l02522"></a>02522         pci_disable_msi(adapter-&gt;pdev);
<a name="l02523"></a>02523         adapter-&gt;flags &amp;= ~FLAG_MSI_ENABLED;
<a name="l02524"></a>02524     }
<a name="l02525"></a>02525 <span class="preprocessor">#endif</span>
<a name="l02526"></a>02526 <span class="preprocessor"></span>}
<a name="l02527"></a>02527 
<a name="l02531"></a>02531 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_irq_disable(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02532"></a>02532 {
<a name="l02533"></a>02533     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02534"></a>02534 
<a name="l02535"></a>02535     ew32(IMC, ~0);
<a name="l02536"></a>02536 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02537"></a>02537 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l02538"></a>02538         ew32(EIAC_82574, 0);
<a name="l02539"></a>02539 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l02540"></a>02540     e1e_flush();
<a name="l02541"></a>02541 
<a name="l02542"></a>02542     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l02543"></a>02543         <span class="keywordtype">int</span> i;
<a name="l02544"></a>02544         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vectors; i++)
<a name="l02545"></a>02545             synchronize_irq(adapter-&gt;msix_entries[i].vector);
<a name="l02546"></a>02546     } <span class="keywordflow">else</span> {
<a name="l02547"></a>02547         synchronize_irq(adapter-&gt;pdev-&gt;irq);
<a name="l02548"></a>02548     }
<a name="l02549"></a>02549 }
<a name="l02550"></a>02550 
<a name="l02554"></a>02554 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_irq_enable(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02555"></a>02555 {
<a name="l02556"></a>02556     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02557"></a>02557 
<a name="l02558"></a>02558 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02559"></a>02559 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l02560"></a>02560         ew32(EIAC_82574, adapter-&gt;eiac_mask &amp; E1000_EIAC_MASK_82574);
<a name="l02561"></a>02561         ew32(IMS, adapter-&gt;eiac_mask | E1000_IMS_OTHER | E1000_IMS_LSC);
<a name="l02562"></a>02562     } <span class="keywordflow">else</span> {
<a name="l02563"></a>02563         ew32(IMS, IMS_ENABLE_MASK);
<a name="l02564"></a>02564     }
<a name="l02565"></a>02565 <span class="preprocessor">#else</span>
<a name="l02566"></a>02566 <span class="preprocessor"></span>    ew32(IMS, IMS_ENABLE_MASK);
<a name="l02567"></a>02567 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l02568"></a>02568     e1e_flush();
<a name="l02569"></a>02569 }
<a name="l02570"></a>02570 
<a name="l02580"></a>02580 <span class="keywordtype">void</span> e1000e_get_hw_control(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02581"></a>02581 {
<a name="l02582"></a>02582     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02583"></a>02583     u32 ctrl_ext;
<a name="l02584"></a>02584     u32 swsm;
<a name="l02585"></a>02585 
<a name="l02586"></a>02586     <span class="comment">/* Let firmware know the driver has taken over */</span>
<a name="l02587"></a>02587     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_SWSM_ON_LOAD) {
<a name="l02588"></a>02588         swsm = er32(SWSM);
<a name="l02589"></a>02589         ew32(SWSM, swsm | E1000_SWSM_DRV_LOAD);
<a name="l02590"></a>02590     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_CTRLEXT_ON_LOAD) {
<a name="l02591"></a>02591         ctrl_ext = er32(CTRL_EXT);
<a name="l02592"></a>02592         ew32(CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_DRV_LOAD);
<a name="l02593"></a>02593     }
<a name="l02594"></a>02594 }
<a name="l02595"></a>02595 
<a name="l02606"></a>02606 <span class="keywordtype">void</span> e1000e_release_hw_control(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02607"></a>02607 {
<a name="l02608"></a>02608     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02609"></a>02609     u32 ctrl_ext;
<a name="l02610"></a>02610     u32 swsm;
<a name="l02611"></a>02611 
<a name="l02612"></a>02612     <span class="comment">/* Let firmware taken over control of h/w */</span>
<a name="l02613"></a>02613     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_SWSM_ON_LOAD) {
<a name="l02614"></a>02614         swsm = er32(SWSM);
<a name="l02615"></a>02615         ew32(SWSM, swsm &amp; ~E1000_SWSM_DRV_LOAD);
<a name="l02616"></a>02616     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_CTRLEXT_ON_LOAD) {
<a name="l02617"></a>02617         ctrl_ext = er32(CTRL_EXT);
<a name="l02618"></a>02618         ew32(CTRL_EXT, ctrl_ext &amp; ~E1000_CTRL_EXT_DRV_LOAD);
<a name="l02619"></a>02619     }
<a name="l02620"></a>02620 }
<a name="l02621"></a>02621 
<a name="l02625"></a>02625 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_alloc_ring_dma(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l02626"></a>02626                 <span class="keyword">struct</span> <a class="code" href="structe1000__ring.html">e1000_ring</a> *ring)
<a name="l02627"></a>02627 {
<a name="l02628"></a>02628     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l02629"></a>02629     <span class="keywordtype">int</span> old_node = dev_to_node(pci_dev_to_dev(pdev));
<a name="l02630"></a>02630     <span class="keywordtype">int</span> retval = 0;
<a name="l02631"></a>02631 
<a name="l02632"></a>02632     <span class="comment">/*</span>
<a name="l02633"></a>02633 <span class="comment">     * must use set_dev_node here to work around the lack of a</span>
<a name="l02634"></a>02634 <span class="comment">     * dma_alloc_coherent_node function call</span>
<a name="l02635"></a>02635 <span class="comment">     */</span>
<a name="l02636"></a>02636     <span class="keywordflow">if</span> (adapter-&gt;node != -1)
<a name="l02637"></a>02637         set_dev_node(pci_dev_to_dev(pdev), adapter-&gt;node);
<a name="l02638"></a>02638     ring-&gt;desc = dma_alloc_coherent(pci_dev_to_dev(pdev), ring-&gt;size, &amp;ring-&gt;dma,
<a name="l02639"></a>02639                     GFP_KERNEL);
<a name="l02640"></a>02640     <span class="keywordflow">if</span> (!ring-&gt;desc)
<a name="l02641"></a>02641         retval = -ENOMEM;
<a name="l02642"></a>02642 
<a name="l02643"></a>02643     <span class="keywordflow">if</span> (adapter-&gt;node != -1)
<a name="l02644"></a>02644         set_dev_node(pci_dev_to_dev(pdev), old_node);
<a name="l02645"></a>02645     <span class="keywordflow">return</span> retval;
<a name="l02646"></a>02646 }
<a name="l02647"></a>02647 
<a name="l02654"></a>02654 <span class="keywordtype">int</span> e1000e_setup_tx_resources(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02655"></a>02655 {
<a name="l02656"></a>02656     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l02657"></a>02657     <span class="keywordtype">int</span> err = -ENOMEM, size;
<a name="l02658"></a>02658 
<a name="l02659"></a>02659     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a>) * tx_ring-&gt;count;
<a name="l02660"></a>02660     tx_ring-&gt;buffer_info = vzalloc_node(size, adapter-&gt;node);
<a name="l02661"></a>02661     <span class="keywordflow">if</span> (!tx_ring-&gt;buffer_info)
<a name="l02662"></a>02662         <span class="keywordflow">goto</span> err;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664     <span class="comment">/* round up to nearest 4K */</span>
<a name="l02665"></a>02665     tx_ring-&gt;size = tx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__tx__desc.html">e1000_tx_desc</a>);
<a name="l02666"></a>02666     tx_ring-&gt;size = ALIGN(tx_ring-&gt;size, 4096);
<a name="l02667"></a>02667 
<a name="l02668"></a>02668     err = e1000_alloc_ring_dma(adapter, tx_ring);
<a name="l02669"></a>02669     <span class="keywordflow">if</span> (err)
<a name="l02670"></a>02670         <span class="keywordflow">goto</span> err;
<a name="l02671"></a>02671 
<a name="l02672"></a>02672     tx_ring-&gt;next_to_use = 0;
<a name="l02673"></a>02673     tx_ring-&gt;next_to_clean = 0;
<a name="l02674"></a>02674 
<a name="l02675"></a>02675     <span class="keywordflow">return</span> 0;
<a name="l02676"></a>02676 err:
<a name="l02677"></a>02677     vfree(tx_ring-&gt;buffer_info);
<a name="l02678"></a>02678     e_err(<span class="stringliteral">&quot;Unable to allocate memory for the transmit descriptor ring\n&quot;</span>);
<a name="l02679"></a>02679     <span class="keywordflow">return</span> err;
<a name="l02680"></a>02680 }
<a name="l02681"></a>02681 
<a name="l02688"></a>02688 <span class="keywordtype">int</span> e1000e_setup_rx_resources(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02689"></a>02689 {
<a name="l02690"></a>02690     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l02691"></a>02691     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l02692"></a>02692     <span class="keywordtype">int</span> i, size, desc_len, err = -ENOMEM;
<a name="l02693"></a>02693 
<a name="l02694"></a>02694     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a>) * rx_ring-&gt;count;
<a name="l02695"></a>02695     rx_ring-&gt;buffer_info = vzalloc_node(size, adapter-&gt;node);
<a name="l02696"></a>02696     <span class="keywordflow">if</span> (!rx_ring-&gt;buffer_info)
<a name="l02697"></a>02697         <span class="keywordflow">goto</span> err;
<a name="l02698"></a>02698 
<a name="l02699"></a>02699     <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++) {
<a name="l02700"></a>02700         buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l02701"></a>02701         buffer_info-&gt;ps_pages = kzalloc_node(PS_PAGE_BUFFERS *
<a name="l02702"></a>02702                         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structe1000__ps__page.html">e1000_ps_page</a>),
<a name="l02703"></a>02703                         GFP_KERNEL, adapter-&gt;node);
<a name="l02704"></a>02704         <span class="keywordflow">if</span> (!buffer_info-&gt;ps_pages)
<a name="l02705"></a>02705             <span class="keywordflow">goto</span> err_pages;
<a name="l02706"></a>02706     }
<a name="l02707"></a>02707 
<a name="l02708"></a>02708     desc_len = <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unione1000__rx__desc__packet__split.html">e1000_rx_desc_packet_split</a>);
<a name="l02709"></a>02709 
<a name="l02710"></a>02710     <span class="comment">/* Round up to nearest 4K */</span>
<a name="l02711"></a>02711     rx_ring-&gt;size = rx_ring-&gt;count * desc_len;
<a name="l02712"></a>02712     rx_ring-&gt;size = ALIGN(rx_ring-&gt;size, 4096);
<a name="l02713"></a>02713 
<a name="l02714"></a>02714     err = e1000_alloc_ring_dma(adapter, rx_ring);
<a name="l02715"></a>02715     <span class="keywordflow">if</span> (err)
<a name="l02716"></a>02716         <span class="keywordflow">goto</span> err_pages;
<a name="l02717"></a>02717 
<a name="l02718"></a>02718     rx_ring-&gt;next_to_clean = 0;
<a name="l02719"></a>02719     rx_ring-&gt;next_to_use = 0;
<a name="l02720"></a>02720     rx_ring-&gt;rx_skb_top = NULL;
<a name="l02721"></a>02721 
<a name="l02722"></a>02722     <span class="keywordflow">return</span> 0;
<a name="l02723"></a>02723 
<a name="l02724"></a>02724 err_pages:
<a name="l02725"></a>02725     <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++) {
<a name="l02726"></a>02726         buffer_info = &amp;rx_ring-&gt;buffer_info[i];
<a name="l02727"></a>02727         kfree(buffer_info-&gt;ps_pages);
<a name="l02728"></a>02728     }
<a name="l02729"></a>02729 err:
<a name="l02730"></a>02730     vfree(rx_ring-&gt;buffer_info);
<a name="l02731"></a>02731     e_err(<span class="stringliteral">&quot;Unable to allocate memory for the receive descriptor ring\n&quot;</span>);
<a name="l02732"></a>02732     <span class="keywordflow">return</span> err;
<a name="l02733"></a>02733 }
<a name="l02734"></a>02734 
<a name="l02739"></a>02739 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_clean_tx_ring(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02740"></a>02740 {
<a name="l02741"></a>02741     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l02742"></a>02742     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l02743"></a>02743     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
<a name="l02744"></a>02744     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l02745"></a>02745 
<a name="l02746"></a>02746     <span class="keywordflow">for</span> (i = 0; i &lt; tx_ring-&gt;count; i++) {
<a name="l02747"></a>02747         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l02748"></a>02748         e1000_put_txbuf(adapter, buffer_info);
<a name="l02749"></a>02749     }
<a name="l02750"></a>02750 
<a name="l02751"></a>02751     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a>) * tx_ring-&gt;count;
<a name="l02752"></a>02752     memset(tx_ring-&gt;buffer_info, 0, size);
<a name="l02753"></a>02753 
<a name="l02754"></a>02754     memset(tx_ring-&gt;desc, 0, tx_ring-&gt;size);
<a name="l02755"></a>02755 
<a name="l02756"></a>02756     tx_ring-&gt;next_to_use = 0;
<a name="l02757"></a>02757     tx_ring-&gt;next_to_clean = 0;
<a name="l02758"></a>02758 
<a name="l02759"></a>02759     writel(0, adapter-&gt;hw.hw_addr + tx_ring-&gt;head);
<a name="l02760"></a>02760     writel(0, adapter-&gt;hw.hw_addr + tx_ring-&gt;tail);
<a name="l02761"></a>02761 }
<a name="l02762"></a>02762 
<a name="l02769"></a>02769 <span class="keywordtype">void</span> e1000e_free_tx_resources(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02770"></a>02770 {
<a name="l02771"></a>02771     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l02772"></a>02772     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l02773"></a>02773 
<a name="l02774"></a>02774     e1000_clean_tx_ring(adapter);
<a name="l02775"></a>02775 
<a name="l02776"></a>02776     vfree(tx_ring-&gt;buffer_info);
<a name="l02777"></a>02777     tx_ring-&gt;buffer_info = NULL;
<a name="l02778"></a>02778 
<a name="l02779"></a>02779     dma_free_coherent(pci_dev_to_dev(pdev), tx_ring-&gt;size, tx_ring-&gt;desc,
<a name="l02780"></a>02780               tx_ring-&gt;dma);
<a name="l02781"></a>02781     tx_ring-&gt;desc = NULL;
<a name="l02782"></a>02782 }
<a name="l02783"></a>02783 
<a name="l02791"></a>02791 <span class="keywordtype">void</span> e1000e_free_rx_resources(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02792"></a>02792 {
<a name="l02793"></a>02793     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l02794"></a>02794     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l02795"></a>02795     <span class="keywordtype">int</span> i;
<a name="l02796"></a>02796 
<a name="l02797"></a>02797     e1000_clean_rx_ring(adapter);
<a name="l02798"></a>02798 
<a name="l02799"></a>02799     <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++)
<a name="l02800"></a>02800         kfree(rx_ring-&gt;buffer_info[i].ps_pages);
<a name="l02801"></a>02801 
<a name="l02802"></a>02802     vfree(rx_ring-&gt;buffer_info);
<a name="l02803"></a>02803     rx_ring-&gt;buffer_info = NULL;
<a name="l02804"></a>02804 
<a name="l02805"></a>02805     dma_free_coherent(pci_dev_to_dev(pdev), rx_ring-&gt;size, rx_ring-&gt;desc,
<a name="l02806"></a>02806               rx_ring-&gt;dma);
<a name="l02807"></a>02807     rx_ring-&gt;desc = NULL;
<a name="l02808"></a>02808 }
<a name="l02809"></a>02809 
<a name="l02826"></a>02826 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e1000_update_itr(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l02827"></a>02827                      u16 itr_setting, <span class="keywordtype">int</span> packets,
<a name="l02828"></a>02828                      <span class="keywordtype">int</span> bytes)
<a name="l02829"></a>02829 {
<a name="l02830"></a>02830     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> retval = itr_setting;
<a name="l02831"></a>02831 
<a name="l02832"></a>02832     <span class="keywordflow">if</span> (packets == 0)
<a name="l02833"></a>02833         <span class="keywordflow">goto</span> update_itr_done;
<a name="l02834"></a>02834 
<a name="l02835"></a>02835     <span class="keywordflow">switch</span> (itr_setting) {
<a name="l02836"></a>02836     <span class="keywordflow">case</span> lowest_latency:
<a name="l02837"></a>02837         <span class="comment">/* handle TSO and jumbo frames */</span>
<a name="l02838"></a>02838         <span class="keywordflow">if</span> (bytes/packets &gt; 8000)
<a name="l02839"></a>02839             retval = bulk_latency;
<a name="l02840"></a>02840         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((packets &lt; 5) &amp;&amp; (bytes &gt; 512))
<a name="l02841"></a>02841             retval = low_latency;
<a name="l02842"></a>02842         <span class="keywordflow">break</span>;
<a name="l02843"></a>02843     <span class="keywordflow">case</span> low_latency:  <span class="comment">/* 50 usec aka 20000 ints/s */</span>
<a name="l02844"></a>02844         <span class="keywordflow">if</span> (bytes &gt; 10000) {
<a name="l02845"></a>02845             <span class="comment">/* this if handles the TSO accounting */</span>
<a name="l02846"></a>02846             <span class="keywordflow">if</span> (bytes/packets &gt; 8000)
<a name="l02847"></a>02847                 retval = bulk_latency;
<a name="l02848"></a>02848             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((packets &lt; 10) || ((bytes/packets) &gt; 1200))
<a name="l02849"></a>02849                 retval = bulk_latency;
<a name="l02850"></a>02850             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((packets &gt; 35))
<a name="l02851"></a>02851                 retval = lowest_latency;
<a name="l02852"></a>02852         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes/packets &gt; 2000) {
<a name="l02853"></a>02853             retval = bulk_latency;
<a name="l02854"></a>02854         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (packets &lt;= 2 &amp;&amp; bytes &lt; 512) {
<a name="l02855"></a>02855             retval = lowest_latency;
<a name="l02856"></a>02856         }
<a name="l02857"></a>02857         <span class="keywordflow">break</span>;
<a name="l02858"></a>02858     <span class="keywordflow">case</span> bulk_latency: <span class="comment">/* 250 usec aka 4000 ints/s */</span>
<a name="l02859"></a>02859         <span class="keywordflow">if</span> (bytes &gt; 25000) {
<a name="l02860"></a>02860             <span class="keywordflow">if</span> (packets &gt; 35)
<a name="l02861"></a>02861                 retval = low_latency;
<a name="l02862"></a>02862         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes &lt; 6000) {
<a name="l02863"></a>02863             retval = low_latency;
<a name="l02864"></a>02864         }
<a name="l02865"></a>02865         <span class="keywordflow">break</span>;
<a name="l02866"></a>02866     }
<a name="l02867"></a>02867 
<a name="l02868"></a>02868 update_itr_done:
<a name="l02869"></a>02869     <span class="keywordflow">return</span> retval;
<a name="l02870"></a>02870 }
<a name="l02871"></a>02871 
<a name="l02872"></a>02872 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_set_itr(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02873"></a>02873 {
<a name="l02874"></a>02874     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02875"></a>02875     u16 current_itr;
<a name="l02876"></a>02876     u32 new_itr = adapter-&gt;itr;
<a name="l02877"></a>02877 
<a name="l02878"></a>02878     <span class="comment">/* for non-gigabit speeds, just fix the interrupt rate at 4000 */</span>
<a name="l02879"></a>02879     <span class="keywordflow">if</span> (adapter-&gt;link_speed != SPEED_1000) {
<a name="l02880"></a>02880         current_itr = 0;
<a name="l02881"></a>02881         new_itr = 4000;
<a name="l02882"></a>02882         <span class="keywordflow">goto</span> set_itr_now;
<a name="l02883"></a>02883     }
<a name="l02884"></a>02884 
<a name="l02885"></a>02885     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_DISABLE_AIM) {
<a name="l02886"></a>02886         new_itr = 0;
<a name="l02887"></a>02887         <span class="keywordflow">goto</span> set_itr_now;
<a name="l02888"></a>02888     }
<a name="l02889"></a>02889 
<a name="l02890"></a>02890     adapter-&gt;tx_itr = e1000_update_itr(adapter,
<a name="l02891"></a>02891                     adapter-&gt;tx_itr,
<a name="l02892"></a>02892                     adapter-&gt;total_tx_packets,
<a name="l02893"></a>02893                     adapter-&gt;total_tx_bytes);
<a name="l02894"></a>02894     <span class="comment">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
<a name="l02895"></a>02895     <span class="keywordflow">if</span> (adapter-&gt;itr_setting == 3 &amp;&amp; adapter-&gt;tx_itr == lowest_latency)
<a name="l02896"></a>02896         adapter-&gt;tx_itr = low_latency;
<a name="l02897"></a>02897 
<a name="l02898"></a>02898     adapter-&gt;rx_itr = e1000_update_itr(adapter,
<a name="l02899"></a>02899                     adapter-&gt;rx_itr,
<a name="l02900"></a>02900                     adapter-&gt;total_rx_packets,
<a name="l02901"></a>02901                     adapter-&gt;total_rx_bytes);
<a name="l02902"></a>02902     <span class="comment">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
<a name="l02903"></a>02903     <span class="keywordflow">if</span> (adapter-&gt;itr_setting == 3 &amp;&amp; adapter-&gt;rx_itr == lowest_latency)
<a name="l02904"></a>02904         adapter-&gt;rx_itr = low_latency;
<a name="l02905"></a>02905 
<a name="l02906"></a>02906     current_itr = max(adapter-&gt;rx_itr, adapter-&gt;tx_itr);
<a name="l02907"></a>02907 
<a name="l02908"></a>02908     <span class="keywordflow">switch</span> (current_itr) {
<a name="l02909"></a>02909     <span class="comment">/* counts and packets in update_itr are dependent on these numbers */</span>
<a name="l02910"></a>02910     <span class="keywordflow">case</span> lowest_latency:
<a name="l02911"></a>02911         new_itr = 70000;
<a name="l02912"></a>02912         <span class="keywordflow">break</span>;
<a name="l02913"></a>02913     <span class="keywordflow">case</span> low_latency:
<a name="l02914"></a>02914         new_itr = 20000; <span class="comment">/* aka hwitr = ~200 */</span>
<a name="l02915"></a>02915         <span class="keywordflow">break</span>;
<a name="l02916"></a>02916     <span class="keywordflow">case</span> bulk_latency:
<a name="l02917"></a>02917         new_itr = 4000;
<a name="l02918"></a>02918         <span class="keywordflow">break</span>;
<a name="l02919"></a>02919     <span class="keywordflow">default</span>:
<a name="l02920"></a>02920         <span class="keywordflow">break</span>;
<a name="l02921"></a>02921     }
<a name="l02922"></a>02922 
<a name="l02923"></a>02923 set_itr_now:
<a name="l02924"></a>02924     <span class="keywordflow">if</span> (new_itr != adapter-&gt;itr) {
<a name="l02925"></a>02925         <span class="comment">/*</span>
<a name="l02926"></a>02926 <span class="comment">         * this attempts to bias the interrupt rate towards Bulk</span>
<a name="l02927"></a>02927 <span class="comment">         * by adding intermediate steps when interrupt rate is</span>
<a name="l02928"></a>02928 <span class="comment">         * increasing</span>
<a name="l02929"></a>02929 <span class="comment">         */</span>
<a name="l02930"></a>02930         new_itr = new_itr &gt; adapter-&gt;itr ?
<a name="l02931"></a>02931                  min(adapter-&gt;itr + (new_itr &gt;&gt; 2), new_itr) :
<a name="l02932"></a>02932                  new_itr;
<a name="l02933"></a>02933         adapter-&gt;itr = new_itr;
<a name="l02934"></a>02934 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02935"></a>02935 <span class="preprocessor"></span>        adapter-&gt;rx_ring-&gt;itr_val = new_itr;
<a name="l02936"></a>02936         <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l02937"></a>02937             adapter-&gt;rx_ring-&gt;set_itr = 1;
<a name="l02938"></a>02938         <span class="keywordflow">else</span>
<a name="l02939"></a>02939             <span class="keywordflow">if</span> (new_itr)
<a name="l02940"></a>02940                 ew32(ITR, 1000000000 / (new_itr * 256));
<a name="l02941"></a>02941             <span class="keywordflow">else</span>
<a name="l02942"></a>02942                 ew32(ITR, 0);
<a name="l02943"></a>02943 <span class="preprocessor">#else</span>
<a name="l02944"></a>02944 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (new_itr)
<a name="l02945"></a>02945             ew32(ITR, 1000000000 / (new_itr * 256));
<a name="l02946"></a>02946         <span class="keywordflow">else</span>
<a name="l02947"></a>02947             ew32(ITR, 0);
<a name="l02948"></a>02948 <span class="preprocessor">#endif</span>
<a name="l02949"></a>02949 <span class="preprocessor"></span>    }
<a name="l02950"></a>02950 }
<a name="l02951"></a>02951 
<a name="l02956"></a>02956 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit e1000_alloc_queues(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l02957"></a>02957 {
<a name="l02958"></a>02958     adapter-&gt;tx_ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structe1000__ring.html">e1000_ring</a>), GFP_KERNEL,
<a name="l02959"></a>02959                     adapter-&gt;node);
<a name="l02960"></a>02960     <span class="keywordflow">if</span> (!adapter-&gt;tx_ring)
<a name="l02961"></a>02961         <span class="keywordflow">goto</span> err;
<a name="l02962"></a>02962 
<a name="l02963"></a>02963     adapter-&gt;rx_ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structe1000__ring.html">e1000_ring</a>), GFP_KERNEL,
<a name="l02964"></a>02964                     adapter-&gt;node);
<a name="l02965"></a>02965     <span class="keywordflow">if</span> (!adapter-&gt;rx_ring)
<a name="l02966"></a>02966         <span class="keywordflow">goto</span> err;
<a name="l02967"></a>02967 
<a name="l02968"></a>02968     <span class="keywordflow">return</span> 0;
<a name="l02969"></a>02969 err:
<a name="l02970"></a>02970     e_err(<span class="stringliteral">&quot;Unable to allocate memory for queues\n&quot;</span>);
<a name="l02971"></a>02971     kfree(adapter-&gt;rx_ring);
<a name="l02972"></a>02972     kfree(adapter-&gt;tx_ring);
<a name="l02973"></a>02973     <span class="keywordflow">return</span> -ENOMEM;
<a name="l02974"></a>02974 }
<a name="l02975"></a>02975 
<a name="l02976"></a>02976 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l02977"></a>02977 <span class="preprocessor"></span>
<a name="l02982"></a>02982 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_poll(<span class="keyword">struct</span> napi_struct *napi, <span class="keywordtype">int</span> budget)
<a name="l02983"></a>02983 {
<a name="l02984"></a>02984     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = container_of(napi, <span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a>,
<a name="l02985"></a>02985                              napi);
<a name="l02986"></a>02986     <span class="keywordtype">int</span> tx_clean_complete = 1, work_done = 0;
<a name="l02987"></a>02987 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02988"></a>02988 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02989"></a>02989 <span class="preprocessor">#endif</span>
<a name="l02990"></a>02990 <span class="preprocessor"></span>
<a name="l02991"></a>02991 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l02992"></a>02992 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!adapter-&gt;msix_entries ||
<a name="l02993"></a>02993         (adapter-&gt;rx_ring-&gt;ims_val &amp; adapter-&gt;tx_ring-&gt;ims_val))
<a name="l02994"></a>02994 <span class="preprocessor">#endif</span>
<a name="l02995"></a>02995 <span class="preprocessor"></span>        tx_clean_complete = e1000_clean_tx_irq(adapter);
<a name="l02996"></a>02996 
<a name="l02997"></a>02997     adapter-&gt;clean_rx(adapter, &amp;work_done, budget);
<a name="l02998"></a>02998 
<a name="l02999"></a>02999     <span class="keywordflow">if</span> (!tx_clean_complete)
<a name="l03000"></a>03000         work_done = budget;
<a name="l03001"></a>03001 
<a name="l03002"></a>03002 <span class="preprocessor">#ifndef HAVE_NETDEV_NAPI_LIST</span>
<a name="l03003"></a>03003 <span class="preprocessor"></span>    <span class="comment">/* if netdev is disabled we need to stop polling */</span>
<a name="l03004"></a>03004     <span class="keywordflow">if</span> (!netif_running(adapter-&gt;netdev))
<a name="l03005"></a>03005         work_done = 0;
<a name="l03006"></a>03006 
<a name="l03007"></a>03007 <span class="preprocessor">#endif</span>
<a name="l03008"></a>03008 <span class="preprocessor"></span>    <span class="comment">/* If Tx completed and all Rx work done, exit the polling mode */</span>
<a name="l03009"></a>03009     <span class="keywordflow">if</span> (work_done &lt; budget) {
<a name="l03010"></a>03010         napi_complete(napi);
<a name="l03011"></a>03011         <span class="keywordflow">if</span> (adapter-&gt;itr_setting &amp; 3)
<a name="l03012"></a>03012             e1000_set_itr(adapter);
<a name="l03013"></a>03013         <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state)) {
<a name="l03014"></a>03014 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l03015"></a>03015 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l03016"></a>03016                 ew32(IMS, adapter-&gt;rx_ring-&gt;ims_val);
<a name="l03017"></a>03017             <span class="keywordflow">else</span>
<a name="l03018"></a>03018 <span class="preprocessor">#endif</span>
<a name="l03019"></a>03019 <span class="preprocessor"></span>                e1000_irq_enable(adapter);
<a name="l03020"></a>03020         }
<a name="l03021"></a>03021     }
<a name="l03022"></a>03022 
<a name="l03023"></a>03023     <span class="keywordflow">return</span> work_done;
<a name="l03024"></a>03024 }
<a name="l03025"></a>03025 
<a name="l03026"></a>03026 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_NAPI */</span>
<a name="l03027"></a>03027 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l03028"></a>03028 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> e1000_vlan_rx_add_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l03029"></a>03029 {
<a name="l03030"></a>03030     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03031"></a>03031     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03032"></a>03032     u32 vfta, index;
<a name="l03033"></a>03033 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l03034"></a>03034 <span class="preprocessor"></span>    <span class="keyword">struct </span>net_device *v_netdev;
<a name="l03035"></a>03035 <span class="preprocessor">#endif</span>
<a name="l03036"></a>03036 <span class="preprocessor"></span>
<a name="l03037"></a>03037     <span class="comment">/* don&#39;t update vlan cookie if already programmed */</span>
<a name="l03038"></a>03038     <span class="keywordflow">if</span> ((adapter-&gt;hw.mng_cookie.status &amp;
<a name="l03039"></a>03039          E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &amp;&amp;
<a name="l03040"></a>03040         (vid == adapter-&gt;mng_vlan_id))
<a name="l03041"></a>03041         <span class="keywordflow">return</span>;
<a name="l03042"></a>03042 
<a name="l03043"></a>03043     <span class="comment">/* add VID to filter table */</span>
<a name="l03044"></a>03044     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_HW_VLAN_FILTER) {
<a name="l03045"></a>03045         index = (vid &gt;&gt; 5) &amp; 0x7F;
<a name="l03046"></a>03046         vfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);
<a name="l03047"></a>03047         vfta |= (1 &lt;&lt; (vid &amp; 0x1F));
<a name="l03048"></a>03048         hw-&gt;mac.ops.write_vfta(hw, index, vfta);
<a name="l03049"></a>03049     }
<a name="l03050"></a>03050 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l03051"></a>03051 <span class="preprocessor"></span>
<a name="l03052"></a>03052     <span class="comment">/*</span>
<a name="l03053"></a>03053 <span class="comment">     * Copy feature flags from netdev to the vlan netdev for this vid.</span>
<a name="l03054"></a>03054 <span class="comment">     * This allows things like TSO to bubble down to our vlan device.</span>
<a name="l03055"></a>03055 <span class="comment">     */</span>
<a name="l03056"></a>03056     v_netdev = vlan_group_get_device(adapter-&gt;vlgrp, vid);
<a name="l03057"></a>03057     v_netdev-&gt;features |= adapter-&gt;netdev-&gt;features;
<a name="l03058"></a>03058     vlan_group_set_device(adapter-&gt;vlgrp, vid, v_netdev);
<a name="l03059"></a>03059 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l03060"></a>03060 }
<a name="l03061"></a>03061 
<a name="l03062"></a>03062 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_vlan_rx_kill_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l03063"></a>03063 {
<a name="l03064"></a>03064     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03065"></a>03065     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03066"></a>03066     u32 vfta, index;
<a name="l03067"></a>03067 
<a name="l03068"></a>03068     <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l03069"></a>03069         e1000_irq_disable(adapter);
<a name="l03070"></a>03070     vlan_group_set_device(adapter-&gt;vlgrp, vid, NULL);
<a name="l03071"></a>03071 
<a name="l03072"></a>03072     <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l03073"></a>03073         e1000_irq_enable(adapter);
<a name="l03074"></a>03074 
<a name="l03075"></a>03075     <span class="keywordflow">if</span> ((adapter-&gt;hw.mng_cookie.status &amp;
<a name="l03076"></a>03076          E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &amp;&amp;
<a name="l03077"></a>03077         (vid == adapter-&gt;mng_vlan_id)) {
<a name="l03078"></a>03078         <span class="comment">/* release control to f/w */</span>
<a name="l03079"></a>03079         e1000e_release_hw_control(adapter);
<a name="l03080"></a>03080         <span class="keywordflow">return</span>;
<a name="l03081"></a>03081     }
<a name="l03082"></a>03082 
<a name="l03083"></a>03083     <span class="comment">/* remove VID from filter table */</span>
<a name="l03084"></a>03084     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_HW_VLAN_FILTER) {
<a name="l03085"></a>03085         index = (vid &gt;&gt; 5) &amp; 0x7F;
<a name="l03086"></a>03086         vfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);
<a name="l03087"></a>03087         vfta &amp;= ~(1 &lt;&lt; (vid &amp; 0x1F));
<a name="l03088"></a>03088         hw-&gt;mac.ops.write_vfta(hw, index, vfta);
<a name="l03089"></a>03089     }
<a name="l03090"></a>03090 }
<a name="l03091"></a>03091 
<a name="l03092"></a>03092 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_update_mng_vlan(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03093"></a>03093 {
<a name="l03094"></a>03094     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l03095"></a>03095     u16 vid = adapter-&gt;hw.mng_cookie.vlan_id;
<a name="l03096"></a>03096     u16 old_vid = adapter-&gt;mng_vlan_id;
<a name="l03097"></a>03097 
<a name="l03098"></a>03098     <span class="keywordflow">if</span> (!adapter-&gt;vlgrp)
<a name="l03099"></a>03099         <span class="keywordflow">return</span>;
<a name="l03100"></a>03100 
<a name="l03101"></a>03101     <span class="keywordflow">if</span> (!vlan_group_get_device(adapter-&gt;vlgrp, vid)) {
<a name="l03102"></a>03102         adapter-&gt;mng_vlan_id = E1000_MNG_VLAN_NONE;
<a name="l03103"></a>03103         <span class="keywordflow">if</span> (adapter-&gt;hw.mng_cookie.status &amp;
<a name="l03104"></a>03104             E1000_MNG_DHCP_COOKIE_STATUS_VLAN) {
<a name="l03105"></a>03105             e1000_vlan_rx_add_vid(netdev, vid);
<a name="l03106"></a>03106             adapter-&gt;mng_vlan_id = vid;
<a name="l03107"></a>03107         }
<a name="l03108"></a>03108 
<a name="l03109"></a>03109         <span class="keywordflow">if</span> ((old_vid != (u16)E1000_MNG_VLAN_NONE) &amp;&amp;
<a name="l03110"></a>03110                 (vid != old_vid) &amp;&amp;
<a name="l03111"></a>03111             !vlan_group_get_device(adapter-&gt;vlgrp, old_vid))
<a name="l03112"></a>03112             e1000_vlan_rx_kill_vid(netdev, old_vid);
<a name="l03113"></a>03113     } <span class="keywordflow">else</span> {
<a name="l03114"></a>03114         adapter-&gt;mng_vlan_id = vid;
<a name="l03115"></a>03115     }
<a name="l03116"></a>03116 }
<a name="l03117"></a>03117 
<a name="l03118"></a>03118 
<a name="l03119"></a>03119 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_vlan_rx_register(<span class="keyword">struct</span> net_device *netdev,
<a name="l03120"></a>03120                    <span class="keyword">struct</span> vlan_group *grp)
<a name="l03121"></a>03121 {
<a name="l03122"></a>03122     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03123"></a>03123     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03124"></a>03124     u32 ctrl, rctl;
<a name="l03125"></a>03125 
<a name="l03126"></a>03126     <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l03127"></a>03127         e1000_irq_disable(adapter);
<a name="l03128"></a>03128     adapter-&gt;vlgrp = grp;
<a name="l03129"></a>03129 
<a name="l03130"></a>03130     <span class="keywordflow">if</span> (grp) {
<a name="l03131"></a>03131         <span class="comment">/* enable VLAN tag insert/strip */</span>
<a name="l03132"></a>03132         ctrl = er32(CTRL);
<a name="l03133"></a>03133         ctrl |= E1000_CTRL_VME;
<a name="l03134"></a>03134         ew32(CTRL, ctrl);
<a name="l03135"></a>03135 
<a name="l03136"></a>03136         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_HW_VLAN_FILTER) {
<a name="l03137"></a>03137             <span class="comment">/* enable VLAN receive filtering */</span>
<a name="l03138"></a>03138             rctl = er32(RCTL);
<a name="l03139"></a>03139             rctl &amp;= ~E1000_RCTL_CFIEN;
<a name="l03140"></a>03140             ew32(RCTL, rctl);
<a name="l03141"></a>03141             e1000_update_mng_vlan(adapter);
<a name="l03142"></a>03142         }
<a name="l03143"></a>03143     } <span class="keywordflow">else</span> {
<a name="l03144"></a>03144         <span class="comment">/* disable VLAN tag insert/strip */</span>
<a name="l03145"></a>03145         ctrl = er32(CTRL);
<a name="l03146"></a>03146         ctrl &amp;= ~E1000_CTRL_VME;
<a name="l03147"></a>03147         ew32(CTRL, ctrl);
<a name="l03148"></a>03148 
<a name="l03149"></a>03149         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_HW_VLAN_FILTER) {
<a name="l03150"></a>03150             <span class="keywordflow">if</span> (adapter-&gt;mng_vlan_id !=
<a name="l03151"></a>03151                 (u16)E1000_MNG_VLAN_NONE) {
<a name="l03152"></a>03152                 e1000_vlan_rx_kill_vid(netdev,
<a name="l03153"></a>03153                                adapter-&gt;mng_vlan_id);
<a name="l03154"></a>03154                 adapter-&gt;mng_vlan_id = E1000_MNG_VLAN_NONE;
<a name="l03155"></a>03155             }
<a name="l03156"></a>03156         }
<a name="l03157"></a>03157     }
<a name="l03158"></a>03158 
<a name="l03159"></a>03159     <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l03160"></a>03160         e1000_irq_enable(adapter);
<a name="l03161"></a>03161 }
<a name="l03162"></a>03162 
<a name="l03163"></a>03163 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_restore_vlan(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03164"></a>03164 {
<a name="l03165"></a>03165     u16 vid;
<a name="l03166"></a>03166 
<a name="l03167"></a>03167     e1000_vlan_rx_register(adapter-&gt;netdev, adapter-&gt;vlgrp);
<a name="l03168"></a>03168 
<a name="l03169"></a>03169     <span class="keywordflow">if</span> (!adapter-&gt;vlgrp)
<a name="l03170"></a>03170         <span class="keywordflow">return</span>;
<a name="l03171"></a>03171 
<a name="l03172"></a>03172     <span class="keywordflow">for</span> (vid = 0; vid &lt; VLAN_N_VID; vid++) {
<a name="l03173"></a>03173         <span class="keywordflow">if</span> (!vlan_group_get_device(adapter-&gt;vlgrp, vid))
<a name="l03174"></a>03174             <span class="keywordflow">continue</span>;
<a name="l03175"></a>03175         e1000_vlan_rx_add_vid(adapter-&gt;netdev, vid);
<a name="l03176"></a>03176     }
<a name="l03177"></a>03177 }
<a name="l03178"></a>03178 
<a name="l03179"></a>03179 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_HW_VLAN_TX */</span>
<a name="l03180"></a>03180 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_init_manageability_pt(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03181"></a>03181 {
<a name="l03182"></a>03182     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03183"></a>03183     u32 manc, manc2h, mdef, i, j;
<a name="l03184"></a>03184 
<a name="l03185"></a>03185     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_MNG_PT_ENABLED))
<a name="l03186"></a>03186         <span class="keywordflow">return</span>;
<a name="l03187"></a>03187 
<a name="l03188"></a>03188     manc = er32(MANC);
<a name="l03189"></a>03189 
<a name="l03190"></a>03190     <span class="comment">/*</span>
<a name="l03191"></a>03191 <span class="comment">     * enable receiving management packets to the host. this will probably</span>
<a name="l03192"></a>03192 <span class="comment">     * generate destination unreachable messages from the host OS, but</span>
<a name="l03193"></a>03193 <span class="comment">     * the packets will be handled on SMBUS</span>
<a name="l03194"></a>03194 <span class="comment">     */</span>
<a name="l03195"></a>03195     manc |= E1000_MANC_EN_MNG2HOST;
<a name="l03196"></a>03196     manc2h = er32(MANC2H);
<a name="l03197"></a>03197 
<a name="l03198"></a>03198     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03199"></a>03199     <span class="keywordflow">default</span>:
<a name="l03200"></a>03200         manc2h |= (E1000_MANC2H_PORT_623 | E1000_MANC2H_PORT_664);
<a name="l03201"></a>03201         <span class="keywordflow">break</span>;
<a name="l03202"></a>03202     <span class="keywordflow">case</span> e1000_82574:
<a name="l03203"></a>03203     <span class="keywordflow">case</span> e1000_82583:
<a name="l03204"></a>03204         <span class="comment">/*</span>
<a name="l03205"></a>03205 <span class="comment">         * Check if IPMI pass-through decision filter already exists;</span>
<a name="l03206"></a>03206 <span class="comment">         * if so, enable it.</span>
<a name="l03207"></a>03207 <span class="comment">         */</span>
<a name="l03208"></a>03208         <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; 8; i++) {
<a name="l03209"></a>03209             mdef = er32(MDEF(i));
<a name="l03210"></a>03210 
<a name="l03211"></a>03211             <span class="comment">/* Ignore filters with anything other than IPMI ports */</span>
<a name="l03212"></a>03212             <span class="keywordflow">if</span> (mdef &amp; ~(E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))
<a name="l03213"></a>03213                 <span class="keywordflow">continue</span>;
<a name="l03214"></a>03214 
<a name="l03215"></a>03215             <span class="comment">/* Enable this decision filter in MANC2H */</span>
<a name="l03216"></a>03216             <span class="keywordflow">if</span> (mdef)
<a name="l03217"></a>03217                 manc2h |= (1 &lt;&lt; i);
<a name="l03218"></a>03218 
<a name="l03219"></a>03219             j |= mdef;
<a name="l03220"></a>03220         }
<a name="l03221"></a>03221 
<a name="l03222"></a>03222         <span class="keywordflow">if</span> (j == (E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))
<a name="l03223"></a>03223             <span class="keywordflow">break</span>;
<a name="l03224"></a>03224 
<a name="l03225"></a>03225         <span class="comment">/* Create new decision filter in an empty filter */</span>
<a name="l03226"></a>03226         <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; 8; i++)
<a name="l03227"></a>03227             <span class="keywordflow">if</span> (er32(MDEF(i)) == 0) {
<a name="l03228"></a>03228                 ew32(MDEF(i), (E1000_MDEF_PORT_623 |
<a name="l03229"></a>03229                            E1000_MDEF_PORT_664));
<a name="l03230"></a>03230                 manc2h |= (1 &lt;&lt; 1);
<a name="l03231"></a>03231                 j++;
<a name="l03232"></a>03232                 <span class="keywordflow">break</span>;
<a name="l03233"></a>03233             }
<a name="l03234"></a>03234 
<a name="l03235"></a>03235         <span class="keywordflow">if</span> (!j)
<a name="l03236"></a>03236             e_warn(<span class="stringliteral">&quot;Unable to create IPMI pass-through filter\n&quot;</span>);
<a name="l03237"></a>03237         <span class="keywordflow">break</span>;
<a name="l03238"></a>03238     }
<a name="l03239"></a>03239 
<a name="l03240"></a>03240     ew32(MANC2H, manc2h);
<a name="l03241"></a>03241     ew32(MANC, manc);
<a name="l03242"></a>03242 }
<a name="l03243"></a>03243 
<a name="l03250"></a>03250 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_configure_tx(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03251"></a>03251 {
<a name="l03252"></a>03252     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03253"></a>03253     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l03254"></a>03254     u64 tdba;
<a name="l03255"></a>03255     u32 tdlen, tctl, tipg, tarc;
<a name="l03256"></a>03256     u32 ipgr1, ipgr2;
<a name="l03257"></a>03257 
<a name="l03258"></a>03258     <span class="comment">/* Setup the HW Tx Head and Tail descriptor pointers */</span>
<a name="l03259"></a>03259     tdba = tx_ring-&gt;dma;
<a name="l03260"></a>03260     tdlen = tx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__tx__desc.html">e1000_tx_desc</a>);
<a name="l03261"></a>03261     ew32(TDBAL(0), (tdba &amp; DMA_BIT_MASK(32)));
<a name="l03262"></a>03262     ew32(TDBAH(0), (tdba &gt;&gt; 32));
<a name="l03263"></a>03263     ew32(TDLEN(0), tdlen);
<a name="l03264"></a>03264     ew32(TDH(0), 0);
<a name="l03265"></a>03265     ew32(TDT(0), 0);
<a name="l03266"></a>03266     tx_ring-&gt;head = E1000_TDH(0);
<a name="l03267"></a>03267     tx_ring-&gt;tail = E1000_TDT(0);
<a name="l03268"></a>03268 
<a name="l03269"></a>03269     <span class="comment">/* Set the default values for the Tx Inter Packet Gap timer */</span>
<a name="l03270"></a>03270     tipg = DEFAULT_82543_TIPG_IPGT_COPPER;          <span class="comment">/*  8  */</span>
<a name="l03271"></a>03271     ipgr1 = DEFAULT_82543_TIPG_IPGR1;               <span class="comment">/*  8  */</span>
<a name="l03272"></a>03272     ipgr2 = DEFAULT_82543_TIPG_IPGR2;               <span class="comment">/*  6  */</span>
<a name="l03273"></a>03273 
<a name="l03274"></a>03274     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_TIPG_MEDIUM_FOR_80003ESLAN)
<a name="l03275"></a>03275         ipgr2 = DEFAULT_80003ES2LAN_TIPG_IPGR2; <span class="comment">/*  7  */</span>
<a name="l03276"></a>03276 
<a name="l03277"></a>03277     tipg |= ipgr1 &lt;&lt; E1000_TIPG_IPGR1_SHIFT;
<a name="l03278"></a>03278     tipg |= ipgr2 &lt;&lt; E1000_TIPG_IPGR2_SHIFT;
<a name="l03279"></a>03279     ew32(TIPG, tipg);
<a name="l03280"></a>03280 
<a name="l03281"></a>03281     <span class="comment">/* Set the Tx Interrupt Delay register */</span>
<a name="l03282"></a>03282     ew32(TIDV, adapter-&gt;tx_int_delay);
<a name="l03283"></a>03283     <span class="comment">/* Tx irq moderation */</span>
<a name="l03284"></a>03284     ew32(TADV, adapter-&gt;tx_abs_int_delay);
<a name="l03285"></a>03285 
<a name="l03286"></a>03286     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_DMA_BURST) {
<a name="l03287"></a>03287         u32 txdctl = er32(TXDCTL(0));
<a name="l03288"></a>03288         txdctl &amp;= ~(E1000_TXDCTL_PTHRESH | E1000_TXDCTL_HTHRESH |
<a name="l03289"></a>03289                 E1000_TXDCTL_WTHRESH);
<a name="l03290"></a>03290         <span class="comment">/*</span>
<a name="l03291"></a>03291 <span class="comment">         * set up some performance related parameters to encourage the</span>
<a name="l03292"></a>03292 <span class="comment">         * hardware to use the bus more efficiently in bursts, depends</span>
<a name="l03293"></a>03293 <span class="comment">         * on the tx_int_delay to be enabled,</span>
<a name="l03294"></a>03294 <span class="comment">         * wthresh = 5 ==&gt; burst write a cacheline (64 bytes) at a time</span>
<a name="l03295"></a>03295 <span class="comment">         * hthresh = 1 ==&gt; prefetch when one or more available</span>
<a name="l03296"></a>03296 <span class="comment">         * pthresh = 0x1f ==&gt; prefetch if internal cache 31 or less</span>
<a name="l03297"></a>03297 <span class="comment">         * BEWARE: this seems to work but should be considered first if</span>
<a name="l03298"></a>03298 <span class="comment">         * there are Tx hangs or other Tx related bugs</span>
<a name="l03299"></a>03299 <span class="comment">         */</span>
<a name="l03300"></a>03300         txdctl |= E1000_TXDCTL_DMA_BURST_ENABLE;
<a name="l03301"></a>03301         ew32(TXDCTL(0), txdctl);
<a name="l03302"></a>03302         <span class="comment">/* erratum work around: set txdctl the same for both queues */</span>
<a name="l03303"></a>03303         ew32(TXDCTL(1), txdctl);
<a name="l03304"></a>03304     }
<a name="l03305"></a>03305 
<a name="l03306"></a>03306     <span class="comment">/* Program the Transmit Control Register */</span>
<a name="l03307"></a>03307     tctl = er32(TCTL);
<a name="l03308"></a>03308     tctl &amp;= ~E1000_TCTL_CT;
<a name="l03309"></a>03309     tctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |
<a name="l03310"></a>03310         (E1000_COLLISION_THRESHOLD &lt;&lt; E1000_CT_SHIFT);
<a name="l03311"></a>03311 
<a name="l03312"></a>03312     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_TARC_SPEED_MODE_BIT) {
<a name="l03313"></a>03313         tarc = er32(TARC(0));
<a name="l03314"></a>03314         <span class="comment">/*</span>
<a name="l03315"></a>03315 <span class="comment">         * set the speed mode bit, we&#39;ll clear it if we&#39;re not at</span>
<a name="l03316"></a>03316 <span class="comment">         * gigabit link later</span>
<a name="l03317"></a>03317 <span class="comment">         */</span>
<a name="l03318"></a>03318 <span class="preprocessor">#define SPEED_MODE_BIT (1 &lt;&lt; 21)</span>
<a name="l03319"></a>03319 <span class="preprocessor"></span>        tarc |= SPEED_MODE_BIT;
<a name="l03320"></a>03320         ew32(TARC(0), tarc);
<a name="l03321"></a>03321     }
<a name="l03322"></a>03322 
<a name="l03323"></a>03323     <span class="comment">/* errata: program both queues to unweighted RR */</span>
<a name="l03324"></a>03324     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_TARC_SET_BIT_ZERO) {
<a name="l03325"></a>03325         tarc = er32(TARC(0));
<a name="l03326"></a>03326         tarc |= 1;
<a name="l03327"></a>03327         ew32(TARC(0), tarc);
<a name="l03328"></a>03328         tarc = er32(TARC(1));
<a name="l03329"></a>03329         tarc |= 1;
<a name="l03330"></a>03330         ew32(TARC(1), tarc);
<a name="l03331"></a>03331     }
<a name="l03332"></a>03332 
<a name="l03333"></a>03333     <span class="comment">/* Setup Transmit Descriptor Settings for eop descriptor */</span>
<a name="l03334"></a>03334     adapter-&gt;txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;
<a name="l03335"></a>03335 
<a name="l03336"></a>03336     <span class="comment">/* only set IDE if we are delaying interrupts using the timers */</span>
<a name="l03337"></a>03337     <span class="keywordflow">if</span> (adapter-&gt;tx_int_delay)
<a name="l03338"></a>03338         adapter-&gt;txd_cmd |= E1000_TXD_CMD_IDE;
<a name="l03339"></a>03339 
<a name="l03340"></a>03340     <span class="comment">/* enable Report Status bit */</span>
<a name="l03341"></a>03341     adapter-&gt;txd_cmd |= E1000_TXD_CMD_RS;
<a name="l03342"></a>03342 
<a name="l03343"></a>03343     ew32(TCTL, tctl);
<a name="l03344"></a>03344 
<a name="l03345"></a>03345     e1000e_config_collision_dist(hw);
<a name="l03346"></a>03346 }
<a name="l03347"></a>03347 
<a name="l03352"></a>03352 <span class="preprocessor">#define PAGE_USE_COUNT(S) (((S) &gt;&gt; PAGE_SHIFT) + \</span>
<a name="l03353"></a>03353 <span class="preprocessor">               (((S) &amp; (PAGE_SIZE - 1)) ? 1 : 0))</span>
<a name="l03354"></a>03354 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> e1000_setup_rctl(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03355"></a>03355 {
<a name="l03356"></a>03356     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03357"></a>03357     u32 rctl, rfctl;
<a name="l03358"></a>03358     u32 pages = 0;
<a name="l03359"></a>03359 
<a name="l03360"></a>03360     <span class="comment">/* Workaround Si errata on 82579 - configure jumbo frame flow */</span>
<a name="l03361"></a>03361     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_pch2lan) {
<a name="l03362"></a>03362         s32 ret_val;
<a name="l03363"></a>03363 
<a name="l03364"></a>03364         <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;mtu &gt; ETH_DATA_LEN)
<a name="l03365"></a>03365             ret_val = e1000_lv_jumbo_workaround_ich8lan(hw, <span class="keyword">true</span>);
<a name="l03366"></a>03366         <span class="keywordflow">else</span>
<a name="l03367"></a>03367             ret_val = e1000_lv_jumbo_workaround_ich8lan(hw, <span class="keyword">false</span>);
<a name="l03368"></a>03368 
<a name="l03369"></a>03369         <span class="keywordflow">if</span> (ret_val)
<a name="l03370"></a>03370             e_dbg(<span class="stringliteral">&quot;failed to enable jumbo frame workaround mode\n&quot;</span>);
<a name="l03371"></a>03371     }
<a name="l03372"></a>03372 
<a name="l03373"></a>03373     <span class="comment">/* Program MC offset vector base */</span>
<a name="l03374"></a>03374     rctl = er32(RCTL);
<a name="l03375"></a>03375     rctl &amp;= ~(3 &lt;&lt; E1000_RCTL_MO_SHIFT);
<a name="l03376"></a>03376     rctl |= E1000_RCTL_EN | E1000_RCTL_BAM |
<a name="l03377"></a>03377         E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |
<a name="l03378"></a>03378         (adapter-&gt;hw.mac.mc_filter_type &lt;&lt; E1000_RCTL_MO_SHIFT);
<a name="l03379"></a>03379 
<a name="l03380"></a>03380     <span class="comment">/* Do not Store bad packets */</span>
<a name="l03381"></a>03381     rctl &amp;= ~E1000_RCTL_SBP;
<a name="l03382"></a>03382 
<a name="l03383"></a>03383     <span class="comment">/* Enable Long Packet receive */</span>
<a name="l03384"></a>03384     <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;mtu &lt;= ETH_DATA_LEN)
<a name="l03385"></a>03385         rctl &amp;= ~E1000_RCTL_LPE;
<a name="l03386"></a>03386     <span class="keywordflow">else</span>
<a name="l03387"></a>03387         rctl |= E1000_RCTL_LPE;
<a name="l03388"></a>03388 
<a name="l03389"></a>03389     <span class="comment">/* Some systems expect that the CRC is included in SMBUS traffic. The</span>
<a name="l03390"></a>03390 <span class="comment">     * hardware strips the CRC before sending to both SMBUS (BMC) and to</span>
<a name="l03391"></a>03391 <span class="comment">     * host memory when this is enabled</span>
<a name="l03392"></a>03392 <span class="comment">     */</span>
<a name="l03393"></a>03393     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_CRC_STRIPPING)
<a name="l03394"></a>03394         rctl |= E1000_RCTL_SECRC;
<a name="l03395"></a>03395 
<a name="l03396"></a>03396     <span class="comment">/* Workaround Si errata on 82577 PHY - configure IPG for jumbos */</span>
<a name="l03397"></a>03397     <span class="keywordflow">if</span> ((hw-&gt;phy.type == e1000_phy_82577) &amp;&amp; (rctl &amp; E1000_RCTL_LPE)) {
<a name="l03398"></a>03398         u16 phy_data;
<a name="l03399"></a>03399 
<a name="l03400"></a>03400         e1e_rphy(hw, 22, &amp;phy_data);
<a name="l03401"></a>03401         phy_data &amp;= 0x0fff;
<a name="l03402"></a>03402         phy_data |= (1 &lt;&lt; 14);
<a name="l03403"></a>03403         e1e_wphy(hw, 0x10, 0x2823);
<a name="l03404"></a>03404         e1e_wphy(hw, 0x11, 0x0003);
<a name="l03405"></a>03405         e1e_wphy(hw, 22, phy_data);
<a name="l03406"></a>03406     }
<a name="l03407"></a>03407 
<a name="l03408"></a>03408     <span class="comment">/* Setup buffer sizes */</span>
<a name="l03409"></a>03409     rctl &amp;= ~E1000_RCTL_SZ_4096;
<a name="l03410"></a>03410     rctl |= E1000_RCTL_BSEX;
<a name="l03411"></a>03411     <span class="keywordflow">switch</span> (adapter-&gt;rx_buffer_len) {
<a name="l03412"></a>03412     <span class="keywordflow">case</span> 2048:
<a name="l03413"></a>03413     <span class="keywordflow">default</span>:
<a name="l03414"></a>03414         rctl |= E1000_RCTL_SZ_2048;
<a name="l03415"></a>03415         rctl &amp;= ~E1000_RCTL_BSEX;
<a name="l03416"></a>03416         <span class="keywordflow">break</span>;
<a name="l03417"></a>03417     <span class="keywordflow">case</span> 4096:
<a name="l03418"></a>03418         rctl |= E1000_RCTL_SZ_4096;
<a name="l03419"></a>03419         <span class="keywordflow">break</span>;
<a name="l03420"></a>03420     <span class="keywordflow">case</span> 8192:
<a name="l03421"></a>03421         rctl |= E1000_RCTL_SZ_8192;
<a name="l03422"></a>03422         <span class="keywordflow">break</span>;
<a name="l03423"></a>03423     <span class="keywordflow">case</span> 16384:
<a name="l03424"></a>03424         rctl |= E1000_RCTL_SZ_16384;
<a name="l03425"></a>03425         <span class="keywordflow">break</span>;
<a name="l03426"></a>03426     }
<a name="l03427"></a>03427 
<a name="l03428"></a>03428     <span class="comment">/*</span>
<a name="l03429"></a>03429 <span class="comment">     * 82571 and greater support packet-split where the protocol</span>
<a name="l03430"></a>03430 <span class="comment">     * header is placed in skb-&gt;data and the packet data is</span>
<a name="l03431"></a>03431 <span class="comment">     * placed in pages hanging off of skb_shinfo(skb)-&gt;nr_frags.</span>
<a name="l03432"></a>03432 <span class="comment">     * In the case of a non-split, skb-&gt;data is linearly filled,</span>
<a name="l03433"></a>03433 <span class="comment">     * followed by the page buffers.  Therefore, skb-&gt;data is</span>
<a name="l03434"></a>03434 <span class="comment">     * sized to hold the largest protocol header.</span>
<a name="l03435"></a>03435 <span class="comment">     *</span>
<a name="l03436"></a>03436 <span class="comment">     * allocations using alloc_page take too long for regular MTU</span>
<a name="l03437"></a>03437 <span class="comment">     * so only enable packet split for jumbo frames</span>
<a name="l03438"></a>03438 <span class="comment">     *</span>
<a name="l03439"></a>03439 <span class="comment">     * Using pages when the page size is greater than 16k wastes</span>
<a name="l03440"></a>03440 <span class="comment">     * a lot of memory, since we allocate 3 pages at all times</span>
<a name="l03441"></a>03441 <span class="comment">     * per packet.</span>
<a name="l03442"></a>03442 <span class="comment">     */</span>
<a name="l03443"></a>03443     pages = PAGE_USE_COUNT(adapter-&gt;netdev-&gt;mtu);
<a name="l03444"></a>03444     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_HAS_ERT) &amp;&amp; (pages &lt;= 3) &amp;&amp;
<a name="l03445"></a>03445         (PAGE_SIZE &lt;= 16384) &amp;&amp; (rctl &amp; E1000_RCTL_LPE))
<a name="l03446"></a>03446         adapter-&gt;rx_ps_pages = pages;
<a name="l03447"></a>03447     <span class="keywordflow">else</span>
<a name="l03448"></a>03448         adapter-&gt;rx_ps_pages = 0;
<a name="l03449"></a>03449 
<a name="l03450"></a>03450     <span class="keywordflow">if</span> (adapter-&gt;rx_ps_pages) {
<a name="l03451"></a>03451         u32 psrctl = 0;
<a name="l03452"></a>03452 
<a name="l03453"></a>03453         <span class="comment">/* Configure extra packet-split registers */</span>
<a name="l03454"></a>03454         rfctl = er32(RFCTL);
<a name="l03455"></a>03455         rfctl |= E1000_RFCTL_EXTEN;
<a name="l03456"></a>03456         <span class="comment">/*</span>
<a name="l03457"></a>03457 <span class="comment">         * disable packet split support for IPv6 extension headers,</span>
<a name="l03458"></a>03458 <span class="comment">         * because some malformed IPv6 headers can hang the Rx</span>
<a name="l03459"></a>03459 <span class="comment">         */</span>
<a name="l03460"></a>03460         rfctl |= (E1000_RFCTL_IPV6_EX_DIS |
<a name="l03461"></a>03461               E1000_RFCTL_NEW_IPV6_EXT_DIS);
<a name="l03462"></a>03462 
<a name="l03463"></a>03463         ew32(RFCTL, rfctl);
<a name="l03464"></a>03464 
<a name="l03465"></a>03465         <span class="comment">/* Enable Packet split descriptors */</span>
<a name="l03466"></a>03466         rctl |= E1000_RCTL_DTYP_PS;
<a name="l03467"></a>03467 
<a name="l03468"></a>03468         psrctl |= adapter-&gt;rx_ps_bsize0 &gt;&gt;
<a name="l03469"></a>03469             E1000_PSRCTL_BSIZE0_SHIFT;
<a name="l03470"></a>03470 
<a name="l03471"></a>03471         <span class="keywordflow">switch</span> (adapter-&gt;rx_ps_pages) {
<a name="l03472"></a>03472         <span class="keywordflow">case</span> 3:
<a name="l03473"></a>03473             psrctl |= PAGE_SIZE &lt;&lt;
<a name="l03474"></a>03474                 E1000_PSRCTL_BSIZE3_SHIFT;
<a name="l03475"></a>03475         <span class="keywordflow">case</span> 2:
<a name="l03476"></a>03476             psrctl |= PAGE_SIZE &lt;&lt;
<a name="l03477"></a>03477                 E1000_PSRCTL_BSIZE2_SHIFT;
<a name="l03478"></a>03478         <span class="keywordflow">case</span> 1:
<a name="l03479"></a>03479             psrctl |= PAGE_SIZE &gt;&gt;
<a name="l03480"></a>03480                 E1000_PSRCTL_BSIZE1_SHIFT;
<a name="l03481"></a>03481             <span class="keywordflow">break</span>;
<a name="l03482"></a>03482         }
<a name="l03483"></a>03483 
<a name="l03484"></a>03484         ew32(PSRCTL, psrctl);
<a name="l03485"></a>03485     }
<a name="l03486"></a>03486 
<a name="l03487"></a>03487     ew32(RCTL, rctl);
<a name="l03488"></a>03488     <span class="comment">/* just started the receive unit, no need to restart */</span>
<a name="l03489"></a>03489     adapter-&gt;flags &amp;= ~FLAG_RX_RESTART_NOW;
<a name="l03490"></a>03490 }
<a name="l03491"></a>03491 
<a name="l03498"></a>03498 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_configure_rx(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03499"></a>03499 {
<a name="l03500"></a>03500     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03501"></a>03501     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *rx_ring = adapter-&gt;rx_ring;
<a name="l03502"></a>03502     u64 rdba;
<a name="l03503"></a>03503     u32 rdlen, rctl, rxcsum, ctrl_ext;
<a name="l03504"></a>03504 
<a name="l03505"></a>03505     <span class="keywordflow">if</span> (adapter-&gt;rx_ps_pages) {
<a name="l03506"></a>03506         <span class="comment">/* this is a 32 byte descriptor */</span>
<a name="l03507"></a>03507         rdlen = rx_ring-&gt;count *
<a name="l03508"></a>03508             <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unione1000__rx__desc__packet__split.html">e1000_rx_desc_packet_split</a>);
<a name="l03509"></a>03509         adapter-&gt;clean_rx = e1000_clean_rx_irq_ps;
<a name="l03510"></a>03510         adapter-&gt;alloc_rx_buf = e1000_alloc_rx_buffers_ps;
<a name="l03511"></a>03511 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l03512"></a>03512 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;mtu &gt; ETH_FRAME_LEN + ETH_FCS_LEN) {
<a name="l03513"></a>03513         rdlen = rx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__rx__desc.html">e1000_rx_desc</a>);
<a name="l03514"></a>03514         adapter-&gt;clean_rx = e1000_clean_jumbo_rx_irq;
<a name="l03515"></a>03515         adapter-&gt;alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;
<a name="l03516"></a>03516 <span class="preprocessor">#endif</span>
<a name="l03517"></a>03517 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l03518"></a>03518         rdlen = rx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__rx__desc.html">e1000_rx_desc</a>);
<a name="l03519"></a>03519         adapter-&gt;clean_rx = e1000_clean_rx_irq;
<a name="l03520"></a>03520         adapter-&gt;alloc_rx_buf = e1000_alloc_rx_buffers;
<a name="l03521"></a>03521     }
<a name="l03522"></a>03522 
<a name="l03523"></a>03523     <span class="comment">/* disable receives while setting up the descriptors */</span>
<a name="l03524"></a>03524     rctl = er32(RCTL);
<a name="l03525"></a>03525     ew32(RCTL, rctl &amp; ~E1000_RCTL_EN);
<a name="l03526"></a>03526     e1e_flush();
<a name="l03527"></a>03527     msleep(10);
<a name="l03528"></a>03528 
<a name="l03529"></a>03529     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_DMA_BURST) {
<a name="l03530"></a>03530         <span class="comment">/*</span>
<a name="l03531"></a>03531 <span class="comment">         * set the writeback threshold (only takes effect if the RDTR</span>
<a name="l03532"></a>03532 <span class="comment">         * is set). set GRAN=1 and write back up to 0x4 worth, and</span>
<a name="l03533"></a>03533 <span class="comment">         * enable prefetching of 0x20 Rx descriptors</span>
<a name="l03534"></a>03534 <span class="comment">         * granularity = 01</span>
<a name="l03535"></a>03535 <span class="comment">         * wthresh = 04,</span>
<a name="l03536"></a>03536 <span class="comment">         * hthresh = 04,</span>
<a name="l03537"></a>03537 <span class="comment">         * pthresh = 0x20</span>
<a name="l03538"></a>03538 <span class="comment">         */</span>
<a name="l03539"></a>03539         ew32(RXDCTL(0), E1000_RXDCTL_DMA_BURST_ENABLE);
<a name="l03540"></a>03540         ew32(RXDCTL(1), E1000_RXDCTL_DMA_BURST_ENABLE);
<a name="l03541"></a>03541 
<a name="l03542"></a>03542         <span class="comment">/*</span>
<a name="l03543"></a>03543 <span class="comment">         * override the delay timers for enabling bursting, only if</span>
<a name="l03544"></a>03544 <span class="comment">         * the value was not set by the user via module options</span>
<a name="l03545"></a>03545 <span class="comment">         */</span>
<a name="l03546"></a>03546         <span class="keywordflow">if</span> (adapter-&gt;rx_int_delay == DEFAULT_RDTR)
<a name="l03547"></a>03547             adapter-&gt;rx_int_delay = BURST_RDTR;
<a name="l03548"></a>03548         <span class="keywordflow">if</span> (adapter-&gt;rx_abs_int_delay == DEFAULT_RADV)
<a name="l03549"></a>03549             adapter-&gt;rx_abs_int_delay = BURST_RADV;
<a name="l03550"></a>03550     }
<a name="l03551"></a>03551 
<a name="l03552"></a>03552     <span class="comment">/* set the Receive Delay Timer Register */</span>
<a name="l03553"></a>03553     ew32(RDTR, adapter-&gt;rx_int_delay);
<a name="l03554"></a>03554 
<a name="l03555"></a>03555     <span class="comment">/* irq moderation */</span>
<a name="l03556"></a>03556     ew32(RADV, adapter-&gt;rx_abs_int_delay);
<a name="l03557"></a>03557     <span class="keywordflow">if</span> ((adapter-&gt;itr_setting != 0) &amp;&amp; (adapter-&gt;itr != 0))
<a name="l03558"></a>03558         ew32(ITR, 1000000000 / (adapter-&gt;itr * 256));
<a name="l03559"></a>03559 
<a name="l03560"></a>03560     ctrl_ext = er32(CTRL_EXT);
<a name="l03561"></a>03561 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l03562"></a>03562 <span class="preprocessor"></span>    <span class="comment">/* Auto-Mask interrupts upon ICR access */</span>
<a name="l03563"></a>03563     ctrl_ext |= E1000_CTRL_EXT_IAME;
<a name="l03564"></a>03564     ew32(IAM, 0xffffffff);
<a name="l03565"></a>03565 <span class="preprocessor">#endif</span>
<a name="l03566"></a>03566 <span class="preprocessor"></span>    ew32(CTRL_EXT, ctrl_ext);
<a name="l03567"></a>03567     e1e_flush();
<a name="l03568"></a>03568 
<a name="l03569"></a>03569     <span class="comment">/*</span>
<a name="l03570"></a>03570 <span class="comment">     * Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<a name="l03571"></a>03571 <span class="comment">     * the Base and Length of the Rx Descriptor Ring</span>
<a name="l03572"></a>03572 <span class="comment">     */</span>
<a name="l03573"></a>03573     rdba = rx_ring-&gt;dma;
<a name="l03574"></a>03574     ew32(RDBAL(0), (rdba &amp; DMA_BIT_MASK(32)));
<a name="l03575"></a>03575     ew32(RDBAH(0), (rdba &gt;&gt; 32));
<a name="l03576"></a>03576     ew32(RDLEN(0), rdlen);
<a name="l03577"></a>03577     ew32(RDH(0), 0);
<a name="l03578"></a>03578     ew32(RDT(0), 0);
<a name="l03579"></a>03579     rx_ring-&gt;head = E1000_RDH(0);
<a name="l03580"></a>03580     rx_ring-&gt;tail = E1000_RDT(0);
<a name="l03581"></a>03581 
<a name="l03582"></a>03582     <span class="comment">/* Enable Receive Checksum Offload for TCP and UDP */</span>
<a name="l03583"></a>03583     rxcsum = er32(RXCSUM);
<a name="l03584"></a>03584     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_RX_CSUM_ENABLED) {
<a name="l03585"></a>03585         rxcsum |= E1000_RXCSUM_TUOFL;
<a name="l03586"></a>03586 
<a name="l03587"></a>03587         <span class="comment">/*</span>
<a name="l03588"></a>03588 <span class="comment">         * IPv4 payload checksum for UDP fragments must be</span>
<a name="l03589"></a>03589 <span class="comment">         * used in conjunction with packet-split.</span>
<a name="l03590"></a>03590 <span class="comment">         */</span>
<a name="l03591"></a>03591         <span class="keywordflow">if</span> (adapter-&gt;rx_ps_pages)
<a name="l03592"></a>03592             rxcsum |= E1000_RXCSUM_IPPCSE;
<a name="l03593"></a>03593     } <span class="keywordflow">else</span> {
<a name="l03594"></a>03594         rxcsum &amp;= ~E1000_RXCSUM_TUOFL;
<a name="l03595"></a>03595         <span class="comment">/* no need to clear IPPCSE as it defaults to 0 */</span>
<a name="l03596"></a>03596     }
<a name="l03597"></a>03597     ew32(RXCSUM, rxcsum);
<a name="l03598"></a>03598 
<a name="l03599"></a>03599     <span class="comment">/*</span>
<a name="l03600"></a>03600 <span class="comment">     * Enable early receives on supported devices, only takes effect when</span>
<a name="l03601"></a>03601 <span class="comment">     * packet size is equal or larger than the specified value (in 8 byte</span>
<a name="l03602"></a>03602 <span class="comment">     * units), e.g. using jumbo frames when setting to E1000_ERT_2048</span>
<a name="l03603"></a>03603 <span class="comment">     */</span>
<a name="l03604"></a>03604     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_HAS_ERT) ||
<a name="l03605"></a>03605         (adapter-&gt;hw.mac.type == e1000_pch2lan)) {
<a name="l03606"></a>03606         <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;mtu &gt; ETH_DATA_LEN) {
<a name="l03607"></a>03607             u32 rxdctl = er32(RXDCTL(0));
<a name="l03608"></a>03608             ew32(RXDCTL(0), rxdctl | 0x3);
<a name="l03609"></a>03609             <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_ERT)
<a name="l03610"></a>03610                 ew32(ERT, E1000_ERT_2048 | (1 &lt;&lt; 13));
<a name="l03611"></a>03611             <span class="comment">/*</span>
<a name="l03612"></a>03612 <span class="comment">             * With jumbo frames and early-receive enabled,</span>
<a name="l03613"></a>03613 <span class="comment">             * excessive C-state transition latencies result in</span>
<a name="l03614"></a>03614 <span class="comment">             * dropped transactions.</span>
<a name="l03615"></a>03615 <span class="comment">             */</span>
<a name="l03616"></a>03616 <span class="preprocessor">#ifdef HAVE_PM_QOS_REQUEST_ACTIVE</span>
<a name="l03617"></a>03617 <span class="preprocessor"></span>            pm_qos_update_request(&amp;adapter-&gt;netdev-&gt;pm_qos_req, 55);
<a name="l03618"></a>03618 <span class="preprocessor">#elif defined(HAVE_PM_QOS_REQUEST_LIST)</span>
<a name="l03619"></a>03619 <span class="preprocessor"></span>            pm_qos_update_request(adapter-&gt;netdev-&gt;pm_qos_req, 55);
<a name="l03620"></a>03620 <span class="preprocessor">#else</span>
<a name="l03621"></a>03621 <span class="preprocessor"></span>            pm_qos_update_requirement(PM_QOS_CPU_DMA_LATENCY,
<a name="l03622"></a>03622                           adapter-&gt;netdev-&gt;name, 55);
<a name="l03623"></a>03623 <span class="preprocessor">#endif</span>
<a name="l03624"></a>03624 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l03625"></a>03625 <span class="preprocessor">#ifdef HAVE_PM_QOS_REQUEST_ACTIVE</span>
<a name="l03626"></a>03626 <span class="preprocessor"></span>            pm_qos_update_request(&amp;adapter-&gt;netdev-&gt;pm_qos_req,
<a name="l03627"></a>03627                           PM_QOS_DEFAULT_VALUE);
<a name="l03628"></a>03628 <span class="preprocessor">#elif defined(HAVE_PM_QOS_REQUEST_LIST)</span>
<a name="l03629"></a>03629 <span class="preprocessor"></span>            pm_qos_update_request(adapter-&gt;netdev-&gt;pm_qos_req,
<a name="l03630"></a>03630                           PM_QOS_DEFAULT_VALUE);
<a name="l03631"></a>03631 <span class="preprocessor">#else</span>
<a name="l03632"></a>03632 <span class="preprocessor"></span>            pm_qos_update_requirement(PM_QOS_CPU_DMA_LATENCY,
<a name="l03633"></a>03633                           adapter-&gt;netdev-&gt;name,
<a name="l03634"></a>03634                           PM_QOS_DEFAULT_VALUE);
<a name="l03635"></a>03635 <span class="preprocessor">#endif</span>
<a name="l03636"></a>03636 <span class="preprocessor"></span>        }
<a name="l03637"></a>03637     }
<a name="l03638"></a>03638 
<a name="l03639"></a>03639     <span class="comment">/* Enable Receives */</span>
<a name="l03640"></a>03640     ew32(RCTL, rctl);
<a name="l03641"></a>03641 }
<a name="l03642"></a>03642 
<a name="l03652"></a>03652 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_update_mc_addr_list(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u8 *mc_addr_list,
<a name="l03653"></a>03653                       u32 mc_addr_count)
<a name="l03654"></a>03654 {
<a name="l03655"></a>03655     hw-&gt;mac.ops.update_mc_addr_list(hw, mc_addr_list, mc_addr_count);
<a name="l03656"></a>03656 }
<a name="l03657"></a>03657 
<a name="l03667"></a>03667 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_set_multi(<span class="keyword">struct</span> net_device *netdev)
<a name="l03668"></a>03668 {
<a name="l03669"></a>03669     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03670"></a>03670     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03671"></a>03671 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03672"></a>03672 <span class="preprocessor"></span>    <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03673"></a>03673 <span class="preprocessor">#else</span>
<a name="l03674"></a>03674 <span class="preprocessor"></span>    <span class="keyword">struct </span>dev_mc_list *ha;
<a name="l03675"></a>03675 <span class="preprocessor">#endif</span>
<a name="l03676"></a>03676 <span class="preprocessor"></span>    u8  *mta_list;
<a name="l03677"></a>03677     u32 rctl;
<a name="l03678"></a>03678 
<a name="l03679"></a>03679     <span class="comment">/* Check for Promiscuous and All Multicast modes */</span>
<a name="l03680"></a>03680 
<a name="l03681"></a>03681     rctl = er32(RCTL);
<a name="l03682"></a>03682 
<a name="l03683"></a>03683     <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_PROMISC) {
<a name="l03684"></a>03684         rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);
<a name="l03685"></a>03685         rctl &amp;= ~E1000_RCTL_VFE;
<a name="l03686"></a>03686     } <span class="keywordflow">else</span> {
<a name="l03687"></a>03687         <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_ALLMULTI) {
<a name="l03688"></a>03688             rctl |= E1000_RCTL_MPE;
<a name="l03689"></a>03689             rctl &amp;= ~E1000_RCTL_UPE;
<a name="l03690"></a>03690         } <span class="keywordflow">else</span> {
<a name="l03691"></a>03691             rctl &amp;= ~(E1000_RCTL_UPE | E1000_RCTL_MPE);
<a name="l03692"></a>03692         }
<a name="l03693"></a>03693         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_HW_VLAN_FILTER)
<a name="l03694"></a>03694             rctl |= E1000_RCTL_VFE;
<a name="l03695"></a>03695     }
<a name="l03696"></a>03696 
<a name="l03697"></a>03697     ew32(RCTL, rctl);
<a name="l03698"></a>03698 
<a name="l03699"></a>03699     <span class="keywordflow">if</span> (!netdev_mc_empty(netdev)) {
<a name="l03700"></a>03700         <span class="keywordtype">int</span> i = 0;
<a name="l03701"></a>03701 
<a name="l03702"></a>03702         mta_list = kmalloc(netdev_mc_count(netdev) * 6, GFP_ATOMIC);
<a name="l03703"></a>03703         <span class="keywordflow">if</span> (!mta_list)
<a name="l03704"></a>03704             <span class="keywordflow">return</span>;
<a name="l03705"></a>03705 
<a name="l03706"></a>03706         <span class="comment">/* prepare a packed array of only addresses. */</span>
<a name="l03707"></a>03707         netdev_for_each_mc_addr(ha, netdev)
<a name="l03708"></a>03708 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03709"></a>03709 <span class="preprocessor"></span>            memcpy(mta_list + (i++ * ETH_ALEN), ha-&gt;addr, ETH_ALEN);
<a name="l03710"></a>03710 <span class="preprocessor">#else</span>
<a name="l03711"></a>03711 <span class="preprocessor"></span>            memcpy(mta_list + (i++ * ETH_ALEN), ha-&gt;dmi_addr,
<a name="l03712"></a>03712                    ETH_ALEN);
<a name="l03713"></a>03713 <span class="preprocessor">#endif</span>
<a name="l03714"></a>03714 <span class="preprocessor"></span>
<a name="l03715"></a>03715         e1000_update_mc_addr_list(hw, mta_list, i);
<a name="l03716"></a>03716         kfree(mta_list);
<a name="l03717"></a>03717     } <span class="keywordflow">else</span> {
<a name="l03718"></a>03718         <span class="comment">/*</span>
<a name="l03719"></a>03719 <span class="comment">         * if we&#39;re called from probe, we might not have</span>
<a name="l03720"></a>03720 <span class="comment">         * anything to do here, so clear out the list</span>
<a name="l03721"></a>03721 <span class="comment">         */</span>
<a name="l03722"></a>03722         e1000_update_mc_addr_list(hw, NULL, 0);
<a name="l03723"></a>03723     }
<a name="l03724"></a>03724 }
<a name="l03725"></a>03725 
<a name="l03730"></a>03730 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_configure(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03731"></a>03731 {
<a name="l03732"></a>03732     e1000_set_multi(adapter-&gt;netdev);
<a name="l03733"></a>03733 
<a name="l03734"></a>03734 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l03735"></a>03735 <span class="preprocessor"></span>    e1000_restore_vlan(adapter);
<a name="l03736"></a>03736 <span class="preprocessor">#endif</span>
<a name="l03737"></a>03737 <span class="preprocessor"></span>    e1000_init_manageability_pt(adapter);
<a name="l03738"></a>03738 
<a name="l03739"></a>03739     e1000_configure_tx(adapter);
<a name="l03740"></a>03740     e1000_setup_rctl(adapter);
<a name="l03741"></a>03741     e1000_configure_rx(adapter);
<a name="l03742"></a>03742     adapter-&gt;alloc_rx_buf(adapter, e1000_desc_unused(adapter-&gt;rx_ring));
<a name="l03743"></a>03743 }
<a name="l03744"></a>03744 
<a name="l03753"></a>03753 <span class="keywordtype">void</span> e1000e_power_up_phy(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03754"></a>03754 {
<a name="l03755"></a>03755     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.ops.power_up)
<a name="l03756"></a>03756         adapter-&gt;hw.phy.ops.power_up(&amp;adapter-&gt;hw);
<a name="l03757"></a>03757 
<a name="l03758"></a>03758     adapter-&gt;hw.mac.ops.setup_link(&amp;adapter-&gt;hw);
<a name="l03759"></a>03759 }
<a name="l03760"></a>03760 
<a name="l03767"></a>03767 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_power_down_phy(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03768"></a>03768 {
<a name="l03769"></a>03769     <span class="comment">/* WoL is enabled */</span>
<a name="l03770"></a>03770     <span class="keywordflow">if</span> (adapter-&gt;wol)
<a name="l03771"></a>03771         <span class="keywordflow">return</span>;
<a name="l03772"></a>03772 
<a name="l03773"></a>03773     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.ops.power_down)
<a name="l03774"></a>03774         adapter-&gt;hw.phy.ops.power_down(&amp;adapter-&gt;hw);
<a name="l03775"></a>03775 }
<a name="l03776"></a>03776 
<a name="l03785"></a>03785 <span class="keywordtype">void</span> e1000e_reset(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03786"></a>03786 {
<a name="l03787"></a>03787     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;adapter-&gt;hw.mac;
<a name="l03788"></a>03788     <span class="keyword">struct </span><a class="code" href="structe1000__fc__info.html">e1000_fc_info</a> *fc = &amp;adapter-&gt;hw.fc;
<a name="l03789"></a>03789     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03790"></a>03790     u32 tx_space, min_tx_space, min_rx_space;
<a name="l03791"></a>03791     u32 pba = adapter-&gt;pba;
<a name="l03792"></a>03792     u16 hwm;
<a name="l03793"></a>03793 
<a name="l03794"></a>03794     <span class="comment">/* reset Packet Buffer Allocation to default */</span>
<a name="l03795"></a>03795     ew32(PBA, pba);
<a name="l03796"></a>03796 
<a name="l03797"></a>03797     <span class="keywordflow">if</span> (adapter-&gt;max_frame_size &gt; ETH_FRAME_LEN + ETH_FCS_LEN) {
<a name="l03798"></a>03798         <span class="comment">/*</span>
<a name="l03799"></a>03799 <span class="comment">         * To maintain wire speed transmits, the Tx FIFO should be</span>
<a name="l03800"></a>03800 <span class="comment">         * large enough to accommodate two full transmit packets,</span>
<a name="l03801"></a>03801 <span class="comment">         * rounded up to the next 1KB and expressed in KB.  Likewise,</span>
<a name="l03802"></a>03802 <span class="comment">         * the Rx FIFO should be large enough to accommodate at least</span>
<a name="l03803"></a>03803 <span class="comment">         * one full receive packet and is similarly rounded up and</span>
<a name="l03804"></a>03804 <span class="comment">         * expressed in KB.</span>
<a name="l03805"></a>03805 <span class="comment">         */</span>
<a name="l03806"></a>03806         pba = er32(PBA);
<a name="l03807"></a>03807         <span class="comment">/* upper 16 bits has Tx packet buffer allocation size in KB */</span>
<a name="l03808"></a>03808         tx_space = pba &gt;&gt; 16;
<a name="l03809"></a>03809         <span class="comment">/* lower 16 bits has Rx packet buffer allocation size in KB */</span>
<a name="l03810"></a>03810         pba &amp;= 0xffff;
<a name="l03811"></a>03811         <span class="comment">/*</span>
<a name="l03812"></a>03812 <span class="comment">         * the Tx fifo also stores 16 bytes of information about the Tx</span>
<a name="l03813"></a>03813 <span class="comment">         * but don&#39;t include ethernet FCS because hardware appends it</span>
<a name="l03814"></a>03814 <span class="comment">         */</span>
<a name="l03815"></a>03815         min_tx_space = (adapter-&gt;max_frame_size +
<a name="l03816"></a>03816                 <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structe1000__tx__desc.html">e1000_tx_desc</a>) -
<a name="l03817"></a>03817                 ETH_FCS_LEN) * 2;
<a name="l03818"></a>03818         min_tx_space = ALIGN(min_tx_space, 1024);
<a name="l03819"></a>03819         min_tx_space &gt;&gt;= 10;
<a name="l03820"></a>03820         <span class="comment">/* software strips receive CRC, so leave room for it */</span>
<a name="l03821"></a>03821         min_rx_space = adapter-&gt;max_frame_size;
<a name="l03822"></a>03822         min_rx_space = ALIGN(min_rx_space, 1024);
<a name="l03823"></a>03823         min_rx_space &gt;&gt;= 10;
<a name="l03824"></a>03824 
<a name="l03825"></a>03825         <span class="comment">/*</span>
<a name="l03826"></a>03826 <span class="comment">         * If current Tx allocation is less than the min Tx FIFO size,</span>
<a name="l03827"></a>03827 <span class="comment">         * and the min Tx FIFO size is less than the current Rx FIFO</span>
<a name="l03828"></a>03828 <span class="comment">         * allocation, take space away from current Rx allocation</span>
<a name="l03829"></a>03829 <span class="comment">         */</span>
<a name="l03830"></a>03830         <span class="keywordflow">if</span> ((tx_space &lt; min_tx_space) &amp;&amp;
<a name="l03831"></a>03831             ((min_tx_space - tx_space) &lt; pba)) {
<a name="l03832"></a>03832             pba -= min_tx_space - tx_space;
<a name="l03833"></a>03833 
<a name="l03834"></a>03834             <span class="comment">/*</span>
<a name="l03835"></a>03835 <span class="comment">             * if short on Rx space, Rx wins and must trump Tx</span>
<a name="l03836"></a>03836 <span class="comment">             * adjustment or use Early Receive if available</span>
<a name="l03837"></a>03837 <span class="comment">             */</span>
<a name="l03838"></a>03838             <span class="keywordflow">if</span> ((pba &lt; min_rx_space) &amp;&amp;
<a name="l03839"></a>03839                 (!(adapter-&gt;flags &amp; FLAG_HAS_ERT)))
<a name="l03840"></a>03840                 <span class="comment">/* ERT enabled in e1000_configure_rx */</span>
<a name="l03841"></a>03841                 pba = min_rx_space;
<a name="l03842"></a>03842         }
<a name="l03843"></a>03843 
<a name="l03844"></a>03844         ew32(PBA, pba);
<a name="l03845"></a>03845     }
<a name="l03846"></a>03846 
<a name="l03847"></a>03847 
<a name="l03848"></a>03848     <span class="comment">/*</span>
<a name="l03849"></a>03849 <span class="comment">     * flow control settings</span>
<a name="l03850"></a>03850 <span class="comment">     *</span>
<a name="l03851"></a>03851 <span class="comment">     * The high water mark must be low enough to fit one full frame</span>
<a name="l03852"></a>03852 <span class="comment">     * (or the size used for early receive) above it in the Rx FIFO.</span>
<a name="l03853"></a>03853 <span class="comment">     * Set it to the lower of:</span>
<a name="l03854"></a>03854 <span class="comment">     * - 90% of the Rx FIFO size, and</span>
<a name="l03855"></a>03855 <span class="comment">     * - the full Rx FIFO size minus the early receive size (for parts</span>
<a name="l03856"></a>03856 <span class="comment">     *   with ERT support assuming ERT set to E1000_ERT_2048), or</span>
<a name="l03857"></a>03857 <span class="comment">     * - the full Rx FIFO size minus one full frame</span>
<a name="l03858"></a>03858 <span class="comment">     */</span>
<a name="l03859"></a>03859     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_DISABLE_FC_PAUSE_TIME)
<a name="l03860"></a>03860         fc-&gt;pause_time = 0xFFFF;
<a name="l03861"></a>03861     <span class="keywordflow">else</span>
<a name="l03862"></a>03862         fc-&gt;pause_time = E1000_FC_PAUSE_TIME;
<a name="l03863"></a>03863     fc-&gt;send_xon = 1;
<a name="l03864"></a>03864     fc-&gt;current_mode = fc-&gt;requested_mode;
<a name="l03865"></a>03865 
<a name="l03866"></a>03866     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03867"></a>03867     <span class="keywordflow">default</span>:
<a name="l03868"></a>03868         <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_HAS_ERT) &amp;&amp;
<a name="l03869"></a>03869             (adapter-&gt;netdev-&gt;mtu &gt; ETH_DATA_LEN))
<a name="l03870"></a>03870             hwm = min(((pba &lt;&lt; 10) * 9 / 10),
<a name="l03871"></a>03871                   ((pba &lt;&lt; 10) - (E1000_ERT_2048 &lt;&lt; 3)));
<a name="l03872"></a>03872         <span class="keywordflow">else</span>
<a name="l03873"></a>03873             hwm = min(((pba &lt;&lt; 10) * 9 / 10),
<a name="l03874"></a>03874                   ((pba &lt;&lt; 10) - adapter-&gt;max_frame_size));
<a name="l03875"></a>03875 
<a name="l03876"></a>03876         fc-&gt;high_water = hwm &amp; E1000_FCRTH_RTH; <span class="comment">/* 8-byte granularity */</span>
<a name="l03877"></a>03877         fc-&gt;low_water = fc-&gt;high_water - 8;
<a name="l03878"></a>03878         <span class="keywordflow">break</span>;
<a name="l03879"></a>03879     <span class="keywordflow">case</span> e1000_pchlan:
<a name="l03880"></a>03880         <span class="comment">/*</span>
<a name="l03881"></a>03881 <span class="comment">         * Workaround PCH LOM adapter hangs with certain network</span>
<a name="l03882"></a>03882 <span class="comment">         * loads.  If hangs persist, try disabling Tx flow control.</span>
<a name="l03883"></a>03883 <span class="comment">         */</span>
<a name="l03884"></a>03884         <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;mtu &gt; ETH_DATA_LEN) {
<a name="l03885"></a>03885             fc-&gt;high_water = 0x3500;
<a name="l03886"></a>03886             fc-&gt;low_water  = 0x1500;
<a name="l03887"></a>03887         } <span class="keywordflow">else</span> {
<a name="l03888"></a>03888             fc-&gt;high_water = 0x5000;
<a name="l03889"></a>03889             fc-&gt;low_water  = 0x3000;
<a name="l03890"></a>03890         }
<a name="l03891"></a>03891         fc-&gt;refresh_time = 0x1000;
<a name="l03892"></a>03892         <span class="keywordflow">break</span>;
<a name="l03893"></a>03893     <span class="keywordflow">case</span> e1000_pch2lan:
<a name="l03894"></a>03894         <span class="comment">/* TODO: validate with these values, adjust as needed */</span>
<a name="l03895"></a>03895         fc-&gt;high_water = 0x05C20;
<a name="l03896"></a>03896         fc-&gt;low_water = 0x05048;
<a name="l03897"></a>03897         fc-&gt;pause_time = 0x0650;
<a name="l03898"></a>03898         fc-&gt;refresh_time = 0x0400;
<a name="l03899"></a>03899         <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;mtu &gt; ETH_DATA_LEN) {
<a name="l03900"></a>03900             pba = 14;
<a name="l03901"></a>03901             ew32(PBA, pba);
<a name="l03902"></a>03902         }
<a name="l03903"></a>03903         <span class="keywordflow">break</span>;
<a name="l03904"></a>03904     }
<a name="l03905"></a>03905 
<a name="l03906"></a>03906     <span class="comment">/*</span>
<a name="l03907"></a>03907 <span class="comment">     * Disable Adaptive Interrupt Moderation if 2 full packets cannot</span>
<a name="l03908"></a>03908 <span class="comment">     * fit in receive buffer and early-receive not supported.</span>
<a name="l03909"></a>03909 <span class="comment">     */</span>
<a name="l03910"></a>03910     <span class="keywordflow">if</span> (adapter-&gt;itr_setting &amp; 0x3) {
<a name="l03911"></a>03911         <span class="keywordflow">if</span> (((adapter-&gt;max_frame_size * 2) &gt; (pba &lt;&lt; 10)) &amp;&amp;
<a name="l03912"></a>03912             !(adapter-&gt;flags &amp; FLAG_HAS_ERT)) {
<a name="l03913"></a>03913             <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; FLAG2_DISABLE_AIM)) {
<a name="l03914"></a>03914                 dev_info(pci_dev_to_dev(adapter-&gt;pdev),
<a name="l03915"></a>03915                     <span class="stringliteral">&quot;Interrupt Throttle Rate turned off\n&quot;</span>);
<a name="l03916"></a>03916                 adapter-&gt;flags2 |= FLAG2_DISABLE_AIM;
<a name="l03917"></a>03917                 ew32(ITR, 0);
<a name="l03918"></a>03918             }
<a name="l03919"></a>03919         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_DISABLE_AIM) {
<a name="l03920"></a>03920             dev_info(pci_dev_to_dev(adapter-&gt;pdev),
<a name="l03921"></a>03921                  <span class="stringliteral">&quot;Interrupt Throttle Rate turned on\n&quot;</span>);
<a name="l03922"></a>03922             adapter-&gt;flags2 &amp;= ~FLAG2_DISABLE_AIM;
<a name="l03923"></a>03923             adapter-&gt;itr = 20000;
<a name="l03924"></a>03924             ew32(ITR, 1000000000 / (adapter-&gt;itr * 256));
<a name="l03925"></a>03925         }
<a name="l03926"></a>03926     }
<a name="l03927"></a>03927 
<a name="l03928"></a>03928     <span class="comment">/* Allow time for pending master requests to run */</span>
<a name="l03929"></a>03929     mac-&gt;ops.reset_hw(hw);
<a name="l03930"></a>03930 
<a name="l03931"></a>03931     <span class="comment">/*</span>
<a name="l03932"></a>03932 <span class="comment">     * For parts with AMT enabled, let the firmware know</span>
<a name="l03933"></a>03933 <span class="comment">     * that the network interface is in control</span>
<a name="l03934"></a>03934 <span class="comment">     */</span>
<a name="l03935"></a>03935     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_AMT)
<a name="l03936"></a>03936         e1000e_get_hw_control(adapter);
<a name="l03937"></a>03937 
<a name="l03938"></a>03938     ew32(WUC, 0);
<a name="l03939"></a>03939 
<a name="l03940"></a>03940     <span class="keywordflow">if</span> (mac-&gt;ops.init_hw(hw))
<a name="l03941"></a>03941         e_err(<span class="stringliteral">&quot;Hardware Error\n&quot;</span>);
<a name="l03942"></a>03942 
<a name="l03943"></a>03943 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l03944"></a>03944 <span class="preprocessor"></span>    e1000_update_mng_vlan(adapter);
<a name="l03945"></a>03945 
<a name="l03946"></a>03946     <span class="comment">/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */</span>
<a name="l03947"></a>03947     ew32(VET, ETH_P_8021Q);
<a name="l03948"></a>03948 
<a name="l03949"></a>03949 <span class="preprocessor">#endif</span>
<a name="l03950"></a>03950 <span class="preprocessor"></span>    e1000e_reset_adaptive(hw);
<a name="l03951"></a>03951 
<a name="l03952"></a>03952     <span class="keywordflow">if</span> (!netif_running(adapter-&gt;netdev) &amp;&amp;
<a name="l03953"></a>03953         !test_bit(__E1000_TESTING, &amp;adapter-&gt;state)) {
<a name="l03954"></a>03954         e1000_power_down_phy(adapter);
<a name="l03955"></a>03955         <span class="keywordflow">return</span>;
<a name="l03956"></a>03956     }
<a name="l03957"></a>03957 
<a name="l03958"></a>03958     e1000_get_phy_info(hw);
<a name="l03959"></a>03959 
<a name="l03960"></a>03960     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_HAS_SMART_POWER_DOWN) &amp;&amp;
<a name="l03961"></a>03961         !(adapter-&gt;flags &amp; FLAG_SMART_POWER_DOWN)) {
<a name="l03962"></a>03962         u16 phy_data = 0;
<a name="l03963"></a>03963         <span class="comment">/*</span>
<a name="l03964"></a>03964 <span class="comment">         * speed up time to link by disabling smart power down, ignore</span>
<a name="l03965"></a>03965 <span class="comment">         * the return value of this function because there is nothing</span>
<a name="l03966"></a>03966 <span class="comment">         * different we would do if it failed</span>
<a name="l03967"></a>03967 <span class="comment">         */</span>
<a name="l03968"></a>03968         e1e_rphy(hw, IGP02E1000_PHY_POWER_MGMT, &amp;phy_data);
<a name="l03969"></a>03969         phy_data &amp;= ~IGP02E1000_PM_SPD;
<a name="l03970"></a>03970         e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, phy_data);
<a name="l03971"></a>03971     }
<a name="l03972"></a>03972 }
<a name="l03973"></a>03973 
<a name="l03974"></a>03974 <span class="keywordtype">int</span> e1000e_up(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l03975"></a>03975 {
<a name="l03976"></a>03976     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03977"></a>03977 
<a name="l03978"></a>03978     <span class="comment">/* hardware has been reset, we need to reload some things */</span>
<a name="l03979"></a>03979     e1000_configure(adapter);
<a name="l03980"></a>03980 
<a name="l03981"></a>03981     clear_bit(__E1000_DOWN, &amp;adapter-&gt;state);
<a name="l03982"></a>03982 
<a name="l03983"></a>03983 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l03984"></a>03984 <span class="preprocessor"></span>    napi_enable(&amp;adapter-&gt;napi);
<a name="l03985"></a>03985 <span class="preprocessor">#endif</span>
<a name="l03986"></a>03986 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l03987"></a>03987 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l03988"></a>03988         e1000_configure_msix(adapter);
<a name="l03989"></a>03989 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l03990"></a>03990     e1000_irq_enable(adapter);
<a name="l03991"></a>03991 
<a name="l03992"></a>03992     <span class="comment">/* fire a link change interrupt to start the watchdog */</span>
<a name="l03993"></a>03993 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l03994"></a>03994 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l03995"></a>03995         ew32(ICS, E1000_ICS_LSC | E1000_ICR_OTHER);
<a name="l03996"></a>03996     <span class="keywordflow">else</span>
<a name="l03997"></a>03997 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000_MSIX */</span>
<a name="l03998"></a>03998         ew32(ICS, E1000_ICS_LSC);
<a name="l03999"></a>03999 
<a name="l04000"></a>04000     <span class="keywordflow">return</span> 0;
<a name="l04001"></a>04001 }
<a name="l04002"></a>04002 
<a name="l04003"></a>04003 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_flush_descriptors(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04004"></a>04004 {
<a name="l04005"></a>04005     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04006"></a>04006 
<a name="l04007"></a>04007     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; FLAG2_DMA_BURST))
<a name="l04008"></a>04008         <span class="keywordflow">return</span>;
<a name="l04009"></a>04009 
<a name="l04010"></a>04010     <span class="comment">/* flush pending descriptor writebacks to memory */</span>
<a name="l04011"></a>04011     ew32(TIDV, adapter-&gt;tx_int_delay | E1000_TIDV_FPD);
<a name="l04012"></a>04012     ew32(RDTR, adapter-&gt;rx_int_delay | E1000_RDTR_FPD);
<a name="l04013"></a>04013 
<a name="l04014"></a>04014     <span class="comment">/* execute the writes immediately */</span>
<a name="l04015"></a>04015     e1e_flush();
<a name="l04016"></a>04016 }
<a name="l04017"></a>04017 
<a name="l04018"></a>04018 <span class="keywordtype">void</span> e1000e_down(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04019"></a>04019 {
<a name="l04020"></a>04020     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l04021"></a>04021     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04022"></a>04022     u32 tctl, rctl;
<a name="l04023"></a>04023 
<a name="l04024"></a>04024     <span class="comment">/*</span>
<a name="l04025"></a>04025 <span class="comment">     * signal that we&#39;re down so the interrupt handler does not</span>
<a name="l04026"></a>04026 <span class="comment">     * reschedule our watchdog timer</span>
<a name="l04027"></a>04027 <span class="comment">     */</span>
<a name="l04028"></a>04028     set_bit(__E1000_DOWN, &amp;adapter-&gt;state);
<a name="l04029"></a>04029 
<a name="l04030"></a>04030     <span class="comment">/* disable receives in the hardware */</span>
<a name="l04031"></a>04031     rctl = er32(RCTL);
<a name="l04032"></a>04032     ew32(RCTL, rctl &amp; ~E1000_RCTL_EN);
<a name="l04033"></a>04033     <span class="comment">/* flush and sleep below */</span>
<a name="l04034"></a>04034 
<a name="l04035"></a>04035     netif_stop_queue(netdev);
<a name="l04036"></a>04036 
<a name="l04037"></a>04037     <span class="comment">/* disable transmits in the hardware */</span>
<a name="l04038"></a>04038     tctl = er32(TCTL);
<a name="l04039"></a>04039     tctl &amp;= ~E1000_TCTL_EN;
<a name="l04040"></a>04040     ew32(TCTL, tctl);
<a name="l04041"></a>04041     <span class="comment">/* flush both disables and wait for them to finish */</span>
<a name="l04042"></a>04042     e1e_flush();
<a name="l04043"></a>04043     msleep(10);
<a name="l04044"></a>04044 
<a name="l04045"></a>04045 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l04046"></a>04046 <span class="preprocessor"></span>    napi_disable(&amp;adapter-&gt;napi);
<a name="l04047"></a>04047 <span class="preprocessor">#endif</span>
<a name="l04048"></a>04048 <span class="preprocessor"></span>    e1000_irq_disable(adapter);
<a name="l04049"></a>04049 
<a name="l04050"></a>04050     del_timer_sync(&amp;adapter-&gt;watchdog_timer);
<a name="l04051"></a>04051     del_timer_sync(&amp;adapter-&gt;phy_info_timer);
<a name="l04052"></a>04052 
<a name="l04053"></a>04053     <span class="comment">/* Link status message must follow this format */</span>
<a name="l04054"></a>04054     printk(KERN_INFO <span class="stringliteral">&quot;e1000e: %s NIC Link is Down\n&quot;</span>, netdev-&gt;name);
<a name="l04055"></a>04055     netif_carrier_off(netdev);
<a name="l04056"></a>04056     adapter-&gt;link_speed = 0;
<a name="l04057"></a>04057     adapter-&gt;link_duplex = 0;
<a name="l04058"></a>04058 
<a name="l04059"></a>04059 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l04060"></a>04060 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!pci_channel_offline(adapter-&gt;pdev))
<a name="l04061"></a>04061 <span class="preprocessor">#endif</span>
<a name="l04062"></a>04062 <span class="preprocessor"></span>        e1000e_reset(adapter);
<a name="l04063"></a>04063 
<a name="l04064"></a>04064     e1000e_flush_descriptors(adapter);
<a name="l04065"></a>04065 
<a name="l04066"></a>04066     e1000_clean_tx_ring(adapter);
<a name="l04067"></a>04067     e1000_clean_rx_ring(adapter);
<a name="l04068"></a>04068 
<a name="l04069"></a>04069     <span class="comment">/*</span>
<a name="l04070"></a>04070 <span class="comment">     * TODO: for power management, we could drop the link and</span>
<a name="l04071"></a>04071 <span class="comment">     * pci_disable_device here.</span>
<a name="l04072"></a>04072 <span class="comment">     */</span>
<a name="l04073"></a>04073 }
<a name="l04074"></a>04074 
<a name="l04075"></a>04075 <span class="keywordtype">void</span> e1000e_reinit_locked(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04076"></a>04076 {
<a name="l04077"></a>04077     might_sleep();
<a name="l04078"></a>04078     <span class="keywordflow">while</span> (test_and_set_bit(__E1000_RESETTING, &amp;adapter-&gt;state))
<a name="l04079"></a>04079         msleep(1);
<a name="l04080"></a>04080     e1000e_down(adapter);
<a name="l04081"></a>04081     e1000e_up(adapter);
<a name="l04082"></a>04082     clear_bit(__E1000_RESETTING, &amp;adapter-&gt;state);
<a name="l04083"></a>04083 }
<a name="l04084"></a>04084 
<a name="l04093"></a>04093 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit e1000_sw_init(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04094"></a>04094 {
<a name="l04095"></a>04095     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l04096"></a>04096     s32 rc;
<a name="l04097"></a>04097 
<a name="l04098"></a>04098     adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN;
<a name="l04099"></a>04099     adapter-&gt;rx_ps_bsize0 = 128;
<a name="l04100"></a>04100     adapter-&gt;max_frame_size = netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l04101"></a>04101     adapter-&gt;min_frame_size = ETH_ZLEN + ETH_FCS_LEN;
<a name="l04102"></a>04102 
<a name="l04103"></a>04103     <span class="comment">/* Set various function pointers */</span>
<a name="l04104"></a>04104     adapter-&gt;ei-&gt;init_ops(&amp;adapter-&gt;hw);
<a name="l04105"></a>04105 
<a name="l04106"></a>04106     rc = adapter-&gt;hw.mac.ops.init_params(&amp;adapter-&gt;hw);
<a name="l04107"></a>04107     <span class="keywordflow">if</span> (rc)
<a name="l04108"></a>04108         <span class="keywordflow">return</span> rc;
<a name="l04109"></a>04109 
<a name="l04110"></a>04110     rc = adapter-&gt;hw.nvm.ops.init_params(&amp;adapter-&gt;hw);
<a name="l04111"></a>04111     <span class="keywordflow">if</span> (rc)
<a name="l04112"></a>04112         <span class="keywordflow">return</span> rc;
<a name="l04113"></a>04113 
<a name="l04114"></a>04114     rc = adapter-&gt;hw.phy.ops.init_params(&amp;adapter-&gt;hw);
<a name="l04115"></a>04115     <span class="keywordflow">if</span> (rc)
<a name="l04116"></a>04116         <span class="keywordflow">return</span> rc;
<a name="l04117"></a>04117 
<a name="l04118"></a>04118 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l04119"></a>04119 <span class="preprocessor"></span>    e1000e_set_interrupt_capability(adapter);
<a name="l04120"></a>04120 
<a name="l04121"></a>04121 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l04122"></a>04122     <span class="keywordflow">if</span> (e1000_alloc_queues(adapter))
<a name="l04123"></a>04123         <span class="keywordflow">return</span> -ENOMEM;
<a name="l04124"></a>04124 
<a name="l04125"></a>04125     <span class="comment">/* Explicitly disable IRQ since the NIC can be in any state. */</span>
<a name="l04126"></a>04126     e1000_irq_disable(adapter);
<a name="l04127"></a>04127 
<a name="l04128"></a>04128     set_bit(__E1000_DOWN, &amp;adapter-&gt;state);
<a name="l04129"></a>04129     <span class="keywordflow">return</span> 0;
<a name="l04130"></a>04130 }
<a name="l04131"></a>04131 
<a name="l04137"></a>04137 <span class="keyword">static</span> irqreturn_t e1000_intr_msi_test(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l04138"></a>04138 {
<a name="l04139"></a>04139     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l04140"></a>04140     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04141"></a>04141     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04142"></a>04142     u32 icr = er32(ICR);
<a name="l04143"></a>04143 
<a name="l04144"></a>04144     e_dbg(<span class="stringliteral">&quot;icr is %08X\n&quot;</span>, icr);
<a name="l04145"></a>04145     <span class="keywordflow">if</span> (icr &amp; E1000_ICR_RXSEQ) {
<a name="l04146"></a>04146         adapter-&gt;flags &amp;= ~FLAG_MSI_TEST_FAILED;
<a name="l04147"></a>04147         wmb();
<a name="l04148"></a>04148     }
<a name="l04149"></a>04149 
<a name="l04150"></a>04150     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l04151"></a>04151 }
<a name="l04152"></a>04152 
<a name="l04159"></a>04159 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_test_msi_interrupt(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04160"></a>04160 {
<a name="l04161"></a>04161     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l04162"></a>04162     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04163"></a>04163     <span class="keywordtype">int</span> err;
<a name="l04164"></a>04164 
<a name="l04165"></a>04165     <span class="comment">/* poll_enable hasn&#39;t been called yet, so don&#39;t need disable */</span>
<a name="l04166"></a>04166     <span class="comment">/* clear any pending events */</span>
<a name="l04167"></a>04167     er32(ICR);
<a name="l04168"></a>04168 
<a name="l04169"></a>04169     <span class="comment">/* free the real vector and request a test handler */</span>
<a name="l04170"></a>04170     e1000_free_irq(adapter);
<a name="l04171"></a>04171 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l04172"></a>04172 <span class="preprocessor"></span>    e1000e_reset_interrupt_capability(adapter);
<a name="l04173"></a>04173 <span class="preprocessor">#endif</span>
<a name="l04174"></a>04174 <span class="preprocessor"></span>
<a name="l04175"></a>04175     <span class="comment">/* Assume that the test fails, if it succeeds then the test</span>
<a name="l04176"></a>04176 <span class="comment">     * MSI irq handler will unset this flag */</span>
<a name="l04177"></a>04177     adapter-&gt;flags |= FLAG_MSI_TEST_FAILED;
<a name="l04178"></a>04178 
<a name="l04179"></a>04179     err = pci_enable_msi(adapter-&gt;pdev);
<a name="l04180"></a>04180     <span class="keywordflow">if</span> (err)
<a name="l04181"></a>04181         <span class="keywordflow">goto</span> msi_test_failed;
<a name="l04182"></a>04182 
<a name="l04183"></a>04183     err = request_irq(adapter-&gt;pdev-&gt;irq, e1000_intr_msi_test, 0,
<a name="l04184"></a>04184               netdev-&gt;name, netdev);
<a name="l04185"></a>04185     <span class="keywordflow">if</span> (err) {
<a name="l04186"></a>04186         pci_disable_msi(adapter-&gt;pdev);
<a name="l04187"></a>04187         <span class="keywordflow">goto</span> msi_test_failed;
<a name="l04188"></a>04188     }
<a name="l04189"></a>04189 
<a name="l04190"></a>04190     wmb();
<a name="l04191"></a>04191 
<a name="l04192"></a>04192     e1000_irq_enable(adapter);
<a name="l04193"></a>04193 
<a name="l04194"></a>04194     <span class="comment">/* fire an unusual interrupt on the test handler */</span>
<a name="l04195"></a>04195     ew32(ICS, E1000_ICS_RXSEQ);
<a name="l04196"></a>04196     e1e_flush();
<a name="l04197"></a>04197     msleep(50);
<a name="l04198"></a>04198 
<a name="l04199"></a>04199     e1000_irq_disable(adapter);
<a name="l04200"></a>04200 
<a name="l04201"></a>04201     rmb();
<a name="l04202"></a>04202 
<a name="l04203"></a>04203     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_MSI_TEST_FAILED) {
<a name="l04204"></a>04204 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l04205"></a>04205 <span class="preprocessor"></span>        adapter-&gt;int_mode = E1000E_INT_MODE_LEGACY;
<a name="l04206"></a>04206 <span class="preprocessor">#endif</span>
<a name="l04207"></a>04207 <span class="preprocessor"></span>        e_info(<span class="stringliteral">&quot;MSI interrupt test failed, using legacy interrupt.\n&quot;</span>);
<a name="l04208"></a>04208     } <span class="keywordflow">else</span> {
<a name="l04209"></a>04209         e_dbg(<span class="stringliteral">&quot;MSI interrupt test succeeded!\n&quot;</span>);
<a name="l04210"></a>04210     }
<a name="l04211"></a>04211 
<a name="l04212"></a>04212     free_irq(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l04213"></a>04213     pci_disable_msi(adapter-&gt;pdev);
<a name="l04214"></a>04214 
<a name="l04215"></a>04215 msi_test_failed:
<a name="l04216"></a>04216 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l04217"></a>04217 <span class="preprocessor"></span>    e1000e_set_interrupt_capability(adapter);
<a name="l04218"></a>04218 <span class="preprocessor">#else</span>
<a name="l04219"></a>04219 <span class="preprocessor"></span>    <span class="comment">/* restore the original vector, even if it failed */</span>
<a name="l04220"></a>04220 <span class="preprocessor">#endif</span>
<a name="l04221"></a>04221 <span class="preprocessor"></span>    <span class="keywordflow">return</span> e1000_request_irq(adapter);
<a name="l04222"></a>04222 }
<a name="l04223"></a>04223 
<a name="l04230"></a>04230 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_test_msi(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04231"></a>04231 {
<a name="l04232"></a>04232     <span class="keywordtype">int</span> err;
<a name="l04233"></a>04233     u16 pci_cmd;
<a name="l04234"></a>04234 
<a name="l04235"></a>04235     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_MSI_ENABLED))
<a name="l04236"></a>04236         <span class="keywordflow">return</span> 0;
<a name="l04237"></a>04237 
<a name="l04238"></a>04238     <span class="comment">/* disable SERR in case the MSI write causes a master abort */</span>
<a name="l04239"></a>04239     pci_read_config_word(adapter-&gt;pdev, PCI_COMMAND, &amp;pci_cmd);
<a name="l04240"></a>04240     <span class="keywordflow">if</span> (pci_cmd &amp; PCI_COMMAND_SERR)
<a name="l04241"></a>04241         pci_write_config_word(adapter-&gt;pdev, PCI_COMMAND,
<a name="l04242"></a>04242                       pci_cmd &amp; ~PCI_COMMAND_SERR);
<a name="l04243"></a>04243 
<a name="l04244"></a>04244     err = e1000_test_msi_interrupt(adapter);
<a name="l04245"></a>04245 
<a name="l04246"></a>04246     <span class="comment">/* re-enable SERR */</span>
<a name="l04247"></a>04247     <span class="keywordflow">if</span> (pci_cmd &amp; PCI_COMMAND_SERR) {
<a name="l04248"></a>04248         pci_read_config_word(adapter-&gt;pdev, PCI_COMMAND, &amp;pci_cmd);
<a name="l04249"></a>04249         pci_cmd |= PCI_COMMAND_SERR;
<a name="l04250"></a>04250         pci_write_config_word(adapter-&gt;pdev, PCI_COMMAND, pci_cmd);
<a name="l04251"></a>04251     }
<a name="l04252"></a>04252 
<a name="l04253"></a>04253     <span class="keywordflow">return</span> err;
<a name="l04254"></a>04254 }
<a name="l04255"></a>04255 
<a name="l04268"></a>04268 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_open(<span class="keyword">struct</span> net_device *netdev)
<a name="l04269"></a>04269 {
<a name="l04270"></a>04270     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04271"></a>04271     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04272"></a>04272     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l04273"></a>04273     <span class="keywordtype">int</span> err;
<a name="l04274"></a>04274 
<a name="l04275"></a>04275     adapter-&gt;pdev = pdev;
<a name="l04276"></a>04276     <span class="comment">/* disallow open during test */</span>
<a name="l04277"></a>04277     <span class="keywordflow">if</span> (test_bit(__E1000_TESTING, &amp;adapter-&gt;state))
<a name="l04278"></a>04278         <span class="keywordflow">return</span> -EBUSY;
<a name="l04279"></a>04279 
<a name="l04280"></a>04280     pm_runtime_get_sync(&amp;pdev-&gt;dev);
<a name="l04281"></a>04281 
<a name="l04282"></a>04282     netif_carrier_off(netdev);
<a name="l04283"></a>04283 
<a name="l04284"></a>04284     <span class="comment">/* allocate transmit descriptors */</span>
<a name="l04285"></a>04285     err = e1000e_setup_tx_resources(adapter);
<a name="l04286"></a>04286     <span class="keywordflow">if</span> (err)
<a name="l04287"></a>04287         <span class="keywordflow">goto</span> err_setup_tx;
<a name="l04288"></a>04288 
<a name="l04289"></a>04289     <span class="comment">/* allocate receive descriptors */</span>
<a name="l04290"></a>04290     err = e1000e_setup_rx_resources(adapter);
<a name="l04291"></a>04291     <span class="keywordflow">if</span> (err)
<a name="l04292"></a>04292         <span class="keywordflow">goto</span> err_setup_rx;
<a name="l04293"></a>04293 
<a name="l04294"></a>04294     <span class="comment">/*</span>
<a name="l04295"></a>04295 <span class="comment">     * If AMT is enabled, let the firmware know that the network</span>
<a name="l04296"></a>04296 <span class="comment">     * interface is now open and reset the part to a known state.</span>
<a name="l04297"></a>04297 <span class="comment">     */</span>
<a name="l04298"></a>04298     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_AMT) {
<a name="l04299"></a>04299         e1000e_get_hw_control(adapter);
<a name="l04300"></a>04300         e1000e_reset(adapter);
<a name="l04301"></a>04301     }
<a name="l04302"></a>04302 
<a name="l04303"></a>04303     e1000e_power_up_phy(adapter);
<a name="l04304"></a>04304 
<a name="l04305"></a>04305 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l04306"></a>04306 <span class="preprocessor"></span>    adapter-&gt;mng_vlan_id = E1000_MNG_VLAN_NONE;
<a name="l04307"></a>04307     <span class="keywordflow">if</span> ((adapter-&gt;hw.mng_cookie.status &amp;
<a name="l04308"></a>04308          E1000_MNG_DHCP_COOKIE_STATUS_VLAN))
<a name="l04309"></a>04309         e1000_update_mng_vlan(adapter);
<a name="l04310"></a>04310 
<a name="l04311"></a>04311 <span class="preprocessor">#endif</span>
<a name="l04312"></a>04312 <span class="preprocessor"></span>    <span class="comment">/* DMA latency requirement to workaround early-receive/jumbo issue */</span>
<a name="l04313"></a>04313     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_HAS_ERT) ||
<a name="l04314"></a>04314         (adapter-&gt;hw.mac.type == e1000_pch2lan))
<a name="l04315"></a>04315 <span class="preprocessor">#ifdef HAVE_PM_QOS_REQUEST_ACTIVE</span>
<a name="l04316"></a>04316 <span class="preprocessor"></span>        pm_qos_add_request(&amp;adapter-&gt;netdev-&gt;pm_qos_req,
<a name="l04317"></a>04317                    PM_QOS_CPU_DMA_LATENCY,
<a name="l04318"></a>04318                    PM_QOS_DEFAULT_VALUE);
<a name="l04319"></a>04319 <span class="preprocessor">#elif defined(HAVE_PM_QOS_REQUEST_LIST)</span>
<a name="l04320"></a>04320 <span class="preprocessor"></span>        adapter-&gt;netdev-&gt;pm_qos_req =
<a name="l04321"></a>04321             pm_qos_add_request(PM_QOS_CPU_DMA_LATENCY,
<a name="l04322"></a>04322                        PM_QOS_DEFAULT_VALUE);
<a name="l04323"></a>04323 <span class="preprocessor">#else</span>
<a name="l04324"></a>04324 <span class="preprocessor"></span>        pm_qos_add_requirement(PM_QOS_CPU_DMA_LATENCY,
<a name="l04325"></a>04325                                adapter-&gt;netdev-&gt;name,
<a name="l04326"></a>04326                        PM_QOS_DEFAULT_VALUE);
<a name="l04327"></a>04327 <span class="preprocessor">#endif</span>
<a name="l04328"></a>04328 <span class="preprocessor"></span>
<a name="l04329"></a>04329     <span class="comment">/*</span>
<a name="l04330"></a>04330 <span class="comment">     * before we allocate an interrupt, we must be ready to handle it.</span>
<a name="l04331"></a>04331 <span class="comment">     * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span>
<a name="l04332"></a>04332 <span class="comment">     * as soon as we call pci_request_irq, so we have to setup our</span>
<a name="l04333"></a>04333 <span class="comment">     * clean_rx handler before we do so.</span>
<a name="l04334"></a>04334 <span class="comment">     */</span>
<a name="l04335"></a>04335     e1000_configure(adapter);
<a name="l04336"></a>04336 
<a name="l04337"></a>04337     err = e1000_request_irq(adapter);
<a name="l04338"></a>04338     <span class="keywordflow">if</span> (err)
<a name="l04339"></a>04339         <span class="keywordflow">goto</span> err_req_irq;
<a name="l04340"></a>04340 
<a name="l04341"></a>04341     <span class="comment">/*</span>
<a name="l04342"></a>04342 <span class="comment">     * Work around PCIe errata with MSI interrupts causing some chipsets to</span>
<a name="l04343"></a>04343 <span class="comment">     * ignore e1000e MSI messages, which means we need to test our MSI</span>
<a name="l04344"></a>04344 <span class="comment">     * interrupt now</span>
<a name="l04345"></a>04345 <span class="comment">     */</span>
<a name="l04346"></a>04346 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l04347"></a>04347 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;int_mode != E1000E_INT_MODE_LEGACY) {
<a name="l04348"></a>04348 <span class="preprocessor">#else</span>
<a name="l04349"></a>04349 <span class="preprocessor"></span>    {
<a name="l04350"></a>04350 <span class="preprocessor">#endif</span>
<a name="l04351"></a>04351 <span class="preprocessor"></span>        err = e1000_test_msi(adapter);
<a name="l04352"></a>04352         <span class="keywordflow">if</span> (err) {
<a name="l04353"></a>04353             e_err(<span class="stringliteral">&quot;Interrupt allocation failed\n&quot;</span>);
<a name="l04354"></a>04354             <span class="keywordflow">goto</span> err_req_irq;
<a name="l04355"></a>04355         }
<a name="l04356"></a>04356     }
<a name="l04357"></a>04357 
<a name="l04358"></a>04358     <span class="comment">/* From here on the code is the same as e1000e_up() */</span>
<a name="l04359"></a>04359     clear_bit(__E1000_DOWN, &amp;adapter-&gt;state);
<a name="l04360"></a>04360 
<a name="l04361"></a>04361 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l04362"></a>04362 <span class="preprocessor"></span>    napi_enable(&amp;adapter-&gt;napi);
<a name="l04363"></a>04363 <span class="preprocessor">#endif</span>
<a name="l04364"></a>04364 <span class="preprocessor"></span>
<a name="l04365"></a>04365     e1000_irq_enable(adapter);
<a name="l04366"></a>04366 
<a name="l04367"></a>04367     adapter-&gt;idle_check = <span class="keyword">true</span>;
<a name="l04368"></a>04368     pm_runtime_put(&amp;pdev-&gt;dev);
<a name="l04369"></a>04369 
<a name="l04370"></a>04370     <span class="comment">/* fire a link status change interrupt to start the watchdog */</span>
<a name="l04371"></a>04371 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l04372"></a>04372 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l04373"></a>04373         ew32(ICS, E1000_ICS_LSC | E1000_ICR_OTHER);
<a name="l04374"></a>04374     <span class="keywordflow">else</span>
<a name="l04375"></a>04375 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000_MSIX */</span>
<a name="l04376"></a>04376         ew32(ICS, E1000_ICS_LSC);
<a name="l04377"></a>04377 
<a name="l04378"></a>04378     <span class="keywordflow">return</span> 0;
<a name="l04379"></a>04379 
<a name="l04380"></a>04380 err_req_irq:
<a name="l04381"></a>04381     e1000e_release_hw_control(adapter);
<a name="l04382"></a>04382     e1000_power_down_phy(adapter);
<a name="l04383"></a>04383     e1000e_free_rx_resources(adapter);
<a name="l04384"></a>04384 err_setup_rx:
<a name="l04385"></a>04385     e1000e_free_tx_resources(adapter);
<a name="l04386"></a>04386 err_setup_tx:
<a name="l04387"></a>04387     e1000e_reset(adapter);
<a name="l04388"></a>04388     pm_runtime_put_sync(&amp;pdev-&gt;dev);
<a name="l04389"></a>04389 
<a name="l04390"></a>04390     <span class="keywordflow">return</span> err;
<a name="l04391"></a>04391 }
<a name="l04392"></a>04392 
<a name="l04404"></a>04404 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_close(<span class="keyword">struct</span> net_device *netdev)
<a name="l04405"></a>04405 {
<a name="l04406"></a>04406     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04407"></a>04407     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l04408"></a>04408 
<a name="l04409"></a>04409     adapter-&gt;pdev = pdev;
<a name="l04410"></a>04410     WARN_ON(test_bit(__E1000_RESETTING, &amp;adapter-&gt;state));
<a name="l04411"></a>04411 
<a name="l04412"></a>04412     pm_runtime_get_sync(&amp;pdev-&gt;dev);
<a name="l04413"></a>04413 
<a name="l04414"></a>04414     <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state)) {
<a name="l04415"></a>04415         e1000e_down(adapter);
<a name="l04416"></a>04416         e1000_free_irq(adapter);
<a name="l04417"></a>04417     }
<a name="l04418"></a>04418     e1000_power_down_phy(adapter);
<a name="l04419"></a>04419 
<a name="l04420"></a>04420     e1000e_free_tx_resources(adapter);
<a name="l04421"></a>04421     e1000e_free_rx_resources(adapter);
<a name="l04422"></a>04422 
<a name="l04423"></a>04423 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l04424"></a>04424 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l04425"></a>04425 <span class="comment">     * kill manageability vlan ID if supported, but not if a vlan with</span>
<a name="l04426"></a>04426 <span class="comment">     * the same ID is registered on the host OS (let 8021q kill it)</span>
<a name="l04427"></a>04427 <span class="comment">     */</span>
<a name="l04428"></a>04428     <span class="keywordflow">if</span> ((adapter-&gt;hw.mng_cookie.status &amp;
<a name="l04429"></a>04429               E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &amp;&amp;
<a name="l04430"></a>04430          !(adapter-&gt;vlgrp &amp;&amp;
<a name="l04431"></a>04431            vlan_group_get_device(adapter-&gt;vlgrp, adapter-&gt;mng_vlan_id)))
<a name="l04432"></a>04432         e1000_vlan_rx_kill_vid(netdev, adapter-&gt;mng_vlan_id);
<a name="l04433"></a>04433 
<a name="l04434"></a>04434 <span class="preprocessor">#endif</span>
<a name="l04435"></a>04435 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l04436"></a>04436 <span class="comment">     * If AMT is enabled, let the firmware know that the network</span>
<a name="l04437"></a>04437 <span class="comment">     * interface is now closed</span>
<a name="l04438"></a>04438 <span class="comment">     */</span>
<a name="l04439"></a>04439     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_HAS_AMT) &amp;&amp;
<a name="l04440"></a>04440         !test_bit(__E1000_TESTING, &amp;adapter-&gt;state))
<a name="l04441"></a>04441         e1000e_release_hw_control(adapter);
<a name="l04442"></a>04442 
<a name="l04443"></a>04443     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_HAS_ERT) ||
<a name="l04444"></a>04444         (adapter-&gt;hw.mac.type == e1000_pch2lan))
<a name="l04445"></a>04445 <span class="preprocessor">#ifdef HAVE_PM_QOS_REQUEST_ACTIVE</span>
<a name="l04446"></a>04446 <span class="preprocessor"></span>        pm_qos_remove_request(&amp;adapter-&gt;netdev-&gt;pm_qos_req);
<a name="l04447"></a>04447 <span class="preprocessor">#elif defined(HAVE_PM_QOS_REQUEST_LIST)</span>
<a name="l04448"></a>04448 <span class="preprocessor"></span>    {
<a name="l04449"></a>04449         pm_qos_remove_request(adapter-&gt;netdev-&gt;pm_qos_req);
<a name="l04450"></a>04450         adapter-&gt;netdev-&gt;pm_qos_req = NULL;
<a name="l04451"></a>04451     }
<a name="l04452"></a>04452 <span class="preprocessor">#else</span>
<a name="l04453"></a>04453 <span class="preprocessor"></span>        pm_qos_remove_requirement(PM_QOS_CPU_DMA_LATENCY,
<a name="l04454"></a>04454                                   adapter-&gt;netdev-&gt;name);
<a name="l04455"></a>04455 <span class="preprocessor">#endif</span>
<a name="l04456"></a>04456 <span class="preprocessor"></span>
<a name="l04457"></a>04457     pm_runtime_put_sync(&amp;pdev-&gt;dev);
<a name="l04458"></a>04458 
<a name="l04459"></a>04459     <span class="keywordflow">return</span> 0;
<a name="l04460"></a>04460 }
<a name="l04468"></a>04468 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_set_mac(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">void</span> *p)
<a name="l04469"></a>04469 {
<a name="l04470"></a>04470     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l04471"></a>04471     <span class="keyword">struct </span>sockaddr *addr = p;
<a name="l04472"></a>04472 
<a name="l04473"></a>04473     <span class="keywordflow">if</span> (!is_valid_ether_addr((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(addr-&gt;sa_data)))
<a name="l04474"></a>04474         <span class="keywordflow">return</span> -EADDRNOTAVAIL;
<a name="l04475"></a>04475 
<a name="l04476"></a>04476     memcpy(netdev-&gt;dev_addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l04477"></a>04477     memcpy(adapter-&gt;hw.mac.addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l04478"></a>04478 
<a name="l04479"></a>04479     e1000e_rar_set(&amp;adapter-&gt;hw, adapter-&gt;hw.mac.addr, 0);
<a name="l04480"></a>04480 
<a name="l04481"></a>04481     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_RESET_OVERWRITES_LAA) {
<a name="l04482"></a>04482         <span class="comment">/* activate the work around */</span>
<a name="l04483"></a>04483         e1000e_set_laa_state_82571(&amp;adapter-&gt;hw, 1);
<a name="l04484"></a>04484 
<a name="l04485"></a>04485         <span class="comment">/*</span>
<a name="l04486"></a>04486 <span class="comment">         * Hold a copy of the LAA in RAR[14] This is done so that</span>
<a name="l04487"></a>04487 <span class="comment">         * between the time RAR[0] gets clobbered  and the time it</span>
<a name="l04488"></a>04488 <span class="comment">         * gets fixed (in e1000_watchdog), the actual LAA is in one</span>
<a name="l04489"></a>04489 <span class="comment">         * of the RARs and no incoming packets directed to this port</span>
<a name="l04490"></a>04490 <span class="comment">         * are dropped. Eventually the LAA will be in RAR[0] and</span>
<a name="l04491"></a>04491 <span class="comment">         * RAR[14]</span>
<a name="l04492"></a>04492 <span class="comment">         */</span>
<a name="l04493"></a>04493         e1000e_rar_set(&amp;adapter-&gt;hw,
<a name="l04494"></a>04494                   adapter-&gt;hw.mac.addr,
<a name="l04495"></a>04495                   adapter-&gt;hw.mac.rar_entry_count - 1);
<a name="l04496"></a>04496     }
<a name="l04497"></a>04497 
<a name="l04498"></a>04498     <span class="keywordflow">return</span> 0;
<a name="l04499"></a>04499 }
<a name="l04500"></a>04500 
<a name="l04509"></a>04509 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_update_phy_task(<span class="keyword">struct</span> work_struct *work)
<a name="l04510"></a>04510 {
<a name="l04511"></a>04511     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = container_of(work,
<a name="l04512"></a>04512                     <span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a>, update_phy_task);
<a name="l04513"></a>04513 
<a name="l04514"></a>04514     <span class="keywordflow">if</span> (test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l04515"></a>04515         <span class="keywordflow">return</span>;
<a name="l04516"></a>04516 
<a name="l04517"></a>04517     e1000_get_phy_info(&amp;adapter-&gt;hw);
<a name="l04518"></a>04518 }
<a name="l04519"></a>04519 
<a name="l04520"></a>04520 <span class="comment">/*</span>
<a name="l04521"></a>04521 <span class="comment"> * Need to wait a few seconds after link up to get diagnostic information from</span>
<a name="l04522"></a>04522 <span class="comment"> * the phy</span>
<a name="l04523"></a>04523 <span class="comment"> */</span>
<a name="l04524"></a>04524 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_update_phy_info(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l04525"></a>04525 {
<a name="l04526"></a>04526     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = (<span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *) data;
<a name="l04527"></a>04527 
<a name="l04528"></a>04528     <span class="keywordflow">if</span> (test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l04529"></a>04529         <span class="keywordflow">return</span>;
<a name="l04530"></a>04530 
<a name="l04531"></a>04531     schedule_work(&amp;adapter-&gt;update_phy_task);
<a name="l04532"></a>04532 }
<a name="l04533"></a>04533 
<a name="l04538"></a>04538 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_update_phy_stats(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04539"></a>04539 {
<a name="l04540"></a>04540     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04541"></a>04541     s32 ret_val;
<a name="l04542"></a>04542     u16 phy_data;
<a name="l04543"></a>04543 
<a name="l04544"></a>04544     ret_val = hw-&gt;phy.ops.acquire(hw);
<a name="l04545"></a>04545     <span class="keywordflow">if</span> (ret_val)
<a name="l04546"></a>04546         <span class="keywordflow">return</span>;
<a name="l04547"></a>04547 
<a name="l04548"></a>04548     hw-&gt;phy.addr = 1;
<a name="l04549"></a>04549 
<a name="l04550"></a>04550 <span class="preprocessor">#define HV_PHY_STATS_PAGE   778</span>
<a name="l04551"></a>04551 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l04552"></a>04552 <span class="comment">     * A page set is expensive so check if already on desired page.</span>
<a name="l04553"></a>04553 <span class="comment">     * If not, set to the page with the PHY status registers.</span>
<a name="l04554"></a>04554 <span class="comment">     */</span>
<a name="l04555"></a>04555     ret_val = e1000e_read_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT,
<a name="l04556"></a>04556                        &amp;phy_data);
<a name="l04557"></a>04557     <span class="keywordflow">if</span> (ret_val)
<a name="l04558"></a>04558         <span class="keywordflow">goto</span> release;
<a name="l04559"></a>04559     <span class="keywordflow">if</span> (phy_data != (HV_PHY_STATS_PAGE &lt;&lt; IGP_PAGE_SHIFT)) {
<a name="l04560"></a>04560         ret_val = e1000e_write_phy_reg_mdic(hw,
<a name="l04561"></a>04561                             IGP01E1000_PHY_PAGE_SELECT,
<a name="l04562"></a>04562                             (HV_PHY_STATS_PAGE &lt;&lt;
<a name="l04563"></a>04563                              IGP_PAGE_SHIFT));
<a name="l04564"></a>04564         <span class="keywordflow">if</span> (ret_val)
<a name="l04565"></a>04565             <span class="keywordflow">goto</span> release;
<a name="l04566"></a>04566     }
<a name="l04567"></a>04567 
<a name="l04568"></a>04568     <span class="comment">/* Read/clear the upper 16-bit registers and read/accumulate lower */</span>
<a name="l04569"></a>04569 
<a name="l04570"></a>04570     <span class="comment">/* Single Collision Count */</span>
<a name="l04571"></a>04571     e1000e_read_phy_reg_mdic(hw, HV_SCC_UPPER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04572"></a>04572                  &amp;phy_data);
<a name="l04573"></a>04573     ret_val = e1000e_read_phy_reg_mdic(hw,
<a name="l04574"></a>04574                        HV_SCC_LOWER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04575"></a>04575                        &amp;phy_data);
<a name="l04576"></a>04576     <span class="keywordflow">if</span> (!ret_val)
<a name="l04577"></a>04577         adapter-&gt;stats.scc += phy_data;
<a name="l04578"></a>04578 
<a name="l04579"></a>04579     <span class="comment">/* Excessive Collision Count */</span>
<a name="l04580"></a>04580     e1000e_read_phy_reg_mdic(hw, HV_ECOL_UPPER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04581"></a>04581                  &amp;phy_data);
<a name="l04582"></a>04582     ret_val = e1000e_read_phy_reg_mdic(hw,
<a name="l04583"></a>04583                        HV_ECOL_LOWER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04584"></a>04584                        &amp;phy_data);
<a name="l04585"></a>04585     <span class="keywordflow">if</span> (!ret_val)
<a name="l04586"></a>04586         adapter-&gt;stats.ecol += phy_data;
<a name="l04587"></a>04587 
<a name="l04588"></a>04588     <span class="comment">/* Multiple Collision Count */</span>
<a name="l04589"></a>04589     e1000e_read_phy_reg_mdic(hw, HV_MCC_UPPER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04590"></a>04590                  &amp;phy_data);
<a name="l04591"></a>04591     ret_val = e1000e_read_phy_reg_mdic(hw,
<a name="l04592"></a>04592                        HV_MCC_LOWER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04593"></a>04593                        &amp;phy_data);
<a name="l04594"></a>04594     <span class="keywordflow">if</span> (!ret_val)
<a name="l04595"></a>04595         adapter-&gt;stats.mcc += phy_data;
<a name="l04596"></a>04596 
<a name="l04597"></a>04597     <span class="comment">/* Late Collision Count */</span>
<a name="l04598"></a>04598     e1000e_read_phy_reg_mdic(hw, HV_LATECOL_UPPER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04599"></a>04599                  &amp;phy_data);
<a name="l04600"></a>04600     ret_val = e1000e_read_phy_reg_mdic(hw,
<a name="l04601"></a>04601                        HV_LATECOL_LOWER &amp;
<a name="l04602"></a>04602                        MAX_PHY_REG_ADDRESS,
<a name="l04603"></a>04603                        &amp;phy_data);
<a name="l04604"></a>04604     <span class="keywordflow">if</span> (!ret_val)
<a name="l04605"></a>04605         adapter-&gt;stats.latecol += phy_data;
<a name="l04606"></a>04606 
<a name="l04607"></a>04607     <span class="comment">/* Collision Count - also used for adaptive IFS */</span>
<a name="l04608"></a>04608     e1000e_read_phy_reg_mdic(hw, HV_COLC_UPPER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04609"></a>04609                  &amp;phy_data);
<a name="l04610"></a>04610     ret_val = e1000e_read_phy_reg_mdic(hw,
<a name="l04611"></a>04611                        HV_COLC_LOWER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04612"></a>04612                        &amp;phy_data);
<a name="l04613"></a>04613     <span class="keywordflow">if</span> (!ret_val)
<a name="l04614"></a>04614         hw-&gt;mac.collision_delta = phy_data;
<a name="l04615"></a>04615 
<a name="l04616"></a>04616     <span class="comment">/* Defer Count */</span>
<a name="l04617"></a>04617     e1000e_read_phy_reg_mdic(hw, HV_DC_UPPER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04618"></a>04618                  &amp;phy_data);
<a name="l04619"></a>04619     ret_val = e1000e_read_phy_reg_mdic(hw,
<a name="l04620"></a>04620                        HV_DC_LOWER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04621"></a>04621                        &amp;phy_data);
<a name="l04622"></a>04622     <span class="keywordflow">if</span> (!ret_val)
<a name="l04623"></a>04623         adapter-&gt;stats.dc += phy_data;
<a name="l04624"></a>04624 
<a name="l04625"></a>04625     <span class="comment">/* Transmit with no CRS */</span>
<a name="l04626"></a>04626     e1000e_read_phy_reg_mdic(hw, HV_TNCRS_UPPER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04627"></a>04627                  &amp;phy_data);
<a name="l04628"></a>04628     ret_val = e1000e_read_phy_reg_mdic(hw,
<a name="l04629"></a>04629                        HV_TNCRS_LOWER &amp; MAX_PHY_REG_ADDRESS,
<a name="l04630"></a>04630                        &amp;phy_data);
<a name="l04631"></a>04631     <span class="keywordflow">if</span> (!ret_val)
<a name="l04632"></a>04632         adapter-&gt;stats.tncrs += phy_data;
<a name="l04633"></a>04633 
<a name="l04634"></a>04634 release:
<a name="l04635"></a>04635     hw-&gt;phy.ops.release(hw);
<a name="l04636"></a>04636 }
<a name="l04637"></a>04637 
<a name="l04642"></a>04642 <span class="keywordtype">void</span> e1000e_update_stats(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04643"></a>04643 {
<a name="l04644"></a>04644 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l04645"></a>04645 <span class="preprocessor"></span>    <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l04646"></a>04646 <span class="preprocessor">#endif</span>
<a name="l04647"></a>04647 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04648"></a>04648 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l04649"></a>04649 <span class="preprocessor"></span>    <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l04650"></a>04650 <span class="preprocessor">#endif</span>
<a name="l04651"></a>04651 <span class="preprocessor"></span>
<a name="l04652"></a>04652     <span class="comment">/*</span>
<a name="l04653"></a>04653 <span class="comment">     * Prevent stats update while adapter is being reset, or if the pci</span>
<a name="l04654"></a>04654 <span class="comment">     * connection is down.</span>
<a name="l04655"></a>04655 <span class="comment">     */</span>
<a name="l04656"></a>04656     <span class="keywordflow">if</span> (adapter-&gt;link_speed == 0)
<a name="l04657"></a>04657         <span class="keywordflow">return</span>;
<a name="l04658"></a>04658 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l04659"></a>04659 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (pci_channel_offline(pdev))
<a name="l04660"></a>04660         <span class="keywordflow">return</span>;
<a name="l04661"></a>04661 <span class="preprocessor">#endif</span>
<a name="l04662"></a>04662 <span class="preprocessor"></span>
<a name="l04663"></a>04663     adapter-&gt;stats.crcerrs += er32(CRCERRS);
<a name="l04664"></a>04664     adapter-&gt;stats.gprc += er32(GPRC);
<a name="l04665"></a>04665     adapter-&gt;stats.gorc += er32(GORCL);
<a name="l04666"></a>04666     er32(GORCH); <span class="comment">/* Clear gorc */</span>
<a name="l04667"></a>04667     adapter-&gt;stats.bprc += er32(BPRC);
<a name="l04668"></a>04668     adapter-&gt;stats.mprc += er32(MPRC);
<a name="l04669"></a>04669     adapter-&gt;stats.roc += er32(ROC);
<a name="l04670"></a>04670 
<a name="l04671"></a>04671     adapter-&gt;stats.mpc += er32(MPC);
<a name="l04672"></a>04672 
<a name="l04673"></a>04673     <span class="comment">/* Half-duplex statistics */</span>
<a name="l04674"></a>04674     <span class="keywordflow">if</span> (adapter-&gt;link_duplex == HALF_DUPLEX) {
<a name="l04675"></a>04675         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_HAS_PHY_STATS) {
<a name="l04676"></a>04676             e1000e_update_phy_stats(adapter);
<a name="l04677"></a>04677         } <span class="keywordflow">else</span> {
<a name="l04678"></a>04678             adapter-&gt;stats.scc += er32(SCC);
<a name="l04679"></a>04679             adapter-&gt;stats.ecol += er32(ECOL);
<a name="l04680"></a>04680             adapter-&gt;stats.mcc += er32(MCC);
<a name="l04681"></a>04681             adapter-&gt;stats.latecol += er32(LATECOL);
<a name="l04682"></a>04682             adapter-&gt;stats.dc += er32(DC);
<a name="l04683"></a>04683 
<a name="l04684"></a>04684             hw-&gt;mac.collision_delta = er32(COLC);
<a name="l04685"></a>04685 
<a name="l04686"></a>04686             <span class="keywordflow">if</span> ((hw-&gt;mac.type != e1000_82574) &amp;&amp;
<a name="l04687"></a>04687                 (hw-&gt;mac.type != e1000_82583))
<a name="l04688"></a>04688                 adapter-&gt;stats.tncrs += er32(TNCRS);
<a name="l04689"></a>04689         }
<a name="l04690"></a>04690         adapter-&gt;stats.colc += hw-&gt;mac.collision_delta;
<a name="l04691"></a>04691     }
<a name="l04692"></a>04692 
<a name="l04693"></a>04693     adapter-&gt;stats.xonrxc += er32(XONRXC);
<a name="l04694"></a>04694     adapter-&gt;stats.xontxc += er32(XONTXC);
<a name="l04695"></a>04695     adapter-&gt;stats.xoffrxc += er32(XOFFRXC);
<a name="l04696"></a>04696     adapter-&gt;stats.xofftxc += er32(XOFFTXC);
<a name="l04697"></a>04697     adapter-&gt;stats.gptc += er32(GPTC);
<a name="l04698"></a>04698     adapter-&gt;stats.gotc += er32(GOTCL);
<a name="l04699"></a>04699     er32(GOTCH); <span class="comment">/* Clear gotc */</span>
<a name="l04700"></a>04700     adapter-&gt;stats.rnbc += er32(RNBC);
<a name="l04701"></a>04701     adapter-&gt;stats.ruc += er32(RUC);
<a name="l04702"></a>04702 
<a name="l04703"></a>04703     adapter-&gt;stats.mptc += er32(MPTC);
<a name="l04704"></a>04704     adapter-&gt;stats.bptc += er32(BPTC);
<a name="l04705"></a>04705 
<a name="l04706"></a>04706     <span class="comment">/* used for adaptive IFS */</span>
<a name="l04707"></a>04707 
<a name="l04708"></a>04708     hw-&gt;mac.tx_packet_delta = er32(TPT);
<a name="l04709"></a>04709     adapter-&gt;stats.tpt += hw-&gt;mac.tx_packet_delta;
<a name="l04710"></a>04710 
<a name="l04711"></a>04711     adapter-&gt;stats.algnerrc += er32(ALGNERRC);
<a name="l04712"></a>04712     adapter-&gt;stats.rxerrc += er32(RXERRC);
<a name="l04713"></a>04713     adapter-&gt;stats.cexterr += er32(CEXTERR);
<a name="l04714"></a>04714     adapter-&gt;stats.tsctc += er32(TSCTC);
<a name="l04715"></a>04715     adapter-&gt;stats.tsctfc += er32(TSCTFC);
<a name="l04716"></a>04716 
<a name="l04717"></a>04717     <span class="comment">/* Fill out the OS statistics structure */</span>
<a name="l04718"></a>04718 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l04719"></a>04719 <span class="preprocessor"></span>    netdev-&gt;stats.multicast = adapter-&gt;stats.mprc;
<a name="l04720"></a>04720     netdev-&gt;stats.collisions = adapter-&gt;stats.colc;
<a name="l04721"></a>04721 <span class="preprocessor">#else</span>
<a name="l04722"></a>04722 <span class="preprocessor"></span>    adapter-&gt;net_stats.multicast = adapter-&gt;stats.mprc;
<a name="l04723"></a>04723     adapter-&gt;net_stats.collisions = adapter-&gt;stats.colc;
<a name="l04724"></a>04724 <span class="preprocessor">#endif</span>
<a name="l04725"></a>04725 <span class="preprocessor"></span>
<a name="l04726"></a>04726     <span class="comment">/* Rx Errors */</span>
<a name="l04727"></a>04727 
<a name="l04728"></a>04728     <span class="comment">/*</span>
<a name="l04729"></a>04729 <span class="comment">     * RLEC on some newer hardware can be incorrect so build</span>
<a name="l04730"></a>04730 <span class="comment">     * our own version based on RUC and ROC</span>
<a name="l04731"></a>04731 <span class="comment">     */</span>
<a name="l04732"></a>04732 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l04733"></a>04733 <span class="preprocessor"></span>    netdev-&gt;stats.rx_errors = adapter-&gt;stats.rxerrc +
<a name="l04734"></a>04734 <span class="preprocessor">#else</span>
<a name="l04735"></a>04735 <span class="preprocessor"></span>    adapter-&gt;net_stats.rx_errors = adapter-&gt;stats.rxerrc +
<a name="l04736"></a>04736 <span class="preprocessor">#endif</span>
<a name="l04737"></a>04737 <span class="preprocessor"></span>        adapter-&gt;stats.crcerrs + adapter-&gt;stats.algnerrc +
<a name="l04738"></a>04738         adapter-&gt;stats.ruc + adapter-&gt;stats.roc +
<a name="l04739"></a>04739         adapter-&gt;stats.cexterr;
<a name="l04740"></a>04740 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l04741"></a>04741 <span class="preprocessor"></span>    netdev-&gt;stats.rx_length_errors = adapter-&gt;stats.ruc +
<a name="l04742"></a>04742                           adapter-&gt;stats.roc;
<a name="l04743"></a>04743     netdev-&gt;stats.rx_crc_errors = adapter-&gt;stats.crcerrs;
<a name="l04744"></a>04744     netdev-&gt;stats.rx_frame_errors = adapter-&gt;stats.algnerrc;
<a name="l04745"></a>04745     netdev-&gt;stats.rx_missed_errors = adapter-&gt;stats.mpc;
<a name="l04746"></a>04746 <span class="preprocessor">#else</span>
<a name="l04747"></a>04747 <span class="preprocessor"></span>    adapter-&gt;net_stats.rx_length_errors = adapter-&gt;stats.ruc +
<a name="l04748"></a>04748                           adapter-&gt;stats.roc;
<a name="l04749"></a>04749     adapter-&gt;net_stats.rx_crc_errors = adapter-&gt;stats.crcerrs;
<a name="l04750"></a>04750     adapter-&gt;net_stats.rx_frame_errors = adapter-&gt;stats.algnerrc;
<a name="l04751"></a>04751     adapter-&gt;net_stats.rx_missed_errors = adapter-&gt;stats.mpc;
<a name="l04752"></a>04752 <span class="preprocessor">#endif</span>
<a name="l04753"></a>04753 <span class="preprocessor"></span>
<a name="l04754"></a>04754     <span class="comment">/* Tx Errors */</span>
<a name="l04755"></a>04755 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l04756"></a>04756 <span class="preprocessor"></span>    netdev-&gt;stats.tx_errors = adapter-&gt;stats.ecol +
<a name="l04757"></a>04757                        adapter-&gt;stats.latecol;
<a name="l04758"></a>04758     netdev-&gt;stats.tx_aborted_errors = adapter-&gt;stats.ecol;
<a name="l04759"></a>04759     netdev-&gt;stats.tx_window_errors = adapter-&gt;stats.latecol;
<a name="l04760"></a>04760     netdev-&gt;stats.tx_carrier_errors = adapter-&gt;stats.tncrs;
<a name="l04761"></a>04761 <span class="preprocessor">#else</span>
<a name="l04762"></a>04762 <span class="preprocessor"></span>    adapter-&gt;net_stats.tx_errors = adapter-&gt;stats.ecol +
<a name="l04763"></a>04763                        adapter-&gt;stats.latecol;
<a name="l04764"></a>04764     adapter-&gt;net_stats.tx_aborted_errors = adapter-&gt;stats.ecol;
<a name="l04765"></a>04765     adapter-&gt;net_stats.tx_window_errors = adapter-&gt;stats.latecol;
<a name="l04766"></a>04766     adapter-&gt;net_stats.tx_carrier_errors = adapter-&gt;stats.tncrs;
<a name="l04767"></a>04767 <span class="preprocessor">#endif</span>
<a name="l04768"></a>04768 <span class="preprocessor"></span>
<a name="l04769"></a>04769     <span class="comment">/* Tx Dropped needs to be maintained elsewhere */</span>
<a name="l04770"></a>04770 
<a name="l04771"></a>04771     <span class="comment">/* Management Stats */</span>
<a name="l04772"></a>04772     adapter-&gt;stats.mgptc += er32(MGTPTC);
<a name="l04773"></a>04773     adapter-&gt;stats.mgprc += er32(MGTPRC);
<a name="l04774"></a>04774     adapter-&gt;stats.mgpdc += er32(MGTPDC);
<a name="l04775"></a>04775 }
<a name="l04776"></a>04776 
<a name="l04777"></a>04777 <span class="preprocessor">#ifdef SIOCGMIIPHY</span>
<a name="l04778"></a>04778 <span class="preprocessor"></span>
<a name="l04782"></a>04782 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_phy_read_status(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04783"></a>04783 {
<a name="l04784"></a>04784     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04785"></a>04785     <span class="keyword">struct </span>e1000_phy_regs *phy = &amp;adapter-&gt;phy_regs;
<a name="l04786"></a>04786 
<a name="l04787"></a>04787     <span class="keywordflow">if</span> ((er32(STATUS) &amp; E1000_STATUS_LU) &amp;&amp;
<a name="l04788"></a>04788         (adapter-&gt;hw.phy.media_type == e1000_media_type_copper)) {
<a name="l04789"></a>04789         <span class="keywordtype">int</span> ret_val;
<a name="l04790"></a>04790 
<a name="l04791"></a>04791         ret_val  = e1e_rphy(hw, PHY_CONTROL, &amp;phy-&gt;bmcr);
<a name="l04792"></a>04792         ret_val |= e1e_rphy(hw, PHY_STATUS, &amp;phy-&gt;bmsr);
<a name="l04793"></a>04793         ret_val |= e1e_rphy(hw, PHY_AUTONEG_ADV, &amp;phy-&gt;advertise);
<a name="l04794"></a>04794         ret_val |= e1e_rphy(hw, PHY_LP_ABILITY, &amp;phy-&gt;lpa);
<a name="l04795"></a>04795         ret_val |= e1e_rphy(hw, PHY_AUTONEG_EXP, &amp;phy-&gt;expansion);
<a name="l04796"></a>04796         ret_val |= e1e_rphy(hw, PHY_1000T_CTRL, &amp;phy-&gt;ctrl1000);
<a name="l04797"></a>04797         ret_val |= e1e_rphy(hw, PHY_1000T_STATUS, &amp;phy-&gt;stat1000);
<a name="l04798"></a>04798         ret_val |= e1e_rphy(hw, PHY_EXT_STATUS, &amp;phy-&gt;estatus);
<a name="l04799"></a>04799         <span class="keywordflow">if</span> (ret_val)
<a name="l04800"></a>04800             e_warn(<span class="stringliteral">&quot;Error reading PHY register\n&quot;</span>);
<a name="l04801"></a>04801     } <span class="keywordflow">else</span> {
<a name="l04802"></a>04802         <span class="comment">/*</span>
<a name="l04803"></a>04803 <span class="comment">         * Do not read PHY registers if link is not up</span>
<a name="l04804"></a>04804 <span class="comment">         * Set values to typical power-on defaults</span>
<a name="l04805"></a>04805 <span class="comment">         */</span>
<a name="l04806"></a>04806         phy-&gt;bmcr = (BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_FULLDPLX);
<a name="l04807"></a>04807         phy-&gt;bmsr = (BMSR_100FULL | BMSR_100HALF | BMSR_10FULL |
<a name="l04808"></a>04808                  BMSR_10HALF | BMSR_ESTATEN | BMSR_ANEGCAPABLE |
<a name="l04809"></a>04809                  BMSR_ERCAP);
<a name="l04810"></a>04810         phy-&gt;advertise = (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP |
<a name="l04811"></a>04811                   ADVERTISE_ALL | ADVERTISE_CSMA);
<a name="l04812"></a>04812         phy-&gt;lpa = 0;
<a name="l04813"></a>04813         phy-&gt;expansion = EXPANSION_ENABLENPAGE;
<a name="l04814"></a>04814         phy-&gt;ctrl1000 = ADVERTISE_1000FULL;
<a name="l04815"></a>04815         phy-&gt;stat1000 = 0;
<a name="l04816"></a>04816         phy-&gt;estatus = (ESTATUS_1000_TFULL | ESTATUS_1000_THALF);
<a name="l04817"></a>04817     }
<a name="l04818"></a>04818 }
<a name="l04819"></a>04819 
<a name="l04820"></a>04820 <span class="preprocessor">#endif </span><span class="comment">/* SIOCGMIIPHY */</span>
<a name="l04821"></a>04821 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_print_link_info(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04822"></a>04822 {
<a name="l04823"></a>04823     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04824"></a>04824     u32 ctrl = er32(CTRL);
<a name="l04825"></a>04825 
<a name="l04826"></a>04826     <span class="comment">/* Link status message must follow this format for user tools */</span>
<a name="l04827"></a>04827     printk(KERN_INFO <span class="stringliteral">&quot;e1000e: %s NIC Link is Up %d Mbps %s, &quot;</span>
<a name="l04828"></a>04828            <span class="stringliteral">&quot;Flow Control: %s\n&quot;</span>,
<a name="l04829"></a>04829            adapter-&gt;netdev-&gt;name,
<a name="l04830"></a>04830            adapter-&gt;link_speed,
<a name="l04831"></a>04831            (adapter-&gt;link_duplex == FULL_DUPLEX) ?
<a name="l04832"></a>04832                             <span class="stringliteral">&quot;Full Duplex&quot;</span> : <span class="stringliteral">&quot;Half Duplex&quot;</span>,
<a name="l04833"></a>04833            ((ctrl &amp; E1000_CTRL_TFCE) &amp;&amp; (ctrl &amp; E1000_CTRL_RFCE)) ?
<a name="l04834"></a>04834                             <span class="stringliteral">&quot;Rx/Tx&quot;</span> :
<a name="l04835"></a>04835            ((ctrl &amp; E1000_CTRL_RFCE) ? <span class="stringliteral">&quot;Rx&quot;</span> :
<a name="l04836"></a>04836            ((ctrl &amp; E1000_CTRL_TFCE) ? <span class="stringliteral">&quot;Tx&quot;</span> : <span class="stringliteral">&quot;None&quot;</span>)));
<a name="l04837"></a>04837 }
<a name="l04838"></a>04838 
<a name="l04839"></a>04839 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000e_has_link(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04840"></a>04840 {
<a name="l04841"></a>04841     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04842"></a>04842     <span class="keywordtype">bool</span> link_active = 0;
<a name="l04843"></a>04843     s32 ret_val = 0;
<a name="l04844"></a>04844 
<a name="l04845"></a>04845     <span class="comment">/*</span>
<a name="l04846"></a>04846 <span class="comment">     * get_link_status is set on LSC (link status) interrupt or</span>
<a name="l04847"></a>04847 <span class="comment">     * Rx sequence error interrupt.  get_link_status will stay</span>
<a name="l04848"></a>04848 <span class="comment">     * false until the check_for_link establishes link</span>
<a name="l04849"></a>04849 <span class="comment">     * for copper adapters ONLY</span>
<a name="l04850"></a>04850 <span class="comment">     */</span>
<a name="l04851"></a>04851     <span class="keywordflow">switch</span> (hw-&gt;phy.media_type) {
<a name="l04852"></a>04852     <span class="keywordflow">case</span> e1000_media_type_copper:
<a name="l04853"></a>04853         <span class="keywordflow">if</span> (hw-&gt;mac.get_link_status) {
<a name="l04854"></a>04854             ret_val = hw-&gt;mac.ops.check_for_link(hw);
<a name="l04855"></a>04855             link_active = !hw-&gt;mac.get_link_status;
<a name="l04856"></a>04856         } <span class="keywordflow">else</span> {
<a name="l04857"></a>04857             link_active = 1;
<a name="l04858"></a>04858         }
<a name="l04859"></a>04859         <span class="keywordflow">break</span>;
<a name="l04860"></a>04860     <span class="keywordflow">case</span> e1000_media_type_fiber:
<a name="l04861"></a>04861         ret_val = hw-&gt;mac.ops.check_for_link(hw);
<a name="l04862"></a>04862         link_active = !!(er32(STATUS) &amp; E1000_STATUS_LU);
<a name="l04863"></a>04863         <span class="keywordflow">break</span>;
<a name="l04864"></a>04864     <span class="keywordflow">case</span> e1000_media_type_internal_serdes:
<a name="l04865"></a>04865         ret_val = hw-&gt;mac.ops.check_for_link(hw);
<a name="l04866"></a>04866         link_active = adapter-&gt;hw.mac.serdes_has_link;
<a name="l04867"></a>04867         <span class="keywordflow">break</span>;
<a name="l04868"></a>04868     <span class="keywordflow">default</span>:
<a name="l04869"></a>04869     <span class="keywordflow">case</span> e1000_media_type_unknown:
<a name="l04870"></a>04870         <span class="keywordflow">break</span>;
<a name="l04871"></a>04871     }
<a name="l04872"></a>04872 
<a name="l04873"></a>04873     <span class="keywordflow">if</span> ((ret_val == E1000_ERR_PHY) &amp;&amp; (hw-&gt;phy.type == e1000_phy_igp_3) &amp;&amp;
<a name="l04874"></a>04874         (er32(CTRL) &amp; E1000_PHY_CTRL_GBE_DISABLE)) {
<a name="l04875"></a>04875         <span class="comment">/* See e1000_kmrn_lock_loss_workaround_ich8lan() */</span>
<a name="l04876"></a>04876         e_info(<span class="stringliteral">&quot;Gigabit has been disabled, downgrading speed\n&quot;</span>);
<a name="l04877"></a>04877     }
<a name="l04878"></a>04878 
<a name="l04879"></a>04879     <span class="keywordflow">return</span> link_active;
<a name="l04880"></a>04880 }
<a name="l04881"></a>04881 
<a name="l04882"></a>04882 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_enable_receives(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04883"></a>04883 {
<a name="l04884"></a>04884     <span class="comment">/* make sure the receive unit is started */</span>
<a name="l04885"></a>04885     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_RX_NEEDS_RESTART) &amp;&amp;
<a name="l04886"></a>04886         (adapter-&gt;flags &amp; FLAG_RX_RESTART_NOW)) {
<a name="l04887"></a>04887         <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04888"></a>04888         u32 rctl = er32(RCTL);
<a name="l04889"></a>04889         ew32(RCTL, rctl | E1000_RCTL_EN);
<a name="l04890"></a>04890         adapter-&gt;flags &amp;= ~FLAG_RX_RESTART_NOW;
<a name="l04891"></a>04891     }
<a name="l04892"></a>04892 }
<a name="l04893"></a>04893 
<a name="l04894"></a>04894 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_check_82574_phy_workaround(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l04895"></a>04895 {
<a name="l04896"></a>04896     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04897"></a>04897 
<a name="l04898"></a>04898     <span class="comment">/*</span>
<a name="l04899"></a>04899 <span class="comment">     * With 82574 controllers, PHY needs to be checked periodically</span>
<a name="l04900"></a>04900 <span class="comment">     * for hung state and reset, if two calls return true</span>
<a name="l04901"></a>04901 <span class="comment">     */</span>
<a name="l04902"></a>04902     <span class="keywordflow">if</span> (e1000_check_phy_82574(hw))
<a name="l04903"></a>04903         adapter-&gt;phy_hang_count++;
<a name="l04904"></a>04904     <span class="keywordflow">else</span>
<a name="l04905"></a>04905         adapter-&gt;phy_hang_count = 0;
<a name="l04906"></a>04906 
<a name="l04907"></a>04907     <span class="keywordflow">if</span> (adapter-&gt;phy_hang_count &gt; 1) {
<a name="l04908"></a>04908         adapter-&gt;phy_hang_count = 0;
<a name="l04909"></a>04909         schedule_work(&amp;adapter-&gt;reset_task);
<a name="l04910"></a>04910     }
<a name="l04911"></a>04911 }
<a name="l04912"></a>04912 
<a name="l04917"></a>04917 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_watchdog(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l04918"></a>04918 {
<a name="l04919"></a>04919     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = (<span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *) data;
<a name="l04920"></a>04920 
<a name="l04921"></a>04921     <span class="comment">/* Do the rest outside of interrupt context */</span>
<a name="l04922"></a>04922     schedule_work(&amp;adapter-&gt;watchdog_task);
<a name="l04923"></a>04923 
<a name="l04924"></a>04924     <span class="comment">/* TODO: make this use queue_delayed_work() */</span>
<a name="l04925"></a>04925 }
<a name="l04926"></a>04926 
<a name="l04927"></a>04927 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_watchdog_task(<span class="keyword">struct</span> work_struct *work)
<a name="l04928"></a>04928 {
<a name="l04929"></a>04929     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = container_of(work,
<a name="l04930"></a>04930                     <span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a>, watchdog_task);
<a name="l04931"></a>04931     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l04932"></a>04932     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;adapter-&gt;hw.mac;
<a name="l04933"></a>04933     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;adapter-&gt;hw.phy;
<a name="l04934"></a>04934     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l04935"></a>04935     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04936"></a>04936     u32 link, tctl;
<a name="l04937"></a>04937 
<a name="l04938"></a>04938     <span class="keywordflow">if</span> (test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l04939"></a>04939         <span class="keywordflow">return</span>;
<a name="l04940"></a>04940 
<a name="l04941"></a>04941     link = e1000e_has_link(adapter);
<a name="l04942"></a>04942     <span class="keywordflow">if</span> ((netif_carrier_ok(netdev)) &amp;&amp; link) {
<a name="l04943"></a>04943         <span class="comment">/* Cancel scheduled suspend requests. */</span>
<a name="l04944"></a>04944         pm_runtime_resume(netdev-&gt;dev.parent);
<a name="l04945"></a>04945 
<a name="l04946"></a>04946         e1000e_enable_receives(adapter);
<a name="l04947"></a>04947         <span class="keywordflow">goto</span> link_up;
<a name="l04948"></a>04948     }
<a name="l04949"></a>04949 
<a name="l04950"></a>04950 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l04951"></a>04951 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((e1000e_enable_tx_pkt_filtering(hw)) &amp;&amp;
<a name="l04952"></a>04952         (adapter-&gt;mng_vlan_id != adapter-&gt;hw.mng_cookie.vlan_id))
<a name="l04953"></a>04953         e1000_update_mng_vlan(adapter);
<a name="l04954"></a>04954 
<a name="l04955"></a>04955 <span class="preprocessor">#endif</span>
<a name="l04956"></a>04956 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (link) {
<a name="l04957"></a>04957         <span class="keywordflow">if</span> (!netif_carrier_ok(netdev)) {
<a name="l04958"></a>04958             <span class="keywordtype">bool</span> txb2b = 1;
<a name="l04959"></a>04959 
<a name="l04960"></a>04960             <span class="comment">/* Cancel scheduled suspend requests. */</span>
<a name="l04961"></a>04961             pm_runtime_resume(netdev-&gt;dev.parent);
<a name="l04962"></a>04962 
<a name="l04963"></a>04963 <span class="preprocessor">#ifdef SIOCGMIIPHY</span>
<a name="l04964"></a>04964 <span class="preprocessor"></span>            <span class="comment">/* update snapshot of PHY registers on LSC */</span>
<a name="l04965"></a>04965             e1000_phy_read_status(adapter);
<a name="l04966"></a>04966 <span class="preprocessor">#endif</span>
<a name="l04967"></a>04967 <span class="preprocessor"></span>            mac-&gt;ops.get_link_up_info(&amp;adapter-&gt;hw,
<a name="l04968"></a>04968                            &amp;adapter-&gt;link_speed,
<a name="l04969"></a>04969                            &amp;adapter-&gt;link_duplex);
<a name="l04970"></a>04970             e1000_print_link_info(adapter);
<a name="l04971"></a>04971             <span class="comment">/*</span>
<a name="l04972"></a>04972 <span class="comment">             * On supported PHYs, check for duplex mismatch only</span>
<a name="l04973"></a>04973 <span class="comment">             * if link has autonegotiated at 10/100 half</span>
<a name="l04974"></a>04974 <span class="comment">             */</span>
<a name="l04975"></a>04975             <span class="keywordflow">if</span> ((hw-&gt;phy.type == e1000_phy_igp_3 ||
<a name="l04976"></a>04976                  hw-&gt;phy.type == e1000_phy_bm) &amp;&amp;
<a name="l04977"></a>04977                 (hw-&gt;mac.autoneg == <span class="keyword">true</span>) &amp;&amp;
<a name="l04978"></a>04978                 (adapter-&gt;link_speed == SPEED_10 ||
<a name="l04979"></a>04979                  adapter-&gt;link_speed == SPEED_100) &amp;&amp;
<a name="l04980"></a>04980                 (adapter-&gt;link_duplex == HALF_DUPLEX)) {
<a name="l04981"></a>04981                 u16 autoneg_exp;
<a name="l04982"></a>04982 
<a name="l04983"></a>04983                 e1e_rphy(hw, PHY_AUTONEG_EXP, &amp;autoneg_exp);
<a name="l04984"></a>04984 
<a name="l04985"></a>04985                 <span class="keywordflow">if</span> (!(autoneg_exp &amp; NWAY_ER_LP_NWAY_CAPS))
<a name="l04986"></a>04986                     e_info(<span class="stringliteral">&quot;Autonegotiated half duplex but&quot;</span>
<a name="l04987"></a>04987                            <span class="stringliteral">&quot; link partner cannot autoneg. &quot;</span>
<a name="l04988"></a>04988                            <span class="stringliteral">&quot; Try forcing full duplex if &quot;</span>
<a name="l04989"></a>04989                            <span class="stringliteral">&quot;link gets many collisions.\n&quot;</span>);
<a name="l04990"></a>04990             }
<a name="l04991"></a>04991 
<a name="l04992"></a>04992             <span class="comment">/* adjust timeout factor according to speed/duplex */</span>
<a name="l04993"></a>04993             adapter-&gt;tx_timeout_factor = 1;
<a name="l04994"></a>04994             <span class="keywordflow">switch</span> (adapter-&gt;link_speed) {
<a name="l04995"></a>04995             <span class="keywordflow">case</span> SPEED_10:
<a name="l04996"></a>04996                 txb2b = 0;
<a name="l04997"></a>04997                 adapter-&gt;tx_timeout_factor = 16;
<a name="l04998"></a>04998                 <span class="keywordflow">break</span>;
<a name="l04999"></a>04999             <span class="keywordflow">case</span> SPEED_100:
<a name="l05000"></a>05000                 txb2b = 0;
<a name="l05001"></a>05001                 adapter-&gt;tx_timeout_factor = 10;
<a name="l05002"></a>05002                 <span class="keywordflow">break</span>;
<a name="l05003"></a>05003             }
<a name="l05004"></a>05004 
<a name="l05005"></a>05005             <span class="comment">/*</span>
<a name="l05006"></a>05006 <span class="comment">             * workaround: re-program speed mode bit after</span>
<a name="l05007"></a>05007 <span class="comment">             * link-up event</span>
<a name="l05008"></a>05008 <span class="comment">             */</span>
<a name="l05009"></a>05009             <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_TARC_SPEED_MODE_BIT) &amp;&amp;
<a name="l05010"></a>05010                 !txb2b) {
<a name="l05011"></a>05011                 u32 tarc0;
<a name="l05012"></a>05012                 tarc0 = er32(TARC(0));
<a name="l05013"></a>05013                 tarc0 &amp;= ~SPEED_MODE_BIT;
<a name="l05014"></a>05014                 ew32(TARC(0), tarc0);
<a name="l05015"></a>05015             }
<a name="l05016"></a>05016 
<a name="l05017"></a>05017 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l05018"></a>05018 <span class="preprocessor"></span>            <span class="comment">/*</span>
<a name="l05019"></a>05019 <span class="comment">             * disable TSO for pcie and 10/100 speeds, to avoid</span>
<a name="l05020"></a>05020 <span class="comment">             * some hardware issues</span>
<a name="l05021"></a>05021 <span class="comment">             */</span>
<a name="l05022"></a>05022             <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_TSO_FORCE)) {
<a name="l05023"></a>05023                 <span class="keywordflow">switch</span> (adapter-&gt;link_speed) {
<a name="l05024"></a>05024                 <span class="keywordflow">case</span> SPEED_10:
<a name="l05025"></a>05025                 <span class="keywordflow">case</span> SPEED_100:
<a name="l05026"></a>05026                     e_info(<span class="stringliteral">&quot;10/100 speed: disabling TSO\n&quot;</span>);
<a name="l05027"></a>05027                     netdev-&gt;features &amp;= ~NETIF_F_TSO;
<a name="l05028"></a>05028 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l05029"></a>05029 <span class="preprocessor"></span>                    netdev-&gt;features &amp;= ~NETIF_F_TSO6;
<a name="l05030"></a>05030 <span class="preprocessor">#endif</span>
<a name="l05031"></a>05031 <span class="preprocessor"></span>                    <span class="keywordflow">break</span>;
<a name="l05032"></a>05032                 <span class="keywordflow">case</span> SPEED_1000:
<a name="l05033"></a>05033                     netdev-&gt;features |= NETIF_F_TSO;
<a name="l05034"></a>05034 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l05035"></a>05035 <span class="preprocessor"></span>                    netdev-&gt;features |= NETIF_F_TSO6;
<a name="l05036"></a>05036 <span class="preprocessor">#endif</span>
<a name="l05037"></a>05037 <span class="preprocessor"></span>                    <span class="keywordflow">break</span>;
<a name="l05038"></a>05038                 <span class="keywordflow">default</span>:
<a name="l05039"></a>05039                     <span class="comment">/* oops */</span>
<a name="l05040"></a>05040                     <span class="keywordflow">break</span>;
<a name="l05041"></a>05041                 }
<a name="l05042"></a>05042             }
<a name="l05043"></a>05043 <span class="preprocessor">#endif</span>
<a name="l05044"></a>05044 <span class="preprocessor"></span>
<a name="l05045"></a>05045             <span class="comment">/*</span>
<a name="l05046"></a>05046 <span class="comment">             * enable transmits in the hardware, need to do this</span>
<a name="l05047"></a>05047 <span class="comment">             * after setting TARC(0)</span>
<a name="l05048"></a>05048 <span class="comment">             */</span>
<a name="l05049"></a>05049             tctl = er32(TCTL);
<a name="l05050"></a>05050             tctl |= E1000_TCTL_EN;
<a name="l05051"></a>05051             ew32(TCTL, tctl);
<a name="l05052"></a>05052 
<a name="l05053"></a>05053             <span class="comment">/*</span>
<a name="l05054"></a>05054 <span class="comment">             * Perform any post-link-up configuration before</span>
<a name="l05055"></a>05055 <span class="comment">             * reporting link up.</span>
<a name="l05056"></a>05056 <span class="comment">             */</span>
<a name="l05057"></a>05057             <span class="keywordflow">if</span> (phy-&gt;ops.cfg_on_link_up)
<a name="l05058"></a>05058                 phy-&gt;ops.cfg_on_link_up(hw);
<a name="l05059"></a>05059 
<a name="l05060"></a>05060             netif_carrier_on(netdev);
<a name="l05061"></a>05061             netif_wake_queue(netdev);
<a name="l05062"></a>05062 
<a name="l05063"></a>05063             <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l05064"></a>05064                 mod_timer(&amp;adapter-&gt;phy_info_timer,
<a name="l05065"></a>05065                       round_jiffies(jiffies + 2 * HZ));
<a name="l05066"></a>05066         }
<a name="l05067"></a>05067     } <span class="keywordflow">else</span> {
<a name="l05068"></a>05068         <span class="keywordflow">if</span> (netif_carrier_ok(netdev)) {
<a name="l05069"></a>05069             adapter-&gt;link_speed = 0;
<a name="l05070"></a>05070             adapter-&gt;link_duplex = 0;
<a name="l05071"></a>05071             <span class="comment">/* Link status message must follow this format */</span>
<a name="l05072"></a>05072             printk(KERN_INFO <span class="stringliteral">&quot;e1000e: %s NIC Link is Down\n&quot;</span>,
<a name="l05073"></a>05073                    adapter-&gt;netdev-&gt;name);
<a name="l05074"></a>05074             netif_carrier_off(netdev);
<a name="l05075"></a>05075             <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l05076"></a>05076                 mod_timer(&amp;adapter-&gt;phy_info_timer,
<a name="l05077"></a>05077                       round_jiffies(jiffies + 2 * HZ));
<a name="l05078"></a>05078 
<a name="l05079"></a>05079             <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_RX_NEEDS_RESTART)
<a name="l05080"></a>05080                 schedule_work(&amp;adapter-&gt;reset_task);
<a name="l05081"></a>05081             <span class="keywordflow">else</span>
<a name="l05082"></a>05082                 pm_schedule_suspend(netdev-&gt;dev.parent,
<a name="l05083"></a>05083                             LINK_TIMEOUT);
<a name="l05084"></a>05084         }
<a name="l05085"></a>05085     }
<a name="l05086"></a>05086 
<a name="l05087"></a>05087 link_up:
<a name="l05088"></a>05088     e1000e_update_stats(adapter);
<a name="l05089"></a>05089 
<a name="l05090"></a>05090     mac-&gt;tx_packet_delta = adapter-&gt;stats.tpt - adapter-&gt;tpt_old;
<a name="l05091"></a>05091     adapter-&gt;tpt_old = adapter-&gt;stats.tpt;
<a name="l05092"></a>05092     mac-&gt;collision_delta = adapter-&gt;stats.colc - adapter-&gt;colc_old;
<a name="l05093"></a>05093     adapter-&gt;colc_old = adapter-&gt;stats.colc;
<a name="l05094"></a>05094 
<a name="l05095"></a>05095     adapter-&gt;gorc = adapter-&gt;stats.gorc - adapter-&gt;gorc_old;
<a name="l05096"></a>05096     adapter-&gt;gorc_old = adapter-&gt;stats.gorc;
<a name="l05097"></a>05097     adapter-&gt;gotc = adapter-&gt;stats.gotc - adapter-&gt;gotc_old;
<a name="l05098"></a>05098     adapter-&gt;gotc_old = adapter-&gt;stats.gotc;
<a name="l05099"></a>05099 
<a name="l05100"></a>05100     e1000e_update_adaptive(&amp;adapter-&gt;hw);
<a name="l05101"></a>05101 
<a name="l05102"></a>05102     <span class="keywordflow">if</span> (!netif_carrier_ok(netdev) &amp;&amp;
<a name="l05103"></a>05103         (e1000_desc_unused(tx_ring) + 1 &lt; tx_ring-&gt;count)) {
<a name="l05104"></a>05104         <span class="comment">/*</span>
<a name="l05105"></a>05105 <span class="comment">         * We&#39;ve lost link, so the controller stops DMA,</span>
<a name="l05106"></a>05106 <span class="comment">         * but we&#39;ve got queued Tx work that&#39;s never going</span>
<a name="l05107"></a>05107 <span class="comment">         * to get done, so reset controller to flush Tx.</span>
<a name="l05108"></a>05108 <span class="comment">         * (Do the reset outside of interrupt context).</span>
<a name="l05109"></a>05109 <span class="comment">         */</span>
<a name="l05110"></a>05110         schedule_work(&amp;adapter-&gt;reset_task);
<a name="l05111"></a>05111         <span class="comment">/* return immediately since reset is imminent */</span>
<a name="l05112"></a>05112         <span class="keywordflow">return</span>;
<a name="l05113"></a>05113     }
<a name="l05114"></a>05114 
<a name="l05115"></a>05115     <span class="comment">/* Simple mode for Interrupt Throttle Rate (ITR) */</span>
<a name="l05116"></a>05116     <span class="keywordflow">if</span> (adapter-&gt;itr_setting == 4) {
<a name="l05117"></a>05117         <span class="comment">/*</span>
<a name="l05118"></a>05118 <span class="comment">         * Symmetric Tx/Rx gets a reduced ITR=2000;</span>
<a name="l05119"></a>05119 <span class="comment">         * Total asymmetrical Tx or Rx gets ITR=8000;</span>
<a name="l05120"></a>05120 <span class="comment">         * everyone else is between 2000-8000.</span>
<a name="l05121"></a>05121 <span class="comment">         */</span>
<a name="l05122"></a>05122         u32 goc = (adapter-&gt;gotc + adapter-&gt;gorc) / 10000;
<a name="l05123"></a>05123         u32 dif = (adapter-&gt;gotc &gt; adapter-&gt;gorc ?
<a name="l05124"></a>05124                 adapter-&gt;gotc - adapter-&gt;gorc :
<a name="l05125"></a>05125                 adapter-&gt;gorc - adapter-&gt;gotc) / 10000;
<a name="l05126"></a>05126         u32 itr = goc &gt; 0 ? (dif * 6000 / goc + 2000) : 8000;
<a name="l05127"></a>05127 
<a name="l05128"></a>05128         ew32(ITR, 1000000000 / (itr * 256));
<a name="l05129"></a>05129     }
<a name="l05130"></a>05130 
<a name="l05131"></a>05131     <span class="comment">/* Cause software interrupt to ensure Rx ring is cleaned */</span>
<a name="l05132"></a>05132 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l05133"></a>05133 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;msix_entries)
<a name="l05134"></a>05134         ew32(ICS, adapter-&gt;rx_ring-&gt;ims_val);
<a name="l05135"></a>05135     <span class="keywordflow">else</span>
<a name="l05136"></a>05136         ew32(ICS, E1000_ICS_RXDMT0);
<a name="l05137"></a>05137 <span class="preprocessor">#else</span>
<a name="l05138"></a>05138 <span class="preprocessor"></span>    ew32(ICS, E1000_ICS_RXDMT0);
<a name="l05139"></a>05139 <span class="preprocessor">#endif</span>
<a name="l05140"></a>05140 <span class="preprocessor"></span>
<a name="l05141"></a>05141     <span class="comment">/* flush pending descriptors to memory before detecting Tx hang */</span>
<a name="l05142"></a>05142     e1000e_flush_descriptors(adapter);
<a name="l05143"></a>05143 
<a name="l05144"></a>05144     <span class="comment">/* Force detection of hung controller every watchdog period */</span>
<a name="l05145"></a>05145     adapter-&gt;detect_tx_hung = 1;
<a name="l05146"></a>05146 
<a name="l05147"></a>05147     <span class="comment">/*</span>
<a name="l05148"></a>05148 <span class="comment">     * With 82571 controllers, LAA may be overwritten due to controller</span>
<a name="l05149"></a>05149 <span class="comment">     * reset from the other port. Set the appropriate LAA in RAR[0]</span>
<a name="l05150"></a>05150 <span class="comment">     */</span>
<a name="l05151"></a>05151     <span class="keywordflow">if</span> (e1000e_get_laa_state_82571(hw))
<a name="l05152"></a>05152         e1000e_rar_set(hw, adapter-&gt;hw.mac.addr, 0);
<a name="l05153"></a>05153 
<a name="l05154"></a>05154     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_CHECK_PHY_HANG)
<a name="l05155"></a>05155         e1000e_check_82574_phy_workaround(adapter);
<a name="l05156"></a>05156 
<a name="l05157"></a>05157     <span class="comment">/* Reset the timer */</span>
<a name="l05158"></a>05158     <span class="keywordflow">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l05159"></a>05159         mod_timer(&amp;adapter-&gt;watchdog_timer,
<a name="l05160"></a>05160               round_jiffies(jiffies + 2 * HZ));
<a name="l05161"></a>05161 }
<a name="l05162"></a>05162 
<a name="l05163"></a>05163 <span class="preprocessor">#define E1000_TX_FLAGS_CSUM     0x00000001</span>
<a name="l05164"></a>05164 <span class="preprocessor"></span><span class="preprocessor">#define E1000_TX_FLAGS_VLAN     0x00000002</span>
<a name="l05165"></a>05165 <span class="preprocessor"></span><span class="preprocessor">#define E1000_TX_FLAGS_TSO      0x00000004</span>
<a name="l05166"></a>05166 <span class="preprocessor"></span><span class="preprocessor">#define E1000_TX_FLAGS_IPV4     0x00000008</span>
<a name="l05167"></a>05167 <span class="preprocessor"></span><span class="preprocessor">#define E1000_TX_FLAGS_VLAN_MASK    0xffff0000</span>
<a name="l05168"></a>05168 <span class="preprocessor"></span><span class="preprocessor">#define E1000_TX_FLAGS_VLAN_SHIFT   16</span>
<a name="l05169"></a>05169 <span class="preprocessor"></span>
<a name="l05170"></a>05170 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_tso(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l05171"></a>05171              <span class="keyword">struct</span> sk_buff *skb)
<a name="l05172"></a>05172 {
<a name="l05173"></a>05173 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l05174"></a>05174 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l05175"></a>05175     <span class="keyword">struct </span><a class="code" href="structe1000__context__desc.html">e1000_context_desc</a> *context_desc;
<a name="l05176"></a>05176     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l05177"></a>05177     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l05178"></a>05178     u32 cmd_length = 0;
<a name="l05179"></a>05179     u16 ipcse = 0, tucse, mss;
<a name="l05180"></a>05180     u8 ipcss, ipcso, tucss, tucso, hdr_len;
<a name="l05181"></a>05181 
<a name="l05182"></a>05182     <span class="keywordflow">if</span> (!skb_is_gso(skb))
<a name="l05183"></a>05183         <span class="keywordflow">return</span> 0;
<a name="l05184"></a>05184 
<a name="l05185"></a>05185     <span class="keywordflow">if</span> (skb_header_cloned(skb)) {
<a name="l05186"></a>05186         <span class="keywordtype">int</span> err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
<a name="l05187"></a>05187 
<a name="l05188"></a>05188         <span class="keywordflow">if</span> (err)
<a name="l05189"></a>05189             <span class="keywordflow">return</span> err;
<a name="l05190"></a>05190     }
<a name="l05191"></a>05191 
<a name="l05192"></a>05192     hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
<a name="l05193"></a>05193     mss = skb_shinfo(skb)-&gt;gso_size;
<a name="l05194"></a>05194     <span class="keywordflow">if</span> (skb-&gt;protocol == htons(ETH_P_IP)) {
<a name="l05195"></a>05195         <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = ip_hdr(skb);
<a name="l05196"></a>05196         iph-&gt;tot_len = 0;
<a name="l05197"></a>05197         iph-&gt;check = 0;
<a name="l05198"></a>05198         tcp_hdr(skb)-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr, iph-&gt;daddr,
<a name="l05199"></a>05199                                                  0, IPPROTO_TCP, 0);
<a name="l05200"></a>05200         cmd_length = E1000_TXD_CMD_IP;
<a name="l05201"></a>05201         ipcse = skb_transport_offset(skb) - 1;
<a name="l05202"></a>05202 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l05203"></a>05203 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (skb_is_gso_v6(skb)) {
<a name="l05204"></a>05204         ipv6_hdr(skb)-&gt;payload_len = 0;
<a name="l05205"></a>05205         tcp_hdr(skb)-&gt;check = ~csum_ipv6_magic(&amp;ipv6_hdr(skb)-&gt;saddr,
<a name="l05206"></a>05206                                                &amp;ipv6_hdr(skb)-&gt;daddr,
<a name="l05207"></a>05207                                                0, IPPROTO_TCP, 0);
<a name="l05208"></a>05208         ipcse = 0;
<a name="l05209"></a>05209 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO6 */</span>
<a name="l05210"></a>05210     }
<a name="l05211"></a>05211     ipcss = skb_network_offset(skb);
<a name="l05212"></a>05212     ipcso = (<span class="keywordtype">void</span> *)&amp;(ip_hdr(skb)-&gt;check) - (<span class="keywordtype">void</span> *)skb-&gt;data;
<a name="l05213"></a>05213     tucss = skb_transport_offset(skb);
<a name="l05214"></a>05214     tucso = (<span class="keywordtype">void</span> *)&amp;(tcp_hdr(skb)-&gt;check) - (<span class="keywordtype">void</span> *)skb-&gt;data;
<a name="l05215"></a>05215     tucse = 0;
<a name="l05216"></a>05216 
<a name="l05217"></a>05217     cmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |
<a name="l05218"></a>05218                    E1000_TXD_CMD_TCP | (skb-&gt;len - (hdr_len)));
<a name="l05219"></a>05219 
<a name="l05220"></a>05220     i = tx_ring-&gt;next_to_use;
<a name="l05221"></a>05221     context_desc = E1000_CONTEXT_DESC(*tx_ring, i);
<a name="l05222"></a>05222     buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l05223"></a>05223 
<a name="l05224"></a>05224     context_desc-&gt;lower_setup.ip_fields.ipcss  = ipcss;
<a name="l05225"></a>05225     context_desc-&gt;lower_setup.ip_fields.ipcso  = ipcso;
<a name="l05226"></a>05226     context_desc-&gt;lower_setup.ip_fields.ipcse  = cpu_to_le16(ipcse);
<a name="l05227"></a>05227     context_desc-&gt;upper_setup.tcp_fields.tucss = tucss;
<a name="l05228"></a>05228     context_desc-&gt;upper_setup.tcp_fields.tucso = tucso;
<a name="l05229"></a>05229     context_desc-&gt;upper_setup.tcp_fields.tucse = cpu_to_le16(tucse);
<a name="l05230"></a>05230     context_desc-&gt;tcp_seg_setup.fields.mss     = cpu_to_le16(mss);
<a name="l05231"></a>05231     context_desc-&gt;tcp_seg_setup.fields.hdr_len = hdr_len;
<a name="l05232"></a>05232     context_desc-&gt;cmd_and_length = cpu_to_le32(cmd_length);
<a name="l05233"></a>05233 
<a name="l05234"></a>05234     buffer_info-&gt;time_stamp = jiffies;
<a name="l05235"></a>05235     buffer_info-&gt;next_to_watch = i;
<a name="l05236"></a>05236 
<a name="l05237"></a>05237     i++;
<a name="l05238"></a>05238     <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l05239"></a>05239         i = 0;
<a name="l05240"></a>05240     tx_ring-&gt;next_to_use = i;
<a name="l05241"></a>05241 
<a name="l05242"></a>05242     <span class="keywordflow">return</span> 1;
<a name="l05243"></a>05243 <span class="preprocessor">#else </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l05244"></a>05244     <span class="keywordflow">return</span> 0;
<a name="l05245"></a>05245 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l05246"></a>05246 }
<a name="l05247"></a>05247 
<a name="l05248"></a>05248 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_tx_csum(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter, <span class="keyword">struct</span> sk_buff *skb)
<a name="l05249"></a>05249 {
<a name="l05250"></a>05250     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l05251"></a>05251     <span class="keyword">struct </span><a class="code" href="structe1000__context__desc.html">e1000_context_desc</a> *context_desc;
<a name="l05252"></a>05252     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l05253"></a>05253     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l05254"></a>05254     u8 css;
<a name="l05255"></a>05255     u32 cmd_len = E1000_TXD_CMD_DEXT;
<a name="l05256"></a>05256     __be16 protocol;
<a name="l05257"></a>05257 
<a name="l05258"></a>05258     <span class="keywordflow">if</span> (skb-&gt;ip_summed != CHECKSUM_PARTIAL)
<a name="l05259"></a>05259         <span class="keywordflow">return</span> 0;
<a name="l05260"></a>05260 
<a name="l05261"></a>05261 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l05262"></a>05262 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (skb-&gt;protocol == cpu_to_be16(ETH_P_8021Q))
<a name="l05263"></a>05263         protocol = vlan_eth_hdr(skb)-&gt;h_vlan_encapsulated_proto;
<a name="l05264"></a>05264     <span class="keywordflow">else</span>
<a name="l05265"></a>05265         protocol = skb-&gt;protocol;
<a name="l05266"></a>05266 <span class="preprocessor">#else</span>
<a name="l05267"></a>05267 <span class="preprocessor"></span>    protocol = skb-&gt;protocol;
<a name="l05268"></a>05268 <span class="preprocessor">#endif</span>
<a name="l05269"></a>05269 <span class="preprocessor"></span>
<a name="l05270"></a>05270     <span class="keywordflow">switch</span> (protocol) {
<a name="l05271"></a>05271     <span class="keywordflow">case</span> cpu_to_be16(ETH_P_IP):
<a name="l05272"></a>05272         if (ip_hdr(skb)-&gt;protocol == IPPROTO_TCP)
<a name="l05273"></a>05273             cmd_len |= E1000_TXD_CMD_TCP;
<a name="l05274"></a>05274         <span class="keywordflow">break</span>;
<a name="l05275"></a>05275     <span class="keywordflow">case</span> cpu_to_be16(ETH_P_IPV6):
<a name="l05276"></a>05276         <span class="comment">/* XXX not handling all IPV6 headers */</span>
<a name="l05277"></a>05277         if (ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_TCP)
<a name="l05278"></a>05278             cmd_len |= E1000_TXD_CMD_TCP;
<a name="l05279"></a>05279         <span class="keywordflow">break</span>;
<a name="l05280"></a>05280     <span class="keywordflow">default</span>:
<a name="l05281"></a>05281         <span class="keywordflow">if</span> (unlikely(net_ratelimit()))
<a name="l05282"></a>05282             e_warn(<span class="stringliteral">&quot;checksum_partial proto=%x!\n&quot;</span>,
<a name="l05283"></a>05283                    be16_to_cpu(protocol));
<a name="l05284"></a>05284         <span class="keywordflow">break</span>;
<a name="l05285"></a>05285     }
<a name="l05286"></a>05286 
<a name="l05287"></a>05287     css = skb_checksum_start_offset(skb);
<a name="l05288"></a>05288 
<a name="l05289"></a>05289     i = tx_ring-&gt;next_to_use;
<a name="l05290"></a>05290     buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l05291"></a>05291     context_desc = E1000_CONTEXT_DESC(*tx_ring, i);
<a name="l05292"></a>05292 
<a name="l05293"></a>05293     context_desc-&gt;lower_setup.ip_config = 0;
<a name="l05294"></a>05294     context_desc-&gt;upper_setup.tcp_fields.tucss = css;
<a name="l05295"></a>05295     context_desc-&gt;upper_setup.tcp_fields.tucso =
<a name="l05296"></a>05296                 css + skb-&gt;csum_offset;
<a name="l05297"></a>05297     context_desc-&gt;upper_setup.tcp_fields.tucse = 0;
<a name="l05298"></a>05298     context_desc-&gt;tcp_seg_setup.data = 0;
<a name="l05299"></a>05299     context_desc-&gt;cmd_and_length = cpu_to_le32(cmd_len);
<a name="l05300"></a>05300 
<a name="l05301"></a>05301     buffer_info-&gt;time_stamp = jiffies;
<a name="l05302"></a>05302     buffer_info-&gt;next_to_watch = i;
<a name="l05303"></a>05303 
<a name="l05304"></a>05304     i++;
<a name="l05305"></a>05305     <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l05306"></a>05306         i = 0;
<a name="l05307"></a>05307     tx_ring-&gt;next_to_use = i;
<a name="l05308"></a>05308 
<a name="l05309"></a>05309     <span class="keywordflow">return</span> 1;
<a name="l05310"></a>05310 }
<a name="l05311"></a>05311 
<a name="l05312"></a>05312 <span class="preprocessor">#define E1000_MAX_PER_TXD   8192</span>
<a name="l05313"></a>05313 <span class="preprocessor"></span><span class="preprocessor">#define E1000_MAX_TXD_PWR   12</span>
<a name="l05314"></a>05314 <span class="preprocessor"></span>
<a name="l05315"></a>05315 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_tx_map(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l05316"></a>05316             <span class="keyword">struct</span> sk_buff *skb, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first,
<a name="l05317"></a>05317             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_per_txd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nr_frags,
<a name="l05318"></a>05318             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mss)
<a name="l05319"></a>05319 {
<a name="l05320"></a>05320     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l05321"></a>05321     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l05322"></a>05322     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l05323"></a>05323     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = skb_headlen(skb);
<a name="l05324"></a>05324     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset = 0, size, count = 0, i;
<a name="l05325"></a>05325     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f, bytecount, segs;
<a name="l05326"></a>05326 
<a name="l05327"></a>05327     i = tx_ring-&gt;next_to_use;
<a name="l05328"></a>05328 
<a name="l05329"></a>05329     <span class="keywordflow">while</span> (len) {
<a name="l05330"></a>05330         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l05331"></a>05331         size = min(len, max_per_txd);
<a name="l05332"></a>05332 
<a name="l05333"></a>05333         buffer_info-&gt;length = size;
<a name="l05334"></a>05334         <span class="comment">/* set time_stamp *before* dma to help avoid a possible race */</span>
<a name="l05335"></a>05335         buffer_info-&gt;time_stamp = jiffies;
<a name="l05336"></a>05336         buffer_info-&gt;dma = dma_map_single(pci_dev_to_dev(pdev),
<a name="l05337"></a>05337                           skb-&gt;data + offset,
<a name="l05338"></a>05338                           size, DMA_TO_DEVICE);
<a name="l05339"></a>05339         buffer_info-&gt;mapped_as_page = <span class="keyword">false</span>;
<a name="l05340"></a>05340         <span class="keywordflow">if</span> (dma_mapping_error(pci_dev_to_dev(pdev), buffer_info-&gt;dma))
<a name="l05341"></a>05341             <span class="keywordflow">goto</span> dma_error;
<a name="l05342"></a>05342 
<a name="l05343"></a>05343         buffer_info-&gt;next_to_watch = i;
<a name="l05344"></a>05344 
<a name="l05345"></a>05345         len -= size;
<a name="l05346"></a>05346         offset += size;
<a name="l05347"></a>05347         count++;
<a name="l05348"></a>05348         i++;
<a name="l05349"></a>05349         <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l05350"></a>05350             i = 0;
<a name="l05351"></a>05351     }
<a name="l05352"></a>05352 
<a name="l05353"></a>05353     <span class="keywordflow">for</span> (f = 0; f &lt; nr_frags; f++) {
<a name="l05354"></a>05354         <span class="keyword">struct </span>skb_frag_struct *frag;
<a name="l05355"></a>05355 
<a name="l05356"></a>05356         frag = &amp;skb_shinfo(skb)-&gt;frags[f];
<a name="l05357"></a>05357         len = frag-&gt;size;
<a name="l05358"></a>05358         offset = frag-&gt;page_offset;
<a name="l05359"></a>05359 
<a name="l05360"></a>05360         <span class="keywordflow">while</span> (len) {
<a name="l05361"></a>05361             buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l05362"></a>05362             size = min(len, max_per_txd);
<a name="l05363"></a>05363 
<a name="l05364"></a>05364             buffer_info-&gt;length = size;
<a name="l05365"></a>05365             buffer_info-&gt;time_stamp = jiffies;
<a name="l05366"></a>05366             buffer_info-&gt;dma = dma_map_page(pci_dev_to_dev(pdev), frag-&gt;page,
<a name="l05367"></a>05367                             offset, size,
<a name="l05368"></a>05368                             DMA_TO_DEVICE);
<a name="l05369"></a>05369             buffer_info-&gt;mapped_as_page = <span class="keyword">true</span>;
<a name="l05370"></a>05370             <span class="keywordflow">if</span> (dma_mapping_error(pci_dev_to_dev(pdev), buffer_info-&gt;dma))
<a name="l05371"></a>05371                 <span class="keywordflow">goto</span> dma_error;
<a name="l05372"></a>05372 
<a name="l05373"></a>05373             buffer_info-&gt;next_to_watch = i;
<a name="l05374"></a>05374 
<a name="l05375"></a>05375             len -= size;
<a name="l05376"></a>05376             offset += size;
<a name="l05377"></a>05377             count++;
<a name="l05378"></a>05378 
<a name="l05379"></a>05379             i++;
<a name="l05380"></a>05380             <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l05381"></a>05381                 i = 0;
<a name="l05382"></a>05382         }
<a name="l05383"></a>05383     }
<a name="l05384"></a>05384 
<a name="l05385"></a>05385     <span class="keywordflow">if</span> (i == 0)
<a name="l05386"></a>05386         i = tx_ring-&gt;count - 1;
<a name="l05387"></a>05387     <span class="keywordflow">else</span>
<a name="l05388"></a>05388         i--;
<a name="l05389"></a>05389 
<a name="l05390"></a>05390 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l05391"></a>05391 <span class="preprocessor"></span>    segs = skb_shinfo(skb)-&gt;gso_segs ? : 1;
<a name="l05392"></a>05392 <span class="preprocessor">#else</span>
<a name="l05393"></a>05393 <span class="preprocessor"></span>    segs = 1;
<a name="l05394"></a>05394 <span class="preprocessor">#endif</span>
<a name="l05395"></a>05395 <span class="preprocessor"></span>    <span class="comment">/* multiply data chunks by size of headers */</span>
<a name="l05396"></a>05396     bytecount = ((segs - 1) * skb_headlen(skb)) + skb-&gt;len;
<a name="l05397"></a>05397 
<a name="l05398"></a>05398     tx_ring-&gt;buffer_info[i].skb = skb;
<a name="l05399"></a>05399     tx_ring-&gt;buffer_info[i].segs = segs;
<a name="l05400"></a>05400     tx_ring-&gt;buffer_info[i].bytecount = bytecount;
<a name="l05401"></a>05401     tx_ring-&gt;buffer_info[first].next_to_watch = i;
<a name="l05402"></a>05402 
<a name="l05403"></a>05403     <span class="keywordflow">return</span> count;
<a name="l05404"></a>05404 
<a name="l05405"></a>05405 dma_error:
<a name="l05406"></a>05406     dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Tx DMA map failed\n&quot;</span>);
<a name="l05407"></a>05407     buffer_info-&gt;dma = 0;
<a name="l05408"></a>05408     <span class="keywordflow">if</span> (count)
<a name="l05409"></a>05409         count--;
<a name="l05410"></a>05410 
<a name="l05411"></a>05411     <span class="keywordflow">while</span> (count--) {
<a name="l05412"></a>05412         <span class="keywordflow">if</span> (i == 0)
<a name="l05413"></a>05413             i += tx_ring-&gt;count;
<a name="l05414"></a>05414         i--;
<a name="l05415"></a>05415         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l05416"></a>05416         e1000_put_txbuf(adapter, buffer_info);
<a name="l05417"></a>05417     }
<a name="l05418"></a>05418 
<a name="l05419"></a>05419     <span class="keywordflow">return</span> count;
<a name="l05420"></a>05420 }
<a name="l05421"></a>05421 
<a name="l05422"></a>05422 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_tx_queue(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l05423"></a>05423                <span class="keywordtype">int</span> tx_flags, <span class="keywordtype">int</span> count)
<a name="l05424"></a>05424 {
<a name="l05425"></a>05425     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l05426"></a>05426     <span class="keyword">struct </span><a class="code" href="structe1000__tx__desc.html">e1000_tx_desc</a> *tx_desc = NULL;
<a name="l05427"></a>05427     <span class="keyword">struct </span><a class="code" href="structe1000__buffer.html">e1000_buffer</a> *buffer_info;
<a name="l05428"></a>05428     u32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;
<a name="l05429"></a>05429     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l05430"></a>05430 
<a name="l05431"></a>05431     <span class="keywordflow">if</span> (tx_flags &amp; E1000_TX_FLAGS_TSO) {
<a name="l05432"></a>05432         txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |
<a name="l05433"></a>05433                  E1000_TXD_CMD_TSE;
<a name="l05434"></a>05434         txd_upper |= E1000_TXD_POPTS_TXSM &lt;&lt; 8;
<a name="l05435"></a>05435 
<a name="l05436"></a>05436         <span class="keywordflow">if</span> (tx_flags &amp; E1000_TX_FLAGS_IPV4)
<a name="l05437"></a>05437             txd_upper |= E1000_TXD_POPTS_IXSM &lt;&lt; 8;
<a name="l05438"></a>05438     }
<a name="l05439"></a>05439 
<a name="l05440"></a>05440     <span class="keywordflow">if</span> (tx_flags &amp; E1000_TX_FLAGS_CSUM) {
<a name="l05441"></a>05441         txd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;
<a name="l05442"></a>05442         txd_upper |= E1000_TXD_POPTS_TXSM &lt;&lt; 8;
<a name="l05443"></a>05443     }
<a name="l05444"></a>05444 
<a name="l05445"></a>05445     <span class="keywordflow">if</span> (tx_flags &amp; E1000_TX_FLAGS_VLAN) {
<a name="l05446"></a>05446         txd_lower |= E1000_TXD_CMD_VLE;
<a name="l05447"></a>05447         txd_upper |= (tx_flags &amp; E1000_TX_FLAGS_VLAN_MASK);
<a name="l05448"></a>05448     }
<a name="l05449"></a>05449 
<a name="l05450"></a>05450     i = tx_ring-&gt;next_to_use;
<a name="l05451"></a>05451 
<a name="l05452"></a>05452     <span class="keywordflow">do</span> {
<a name="l05453"></a>05453         buffer_info = &amp;tx_ring-&gt;buffer_info[i];
<a name="l05454"></a>05454         tx_desc = E1000_TX_DESC(*tx_ring, i);
<a name="l05455"></a>05455         tx_desc-&gt;buffer_addr = cpu_to_le64(buffer_info-&gt;dma);
<a name="l05456"></a>05456         tx_desc-&gt;lower.data =
<a name="l05457"></a>05457             cpu_to_le32(txd_lower | buffer_info-&gt;length);
<a name="l05458"></a>05458         tx_desc-&gt;upper.data = cpu_to_le32(txd_upper);
<a name="l05459"></a>05459 
<a name="l05460"></a>05460         i++;
<a name="l05461"></a>05461         <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l05462"></a>05462             i = 0;
<a name="l05463"></a>05463     } <span class="keywordflow">while</span> (--count &gt; 0);
<a name="l05464"></a>05464 
<a name="l05465"></a>05465     tx_desc-&gt;lower.data |= cpu_to_le32(adapter-&gt;txd_cmd);
<a name="l05466"></a>05466 
<a name="l05467"></a>05467     <span class="comment">/*</span>
<a name="l05468"></a>05468 <span class="comment">     * Force memory writes to complete before letting h/w</span>
<a name="l05469"></a>05469 <span class="comment">     * know there are new descriptors to fetch.  (Only</span>
<a name="l05470"></a>05470 <span class="comment">     * applicable for weak-ordered memory model archs,</span>
<a name="l05471"></a>05471 <span class="comment">     * such as IA-64).</span>
<a name="l05472"></a>05472 <span class="comment">     */</span>
<a name="l05473"></a>05473     wmb();
<a name="l05474"></a>05474 
<a name="l05475"></a>05475     tx_ring-&gt;next_to_use = i;
<a name="l05476"></a>05476     writel(i, adapter-&gt;hw.hw_addr + tx_ring-&gt;tail);
<a name="l05477"></a>05477     <span class="comment">/*</span>
<a name="l05478"></a>05478 <span class="comment">     * we need this if more than one processor can write to our tail</span>
<a name="l05479"></a>05479 <span class="comment">     * at a time, it synchronizes IO on IA64/Altix systems</span>
<a name="l05480"></a>05480 <span class="comment">     */</span>
<a name="l05481"></a>05481     mmiowb();
<a name="l05482"></a>05482 }
<a name="l05483"></a>05483 
<a name="l05484"></a>05484 <span class="preprocessor">#define MINIMUM_DHCP_PACKET_SIZE 282</span>
<a name="l05485"></a>05485 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> e1000_transfer_dhcp_info(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter,
<a name="l05486"></a>05486                     <span class="keyword">struct</span> sk_buff *skb)
<a name="l05487"></a>05487 {
<a name="l05488"></a>05488     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw =  &amp;adapter-&gt;hw;
<a name="l05489"></a>05489     u16 length, offset;
<a name="l05490"></a>05490 
<a name="l05491"></a>05491 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l05492"></a>05492 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (vlan_tx_tag_present(skb)) {
<a name="l05493"></a>05493         <span class="keywordflow">if</span> (!((vlan_tx_tag_get(skb) == adapter-&gt;hw.mng_cookie.vlan_id) &amp;&amp;
<a name="l05494"></a>05494             (adapter-&gt;hw.mng_cookie.status &amp;
<a name="l05495"></a>05495             E1000_MNG_DHCP_COOKIE_STATUS_VLAN)))
<a name="l05496"></a>05496             <span class="keywordflow">return</span> 0;
<a name="l05497"></a>05497     }
<a name="l05498"></a>05498 
<a name="l05499"></a>05499 <span class="preprocessor">#endif</span>
<a name="l05500"></a>05500 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (skb-&gt;len &lt;= MINIMUM_DHCP_PACKET_SIZE)
<a name="l05501"></a>05501         <span class="keywordflow">return</span> 0;
<a name="l05502"></a>05502 
<a name="l05503"></a>05503     <span class="keywordflow">if</span> (((<span class="keyword">struct</span> ethhdr *) skb-&gt;data)-&gt;h_proto != htons(ETH_P_IP))
<a name="l05504"></a>05504         <span class="keywordflow">return</span> 0;
<a name="l05505"></a>05505 
<a name="l05506"></a>05506     {
<a name="l05507"></a>05507         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *<a class="code" href="structip.html">ip</a> = (<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *)((u8 *)skb-&gt;data+14);
<a name="l05508"></a>05508         <span class="keyword">struct </span><a class="code" href="structudphdr.html">udphdr</a> *udp;
<a name="l05509"></a>05509 
<a name="l05510"></a>05510         <span class="keywordflow">if</span> (ip-&gt;protocol != IPPROTO_UDP)
<a name="l05511"></a>05511             <span class="keywordflow">return</span> 0;
<a name="l05512"></a>05512 
<a name="l05513"></a>05513         udp = (<span class="keyword">struct </span><a class="code" href="structudphdr.html">udphdr</a> *)((u8 *)ip + (ip-&gt;ihl &lt;&lt; 2));
<a name="l05514"></a>05514         <span class="keywordflow">if</span> (ntohs(udp-&gt;dest) != 67)
<a name="l05515"></a>05515             <span class="keywordflow">return</span> 0;
<a name="l05516"></a>05516 
<a name="l05517"></a>05517         offset = (u8 *)udp + 8 - skb-&gt;data;
<a name="l05518"></a>05518         length = skb-&gt;len - offset;
<a name="l05519"></a>05519         <span class="keywordflow">return</span> e1000e_mng_write_dhcp_info(hw, (u8 *)udp + 8, length);
<a name="l05520"></a>05520     }
<a name="l05521"></a>05521 
<a name="l05522"></a>05522     <span class="keywordflow">return</span> 0;
<a name="l05523"></a>05523 }
<a name="l05524"></a>05524 
<a name="l05525"></a>05525 <span class="keyword">static</span> <span class="keywordtype">int</span> __e1000_maybe_stop_tx(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> size)
<a name="l05526"></a>05526 {
<a name="l05527"></a>05527     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05528"></a>05528 
<a name="l05529"></a>05529     netif_stop_queue(netdev);
<a name="l05530"></a>05530     <span class="comment">/*</span>
<a name="l05531"></a>05531 <span class="comment">     * Herbert&#39;s original patch had:</span>
<a name="l05532"></a>05532 <span class="comment">     *  smp_mb__after_netif_stop_queue();</span>
<a name="l05533"></a>05533 <span class="comment">     * but since that doesn&#39;t exist yet, just open code it.</span>
<a name="l05534"></a>05534 <span class="comment">     */</span>
<a name="l05535"></a>05535     smp_mb();
<a name="l05536"></a>05536 
<a name="l05537"></a>05537     <span class="comment">/*</span>
<a name="l05538"></a>05538 <span class="comment">     * We need to check again in a case another CPU has just</span>
<a name="l05539"></a>05539 <span class="comment">     * made room available.</span>
<a name="l05540"></a>05540 <span class="comment">     */</span>
<a name="l05541"></a>05541     <span class="keywordflow">if</span> (e1000_desc_unused(adapter-&gt;tx_ring) &lt; size)
<a name="l05542"></a>05542         <span class="keywordflow">return</span> -EBUSY;
<a name="l05543"></a>05543 
<a name="l05544"></a>05544     <span class="comment">/* A reprieve! */</span>
<a name="l05545"></a>05545     netif_start_queue(netdev);
<a name="l05546"></a>05546     ++adapter-&gt;restart_queue;
<a name="l05547"></a>05547     <span class="keywordflow">return</span> 0;
<a name="l05548"></a>05548 }
<a name="l05549"></a>05549 
<a name="l05550"></a>05550 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_maybe_stop_tx(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> size)
<a name="l05551"></a>05551 {
<a name="l05552"></a>05552     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05553"></a>05553 
<a name="l05554"></a>05554     <span class="keywordflow">if</span> (e1000_desc_unused(adapter-&gt;tx_ring) &gt;= size)
<a name="l05555"></a>05555         <span class="keywordflow">return</span> 0;
<a name="l05556"></a>05556     <span class="keywordflow">return</span> __e1000_maybe_stop_tx(netdev, size);
<a name="l05557"></a>05557 }
<a name="l05558"></a>05558 
<a name="l05559"></a>05559 <span class="preprocessor">#define TXD_USE_COUNT(S, X) (((S) &gt;&gt; (X)) + 1 )</span>
<a name="l05560"></a>05560 <span class="preprocessor"></span><span class="keyword">static</span> netdev_tx_t e1000_xmit_frame(<span class="keyword">struct</span> sk_buff *skb,
<a name="l05561"></a>05561                     <span class="keyword">struct</span> net_device *netdev)
<a name="l05562"></a>05562 {
<a name="l05563"></a>05563     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05564"></a>05564     <span class="keyword">struct </span><a class="code" href="structe1000__ring.html">e1000_ring</a> *tx_ring = adapter-&gt;tx_ring;
<a name="l05565"></a>05565     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first;
<a name="l05566"></a>05566     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_per_txd = E1000_MAX_PER_TXD;
<a name="l05567"></a>05567     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_txd_pwr = E1000_MAX_TXD_PWR;
<a name="l05568"></a>05568     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tx_flags = 0;
<a name="l05569"></a>05569     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = skb_headlen(skb);
<a name="l05570"></a>05570     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nr_frags;
<a name="l05571"></a>05571     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mss;
<a name="l05572"></a>05572     <span class="keywordtype">int</span> count = 0;
<a name="l05573"></a>05573     <span class="keywordtype">int</span> tso;
<a name="l05574"></a>05574     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f;
<a name="l05575"></a>05575 
<a name="l05576"></a>05576     <span class="keywordflow">if</span> (test_bit(__E1000_DOWN, &amp;adapter-&gt;state)) {
<a name="l05577"></a>05577         dev_kfree_skb_any(skb);
<a name="l05578"></a>05578         <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l05579"></a>05579     }
<a name="l05580"></a>05580 
<a name="l05581"></a>05581     <span class="keywordflow">if</span> (skb-&gt;len &lt;= 0) {
<a name="l05582"></a>05582         dev_kfree_skb_any(skb);
<a name="l05583"></a>05583         <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l05584"></a>05584     }
<a name="l05585"></a>05585 
<a name="l05586"></a>05586 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l05587"></a>05587 <span class="preprocessor"></span>    mss = skb_shinfo(skb)-&gt;gso_size;
<a name="l05588"></a>05588     <span class="comment">/*</span>
<a name="l05589"></a>05589 <span class="comment">     * The controller does a simple calculation to</span>
<a name="l05590"></a>05590 <span class="comment">     * make sure there is enough room in the FIFO before</span>
<a name="l05591"></a>05591 <span class="comment">     * initiating the DMA for each buffer.  The calc is:</span>
<a name="l05592"></a>05592 <span class="comment">     * 4 = ceil(buffer len/mss).  To make sure we don&#39;t</span>
<a name="l05593"></a>05593 <span class="comment">     * overrun the FIFO, adjust the max buffer len if mss</span>
<a name="l05594"></a>05594 <span class="comment">     * drops.</span>
<a name="l05595"></a>05595 <span class="comment">     */</span>
<a name="l05596"></a>05596     <span class="keywordflow">if</span> (mss) {
<a name="l05597"></a>05597         u8 hdr_len;
<a name="l05598"></a>05598         max_per_txd = min(mss &lt;&lt; 2, max_per_txd);
<a name="l05599"></a>05599         max_txd_pwr = fls(max_per_txd) - 1;
<a name="l05600"></a>05600 
<a name="l05601"></a>05601         <span class="comment">/*</span>
<a name="l05602"></a>05602 <span class="comment">         * TSO Workaround for 82571/2/3 Controllers -- if skb-&gt;data</span>
<a name="l05603"></a>05603 <span class="comment">         * points to just header, pull a few bytes of payload from</span>
<a name="l05604"></a>05604 <span class="comment">         * frags into skb-&gt;data</span>
<a name="l05605"></a>05605 <span class="comment">         */</span>
<a name="l05606"></a>05606         hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
<a name="l05607"></a>05607         <span class="comment">/*</span>
<a name="l05608"></a>05608 <span class="comment">         * we do this workaround for ES2LAN, but it is un-necessary,</span>
<a name="l05609"></a>05609 <span class="comment">         * avoiding it could save a lot of cycles</span>
<a name="l05610"></a>05610 <span class="comment">         */</span>
<a name="l05611"></a>05611         <span class="keywordflow">if</span> (skb-&gt;data_len &amp;&amp; (hdr_len == len)) {
<a name="l05612"></a>05612             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pull_size;
<a name="l05613"></a>05613 
<a name="l05614"></a>05614             pull_size = min((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)4, skb-&gt;data_len);
<a name="l05615"></a>05615             <span class="keywordflow">if</span> (!__pskb_pull_tail(skb, pull_size)) {
<a name="l05616"></a>05616                 e_err(<span class="stringliteral">&quot;__pskb_pull_tail failed.\n&quot;</span>);
<a name="l05617"></a>05617                 dev_kfree_skb_any(skb);
<a name="l05618"></a>05618                 <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l05619"></a>05619             }
<a name="l05620"></a>05620             len = skb_headlen(skb);
<a name="l05621"></a>05621         }
<a name="l05622"></a>05622     }
<a name="l05623"></a>05623 
<a name="l05624"></a>05624     <span class="comment">/* reserve a descriptor for the offload context */</span>
<a name="l05625"></a>05625     <span class="keywordflow">if</span> ((mss) || (skb-&gt;ip_summed == CHECKSUM_PARTIAL))
<a name="l05626"></a>05626         count++;
<a name="l05627"></a>05627     count++;
<a name="l05628"></a>05628 <span class="preprocessor">#else</span>
<a name="l05629"></a>05629 <span class="preprocessor"></span>    mss = 0;
<a name="l05630"></a>05630 
<a name="l05631"></a>05631     <span class="keywordflow">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL)
<a name="l05632"></a>05632     count++;
<a name="l05633"></a>05633 <span class="preprocessor">#endif</span>
<a name="l05634"></a>05634 <span class="preprocessor"></span>
<a name="l05635"></a>05635     count += TXD_USE_COUNT(len, max_txd_pwr);
<a name="l05636"></a>05636 
<a name="l05637"></a>05637     nr_frags = skb_shinfo(skb)-&gt;nr_frags;
<a name="l05638"></a>05638     <span class="keywordflow">for</span> (f = 0; f &lt; nr_frags; f++)
<a name="l05639"></a>05639         count += TXD_USE_COUNT(skb_shinfo(skb)-&gt;frags[f].size,
<a name="l05640"></a>05640                        max_txd_pwr);
<a name="l05641"></a>05641 
<a name="l05642"></a>05642     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.tx_pkt_filtering)
<a name="l05643"></a>05643         e1000_transfer_dhcp_info(adapter, skb);
<a name="l05644"></a>05644 
<a name="l05645"></a>05645     <span class="comment">/*</span>
<a name="l05646"></a>05646 <span class="comment">     * need: count + 2 desc gap to keep tail from touching</span>
<a name="l05647"></a>05647 <span class="comment">     * head, otherwise try next time</span>
<a name="l05648"></a>05648 <span class="comment">     */</span>
<a name="l05649"></a>05649     <span class="keywordflow">if</span> (e1000_maybe_stop_tx(netdev, count + 2))
<a name="l05650"></a>05650         <span class="keywordflow">return</span> NETDEV_TX_BUSY;
<a name="l05651"></a>05651 
<a name="l05652"></a>05652 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l05653"></a>05653 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (vlan_tx_tag_present(skb)) {
<a name="l05654"></a>05654         tx_flags |= E1000_TX_FLAGS_VLAN;
<a name="l05655"></a>05655         tx_flags |= (vlan_tx_tag_get(skb) &lt;&lt; E1000_TX_FLAGS_VLAN_SHIFT);
<a name="l05656"></a>05656     }
<a name="l05657"></a>05657 
<a name="l05658"></a>05658 <span class="preprocessor">#endif</span>
<a name="l05659"></a>05659 <span class="preprocessor"></span>    first = tx_ring-&gt;next_to_use;
<a name="l05660"></a>05660 
<a name="l05661"></a>05661     tso = e1000_tso(adapter, skb);
<a name="l05662"></a>05662     <span class="keywordflow">if</span> (tso &lt; 0) {
<a name="l05663"></a>05663         dev_kfree_skb_any(skb);
<a name="l05664"></a>05664         <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l05665"></a>05665     }
<a name="l05666"></a>05666 
<a name="l05667"></a>05667     <span class="keywordflow">if</span> (tso)
<a name="l05668"></a>05668         tx_flags |= E1000_TX_FLAGS_TSO;
<a name="l05669"></a>05669     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e1000_tx_csum(adapter, skb))
<a name="l05670"></a>05670         tx_flags |= E1000_TX_FLAGS_CSUM;
<a name="l05671"></a>05671 
<a name="l05672"></a>05672     <span class="comment">/*</span>
<a name="l05673"></a>05673 <span class="comment">     * Old method was to assume IPv4 packet by default if TSO was enabled.</span>
<a name="l05674"></a>05674 <span class="comment">     * 82571 hardware supports TSO capabilities for IPv6 as well...</span>
<a name="l05675"></a>05675 <span class="comment">     * no longer assume, we must.</span>
<a name="l05676"></a>05676 <span class="comment">     */</span>
<a name="l05677"></a>05677     <span class="keywordflow">if</span> (skb-&gt;protocol == htons(ETH_P_IP))
<a name="l05678"></a>05678         tx_flags |= E1000_TX_FLAGS_IPV4;
<a name="l05679"></a>05679 
<a name="l05680"></a>05680     count = e1000_tx_map(adapter, skb, first, max_per_txd, nr_frags, mss);
<a name="l05681"></a>05681     <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l05682"></a>05682         <span class="comment">/* handle pci_map_single() error in e1000_tx_map */</span>
<a name="l05683"></a>05683         dev_kfree_skb_any(skb);
<a name="l05684"></a>05684         tx_ring-&gt;next_to_use = first;
<a name="l05685"></a>05685         <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l05686"></a>05686     }
<a name="l05687"></a>05687 
<a name="l05688"></a>05688     e1000_tx_queue(adapter, tx_flags, count);
<a name="l05689"></a>05689 
<a name="l05690"></a>05690     netdev-&gt;trans_start = jiffies;
<a name="l05691"></a>05691 
<a name="l05692"></a>05692     <span class="comment">/* Make sure there is space in the ring for the next send. */</span>
<a name="l05693"></a>05693     e1000_maybe_stop_tx(netdev, MAX_SKB_FRAGS + 2);
<a name="l05694"></a>05694 
<a name="l05695"></a>05695     <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l05696"></a>05696 }
<a name="l05697"></a>05697 
<a name="l05702"></a>05702 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_tx_timeout(<span class="keyword">struct</span> net_device *netdev)
<a name="l05703"></a>05703 {
<a name="l05704"></a>05704     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05705"></a>05705 
<a name="l05706"></a>05706     <span class="comment">/* Do the reset outside of interrupt context */</span>
<a name="l05707"></a>05707     adapter-&gt;tx_timeout_count++;
<a name="l05708"></a>05708     schedule_work(&amp;adapter-&gt;reset_task);
<a name="l05709"></a>05709 }
<a name="l05710"></a>05710 
<a name="l05711"></a>05711 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_reset_task(<span class="keyword">struct</span> work_struct *work)
<a name="l05712"></a>05712 {
<a name="l05713"></a>05713     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter;
<a name="l05714"></a>05714     adapter = container_of(work, <span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a>, reset_task);
<a name="l05715"></a>05715 
<a name="l05716"></a>05716     <span class="comment">/* don&#39;t run the task if already down */</span>
<a name="l05717"></a>05717     <span class="keywordflow">if</span> (test_bit(__E1000_DOWN, &amp;adapter-&gt;state))
<a name="l05718"></a>05718         <span class="keywordflow">return</span>;
<a name="l05719"></a>05719 
<a name="l05720"></a>05720     <span class="keywordflow">if</span> (!((adapter-&gt;flags &amp; FLAG_RX_NEEDS_RESTART) &amp;&amp;
<a name="l05721"></a>05721           (adapter-&gt;flags &amp; FLAG_RX_RESTART_NOW))) {
<a name="l05722"></a>05722         e1000e_dump(adapter);
<a name="l05723"></a>05723         e_err(<span class="stringliteral">&quot;Reset adapter\n&quot;</span>);
<a name="l05724"></a>05724     }
<a name="l05725"></a>05725     e1000e_reinit_locked(adapter);
<a name="l05726"></a>05726 }
<a name="l05727"></a>05727 
<a name="l05735"></a>05735 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *e1000_get_stats(<span class="keyword">struct</span> net_device *netdev)
<a name="l05736"></a>05736 {
<a name="l05737"></a>05737 <span class="preprocessor">#ifndef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l05738"></a>05738 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05739"></a>05739 
<a name="l05740"></a>05740     <span class="comment">/* only return the current stats */</span>
<a name="l05741"></a>05741     <span class="keywordflow">return</span> &amp;adapter-&gt;net_stats;
<a name="l05742"></a>05742 <span class="preprocessor">#else </span><span class="comment">/* HAVE_NETDEV_STATS_IN_NETDEV */</span>
<a name="l05743"></a>05743     <span class="comment">/* only return the current stats */</span>
<a name="l05744"></a>05744     <span class="keywordflow">return</span> &amp;netdev-&gt;stats;
<a name="l05745"></a>05745 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_STATS_IN_NETDEV */</span>
<a name="l05746"></a>05746 }
<a name="l05747"></a>05747 
<a name="l05755"></a>05755 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_change_mtu(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> new_mtu)
<a name="l05756"></a>05756 {
<a name="l05757"></a>05757     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05758"></a>05758     <span class="keywordtype">int</span> max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l05759"></a>05759 
<a name="l05760"></a>05760     <span class="comment">/* Jumbo frame support */</span>
<a name="l05761"></a>05761     <span class="keywordflow">if</span> ((max_frame &gt; ETH_FRAME_LEN + ETH_FCS_LEN) &amp;&amp;
<a name="l05762"></a>05762         !(adapter-&gt;flags &amp; FLAG_HAS_JUMBO_FRAMES)) {
<a name="l05763"></a>05763         e_err(<span class="stringliteral">&quot;Jumbo Frames not supported.\n&quot;</span>);
<a name="l05764"></a>05764         <span class="keywordflow">return</span> -EINVAL;
<a name="l05765"></a>05765     }
<a name="l05766"></a>05766 
<a name="l05767"></a>05767     <span class="comment">/* Supported frame sizes */</span>
<a name="l05768"></a>05768     <span class="keywordflow">if</span> ((new_mtu &lt; ETH_ZLEN + ETH_FCS_LEN + VLAN_HLEN) ||
<a name="l05769"></a>05769         (max_frame &gt; adapter-&gt;max_hw_frame_size)) {
<a name="l05770"></a>05770         e_err(<span class="stringliteral">&quot;Unsupported MTU setting\n&quot;</span>);
<a name="l05771"></a>05771         <span class="keywordflow">return</span> -EINVAL;
<a name="l05772"></a>05772     }
<a name="l05773"></a>05773 
<a name="l05774"></a>05774     <span class="comment">/* Jumbo frame workaround on 82579 requires CRC be stripped */</span>
<a name="l05775"></a>05775     <span class="keywordflow">if</span> ((adapter-&gt;hw.mac.type == e1000_pch2lan) &amp;&amp;
<a name="l05776"></a>05776         !(adapter-&gt;flags2 &amp; FLAG2_CRC_STRIPPING) &amp;&amp;
<a name="l05777"></a>05777         (new_mtu &gt; ETH_DATA_LEN)) {
<a name="l05778"></a>05778         e_err(<span class="stringliteral">&quot;Jumbo Frames not supported on 82579 when CRC &quot;</span>
<a name="l05779"></a>05779               <span class="stringliteral">&quot;stripping is disabled.\n&quot;</span>);
<a name="l05780"></a>05780         <span class="keywordflow">return</span> -EINVAL;
<a name="l05781"></a>05781     }
<a name="l05782"></a>05782 
<a name="l05783"></a>05783     <span class="comment">/* 82573 Errata 17 */</span>
<a name="l05784"></a>05784     <span class="keywordflow">if</span> (((adapter-&gt;hw.mac.type == e1000_82573) ||
<a name="l05785"></a>05785          (adapter-&gt;hw.mac.type == e1000_82574)) &amp;&amp;
<a name="l05786"></a>05786         (max_frame &gt; ETH_FRAME_LEN + ETH_FCS_LEN)) {
<a name="l05787"></a>05787         adapter-&gt;flags2 |= FLAG2_DISABLE_ASPM_L1;
<a name="l05788"></a>05788         e1000e_disable_aspm(adapter-&gt;pdev, PCIE_LINK_STATE_L1);
<a name="l05789"></a>05789     }
<a name="l05790"></a>05790 
<a name="l05791"></a>05791     <span class="keywordflow">while</span> (test_and_set_bit(__E1000_RESETTING, &amp;adapter-&gt;state))
<a name="l05792"></a>05792         msleep(1);
<a name="l05793"></a>05793     <span class="comment">/* e1000e_down -&gt; e1000e_reset dependent on max_frame_size &amp; mtu */</span>
<a name="l05794"></a>05794     adapter-&gt;max_frame_size = max_frame;
<a name="l05795"></a>05795     e_info(<span class="stringliteral">&quot;changing MTU from %d to %d\n&quot;</span>, netdev-&gt;mtu, new_mtu);
<a name="l05796"></a>05796     netdev-&gt;mtu = new_mtu;
<a name="l05797"></a>05797     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l05798"></a>05798         e1000e_down(adapter);
<a name="l05799"></a>05799 
<a name="l05800"></a>05800     <span class="comment">/*</span>
<a name="l05801"></a>05801 <span class="comment">     * NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN</span>
<a name="l05802"></a>05802 <span class="comment">     * means we reserve 2 more, this pushes us to allocate from the next</span>
<a name="l05803"></a>05803 <span class="comment">     * larger slab size.</span>
<a name="l05804"></a>05804 <span class="comment">     * i.e. RXBUFFER_2048 --&gt; size-4096 slab</span>
<a name="l05805"></a>05805 <span class="comment">     * However with the new *_jumbo_rx* routines, jumbo receives will use</span>
<a name="l05806"></a>05806 <span class="comment">     * fragmented skbs</span>
<a name="l05807"></a>05807 <span class="comment">     */</span>
<a name="l05808"></a>05808 
<a name="l05809"></a>05809     <span class="keywordflow">if</span> (max_frame &lt;= 2048)
<a name="l05810"></a>05810         adapter-&gt;rx_buffer_len = 2048;
<a name="l05811"></a>05811 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l05812"></a>05812 <span class="preprocessor"></span>    <span class="keywordflow">else</span>
<a name="l05813"></a>05813         adapter-&gt;rx_buffer_len = 4096;
<a name="l05814"></a>05814 <span class="preprocessor">#else</span>
<a name="l05815"></a>05815 <span class="preprocessor"></span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (max_frame &lt;= 4096)
<a name="l05816"></a>05816         adapter-&gt;rx_buffer_len = 4096;
<a name="l05817"></a>05817     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (max_frame &lt;= 8192)
<a name="l05818"></a>05818         adapter-&gt;rx_buffer_len = 8192;
<a name="l05819"></a>05819     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (max_frame &lt;= 16384)
<a name="l05820"></a>05820         adapter-&gt;rx_buffer_len = 16384;
<a name="l05821"></a>05821 <span class="preprocessor">#endif</span>
<a name="l05822"></a>05822 <span class="preprocessor"></span>
<a name="l05823"></a>05823     <span class="comment">/* adjust allocation if LPE protects us, and we aren&#39;t using SBP */</span>
<a name="l05824"></a>05824     <span class="keywordflow">if</span> ((max_frame == ETH_FRAME_LEN + ETH_FCS_LEN) ||
<a name="l05825"></a>05825          (max_frame == ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN))
<a name="l05826"></a>05826         adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN
<a name="l05827"></a>05827                      + ETH_FCS_LEN;
<a name="l05828"></a>05828 
<a name="l05829"></a>05829     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l05830"></a>05830         e1000e_up(adapter);
<a name="l05831"></a>05831     <span class="keywordflow">else</span>
<a name="l05832"></a>05832         e1000e_reset(adapter);
<a name="l05833"></a>05833 
<a name="l05834"></a>05834     clear_bit(__E1000_RESETTING, &amp;adapter-&gt;state);
<a name="l05835"></a>05835 
<a name="l05836"></a>05836     <span class="keywordflow">return</span> 0;
<a name="l05837"></a>05837 }
<a name="l05838"></a>05838 
<a name="l05839"></a>05839 <span class="preprocessor">#if defined(SIOCGMIIPHY) || defined(SIOCGMIIREG) || defined(SIOCSMIIREG)</span>
<a name="l05840"></a>05840 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> e1000_mii_ioctl(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *ifr,
<a name="l05841"></a>05841                <span class="keywordtype">int</span> cmd)
<a name="l05842"></a>05842 {
<a name="l05843"></a>05843     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l05844"></a>05844     <span class="keyword">struct </span>mii_ioctl_data *data = if_mii(ifr);
<a name="l05845"></a>05845 
<a name="l05846"></a>05846     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.media_type != e1000_media_type_copper)
<a name="l05847"></a>05847         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l05848"></a>05848 
<a name="l05849"></a>05849     <span class="keywordflow">switch</span> (cmd) {
<a name="l05850"></a>05850 <span class="preprocessor">#ifdef SIOCGMIIPHY</span>
<a name="l05851"></a>05851 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCGMIIPHY:
<a name="l05852"></a>05852         data-&gt;phy_id = adapter-&gt;hw.phy.addr;
<a name="l05853"></a>05853         <span class="keywordflow">break</span>;
<a name="l05854"></a>05854 <span class="preprocessor">#endif</span>
<a name="l05855"></a>05855 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIOCGMIIREG</span>
<a name="l05856"></a>05856 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCGMIIREG:
<a name="l05857"></a>05857         e1000_phy_read_status(adapter);
<a name="l05858"></a>05858 
<a name="l05859"></a>05859         <span class="keywordflow">switch</span> (data-&gt;reg_num &amp; 0x1F) {
<a name="l05860"></a>05860         <span class="keywordflow">case</span> MII_BMCR:
<a name="l05861"></a>05861             data-&gt;val_out = adapter-&gt;phy_regs.bmcr;
<a name="l05862"></a>05862             <span class="keywordflow">break</span>;
<a name="l05863"></a>05863         <span class="keywordflow">case</span> MII_BMSR:
<a name="l05864"></a>05864             data-&gt;val_out = adapter-&gt;phy_regs.bmsr;
<a name="l05865"></a>05865             <span class="keywordflow">break</span>;
<a name="l05866"></a>05866         <span class="keywordflow">case</span> MII_PHYSID1:
<a name="l05867"></a>05867             data-&gt;val_out = (adapter-&gt;hw.phy.id &gt;&gt; 16);
<a name="l05868"></a>05868             <span class="keywordflow">break</span>;
<a name="l05869"></a>05869         <span class="keywordflow">case</span> MII_PHYSID2:
<a name="l05870"></a>05870             data-&gt;val_out = (adapter-&gt;hw.phy.id &amp; 0xFFFF);
<a name="l05871"></a>05871             <span class="keywordflow">break</span>;
<a name="l05872"></a>05872         <span class="keywordflow">case</span> MII_ADVERTISE:
<a name="l05873"></a>05873             data-&gt;val_out = adapter-&gt;phy_regs.advertise;
<a name="l05874"></a>05874             <span class="keywordflow">break</span>;
<a name="l05875"></a>05875         <span class="keywordflow">case</span> MII_LPA:
<a name="l05876"></a>05876             data-&gt;val_out = adapter-&gt;phy_regs.lpa;
<a name="l05877"></a>05877             <span class="keywordflow">break</span>;
<a name="l05878"></a>05878         <span class="keywordflow">case</span> MII_EXPANSION:
<a name="l05879"></a>05879             data-&gt;val_out = adapter-&gt;phy_regs.expansion;
<a name="l05880"></a>05880             <span class="keywordflow">break</span>;
<a name="l05881"></a>05881         <span class="keywordflow">case</span> MII_CTRL1000:
<a name="l05882"></a>05882             data-&gt;val_out = adapter-&gt;phy_regs.ctrl1000;
<a name="l05883"></a>05883             <span class="keywordflow">break</span>;
<a name="l05884"></a>05884         <span class="keywordflow">case</span> MII_STAT1000:
<a name="l05885"></a>05885             data-&gt;val_out = adapter-&gt;phy_regs.stat1000;
<a name="l05886"></a>05886             <span class="keywordflow">break</span>;
<a name="l05887"></a>05887         <span class="keywordflow">case</span> MII_ESTATUS:
<a name="l05888"></a>05888             data-&gt;val_out = adapter-&gt;phy_regs.estatus;
<a name="l05889"></a>05889             <span class="keywordflow">break</span>;
<a name="l05890"></a>05890         <span class="keywordflow">default</span>:
<a name="l05891"></a>05891             <span class="keywordflow">return</span> -EIO;
<a name="l05892"></a>05892         }
<a name="l05893"></a>05893         <span class="keywordflow">break</span>;
<a name="l05894"></a>05894 <span class="preprocessor">#endif</span>
<a name="l05895"></a>05895 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIOCGMIIREG</span>
<a name="l05896"></a>05896 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCSMIIREG:
<a name="l05897"></a>05897 <span class="preprocessor">#endif</span>
<a name="l05898"></a>05898 <span class="preprocessor"></span>    <span class="keywordflow">default</span>:
<a name="l05899"></a>05899         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l05900"></a>05900     }
<a name="l05901"></a>05901     <span class="keywordflow">return</span> 0;
<a name="l05902"></a>05902 }
<a name="l05903"></a>05903 <span class="preprocessor">#endif </span><span class="comment">/* defined(SIOCGMIIPHY||SIOCGMIIREG||SIOCSMIIREG) */</span>
<a name="l05904"></a>05904 
<a name="l05905"></a>05905 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_ioctl(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *ifr, <span class="keywordtype">int</span> cmd)
<a name="l05906"></a>05906 {
<a name="l05907"></a>05907     <span class="keywordflow">switch</span> (cmd) {
<a name="l05908"></a>05908 <span class="preprocessor">#ifdef SIOCGMIIPHY</span>
<a name="l05909"></a>05909 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCGMIIPHY:
<a name="l05910"></a>05910 <span class="preprocessor">#endif</span>
<a name="l05911"></a>05911 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIOCGMIIREG</span>
<a name="l05912"></a>05912 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCGMIIREG:
<a name="l05913"></a>05913 <span class="preprocessor">#endif</span>
<a name="l05914"></a>05914 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIOCSMIIREG</span>
<a name="l05915"></a>05915 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCSMIIREG:
<a name="l05916"></a>05916 <span class="preprocessor">#endif</span>
<a name="l05917"></a>05917 <span class="preprocessor"></span><span class="preprocessor">#if defined(SIOCGMIIPHY) || defined(SIOCGMIIREG) || defined(SIOCSMIIREG)</span>
<a name="l05918"></a>05918 <span class="preprocessor"></span>        <span class="keywordflow">return</span> e1000_mii_ioctl(netdev, ifr, cmd);
<a name="l05919"></a>05919 <span class="preprocessor">#endif</span>
<a name="l05920"></a>05920 <span class="preprocessor"></span><span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l05921"></a>05921 <span class="preprocessor"></span>    <span class="keywordflow">case</span> SIOCETHTOOL:
<a name="l05922"></a>05922         <span class="keywordflow">return</span> ethtool_ioctl(ifr);
<a name="l05923"></a>05923 <span class="preprocessor">#endif</span>
<a name="l05924"></a>05924 <span class="preprocessor"></span>    <span class="keywordflow">default</span>:
<a name="l05925"></a>05925         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l05926"></a>05926     }
<a name="l05927"></a>05927 }
<a name="l05928"></a>05928 
<a name="l05929"></a>05929 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_init_phy_wakeup(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter, u32 wufc)
<a name="l05930"></a>05930 {
<a name="l05931"></a>05931     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05932"></a>05932     u32 i, mac_reg;
<a name="l05933"></a>05933     u16 phy_reg;
<a name="l05934"></a>05934     <span class="keywordtype">int</span> retval = 0;
<a name="l05935"></a>05935 
<a name="l05936"></a>05936     <span class="comment">/* copy MAC RARs to PHY RARs */</span>
<a name="l05937"></a>05937     e1000_copy_rx_addrs_to_phy_ich8lan(hw);
<a name="l05938"></a>05938 
<a name="l05939"></a>05939     <span class="comment">/* copy MAC MTA to PHY MTA */</span>
<a name="l05940"></a>05940     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;hw.mac.mta_reg_count; i++) {
<a name="l05941"></a>05941         mac_reg = E1000_READ_REG_ARRAY(hw, E1000_MTA, i);
<a name="l05942"></a>05942         e1e_wphy(hw, BM_MTA(i), (u16)(mac_reg &amp; 0xFFFF));
<a name="l05943"></a>05943         e1e_wphy(hw, BM_MTA(i) + 1, (u16)((mac_reg &gt;&gt; 16) &amp; 0xFFFF));
<a name="l05944"></a>05944     }
<a name="l05945"></a>05945 
<a name="l05946"></a>05946     <span class="comment">/* configure PHY Rx Control register */</span>
<a name="l05947"></a>05947     e1e_rphy(&amp;adapter-&gt;hw, BM_RCTL, &amp;phy_reg);
<a name="l05948"></a>05948     mac_reg = er32(RCTL);
<a name="l05949"></a>05949     <span class="keywordflow">if</span> (mac_reg &amp; E1000_RCTL_UPE)
<a name="l05950"></a>05950         phy_reg |= BM_RCTL_UPE;
<a name="l05951"></a>05951     <span class="keywordflow">if</span> (mac_reg &amp; E1000_RCTL_MPE)
<a name="l05952"></a>05952         phy_reg |= BM_RCTL_MPE;
<a name="l05953"></a>05953     phy_reg &amp;= ~(BM_RCTL_MO_MASK);
<a name="l05954"></a>05954     <span class="keywordflow">if</span> (mac_reg &amp; E1000_RCTL_MO_3)
<a name="l05955"></a>05955         phy_reg |= (((mac_reg &amp; E1000_RCTL_MO_3) &gt;&gt; E1000_RCTL_MO_SHIFT)
<a name="l05956"></a>05956                 &lt;&lt; BM_RCTL_MO_SHIFT);
<a name="l05957"></a>05957     <span class="keywordflow">if</span> (mac_reg &amp; E1000_RCTL_BAM)
<a name="l05958"></a>05958         phy_reg |= BM_RCTL_BAM;
<a name="l05959"></a>05959     <span class="keywordflow">if</span> (mac_reg &amp; E1000_RCTL_PMCF)
<a name="l05960"></a>05960         phy_reg |= BM_RCTL_PMCF;
<a name="l05961"></a>05961     mac_reg = er32(CTRL);
<a name="l05962"></a>05962     <span class="keywordflow">if</span> (mac_reg &amp; E1000_CTRL_RFCE)
<a name="l05963"></a>05963         phy_reg |= BM_RCTL_RFCE;
<a name="l05964"></a>05964     e1e_wphy(&amp;adapter-&gt;hw, BM_RCTL, phy_reg);
<a name="l05965"></a>05965 
<a name="l05966"></a>05966     <span class="comment">/* enable PHY wakeup in MAC register */</span>
<a name="l05967"></a>05967     ew32(WUFC, wufc);
<a name="l05968"></a>05968     ew32(WUC, E1000_WUC_PHY_WAKE | E1000_WUC_PME_EN);
<a name="l05969"></a>05969 
<a name="l05970"></a>05970     <span class="comment">/* configure and enable PHY wakeup in PHY registers */</span>
<a name="l05971"></a>05971     e1e_wphy(&amp;adapter-&gt;hw, BM_WUFC, wufc);
<a name="l05972"></a>05972     e1e_wphy(&amp;adapter-&gt;hw, BM_WUC, E1000_WUC_PME_EN);
<a name="l05973"></a>05973 
<a name="l05974"></a>05974     <span class="comment">/* activate PHY wakeup */</span>
<a name="l05975"></a>05975     retval = hw-&gt;phy.ops.acquire(hw);
<a name="l05976"></a>05976     <span class="keywordflow">if</span> (retval) {
<a name="l05977"></a>05977         e_err(<span class="stringliteral">&quot;Could not acquire PHY\n&quot;</span>);
<a name="l05978"></a>05978         <span class="keywordflow">return</span> retval;
<a name="l05979"></a>05979     }
<a name="l05980"></a>05980     e1000e_write_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT,
<a name="l05981"></a>05981                              (BM_WUC_ENABLE_PAGE &lt;&lt; IGP_PAGE_SHIFT));
<a name="l05982"></a>05982     retval = e1000e_read_phy_reg_mdic(hw, BM_WUC_ENABLE_REG, &amp;phy_reg);
<a name="l05983"></a>05983     <span class="keywordflow">if</span> (retval) {
<a name="l05984"></a>05984         e_err(<span class="stringliteral">&quot;Could not read PHY page 769\n&quot;</span>);
<a name="l05985"></a>05985         <span class="keywordflow">goto</span> out;
<a name="l05986"></a>05986     }
<a name="l05987"></a>05987     phy_reg |= BM_WUC_ENABLE_BIT | BM_WUC_HOST_WU_BIT;
<a name="l05988"></a>05988     retval = e1000e_write_phy_reg_mdic(hw, BM_WUC_ENABLE_REG, phy_reg);
<a name="l05989"></a>05989     <span class="keywordflow">if</span> (retval)
<a name="l05990"></a>05990         e_err(<span class="stringliteral">&quot;Could not set PHY Host Wakeup bit\n&quot;</span>);
<a name="l05991"></a>05991 out:
<a name="l05992"></a>05992     hw-&gt;phy.ops.release(hw);
<a name="l05993"></a>05993 
<a name="l05994"></a>05994     <span class="keywordflow">return</span> retval;
<a name="l05995"></a>05995 }
<a name="l05996"></a>05996 
<a name="l05997"></a>05997 <span class="keyword">static</span> <span class="keywordtype">int</span> __e1000_shutdown(<span class="keyword">struct</span> pci_dev *pdev, <span class="keywordtype">bool</span> *enable_wake,
<a name="l05998"></a>05998                 <span class="keywordtype">bool</span> runtime)
<a name="l05999"></a>05999 {
<a name="l06000"></a>06000     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06001"></a>06001     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06002"></a>06002     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06003"></a>06003     u32 ctrl, ctrl_ext, rctl, status;
<a name="l06004"></a>06004     <span class="comment">/* Runtime suspend should only enable wakeup for link changes */</span>
<a name="l06005"></a>06005     u32 wufc = runtime ? E1000_WUFC_LNKC : adapter-&gt;wol;
<a name="l06006"></a>06006     <span class="keywordtype">int</span> retval = 0;
<a name="l06007"></a>06007 
<a name="l06008"></a>06008     netif_device_detach(netdev);
<a name="l06009"></a>06009 
<a name="l06010"></a>06010     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l06011"></a>06011         WARN_ON(test_bit(__E1000_RESETTING, &amp;adapter-&gt;state));
<a name="l06012"></a>06012         e1000e_down(adapter);
<a name="l06013"></a>06013         e1000_free_irq(adapter);
<a name="l06014"></a>06014     }
<a name="l06015"></a>06015 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l06016"></a>06016 <span class="preprocessor"></span>    e1000e_reset_interrupt_capability(adapter);
<a name="l06017"></a>06017 <span class="preprocessor">#endif</span>
<a name="l06018"></a>06018 <span class="preprocessor"></span>
<a name="l06019"></a>06019     retval = pci_save_state(pdev);
<a name="l06020"></a>06020     <span class="keywordflow">if</span> (retval)
<a name="l06021"></a>06021         <span class="keywordflow">return</span> retval;
<a name="l06022"></a>06022 
<a name="l06023"></a>06023     status = er32(STATUS);
<a name="l06024"></a>06024     <span class="keywordflow">if</span> (status &amp; E1000_STATUS_LU)
<a name="l06025"></a>06025         wufc &amp;= ~E1000_WUFC_LNKC;
<a name="l06026"></a>06026 
<a name="l06027"></a>06027     <span class="keywordflow">if</span> (wufc) {
<a name="l06028"></a>06028         e1000_setup_rctl(adapter);
<a name="l06029"></a>06029         e1000_set_multi(netdev);
<a name="l06030"></a>06030 
<a name="l06031"></a>06031         <span class="comment">/* turn on all-multi mode if wake on multicast is enabled */</span>
<a name="l06032"></a>06032         <span class="keywordflow">if</span> (wufc &amp; E1000_WUFC_MC) {
<a name="l06033"></a>06033             rctl = er32(RCTL);
<a name="l06034"></a>06034             rctl |= E1000_RCTL_MPE;
<a name="l06035"></a>06035             ew32(RCTL, rctl);
<a name="l06036"></a>06036         }
<a name="l06037"></a>06037 
<a name="l06038"></a>06038         ctrl = er32(CTRL);
<a name="l06039"></a>06039         <span class="comment">/* advertise wake from D3Cold */</span>
<a name="l06040"></a>06040 <span class="preprocessor">        #define E1000_CTRL_ADVD3WUC 0x00100000</span>
<a name="l06041"></a>06041 <span class="preprocessor"></span>        <span class="comment">/* phy power management enable */</span>
<a name="l06042"></a>06042 <span class="preprocessor">        #define E1000_CTRL_EN_PHY_PWR_MGMT 0x00200000</span>
<a name="l06043"></a>06043 <span class="preprocessor"></span>        ctrl |= E1000_CTRL_ADVD3WUC;
<a name="l06044"></a>06044         <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; FLAG2_HAS_PHY_WAKEUP))
<a name="l06045"></a>06045             ctrl |= E1000_CTRL_EN_PHY_PWR_MGMT;
<a name="l06046"></a>06046         ew32(CTRL, ctrl);
<a name="l06047"></a>06047 
<a name="l06048"></a>06048         <span class="keywordflow">if</span> (adapter-&gt;hw.phy.media_type == e1000_media_type_fiber ||
<a name="l06049"></a>06049             adapter-&gt;hw.phy.media_type ==
<a name="l06050"></a>06050             e1000_media_type_internal_serdes) {
<a name="l06051"></a>06051             <span class="comment">/* keep the laser running in D3 */</span>
<a name="l06052"></a>06052             ctrl_ext = er32(CTRL_EXT);
<a name="l06053"></a>06053             ctrl_ext |= E1000_CTRL_EXT_SDP3_DATA;
<a name="l06054"></a>06054             ew32(CTRL_EXT, ctrl_ext);
<a name="l06055"></a>06055         }
<a name="l06056"></a>06056 
<a name="l06057"></a>06057         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_IS_ICH)
<a name="l06058"></a>06058             e1000e_disable_gig_wol_ich8lan(&amp;adapter-&gt;hw);
<a name="l06059"></a>06059 
<a name="l06060"></a>06060         <span class="comment">/* Allow time for pending master requests to run */</span>
<a name="l06061"></a>06061         e1000e_disable_pcie_master(&amp;adapter-&gt;hw);
<a name="l06062"></a>06062 
<a name="l06063"></a>06063         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_HAS_PHY_WAKEUP) {
<a name="l06064"></a>06064             <span class="comment">/* enable wakeup by the PHY */</span>
<a name="l06065"></a>06065             retval = e1000_init_phy_wakeup(adapter, wufc);
<a name="l06066"></a>06066             <span class="keywordflow">if</span> (retval)
<a name="l06067"></a>06067                 <span class="keywordflow">return</span> retval;
<a name="l06068"></a>06068         } <span class="keywordflow">else</span> {
<a name="l06069"></a>06069             <span class="comment">/* enable wakeup by the MAC */</span>
<a name="l06070"></a>06070             ew32(WUFC, wufc);
<a name="l06071"></a>06071             ew32(WUC, E1000_WUC_PME_EN);
<a name="l06072"></a>06072         }
<a name="l06073"></a>06073     } <span class="keywordflow">else</span> {
<a name="l06074"></a>06074         ew32(WUC, 0);
<a name="l06075"></a>06075         ew32(WUFC, 0);
<a name="l06076"></a>06076     }
<a name="l06077"></a>06077 
<a name="l06078"></a>06078     *enable_wake = !!wufc;
<a name="l06079"></a>06079 
<a name="l06080"></a>06080     <span class="comment">/* make sure adapter isn&#39;t asleep if manageability is enabled */</span>
<a name="l06081"></a>06081     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_MNG_PT_ENABLED) ||
<a name="l06082"></a>06082         (hw-&gt;mac.ops.check_mng_mode(hw)))
<a name="l06083"></a>06083         *enable_wake = <span class="keyword">true</span>;
<a name="l06084"></a>06084 
<a name="l06085"></a>06085     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.type == e1000_phy_igp_3)
<a name="l06086"></a>06086         e1000e_igp3_phy_powerdown_workaround_ich8lan(&amp;adapter-&gt;hw);
<a name="l06087"></a>06087 
<a name="l06088"></a>06088     <span class="comment">/*</span>
<a name="l06089"></a>06089 <span class="comment">     * Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<a name="l06090"></a>06090 <span class="comment">     * would have already happened in close and is redundant.</span>
<a name="l06091"></a>06091 <span class="comment">     */</span>
<a name="l06092"></a>06092     e1000e_release_hw_control(adapter);
<a name="l06093"></a>06093 
<a name="l06094"></a>06094     pci_disable_device(pdev);
<a name="l06095"></a>06095 
<a name="l06096"></a>06096     <span class="keywordflow">return</span> 0;
<a name="l06097"></a>06097 }
<a name="l06098"></a>06098 
<a name="l06099"></a>06099 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_power_off(<span class="keyword">struct</span> pci_dev *pdev, <span class="keywordtype">bool</span> sleep, <span class="keywordtype">bool</span> wake)
<a name="l06100"></a>06100 {
<a name="l06101"></a>06101     <span class="keywordflow">if</span> (sleep &amp;&amp; wake) {
<a name="l06102"></a>06102         pci_prepare_to_sleep(pdev);
<a name="l06103"></a>06103         <span class="keywordflow">return</span>;
<a name="l06104"></a>06104     }
<a name="l06105"></a>06105 
<a name="l06106"></a>06106     pci_wake_from_d3(pdev, wake);
<a name="l06107"></a>06107     pci_set_power_state(pdev, PCI_D3hot);
<a name="l06108"></a>06108 }
<a name="l06109"></a>06109 
<a name="l06110"></a>06110 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_complete_shutdown(<span class="keyword">struct</span> pci_dev *pdev, <span class="keywordtype">bool</span> sleep,
<a name="l06111"></a>06111                                     <span class="keywordtype">bool</span> wake)
<a name="l06112"></a>06112 {
<a name="l06113"></a>06113     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06114"></a>06114     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06115"></a>06115 
<a name="l06116"></a>06116     <span class="comment">/*</span>
<a name="l06117"></a>06117 <span class="comment">     * The pci-e switch on some quad port adapters will report a</span>
<a name="l06118"></a>06118 <span class="comment">     * correctable error when the MAC transitions from D0 to D3.  To</span>
<a name="l06119"></a>06119 <span class="comment">     * prevent this we need to mask off the correctable errors on the</span>
<a name="l06120"></a>06120 <span class="comment">     * downstream port of the pci-e switch.</span>
<a name="l06121"></a>06121 <span class="comment">     */</span>
<a name="l06122"></a>06122     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_IS_QUAD_PORT) {
<a name="l06123"></a>06123         <span class="keyword">struct </span>pci_dev *us_dev = pdev-&gt;bus-&gt;self;
<a name="l06124"></a>06124         <span class="keywordtype">int</span> pos = pci_find_capability(us_dev, PCI_CAP_ID_EXP);
<a name="l06125"></a>06125         u16 devctl;
<a name="l06126"></a>06126 
<a name="l06127"></a>06127         pci_read_config_word(us_dev, pos + PCI_EXP_DEVCTL, &amp;devctl);
<a name="l06128"></a>06128         pci_write_config_word(us_dev, pos + PCI_EXP_DEVCTL,
<a name="l06129"></a>06129                               (devctl &amp; ~PCI_EXP_DEVCTL_CERE));
<a name="l06130"></a>06130 
<a name="l06131"></a>06131         e1000_power_off(pdev, sleep, wake);
<a name="l06132"></a>06132 
<a name="l06133"></a>06133         pci_write_config_word(us_dev, pos + PCI_EXP_DEVCTL, devctl);
<a name="l06134"></a>06134     } <span class="keywordflow">else</span> {
<a name="l06135"></a>06135         e1000_power_off(pdev, sleep, wake);
<a name="l06136"></a>06136     }
<a name="l06137"></a>06137 }
<a name="l06138"></a>06138 
<a name="l06139"></a>06139 <span class="preprocessor">#ifdef CONFIG_PCIEASPM</span>
<a name="l06140"></a>06140 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> __e1000e_disable_aspm(<span class="keyword">struct</span> pci_dev *pdev, u16 <a class="code" href="structstate.html">state</a>)
<a name="l06141"></a>06141 {
<a name="l06142"></a>06142     pci_disable_link_state(pdev, state);
<a name="l06143"></a>06143 }
<a name="l06144"></a>06144 <span class="preprocessor">#else</span>
<a name="l06145"></a>06145 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> __e1000e_disable_aspm(<span class="keyword">struct</span> pci_dev *pdev, u16 <a class="code" href="structstate.html">state</a>)
<a name="l06146"></a>06146 {
<a name="l06147"></a>06147     <span class="keywordtype">int</span> pos;
<a name="l06148"></a>06148     u16 reg16;
<a name="l06149"></a>06149 
<a name="l06150"></a>06150     <span class="comment">/*</span>
<a name="l06151"></a>06151 <span class="comment">     * Both device and parent should have the same ASPM setting.</span>
<a name="l06152"></a>06152 <span class="comment">     * Disable ASPM in downstream component first and then upstream.</span>
<a name="l06153"></a>06153 <span class="comment">     */</span>
<a name="l06154"></a>06154     pos = pci_pcie_cap(pdev);
<a name="l06155"></a>06155     pci_read_config_word(pdev, pos + PCI_EXP_LNKCTL, &amp;reg16);
<a name="l06156"></a>06156     reg16 &amp;= ~state;
<a name="l06157"></a>06157     pci_write_config_word(pdev, pos + PCI_EXP_LNKCTL, reg16);
<a name="l06158"></a>06158 
<a name="l06159"></a>06159     <span class="keywordflow">if</span> (!pdev-&gt;bus-&gt;self)
<a name="l06160"></a>06160         <span class="keywordflow">return</span>;
<a name="l06161"></a>06161 
<a name="l06162"></a>06162     pos = pci_pcie_cap(pdev-&gt;bus-&gt;self);
<a name="l06163"></a>06163     pci_read_config_word(pdev-&gt;bus-&gt;self, pos + PCI_EXP_LNKCTL, &amp;reg16);
<a name="l06164"></a>06164     reg16 &amp;= ~state;
<a name="l06165"></a>06165     pci_write_config_word(pdev-&gt;bus-&gt;self, pos + PCI_EXP_LNKCTL, reg16);
<a name="l06166"></a>06166 }
<a name="l06167"></a>06167 <span class="preprocessor">#endif</span>
<a name="l06168"></a>06168 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> e1000e_disable_aspm(<span class="keyword">struct</span> pci_dev *pdev, u16 state)
<a name="l06169"></a>06169 {
<a name="l06170"></a>06170     dev_info(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;Disabling ASPM %s %s\n&quot;</span>,
<a name="l06171"></a>06171          (state &amp; PCIE_LINK_STATE_L0S) ? <span class="stringliteral">&quot;L0s&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l06172"></a>06172          (state &amp; PCIE_LINK_STATE_L1) ? <span class="stringliteral">&quot;L1&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l06173"></a>06173 
<a name="l06174"></a>06174     __e1000e_disable_aspm(pdev, state);
<a name="l06175"></a>06175 }
<a name="l06176"></a>06176 
<a name="l06177"></a>06177 <span class="preprocessor">#ifdef CONFIG_PM_OPS</span>
<a name="l06178"></a>06178 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> e1000e_pm_ready(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l06179"></a>06179 {
<a name="l06180"></a>06180     <span class="keywordflow">return</span> !!adapter-&gt;tx_ring-&gt;buffer_info;
<a name="l06181"></a>06181 }
<a name="l06182"></a>06182 
<a name="l06183"></a>06183 <span class="keyword">static</span> <span class="keywordtype">int</span> __e1000_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06184"></a>06184 {
<a name="l06185"></a>06185     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06186"></a>06186     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06187"></a>06187     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06188"></a>06188     u32 err;
<a name="l06189"></a>06189 
<a name="l06190"></a>06190     pci_set_power_state(pdev, PCI_D0);
<a name="l06191"></a>06191     pci_restore_state(pdev);
<a name="l06192"></a>06192     pci_save_state(pdev);
<a name="l06193"></a>06193     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_DISABLE_ASPM_L1)
<a name="l06194"></a>06194         e1000e_disable_aspm(pdev, PCIE_LINK_STATE_L1);
<a name="l06195"></a>06195 
<a name="l06196"></a>06196 <span class="preprocessor">#ifndef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l06197"></a>06197 <span class="preprocessor"></span>    err = pci_enable_device_mem(pdev);
<a name="l06198"></a>06198     <span class="keywordflow">if</span> (err) {
<a name="l06199"></a>06199         dev_err(pci_dev_to_dev(pdev),
<a name="l06200"></a>06200             <span class="stringliteral">&quot;Cannot enable PCI device from suspend\n&quot;</span>);
<a name="l06201"></a>06201         <span class="keywordflow">return</span> err;
<a name="l06202"></a>06202     }
<a name="l06203"></a>06203 
<a name="l06204"></a>06204     pci_set_master(pdev);
<a name="l06205"></a>06205 
<a name="l06206"></a>06206     pci_enable_wake(pdev, PCI_D3hot, 0);
<a name="l06207"></a>06207     pci_enable_wake(pdev, PCI_D3cold, 0);
<a name="l06208"></a>06208 
<a name="l06209"></a>06209 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SYSTEM_SLEEP_PM_OPS */</span>
<a name="l06210"></a>06210 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l06211"></a>06211 <span class="preprocessor"></span>    e1000e_set_interrupt_capability(adapter);
<a name="l06212"></a>06212 <span class="preprocessor">#endif</span>
<a name="l06213"></a>06213 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l06214"></a>06214         err = e1000_request_irq(adapter);
<a name="l06215"></a>06215         <span class="keywordflow">if</span> (err)
<a name="l06216"></a>06216             <span class="keywordflow">return</span> err;
<a name="l06217"></a>06217     }
<a name="l06218"></a>06218 
<a name="l06219"></a>06219     e1000e_power_up_phy(adapter);
<a name="l06220"></a>06220 
<a name="l06221"></a>06221     <span class="comment">/* report the system wakeup cause from S3/S4 */</span>
<a name="l06222"></a>06222     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_HAS_PHY_WAKEUP) {
<a name="l06223"></a>06223         u16 phy_data;
<a name="l06224"></a>06224 
<a name="l06225"></a>06225         e1e_rphy(&amp;adapter-&gt;hw, BM_WUS, &amp;phy_data);
<a name="l06226"></a>06226         <span class="keywordflow">if</span> (phy_data) {
<a name="l06227"></a>06227             e_info(<span class="stringliteral">&quot;PHY Wakeup cause - %s\n&quot;</span>,
<a name="l06228"></a>06228                 phy_data &amp; E1000_WUS_EX ? <span class="stringliteral">&quot;Unicast Packet&quot;</span> :
<a name="l06229"></a>06229                 phy_data &amp; E1000_WUS_MC ? <span class="stringliteral">&quot;Multicast Packet&quot;</span> :
<a name="l06230"></a>06230                 phy_data &amp; E1000_WUS_BC ? <span class="stringliteral">&quot;Broadcast Packet&quot;</span> :
<a name="l06231"></a>06231                 phy_data &amp; E1000_WUS_MAG ? <span class="stringliteral">&quot;Magic Packet&quot;</span> :
<a name="l06232"></a>06232                 phy_data &amp; E1000_WUS_LNKC ? <span class="stringliteral">&quot;Link Status &quot;</span>
<a name="l06233"></a>06233                 <span class="stringliteral">&quot; Change&quot;</span> : <span class="stringliteral">&quot;other&quot;</span>);
<a name="l06234"></a>06234         }
<a name="l06235"></a>06235         e1e_wphy(&amp;adapter-&gt;hw, BM_WUS, ~0);
<a name="l06236"></a>06236     } <span class="keywordflow">else</span> {
<a name="l06237"></a>06237         u32 wus = er32(WUS);
<a name="l06238"></a>06238         <span class="keywordflow">if</span> (wus) {
<a name="l06239"></a>06239             e_info(<span class="stringliteral">&quot;MAC Wakeup cause - %s\n&quot;</span>,
<a name="l06240"></a>06240                 wus &amp; E1000_WUS_EX ? <span class="stringliteral">&quot;Unicast Packet&quot;</span> :
<a name="l06241"></a>06241                 wus &amp; E1000_WUS_MC ? <span class="stringliteral">&quot;Multicast Packet&quot;</span> :
<a name="l06242"></a>06242                 wus &amp; E1000_WUS_BC ? <span class="stringliteral">&quot;Broadcast Packet&quot;</span> :
<a name="l06243"></a>06243                 wus &amp; E1000_WUS_MAG ? <span class="stringliteral">&quot;Magic Packet&quot;</span> :
<a name="l06244"></a>06244                 wus &amp; E1000_WUS_LNKC ? <span class="stringliteral">&quot;Link Status Change&quot;</span> :
<a name="l06245"></a>06245                 <span class="stringliteral">&quot;other&quot;</span>);
<a name="l06246"></a>06246         }
<a name="l06247"></a>06247         ew32(WUS, ~0);
<a name="l06248"></a>06248     }
<a name="l06249"></a>06249 
<a name="l06250"></a>06250     e1000e_reset(adapter);
<a name="l06251"></a>06251 
<a name="l06252"></a>06252     e1000_init_manageability_pt(adapter);
<a name="l06253"></a>06253 
<a name="l06254"></a>06254     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l06255"></a>06255         e1000e_up(adapter);
<a name="l06256"></a>06256 
<a name="l06257"></a>06257     netif_device_attach(netdev);
<a name="l06258"></a>06258 
<a name="l06259"></a>06259     <span class="comment">/*</span>
<a name="l06260"></a>06260 <span class="comment">     * If the controller has AMT, do not set DRV_LOAD until the interface</span>
<a name="l06261"></a>06261 <span class="comment">     * is up.  For all other cases, let the f/w know that the h/w is now</span>
<a name="l06262"></a>06262 <span class="comment">     * under the control of the driver.</span>
<a name="l06263"></a>06263 <span class="comment">     */</span>
<a name="l06264"></a>06264     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_HAS_AMT))
<a name="l06265"></a>06265         e1000e_get_hw_control(adapter);
<a name="l06266"></a>06266 
<a name="l06267"></a>06267     <span class="keywordflow">return</span> 0;
<a name="l06268"></a>06268 }
<a name="l06269"></a>06269 
<a name="l06270"></a>06270 <span class="preprocessor">#ifdef CONFIG_PM_SLEEP</span>
<a name="l06271"></a>06271 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l06272"></a>06272 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> e1000_suspend(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev)
<a name="l06273"></a>06273 <span class="preprocessor">#else</span>
<a name="l06274"></a>06274 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> e1000_suspend(<span class="keyword">struct</span> pci_dev *pdev, pm_message_t state)
<a name="l06275"></a>06275 <span class="preprocessor">#endif</span>
<a name="l06276"></a>06276 <span class="preprocessor"></span>{
<a name="l06277"></a>06277 <span class="preprocessor">#ifdef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l06278"></a>06278 <span class="preprocessor"></span>    <span class="keyword">struct </span>pci_dev *pdev = to_pci_dev(dev);
<a name="l06279"></a>06279 <span class="preprocessor">#endif</span>
<a name="l06280"></a>06280 <span class="preprocessor"></span>    <span class="keywordtype">int</span> retval;
<a name="l06281"></a>06281     <span class="keywordtype">bool</span> wake;
<a name="l06282"></a>06282 
<a name="l06283"></a>06283     retval = __e1000_shutdown(pdev, &amp;wake, <span class="keyword">false</span>);
<a name="l06284"></a>06284     <span class="keywordflow">if</span> (!retval)
<a name="l06285"></a>06285         e1000_complete_shutdown(pdev, <span class="keyword">true</span>, wake);
<a name="l06286"></a>06286 
<a name="l06287"></a>06287     <span class="keywordflow">return</span> retval;
<a name="l06288"></a>06288 }
<a name="l06289"></a>06289 
<a name="l06290"></a>06290 <span class="preprocessor">#ifdef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l06291"></a>06291 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> e1000_resume(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev)
<a name="l06292"></a>06292 <span class="preprocessor">#else</span>
<a name="l06293"></a>06293 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> e1000_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06294"></a>06294 <span class="preprocessor">#endif</span>
<a name="l06295"></a>06295 <span class="preprocessor"></span>{
<a name="l06296"></a>06296 <span class="preprocessor">#ifdef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l06297"></a>06297 <span class="preprocessor"></span>    <span class="keyword">struct </span>pci_dev *pdev = to_pci_dev(dev);
<a name="l06298"></a>06298 <span class="preprocessor">#endif</span>
<a name="l06299"></a>06299 <span class="preprocessor"></span>    <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06300"></a>06300     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06301"></a>06301 
<a name="l06302"></a>06302     <span class="keywordflow">if</span> (e1000e_pm_ready(adapter))
<a name="l06303"></a>06303         adapter-&gt;idle_check = <span class="keyword">true</span>;
<a name="l06304"></a>06304 
<a name="l06305"></a>06305     <span class="keywordflow">return</span> __e1000_resume(pdev);
<a name="l06306"></a>06306 }
<a name="l06307"></a>06307 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PM_SLEEP */</span>
<a name="l06308"></a>06308 
<a name="l06309"></a>06309 <span class="preprocessor">#ifdef CONFIG_PM_RUNTIME</span>
<a name="l06310"></a>06310 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l06311"></a>06311 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> e1000_runtime_suspend(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev)
<a name="l06312"></a>06312 {
<a name="l06313"></a>06313     <span class="keyword">struct </span>pci_dev *pdev = to_pci_dev(dev);
<a name="l06314"></a>06314     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06315"></a>06315     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06316"></a>06316 
<a name="l06317"></a>06317     <span class="keywordflow">if</span> (e1000e_pm_ready(adapter)) {
<a name="l06318"></a>06318         <span class="keywordtype">bool</span> wake;
<a name="l06319"></a>06319 
<a name="l06320"></a>06320         __e1000_shutdown(pdev, &amp;wake, <span class="keyword">true</span>);
<a name="l06321"></a>06321     }
<a name="l06322"></a>06322 
<a name="l06323"></a>06323     <span class="keywordflow">return</span> 0;
<a name="l06324"></a>06324 }
<a name="l06325"></a>06325 
<a name="l06326"></a>06326 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_idle(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev)
<a name="l06327"></a>06327 {
<a name="l06328"></a>06328     <span class="keyword">struct </span>pci_dev *pdev = to_pci_dev(dev);
<a name="l06329"></a>06329     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06330"></a>06330     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06331"></a>06331 
<a name="l06332"></a>06332     <span class="keywordflow">if</span> (!e1000e_pm_ready(adapter))
<a name="l06333"></a>06333         <span class="keywordflow">return</span> 0;
<a name="l06334"></a>06334 
<a name="l06335"></a>06335     <span class="keywordflow">if</span> (adapter-&gt;idle_check) {
<a name="l06336"></a>06336         adapter-&gt;idle_check = <span class="keyword">false</span>;
<a name="l06337"></a>06337         <span class="keywordflow">if</span> (!e1000e_has_link(adapter))
<a name="l06338"></a>06338             pm_schedule_suspend(dev, MSEC_PER_SEC);
<a name="l06339"></a>06339     }
<a name="l06340"></a>06340 
<a name="l06341"></a>06341     <span class="keywordflow">return</span> -EBUSY;
<a name="l06342"></a>06342 }
<a name="l06343"></a>06343 
<a name="l06344"></a>06344 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_runtime_resume(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev)
<a name="l06345"></a>06345 {
<a name="l06346"></a>06346     <span class="keyword">struct </span>pci_dev *pdev = to_pci_dev(dev);
<a name="l06347"></a>06347     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06348"></a>06348     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06349"></a>06349 
<a name="l06350"></a>06350     <span class="keywordflow">if</span> (!e1000e_pm_ready(adapter))
<a name="l06351"></a>06351         <span class="keywordflow">return</span> 0;
<a name="l06352"></a>06352 
<a name="l06353"></a>06353     adapter-&gt;idle_check = !dev-&gt;power.runtime_auto;
<a name="l06354"></a>06354     <span class="keywordflow">return</span> __e1000_resume(pdev);
<a name="l06355"></a>06355 }
<a name="l06356"></a>06356 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SYSTEM_SLEEP_PM_OPS */</span>
<a name="l06357"></a>06357 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PM_RUNTIME */</span>
<a name="l06358"></a>06358 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PM_OPS */</span>
<a name="l06359"></a>06359 
<a name="l06360"></a>06360 <span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l06361"></a>06361 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> e1000_shutdown(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06362"></a>06362 {
<a name="l06363"></a>06363     <span class="keywordtype">bool</span> wake = <span class="keyword">false</span>;
<a name="l06364"></a>06364 
<a name="l06365"></a>06365     __e1000_shutdown(pdev, &amp;wake, <span class="keyword">false</span>);
<a name="l06366"></a>06366 
<a name="l06367"></a>06367     <span class="keywordflow">if</span> (system_state == SYSTEM_POWER_OFF)
<a name="l06368"></a>06368         e1000_complete_shutdown(pdev, <span class="keyword">false</span>, wake);
<a name="l06369"></a>06369 }
<a name="l06370"></a>06370 <span class="preprocessor">#else</span>
<a name="l06371"></a>06371 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span>pci_driver e1000_driver;
<a name="l06372"></a>06372 <span class="keyword">static</span> <span class="keywordtype">int</span> e1000_notify_reboot(<span class="keyword">struct</span> notifier_block *nb, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l06373"></a>06373                    <span class="keywordtype">void</span> *ptr)
<a name="l06374"></a>06374 {
<a name="l06375"></a>06375     <span class="keyword">struct </span>pci_dev *pdev = NULL;
<a name="l06376"></a>06376     <span class="keywordtype">bool</span> wake = <span class="keyword">false</span>;
<a name="l06377"></a>06377 
<a name="l06378"></a>06378     <span class="keywordflow">switch</span> (event) {
<a name="l06379"></a>06379     <span class="keywordflow">case</span> SYS_DOWN:
<a name="l06380"></a>06380     <span class="keywordflow">case</span> SYS_HALT:
<a name="l06381"></a>06381     <span class="keywordflow">case</span> SYS_POWER_OFF:
<a name="l06382"></a>06382         <span class="keywordflow">while</span> ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev))) {
<a name="l06383"></a>06383             <span class="keywordflow">if</span> (pci_dev_driver(pdev) == &amp;e1000_driver) {
<a name="l06384"></a>06384                 __e1000_shutdown(pdev, &amp;wake, <span class="keyword">false</span>);
<a name="l06385"></a>06385                 <span class="keywordflow">if</span> (event == SYS_POWER_OFF)
<a name="l06386"></a>06386                     e1000_complete_shutdown(pdev, <span class="keyword">false</span>,
<a name="l06387"></a>06387                                 wake);
<a name="l06388"></a>06388             }
<a name="l06389"></a>06389         }
<a name="l06390"></a>06390         <span class="keywordflow">break</span>;
<a name="l06391"></a>06391     }
<a name="l06392"></a>06392     <span class="keywordflow">return</span> NOTIFY_DONE;
<a name="l06393"></a>06393 }
<a name="l06394"></a>06394 
<a name="l06395"></a>06395 <span class="keyword">static</span> <span class="keyword">struct </span>notifier_block e1000_notifier_reboot = {
<a name="l06396"></a>06396     .notifier_call  = e1000_notify_reboot,
<a name="l06397"></a>06397     .next       = NULL,
<a name="l06398"></a>06398     .priority   = 0
<a name="l06399"></a>06399 };
<a name="l06400"></a>06400 <span class="preprocessor">#endif </span><span class="comment">/* USE_REBOOT_NOTIFIER */</span>
<a name="l06401"></a>06401 
<a name="l06402"></a>06402 <span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l06403"></a>06403 <span class="preprocessor"></span>
<a name="l06404"></a>06404 <span class="keyword">static</span> irqreturn_t e1000_intr_msix(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l06405"></a>06405 {
<a name="l06406"></a>06406     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l06407"></a>06407     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06408"></a>06408     <span class="keywordtype">int</span> vector, msix_irq;
<a name="l06409"></a>06409 
<a name="l06410"></a>06410     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l06411"></a>06411         vector = 0;
<a name="l06412"></a>06412         msix_irq = adapter-&gt;msix_entries[vector].vector;
<a name="l06413"></a>06413         disable_irq(msix_irq);
<a name="l06414"></a>06414         e1000_intr_msix_rx(msix_irq, netdev);
<a name="l06415"></a>06415         enable_irq(msix_irq);
<a name="l06416"></a>06416 
<a name="l06417"></a>06417 <span class="preprocessor">#ifdef CONFIG_E1000E_SEPARATE_TX_HANDLER</span>
<a name="l06418"></a>06418 <span class="preprocessor"></span>        vector++;
<a name="l06419"></a>06419         msix_irq = adapter-&gt;msix_entries[vector].vector;
<a name="l06420"></a>06420         disable_irq(msix_irq);
<a name="l06421"></a>06421         e1000_intr_msix_tx(msix_irq, netdev);
<a name="l06422"></a>06422         enable_irq(msix_irq);
<a name="l06423"></a>06423 
<a name="l06424"></a>06424 <span class="preprocessor">#endif</span>
<a name="l06425"></a>06425 <span class="preprocessor"></span>        vector++;
<a name="l06426"></a>06426         msix_irq = adapter-&gt;msix_entries[vector].vector;
<a name="l06427"></a>06427         disable_irq(msix_irq);
<a name="l06428"></a>06428         e1000_msix_other(msix_irq, netdev);
<a name="l06429"></a>06429         enable_irq(msix_irq);
<a name="l06430"></a>06430     }
<a name="l06431"></a>06431 
<a name="l06432"></a>06432     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l06433"></a>06433 }
<a name="l06434"></a>06434 
<a name="l06435"></a>06435 <span class="comment">/*</span>
<a name="l06436"></a>06436 <span class="comment"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<a name="l06437"></a>06437 <span class="comment"> * without having to re-enable interrupts. It&#39;s not called while</span>
<a name="l06438"></a>06438 <span class="comment"> * the interrupt routine is executing.</span>
<a name="l06439"></a>06439 <span class="comment"> */</span>
<a name="l06440"></a>06440 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_netpoll(<span class="keyword">struct</span> net_device *netdev)
<a name="l06441"></a>06441 {
<a name="l06442"></a>06442     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06443"></a>06443 
<a name="l06444"></a>06444     enable_irq(adapter-&gt;pdev-&gt;irq);
<a name="l06445"></a>06445     <span class="keywordflow">switch</span> (adapter-&gt;int_mode) {
<a name="l06446"></a>06446     <span class="keywordflow">case</span> E1000E_INT_MODE_MSIX:
<a name="l06447"></a>06447         e1000_intr_msix(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l06448"></a>06448         <span class="keywordflow">break</span>;
<a name="l06449"></a>06449     <span class="keywordflow">case</span> E1000E_INT_MODE_MSI:
<a name="l06450"></a>06450         disable_irq(adapter-&gt;pdev-&gt;irq);
<a name="l06451"></a>06451         e1000_intr_msi(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l06452"></a>06452         enable_irq(adapter-&gt;pdev-&gt;irq);
<a name="l06453"></a>06453         <span class="keywordflow">break</span>;
<a name="l06454"></a>06454     <span class="keywordflow">default</span>: <span class="comment">/* E1000E_INT_MODE_LEGACY */</span>
<a name="l06455"></a>06455         disable_irq(adapter-&gt;pdev-&gt;irq);
<a name="l06456"></a>06456         e1000_intr(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l06457"></a>06457         enable_irq(adapter-&gt;pdev-&gt;irq);
<a name="l06458"></a>06458         <span class="keywordflow">break</span>;
<a name="l06459"></a>06459     }
<a name="l06460"></a>06460 }
<a name="l06461"></a>06461 <span class="preprocessor">#endif</span>
<a name="l06462"></a>06462 <span class="preprocessor"></span>
<a name="l06463"></a>06463 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l06464"></a>06464 <span class="preprocessor"></span>
<a name="l06472"></a>06472 <span class="keyword">static</span> pci_ers_result_t e1000_io_error_detected(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l06473"></a>06473                         pci_channel_state_t state)
<a name="l06474"></a>06474 {
<a name="l06475"></a>06475     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06476"></a>06476     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06477"></a>06477 
<a name="l06478"></a>06478     netif_device_detach(netdev);
<a name="l06479"></a>06479 
<a name="l06480"></a>06480     <span class="keywordflow">if</span> (state == pci_channel_io_perm_failure)
<a name="l06481"></a>06481         <span class="keywordflow">return</span> PCI_ERS_RESULT_DISCONNECT;
<a name="l06482"></a>06482 
<a name="l06483"></a>06483     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l06484"></a>06484         e1000e_down(adapter);
<a name="l06485"></a>06485     pci_disable_device(pdev);
<a name="l06486"></a>06486 
<a name="l06487"></a>06487     <span class="comment">/* Request a slot slot reset. */</span>
<a name="l06488"></a>06488     <span class="keywordflow">return</span> PCI_ERS_RESULT_NEED_RESET;
<a name="l06489"></a>06489 }
<a name="l06490"></a>06490 
<a name="l06498"></a>06498 <span class="keyword">static</span> pci_ers_result_t e1000_io_slot_reset(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06499"></a>06499 {
<a name="l06500"></a>06500     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06501"></a>06501     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06502"></a>06502     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06503"></a>06503     <span class="keywordtype">int</span> err;
<a name="l06504"></a>06504     pci_ers_result_t result;
<a name="l06505"></a>06505 
<a name="l06506"></a>06506     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; FLAG2_DISABLE_ASPM_L1)
<a name="l06507"></a>06507         e1000e_disable_aspm(pdev, PCIE_LINK_STATE_L1);
<a name="l06508"></a>06508     err = pci_enable_device_mem(pdev);
<a name="l06509"></a>06509     <span class="keywordflow">if</span> (err) {
<a name="l06510"></a>06510         dev_err(pci_dev_to_dev(pdev),
<a name="l06511"></a>06511             <span class="stringliteral">&quot;Cannot re-enable PCI device after reset.\n&quot;</span>);
<a name="l06512"></a>06512         result = PCI_ERS_RESULT_DISCONNECT;
<a name="l06513"></a>06513     } <span class="keywordflow">else</span> {
<a name="l06514"></a>06514         pci_set_master(pdev);
<a name="l06515"></a>06515         pci_restore_state(pdev);
<a name="l06516"></a>06516         pci_save_state(pdev);
<a name="l06517"></a>06517 
<a name="l06518"></a>06518         pci_enable_wake(pdev, PCI_D3hot, 0);
<a name="l06519"></a>06519         pci_enable_wake(pdev, PCI_D3cold, 0);
<a name="l06520"></a>06520 
<a name="l06521"></a>06521         e1000e_reset(adapter);
<a name="l06522"></a>06522         ew32(WUS, ~0);
<a name="l06523"></a>06523         result = PCI_ERS_RESULT_RECOVERED;
<a name="l06524"></a>06524     }
<a name="l06525"></a>06525 
<a name="l06526"></a>06526     pci_cleanup_aer_uncorrect_error_status(pdev);
<a name="l06527"></a>06527 
<a name="l06528"></a>06528     <span class="keywordflow">return</span> result;
<a name="l06529"></a>06529 }
<a name="l06530"></a>06530 
<a name="l06539"></a>06539 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_io_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06540"></a>06540 {
<a name="l06541"></a>06541     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l06542"></a>06542     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06543"></a>06543 
<a name="l06544"></a>06544     e1000_init_manageability_pt(adapter);
<a name="l06545"></a>06545 
<a name="l06546"></a>06546     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l06547"></a>06547         <span class="keywordflow">if</span> (e1000e_up(adapter)) {
<a name="l06548"></a>06548             dev_err(pci_dev_to_dev(pdev),
<a name="l06549"></a>06549                 <span class="stringliteral">&quot;can&#39;t bring device back up after reset\n&quot;</span>);
<a name="l06550"></a>06550             <span class="keywordflow">return</span>;
<a name="l06551"></a>06551         }
<a name="l06552"></a>06552     }
<a name="l06553"></a>06553 
<a name="l06554"></a>06554     netif_device_attach(netdev);
<a name="l06555"></a>06555 
<a name="l06556"></a>06556     <span class="comment">/*</span>
<a name="l06557"></a>06557 <span class="comment">     * If the controller has AMT, do not set DRV_LOAD until the interface</span>
<a name="l06558"></a>06558 <span class="comment">     * is up.  For all other cases, let the f/w know that the h/w is now</span>
<a name="l06559"></a>06559 <span class="comment">     * under the control of the driver.</span>
<a name="l06560"></a>06560 <span class="comment">     */</span>
<a name="l06561"></a>06561     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_HAS_AMT))
<a name="l06562"></a>06562         e1000e_get_hw_control(adapter);
<a name="l06563"></a>06563 
<a name="l06564"></a>06564 }
<a name="l06565"></a>06565 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PCI_ERS */</span>
<a name="l06566"></a>06566 
<a name="l06567"></a>06567 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_print_device_info(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l06568"></a>06568 {
<a name="l06569"></a>06569     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06570"></a>06570     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06571"></a>06571     u32 ret_val;
<a name="l06572"></a>06572     u8 pba_str[E1000_PBANUM_LENGTH];
<a name="l06573"></a>06573 
<a name="l06574"></a>06574     <span class="comment">/* print bus type/speed/width info */</span>
<a name="l06575"></a>06575     e_info(<span class="stringliteral">&quot;(PCI Express:2.5GB/s:%s) %02x:%02x:%02x:%02x:%02x:%02x\n&quot;</span>,
<a name="l06576"></a>06576            <span class="comment">/* bus width */</span>
<a name="l06577"></a>06577            ((hw-&gt;bus.width == e1000_bus_width_pcie_x4) ? <span class="stringliteral">&quot;Width x4&quot;</span> :
<a name="l06578"></a>06578             <span class="stringliteral">&quot;Width x1&quot;</span>),
<a name="l06579"></a>06579            <span class="comment">/* MAC address */</span>
<a name="l06580"></a>06580           netdev-&gt;dev_addr[0], netdev-&gt;dev_addr[1],
<a name="l06581"></a>06581           netdev-&gt;dev_addr[2], netdev-&gt;dev_addr[3],
<a name="l06582"></a>06582           netdev-&gt;dev_addr[4], netdev-&gt;dev_addr[5]);
<a name="l06583"></a>06583     e_info(<span class="stringliteral">&quot;Intel(R) PRO/%s Network Connection\n&quot;</span>,
<a name="l06584"></a>06584            (hw-&gt;phy.type == e1000_phy_ife) ? <span class="stringliteral">&quot;10/100&quot;</span> : <span class="stringliteral">&quot;1000&quot;</span>);
<a name="l06585"></a>06585     ret_val = e1000_read_pba_string_generic(hw, pba_str,
<a name="l06586"></a>06586                         E1000_PBANUM_LENGTH);
<a name="l06587"></a>06587     <span class="keywordflow">if</span> (ret_val)
<a name="l06588"></a>06588         strncpy((<span class="keywordtype">char</span> *)pba_str, <span class="stringliteral">&quot;Unknown&quot;</span>, <span class="keyword">sizeof</span>(pba_str) - 1);
<a name="l06589"></a>06589     e_info(<span class="stringliteral">&quot;MAC: %d, PHY: %d, PBA No: %s\n&quot;</span>,
<a name="l06590"></a>06590            hw-&gt;mac.type, hw-&gt;phy.type, pba_str);
<a name="l06591"></a>06591 }
<a name="l06592"></a>06592 
<a name="l06593"></a>06593 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_eeprom_checks(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter)
<a name="l06594"></a>06594 {
<a name="l06595"></a>06595     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06596"></a>06596     <span class="keywordtype">int</span> ret_val;
<a name="l06597"></a>06597     u16 buf = 0;
<a name="l06598"></a>06598 
<a name="l06599"></a>06599     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82573)
<a name="l06600"></a>06600         <span class="keywordflow">return</span>;
<a name="l06601"></a>06601 
<a name="l06602"></a>06602     ret_val = e1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &amp;buf);
<a name="l06603"></a>06603     <span class="keywordflow">if</span> (!ret_val &amp;&amp; (!(le16_to_cpu(buf) &amp; (1 &lt;&lt; 0)))) {
<a name="l06604"></a>06604         <span class="comment">/* Deep Smart Power Down (DSPD) */</span>
<a name="l06605"></a>06605         dev_warn(pci_dev_to_dev(adapter-&gt;pdev),
<a name="l06606"></a>06606              <span class="stringliteral">&quot;Warning: detected DSPD enabled in EEPROM\n&quot;</span>);
<a name="l06607"></a>06607     }
<a name="l06608"></a>06608 }
<a name="l06609"></a>06609 
<a name="l06610"></a>06610 s32 e1000_read_pcie_cap_reg(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 reg, u16 *value)
<a name="l06611"></a>06611 {
<a name="l06612"></a>06612     u16 cap_offset;
<a name="l06613"></a>06613 
<a name="l06614"></a>06614     cap_offset = pci_find_capability(hw-&gt;adapter-&gt;pdev, PCI_CAP_ID_EXP);
<a name="l06615"></a>06615     <span class="keywordflow">if</span> (!cap_offset)
<a name="l06616"></a>06616         <span class="keywordflow">return</span> -E1000_ERR_CONFIG;
<a name="l06617"></a>06617 
<a name="l06618"></a>06618     pci_read_config_word(hw-&gt;adapter-&gt;pdev, cap_offset + reg, value);
<a name="l06619"></a>06619 
<a name="l06620"></a>06620     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l06621"></a>06621 }
<a name="l06622"></a>06622 
<a name="l06623"></a>06623 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l06624"></a>06624 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>net_device_ops e1000e_netdev_ops = {
<a name="l06625"></a>06625     .ndo_open       = e1000_open,
<a name="l06626"></a>06626     .ndo_stop       = e1000_close,
<a name="l06627"></a>06627     .ndo_start_xmit     = e1000_xmit_frame,
<a name="l06628"></a>06628     .ndo_get_stats      = e1000_get_stats,
<a name="l06629"></a>06629     .ndo_set_multicast_list = e1000_set_multi,
<a name="l06630"></a>06630     .ndo_set_mac_address    = e1000_set_mac,
<a name="l06631"></a>06631     .ndo_change_mtu     = e1000_change_mtu,
<a name="l06632"></a>06632     .ndo_do_ioctl       = e1000_ioctl,
<a name="l06633"></a>06633     .ndo_tx_timeout     = e1000_tx_timeout,
<a name="l06634"></a>06634     .ndo_validate_addr  = eth_validate_addr,
<a name="l06635"></a>06635 
<a name="l06636"></a>06636 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l06637"></a>06637 <span class="preprocessor"></span>    .ndo_vlan_rx_register   = e1000_vlan_rx_register,
<a name="l06638"></a>06638     .ndo_vlan_rx_add_vid    = e1000_vlan_rx_add_vid,
<a name="l06639"></a>06639     .ndo_vlan_rx_kill_vid   = e1000_vlan_rx_kill_vid,
<a name="l06640"></a>06640 <span class="preprocessor">#endif</span>
<a name="l06641"></a>06641 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l06642"></a>06642 <span class="preprocessor"></span>    .ndo_poll_controller    = e1000_netpoll,
<a name="l06643"></a>06643 <span class="preprocessor">#endif</span>
<a name="l06644"></a>06644 <span class="preprocessor"></span>};
<a name="l06645"></a>06645 
<a name="l06646"></a>06646 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l06647"></a>06647 
<a name="l06658"></a>06658 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit e1000_probe(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l06659"></a>06659                  <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *ent)
<a name="l06660"></a>06660 {
<a name="l06661"></a>06661     <span class="keyword">struct </span>net_device *netdev;
<a name="l06662"></a>06662     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter;
<a name="l06663"></a>06663     <span class="keyword">struct </span><a class="code" href="structe1000__hw.html">e1000_hw</a> *hw;
<a name="l06664"></a>06664     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structe1000__info.html">e1000_info</a> *ei = e1000_info_tbl[ent-&gt;driver_data];
<a name="l06665"></a>06665     resource_size_t mmio_start, mmio_len;
<a name="l06666"></a>06666     resource_size_t flash_start, flash_len;
<a name="l06667"></a>06667     <span class="keyword">static</span> <span class="keywordtype">int</span> cards_found;
<a name="l06668"></a>06668     <span class="keywordtype">int</span> i, err, pci_using_dac;
<a name="l06669"></a>06669     u16 eeprom_data = 0;
<a name="l06670"></a>06670     u16 eeprom_apme_mask = E1000_EEPROM_APME;
<a name="l06671"></a>06671 
<a name="l06672"></a>06672     <span class="keywordflow">if</span> (ei-&gt;flags2 &amp; FLAG2_DISABLE_ASPM_L1)
<a name="l06673"></a>06673         e1000e_disable_aspm(pdev, PCIE_LINK_STATE_L1);
<a name="l06674"></a>06674 
<a name="l06675"></a>06675     err = pci_enable_device_mem(pdev);
<a name="l06676"></a>06676     <span class="keywordflow">if</span> (err)
<a name="l06677"></a>06677         <span class="keywordflow">return</span> err;
<a name="l06678"></a>06678 
<a name="l06679"></a>06679     pci_using_dac = 0;
<a name="l06680"></a>06680     err = dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64));
<a name="l06681"></a>06681     <span class="keywordflow">if</span> (!err) {
<a name="l06682"></a>06682         err = dma_set_coherent_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64));
<a name="l06683"></a>06683         <span class="keywordflow">if</span> (!err)
<a name="l06684"></a>06684             pci_using_dac = 1;
<a name="l06685"></a>06685     } <span class="keywordflow">else</span> {
<a name="l06686"></a>06686         err = dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(32));
<a name="l06687"></a>06687         <span class="keywordflow">if</span> (err) {
<a name="l06688"></a>06688             err = dma_set_coherent_mask(pci_dev_to_dev(pdev),
<a name="l06689"></a>06689                             DMA_BIT_MASK(32));
<a name="l06690"></a>06690             <span class="keywordflow">if</span> (err) {
<a name="l06691"></a>06691                 dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;No usable DMA &quot;</span>
<a name="l06692"></a>06692                     <span class="stringliteral">&quot;configuration, aborting\n&quot;</span>);
<a name="l06693"></a>06693                 <span class="keywordflow">goto</span> err_dma;
<a name="l06694"></a>06694             }
<a name="l06695"></a>06695         }
<a name="l06696"></a>06696     }
<a name="l06697"></a>06697 
<a name="l06698"></a>06698 <span class="comment">/* *INDENT-OFF* */</span>
<a name="l06699"></a>06699     err = pci_request_selected_regions_exclusive(pdev,
<a name="l06700"></a>06700                     pci_select_bars(pdev, IORESOURCE_MEM),
<a name="l06701"></a>06701                     e1000e_driver_name);
<a name="l06702"></a>06702 <span class="comment">/* *INDENT-ON* */</span>
<a name="l06703"></a>06703     <span class="keywordflow">if</span> (err)
<a name="l06704"></a>06704         <span class="keywordflow">goto</span> err_pci_reg;
<a name="l06705"></a>06705 
<a name="l06706"></a>06706     <span class="comment">/* AER (Advanced Error Reporting) hooks */</span>
<a name="l06707"></a>06707     pci_enable_pcie_error_reporting(pdev);
<a name="l06708"></a>06708 
<a name="l06709"></a>06709     pci_set_master(pdev);
<a name="l06710"></a>06710 
<a name="l06711"></a>06711     err = -ENOMEM;
<a name="l06712"></a>06712     netdev = alloc_etherdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structe1000__adapter.html">e1000_adapter</a>));
<a name="l06713"></a>06713     <span class="keywordflow">if</span> (!netdev)
<a name="l06714"></a>06714         <span class="keywordflow">goto</span> err_alloc_etherdev;
<a name="l06715"></a>06715 
<a name="l06716"></a>06716     SET_MODULE_OWNER(netdev);
<a name="l06717"></a>06717     SET_NETDEV_DEV(netdev, pci_dev_to_dev(pdev));
<a name="l06718"></a>06718 
<a name="l06719"></a>06719     netdev-&gt;irq = pdev-&gt;irq;
<a name="l06720"></a>06720 
<a name="l06721"></a>06721     pci_set_drvdata(pdev, netdev);
<a name="l06722"></a>06722 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l06723"></a>06723 <span class="preprocessor"></span>    <span class="comment">/* PCI config space info */</span>
<a name="l06724"></a>06724     err = pci_save_state(pdev);
<a name="l06725"></a>06725     <span class="keywordflow">if</span> (err)
<a name="l06726"></a>06726         <span class="keywordflow">goto</span> err_ioremap;
<a name="l06727"></a>06727 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PCI_ERS */</span>
<a name="l06728"></a>06728     adapter = netdev_priv(netdev);
<a name="l06729"></a>06729     hw = &amp;adapter-&gt;hw;
<a name="l06730"></a>06730     adapter-&gt;node = -1;
<a name="l06731"></a>06731     adapter-&gt;netdev = netdev;
<a name="l06732"></a>06732     adapter-&gt;pdev = pdev;
<a name="l06733"></a>06733     adapter-&gt;ei = ei;
<a name="l06734"></a>06734     adapter-&gt;pba = ei-&gt;pba;
<a name="l06735"></a>06735     adapter-&gt;flags = ei-&gt;flags;
<a name="l06736"></a>06736     adapter-&gt;flags2 = ei-&gt;flags2;
<a name="l06737"></a>06737     adapter-&gt;hw.adapter = adapter;
<a name="l06738"></a>06738     adapter-&gt;hw.mac.type = ei-&gt;mac;
<a name="l06739"></a>06739     adapter-&gt;max_hw_frame_size = ei-&gt;max_hw_frame_size;
<a name="l06740"></a>06740     adapter-&gt;msg_enable = (1 &lt;&lt; NETIF_MSG_DRV | NETIF_MSG_PROBE) - 1;
<a name="l06741"></a>06741 
<a name="l06742"></a>06742     mmio_start = pci_resource_start(pdev, 0);
<a name="l06743"></a>06743     mmio_len = pci_resource_len(pdev, 0);
<a name="l06744"></a>06744 
<a name="l06745"></a>06745     err = -EIO;
<a name="l06746"></a>06746     adapter-&gt;hw.hw_addr = ioremap(mmio_start, mmio_len);
<a name="l06747"></a>06747     <span class="keywordflow">if</span> (!adapter-&gt;hw.hw_addr)
<a name="l06748"></a>06748         <span class="keywordflow">goto</span> err_ioremap;
<a name="l06749"></a>06749 
<a name="l06750"></a>06750     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; FLAG_HAS_FLASH) &amp;&amp;
<a name="l06751"></a>06751         (pci_resource_flags(pdev, 1) &amp; IORESOURCE_MEM)) {
<a name="l06752"></a>06752         flash_start = pci_resource_start(pdev, 1);
<a name="l06753"></a>06753         flash_len = pci_resource_len(pdev, 1);
<a name="l06754"></a>06754         adapter-&gt;hw.flash_address = ioremap(flash_start, flash_len);
<a name="l06755"></a>06755         <span class="keywordflow">if</span> (!adapter-&gt;hw.flash_address)
<a name="l06756"></a>06756             <span class="keywordflow">goto</span> err_flashmap;
<a name="l06757"></a>06757     }
<a name="l06758"></a>06758 
<a name="l06759"></a>06759     <span class="comment">/* construct the net_device struct */</span>
<a name="l06760"></a>06760 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l06761"></a>06761 <span class="preprocessor"></span>    netdev-&gt;netdev_ops      = &amp;e1000e_netdev_ops;
<a name="l06762"></a>06762 <span class="preprocessor">#else</span>
<a name="l06763"></a>06763 <span class="preprocessor"></span>    netdev-&gt;open            = &amp;e1000_open;
<a name="l06764"></a>06764     netdev-&gt;stop            = &amp;e1000_close;
<a name="l06765"></a>06765     netdev-&gt;hard_start_xmit     = &amp;e1000_xmit_frame;
<a name="l06766"></a>06766     netdev-&gt;get_stats       = &amp;e1000_get_stats;
<a name="l06767"></a>06767     netdev-&gt;set_multicast_list  = &amp;e1000_set_multi;
<a name="l06768"></a>06768     netdev-&gt;set_mac_address     = &amp;e1000_set_mac;
<a name="l06769"></a>06769     netdev-&gt;change_mtu      = &amp;e1000_change_mtu;
<a name="l06770"></a>06770     netdev-&gt;do_ioctl        = &amp;e1000_ioctl;
<a name="l06771"></a>06771     netdev-&gt;tx_timeout      = &amp;e1000_tx_timeout;
<a name="l06772"></a>06772 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l06773"></a>06773 <span class="preprocessor"></span>    netdev-&gt;vlan_rx_register    = e1000_vlan_rx_register;
<a name="l06774"></a>06774     netdev-&gt;vlan_rx_add_vid     = e1000_vlan_rx_add_vid;
<a name="l06775"></a>06775     netdev-&gt;vlan_rx_kill_vid    = e1000_vlan_rx_kill_vid;
<a name="l06776"></a>06776 <span class="preprocessor">#endif</span>
<a name="l06777"></a>06777 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l06778"></a>06778 <span class="preprocessor"></span>    netdev-&gt;poll_controller     = e1000_netpoll;
<a name="l06779"></a>06779 <span class="preprocessor">#endif</span>
<a name="l06780"></a>06780 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l06781"></a>06781     e1000e_set_ethtool_ops(netdev);
<a name="l06782"></a>06782     netdev-&gt;watchdog_timeo      = 5 * HZ;
<a name="l06783"></a>06783 <span class="preprocessor">#ifdef CONFIG_E1000E_NAPI</span>
<a name="l06784"></a>06784 <span class="preprocessor"></span>    netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_poll, 64);
<a name="l06785"></a>06785 <span class="preprocessor">#endif</span>
<a name="l06786"></a>06786 <span class="preprocessor"></span>    strncpy(netdev-&gt;name, pci_name(pdev), <span class="keyword">sizeof</span>(netdev-&gt;name) - 1);
<a name="l06787"></a>06787 
<a name="l06788"></a>06788     netdev-&gt;mem_start = mmio_start;
<a name="l06789"></a>06789     netdev-&gt;mem_end = mmio_start + mmio_len;
<a name="l06790"></a>06790 
<a name="l06791"></a>06791     adapter-&gt;bd_number = cards_found++;
<a name="l06792"></a>06792 
<a name="l06793"></a>06793     e1000e_check_options(adapter);
<a name="l06794"></a>06794 
<a name="l06795"></a>06795     <span class="keywordflow">if</span> (adapter-&gt;node &gt;= 0)
<a name="l06796"></a>06796         dev_info(pci_dev_to_dev(pdev),
<a name="l06797"></a>06797              <span class="stringliteral">&quot;Using NUMA node %d for memory allocations\n&quot;</span>,
<a name="l06798"></a>06798              adapter-&gt;node);
<a name="l06799"></a>06799 
<a name="l06800"></a>06800     <span class="comment">/* setup adapter struct */</span>
<a name="l06801"></a>06801     err = e1000_sw_init(adapter);
<a name="l06802"></a>06802     <span class="keywordflow">if</span> (err)
<a name="l06803"></a>06803         <span class="keywordflow">goto</span> err_sw_init;
<a name="l06804"></a>06804 
<a name="l06805"></a>06805     <span class="keywordflow">if</span> (ei-&gt;get_variants) {
<a name="l06806"></a>06806         err = ei-&gt;get_variants(adapter);
<a name="l06807"></a>06807         <span class="keywordflow">if</span> (err)
<a name="l06808"></a>06808             <span class="keywordflow">goto</span> err_hw_init;
<a name="l06809"></a>06809     }
<a name="l06810"></a>06810 
<a name="l06811"></a>06811     hw-&gt;mac.ops.get_bus_info(&amp;adapter-&gt;hw);
<a name="l06812"></a>06812 
<a name="l06813"></a>06813     adapter-&gt;hw.phy.autoneg_wait_to_complete = 0;
<a name="l06814"></a>06814 
<a name="l06815"></a>06815     <span class="comment">/* Copper options */</span>
<a name="l06816"></a>06816     <span class="keywordflow">if</span> (adapter-&gt;hw.phy.media_type == e1000_media_type_copper) {
<a name="l06817"></a>06817         adapter-&gt;hw.phy.mdix = AUTO_ALL_MODES;
<a name="l06818"></a>06818         adapter-&gt;hw.phy.disable_polarity_correction = 0;
<a name="l06819"></a>06819         adapter-&gt;hw.phy.ms_type = e1000_ms_hw_default;
<a name="l06820"></a>06820     }
<a name="l06821"></a>06821 
<a name="l06822"></a>06822     <span class="keywordflow">if</span> (e1000_check_reset_block(&amp;adapter-&gt;hw))
<a name="l06823"></a>06823         e_info(<span class="stringliteral">&quot;PHY reset is blocked due to SOL/IDER session.\n&quot;</span>);
<a name="l06824"></a>06824 
<a name="l06825"></a>06825 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l06826"></a>06826 <span class="preprocessor"></span>    netdev-&gt;features = NETIF_F_SG |
<a name="l06827"></a>06827         NETIF_F_HW_CSUM | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
<a name="l06828"></a>06828 
<a name="l06829"></a>06829     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_HAS_HW_VLAN_FILTER)
<a name="l06830"></a>06830         netdev-&gt;features |= NETIF_F_HW_VLAN_FILTER;
<a name="l06831"></a>06831 <span class="preprocessor">#else</span>
<a name="l06832"></a>06832 <span class="preprocessor"></span>    netdev-&gt;features = NETIF_F_SG | NETIF_F_HW_CSUM;
<a name="l06833"></a>06833 <span class="preprocessor">#endif</span>
<a name="l06834"></a>06834 <span class="preprocessor"></span>
<a name="l06835"></a>06835 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l06836"></a>06836 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO;
<a name="l06837"></a>06837 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l06838"></a>06838 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO6;
<a name="l06839"></a>06839 <span class="preprocessor">#endif</span>
<a name="l06840"></a>06840 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l06841"></a>06841 <span class="preprocessor"></span>
<a name="l06842"></a>06842 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l06843"></a>06843 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l06844"></a>06844 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_TSO;
<a name="l06845"></a>06845 <span class="preprocessor">#endif</span>
<a name="l06846"></a>06846 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l06847"></a>06847 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_TSO6;
<a name="l06848"></a>06848 <span class="preprocessor">#endif</span>
<a name="l06849"></a>06849 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_HW_CSUM;
<a name="l06850"></a>06850     netdev-&gt;vlan_features |= NETIF_F_SG;
<a name="l06851"></a>06851 
<a name="l06852"></a>06852 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l06853"></a>06853     <span class="keywordflow">if</span> (pci_using_dac) {
<a name="l06854"></a>06854         netdev-&gt;features |= NETIF_F_HIGHDMA;
<a name="l06855"></a>06855 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l06856"></a>06856 <span class="preprocessor"></span>        netdev-&gt;vlan_features |= NETIF_F_HIGHDMA;
<a name="l06857"></a>06857 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l06858"></a>06858     }
<a name="l06859"></a>06859 
<a name="l06860"></a>06860     <span class="keywordflow">if</span> (e1000e_enable_mng_pass_thru(&amp;adapter-&gt;hw))
<a name="l06861"></a>06861         adapter-&gt;flags |= FLAG_MNG_PT_ENABLED;
<a name="l06862"></a>06862 
<a name="l06863"></a>06863     <span class="comment">/*</span>
<a name="l06864"></a>06864 <span class="comment">     * before reading the NVM, reset the controller to</span>
<a name="l06865"></a>06865 <span class="comment">     * put the device in a known good starting state</span>
<a name="l06866"></a>06866 <span class="comment">     */</span>
<a name="l06867"></a>06867     adapter-&gt;hw.mac.ops.reset_hw(&amp;adapter-&gt;hw);
<a name="l06868"></a>06868 
<a name="l06869"></a>06869     <span class="comment">/*</span>
<a name="l06870"></a>06870 <span class="comment">     * systems with ASPM and others may see the checksum fail on the first</span>
<a name="l06871"></a>06871 <span class="comment">     * attempt. Let&#39;s give it a few tries</span>
<a name="l06872"></a>06872 <span class="comment">     */</span>
<a name="l06873"></a>06873     <span class="keywordflow">for</span> (i = 0;; i++) {
<a name="l06874"></a>06874         <span class="keywordflow">if</span> (e1000_validate_nvm_checksum(&amp;adapter-&gt;hw) &gt;= 0)
<a name="l06875"></a>06875             <span class="keywordflow">break</span>;
<a name="l06876"></a>06876         <span class="keywordflow">if</span> (i == 2) {
<a name="l06877"></a>06877             e_err(<span class="stringliteral">&quot;The NVM Checksum Is Not Valid\n&quot;</span>);
<a name="l06878"></a>06878             err = -EIO;
<a name="l06879"></a>06879             <span class="keywordflow">goto</span> err_eeprom;
<a name="l06880"></a>06880         }
<a name="l06881"></a>06881     }
<a name="l06882"></a>06882 
<a name="l06883"></a>06883     e1000_eeprom_checks(adapter);
<a name="l06884"></a>06884 
<a name="l06885"></a>06885     <span class="comment">/* copy the MAC address */</span>
<a name="l06886"></a>06886     <span class="keywordflow">if</span> (e1000e_read_mac_addr(&amp;adapter-&gt;hw))
<a name="l06887"></a>06887         e_err(<span class="stringliteral">&quot;NVM Read Error while reading MAC address\n&quot;</span>);
<a name="l06888"></a>06888 
<a name="l06889"></a>06889     memcpy(netdev-&gt;dev_addr, adapter-&gt;hw.mac.addr, netdev-&gt;addr_len);
<a name="l06890"></a>06890 <span class="preprocessor">#ifdef ETHTOOL_GPERMADDR</span>
<a name="l06891"></a>06891 <span class="preprocessor"></span>    memcpy(netdev-&gt;perm_addr, adapter-&gt;hw.mac.addr, netdev-&gt;addr_len);
<a name="l06892"></a>06892 
<a name="l06893"></a>06893     <span class="keywordflow">if</span> (!is_valid_ether_addr(netdev-&gt;perm_addr)) {
<a name="l06894"></a>06894 <span class="preprocessor">#else</span>
<a name="l06895"></a>06895 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!is_valid_ether_addr(netdev-&gt;dev_addr)) {
<a name="l06896"></a>06896 <span class="preprocessor">#endif</span>
<a name="l06897"></a>06897 <span class="preprocessor"></span>        e_err(<span class="stringliteral">&quot;Invalid MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n&quot;</span>,
<a name="l06898"></a>06898               netdev-&gt;dev_addr[0], netdev-&gt;dev_addr[1],
<a name="l06899"></a>06899               netdev-&gt;dev_addr[2], netdev-&gt;dev_addr[3],
<a name="l06900"></a>06900               netdev-&gt;dev_addr[4], netdev-&gt;dev_addr[5]);
<a name="l06901"></a>06901         err = -EIO;
<a name="l06902"></a>06902         <span class="keywordflow">goto</span> err_eeprom;
<a name="l06903"></a>06903     }
<a name="l06904"></a>06904 
<a name="l06905"></a>06905     init_timer(&amp;adapter-&gt;watchdog_timer);
<a name="l06906"></a>06906     adapter-&gt;watchdog_timer.function = e1000_watchdog;
<a name="l06907"></a>06907     adapter-&gt;watchdog_timer.data = (<span class="keywordtype">unsigned</span> long)adapter;
<a name="l06908"></a>06908 
<a name="l06909"></a>06909     init_timer(&amp;adapter-&gt;phy_info_timer);
<a name="l06910"></a>06910     adapter-&gt;phy_info_timer.function = e1000_update_phy_info;
<a name="l06911"></a>06911     adapter-&gt;phy_info_timer.data = (<span class="keywordtype">unsigned</span> long)adapter;
<a name="l06912"></a>06912 
<a name="l06913"></a>06913     INIT_WORK(&amp;adapter-&gt;reset_task, e1000_reset_task);
<a name="l06914"></a>06914     INIT_WORK(&amp;adapter-&gt;watchdog_task, e1000_watchdog_task);
<a name="l06915"></a>06915     INIT_WORK(&amp;adapter-&gt;downshift_task, e1000e_downshift_workaround);
<a name="l06916"></a>06916     INIT_WORK(&amp;adapter-&gt;update_phy_task, e1000e_update_phy_task);
<a name="l06917"></a>06917     INIT_WORK(&amp;adapter-&gt;print_hang_task, e1000_print_hw_hang);
<a name="l06918"></a>06918     INIT_WORK(&amp;adapter-&gt;led_blink_task, e1000e_led_blink_task);
<a name="l06919"></a>06919 
<a name="l06920"></a>06920     <span class="comment">/* Initialize link parameters. User can change them with ethtool */</span>
<a name="l06921"></a>06921     adapter-&gt;hw.mac.autoneg = 1;
<a name="l06922"></a>06922     adapter-&gt;fc_autoneg = 1;
<a name="l06923"></a>06923     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == e1000_pchlan) {
<a name="l06924"></a>06924         <span class="comment">/* Workaround h/w hang when Tx flow control enabled */</span>
<a name="l06925"></a>06925         adapter-&gt;hw.fc.requested_mode = e1000_fc_rx_pause;
<a name="l06926"></a>06926         adapter-&gt;hw.fc.current_mode = e1000_fc_rx_pause;
<a name="l06927"></a>06927     } <span class="keywordflow">else</span> {
<a name="l06928"></a>06928         adapter-&gt;hw.fc.requested_mode = e1000_fc_default;
<a name="l06929"></a>06929         adapter-&gt;hw.fc.current_mode = e1000_fc_default;
<a name="l06930"></a>06930     }
<a name="l06931"></a>06931     adapter-&gt;hw.phy.autoneg_advertised = 0x2f;
<a name="l06932"></a>06932 
<a name="l06933"></a>06933     <span class="comment">/* ring size defaults */</span>
<a name="l06934"></a>06934     adapter-&gt;rx_ring-&gt;count = 256;
<a name="l06935"></a>06935     adapter-&gt;tx_ring-&gt;count = 256;
<a name="l06936"></a>06936 
<a name="l06937"></a>06937     <span class="comment">/*</span>
<a name="l06938"></a>06938 <span class="comment">     * Initial Wake on LAN setting - If APM wake is enabled in</span>
<a name="l06939"></a>06939 <span class="comment">     * the EEPROM, enable the ACPI Magic Packet filter</span>
<a name="l06940"></a>06940 <span class="comment">     */</span>
<a name="l06941"></a>06941     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_APME_IN_WUC) {
<a name="l06942"></a>06942         <span class="comment">/* APME bit in EEPROM is mapped to WUC.APME */</span>
<a name="l06943"></a>06943         eeprom_data = er32(WUC);
<a name="l06944"></a>06944         eeprom_apme_mask = E1000_WUC_APME;
<a name="l06945"></a>06945         <span class="keywordflow">if</span> ((hw-&gt;mac.type &gt; e1000_ich10lan) &amp;&amp;
<a name="l06946"></a>06946             (eeprom_data &amp; E1000_WUC_PHY_WAKE))
<a name="l06947"></a>06947             adapter-&gt;flags2 |= FLAG2_HAS_PHY_WAKEUP;
<a name="l06948"></a>06948     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_APME_IN_CTRL3) {
<a name="l06949"></a>06949         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; FLAG_APME_CHECK_PORT_B &amp;&amp;
<a name="l06950"></a>06950             (adapter-&gt;hw.bus.func == 1))
<a name="l06951"></a>06951             e1000_read_nvm(&amp;adapter-&gt;hw, NVM_INIT_CONTROL3_PORT_B,
<a name="l06952"></a>06952                            1, &amp;eeprom_data);
<a name="l06953"></a>06953         <span class="keywordflow">else</span>
<a name="l06954"></a>06954             e1000_read_nvm(&amp;adapter-&gt;hw, NVM_INIT_CONTROL3_PORT_A,
<a name="l06955"></a>06955                            1, &amp;eeprom_data);
<a name="l06956"></a>06956     }
<a name="l06957"></a>06957 
<a name="l06958"></a>06958     <span class="comment">/* fetch WoL from EEPROM */</span>
<a name="l06959"></a>06959     <span class="keywordflow">if</span> (eeprom_data &amp; eeprom_apme_mask)
<a name="l06960"></a>06960         adapter-&gt;eeprom_wol |= E1000_WUFC_MAG;
<a name="l06961"></a>06961 
<a name="l06962"></a>06962     <span class="comment">/*</span>
<a name="l06963"></a>06963 <span class="comment">     * now that we have the eeprom settings, apply the special cases</span>
<a name="l06964"></a>06964 <span class="comment">     * where the eeprom may be wrong or the board simply won&#39;t support</span>
<a name="l06965"></a>06965 <span class="comment">     * wake on lan on a particular port</span>
<a name="l06966"></a>06966 <span class="comment">     */</span>
<a name="l06967"></a>06967     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_HAS_WOL))
<a name="l06968"></a>06968         adapter-&gt;eeprom_wol = 0;
<a name="l06969"></a>06969 
<a name="l06970"></a>06970     <span class="comment">/* initialize the wol settings based on the eeprom settings */</span>
<a name="l06971"></a>06971     adapter-&gt;wol = adapter-&gt;eeprom_wol;
<a name="l06972"></a>06972     device_set_wakeup_enable(pci_dev_to_dev(adapter-&gt;pdev), adapter-&gt;wol);
<a name="l06973"></a>06973 
<a name="l06974"></a>06974     <span class="comment">/* save off EEPROM version number */</span>
<a name="l06975"></a>06975     e1000_read_nvm(&amp;adapter-&gt;hw, 5, 1, &amp;adapter-&gt;eeprom_vers);
<a name="l06976"></a>06976 
<a name="l06977"></a>06977     <span class="comment">/* reset the hardware with the new settings */</span>
<a name="l06978"></a>06978     e1000e_reset(adapter);
<a name="l06979"></a>06979 
<a name="l06980"></a>06980     <span class="comment">/*</span>
<a name="l06981"></a>06981 <span class="comment">     * If the controller has AMT, do not set DRV_LOAD until the interface</span>
<a name="l06982"></a>06982 <span class="comment">     * is up.  For all other cases, let the f/w know that the h/w is now</span>
<a name="l06983"></a>06983 <span class="comment">     * under the control of the driver.</span>
<a name="l06984"></a>06984 <span class="comment">     */</span>
<a name="l06985"></a>06985     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_HAS_AMT))
<a name="l06986"></a>06986         e1000e_get_hw_control(adapter);
<a name="l06987"></a>06987 
<a name="l06988"></a>06988     strncpy(netdev-&gt;name, <span class="stringliteral">&quot;eth%d&quot;</span>, <span class="keyword">sizeof</span>(netdev-&gt;name) - 1);
<a name="l06989"></a>06989     err = register_netdev(netdev);
<a name="l06990"></a>06990     <span class="keywordflow">if</span> (err)
<a name="l06991"></a>06991         <span class="keywordflow">goto</span> err_register;
<a name="l06992"></a>06992 
<a name="l06993"></a>06993     <span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span>
<a name="l06994"></a>06994     netif_carrier_off(netdev);
<a name="l06995"></a>06995 
<a name="l06996"></a>06996     e1000_print_device_info(adapter);
<a name="l06997"></a>06997 
<a name="l06998"></a>06998     <span class="keywordflow">if</span> (pci_dev_run_wake(pdev))
<a name="l06999"></a>06999         pm_runtime_put_noidle(&amp;pdev-&gt;dev);
<a name="l07000"></a>07000 
<a name="l07001"></a>07001     <span class="keywordflow">return</span> 0;
<a name="l07002"></a>07002 
<a name="l07003"></a>07003 err_register:
<a name="l07004"></a>07004     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; FLAG_HAS_AMT))
<a name="l07005"></a>07005         e1000e_release_hw_control(adapter);
<a name="l07006"></a>07006 err_eeprom:
<a name="l07007"></a>07007     <span class="keywordflow">if</span> (!e1000_check_reset_block(&amp;adapter-&gt;hw))
<a name="l07008"></a>07008         e1000_phy_hw_reset(&amp;adapter-&gt;hw);
<a name="l07009"></a>07009 err_hw_init:
<a name="l07010"></a>07010     kfree(adapter-&gt;tx_ring);
<a name="l07011"></a>07011     kfree(adapter-&gt;rx_ring);
<a name="l07012"></a>07012 err_sw_init:
<a name="l07013"></a>07013     <span class="keywordflow">if</span> (adapter-&gt;hw.flash_address)
<a name="l07014"></a>07014         iounmap(adapter-&gt;hw.flash_address);
<a name="l07015"></a>07015 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l07016"></a>07016 <span class="preprocessor"></span>    e1000e_reset_interrupt_capability(adapter);
<a name="l07017"></a>07017 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l07018"></a>07018 err_flashmap:
<a name="l07019"></a>07019     iounmap(adapter-&gt;hw.hw_addr);
<a name="l07020"></a>07020 err_ioremap:
<a name="l07021"></a>07021     free_netdev(netdev);
<a name="l07022"></a>07022 err_alloc_etherdev:
<a name="l07023"></a>07023     pci_release_selected_regions(pdev,
<a name="l07024"></a>07024                      pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l07025"></a>07025 err_pci_reg:
<a name="l07026"></a>07026 err_dma:
<a name="l07027"></a>07027     pci_disable_device(pdev);
<a name="l07028"></a>07028     <span class="keywordflow">return</span> err;
<a name="l07029"></a>07029 }
<a name="l07030"></a>07030 
<a name="l07040"></a>07040 <span class="keyword">static</span> <span class="keywordtype">void</span> __devexit e1000_remove(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l07041"></a>07041 {
<a name="l07042"></a>07042     <span class="keyword">struct </span>net_device *netdev = pci_get_drvdata(pdev);
<a name="l07043"></a>07043     <span class="keyword">struct </span><a class="code" href="structe1000__adapter.html">e1000_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07044"></a>07044     <span class="keywordtype">bool</span> down = test_bit(__E1000_DOWN, &amp;adapter-&gt;state);
<a name="l07045"></a>07045 
<a name="l07046"></a>07046     <span class="comment">/*</span>
<a name="l07047"></a>07047 <span class="comment">     * The timers may be rescheduled, so explicitly disable them</span>
<a name="l07048"></a>07048 <span class="comment">     * from being rescheduled.</span>
<a name="l07049"></a>07049 <span class="comment">     */</span>
<a name="l07050"></a>07050     <span class="keywordflow">if</span> (!down)
<a name="l07051"></a>07051         set_bit(__E1000_DOWN, &amp;adapter-&gt;state);
<a name="l07052"></a>07052     del_timer_sync(&amp;adapter-&gt;watchdog_timer);
<a name="l07053"></a>07053     del_timer_sync(&amp;adapter-&gt;phy_info_timer);
<a name="l07054"></a>07054 
<a name="l07055"></a>07055     cancel_work_sync(&amp;adapter-&gt;reset_task);
<a name="l07056"></a>07056     cancel_work_sync(&amp;adapter-&gt;watchdog_task);
<a name="l07057"></a>07057     cancel_work_sync(&amp;adapter-&gt;downshift_task);
<a name="l07058"></a>07058     cancel_work_sync(&amp;adapter-&gt;update_phy_task);
<a name="l07059"></a>07059     cancel_work_sync(&amp;adapter-&gt;led_blink_task);
<a name="l07060"></a>07060     cancel_work_sync(&amp;adapter-&gt;print_hang_task);
<a name="l07061"></a>07061 
<a name="l07062"></a>07062     <span class="keywordflow">if</span> (!(netdev-&gt;flags &amp; IFF_UP))
<a name="l07063"></a>07063         e1000_power_down_phy(adapter);
<a name="l07064"></a>07064 
<a name="l07065"></a>07065     <span class="comment">/* Don&#39;t lie to e1000_close() down the road. */</span>
<a name="l07066"></a>07066     <span class="keywordflow">if</span> (!down)
<a name="l07067"></a>07067         clear_bit(__E1000_DOWN, &amp;adapter-&gt;state);
<a name="l07068"></a>07068     unregister_netdev(netdev);
<a name="l07069"></a>07069 
<a name="l07070"></a>07070     <span class="keywordflow">if</span> (pci_dev_run_wake(pdev))
<a name="l07071"></a>07071         pm_runtime_get_noresume(&amp;pdev-&gt;dev);
<a name="l07072"></a>07072 
<a name="l07073"></a>07073     <span class="comment">/*</span>
<a name="l07074"></a>07074 <span class="comment">     * Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<a name="l07075"></a>07075 <span class="comment">     * would have already happened in close and is redundant.</span>
<a name="l07076"></a>07076 <span class="comment">     */</span>
<a name="l07077"></a>07077     e1000e_release_hw_control(adapter);
<a name="l07078"></a>07078 
<a name="l07079"></a>07079 <span class="preprocessor">#ifdef CONFIG_E1000E_MSIX</span>
<a name="l07080"></a>07080 <span class="preprocessor"></span>    e1000e_reset_interrupt_capability(adapter);
<a name="l07081"></a>07081 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_E1000E_MSIX */</span>
<a name="l07082"></a>07082     kfree(adapter-&gt;tx_ring);
<a name="l07083"></a>07083     kfree(adapter-&gt;rx_ring);
<a name="l07084"></a>07084 
<a name="l07085"></a>07085     iounmap(adapter-&gt;hw.hw_addr);
<a name="l07086"></a>07086     <span class="keywordflow">if</span> (adapter-&gt;hw.flash_address)
<a name="l07087"></a>07087         iounmap(adapter-&gt;hw.flash_address);
<a name="l07088"></a>07088     pci_release_selected_regions(pdev,
<a name="l07089"></a>07089                                  pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l07090"></a>07090 
<a name="l07091"></a>07091     free_netdev(netdev);
<a name="l07092"></a>07092 
<a name="l07093"></a>07093     <span class="comment">/* AER disable */</span>
<a name="l07094"></a>07094     pci_disable_pcie_error_reporting(pdev);
<a name="l07095"></a>07095 
<a name="l07096"></a>07096     pci_disable_device(pdev);
<a name="l07097"></a>07097 }
<a name="l07098"></a>07098 
<a name="l07099"></a>07099 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l07100"></a>07100 <span class="preprocessor"></span><span class="comment">/* PCI Error Recovery (ERS) */</span>
<a name="l07101"></a>07101 <span class="keyword">static</span> <span class="keyword">struct </span>pci_error_handlers e1000_err_handler = {
<a name="l07102"></a>07102     .error_detected = e1000_io_error_detected,
<a name="l07103"></a>07103     .slot_reset = e1000_io_slot_reset,
<a name="l07104"></a>07104     .resume = e1000_io_resume,
<a name="l07105"></a>07105 };
<a name="l07106"></a>07106 <span class="preprocessor">#endif</span>
<a name="l07107"></a>07107 <span class="preprocessor"></span>
<a name="l07108"></a>07108 <span class="keyword">static</span> DEFINE_PCI_DEVICE_TABLE(e1000e_pci_tbl) = {
<a name="l07109"></a>07109     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_COPPER), board_82571 },
<a name="l07110"></a>07110     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_FIBER), board_82571 },
<a name="l07111"></a>07111     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_COPPER), board_82571 },
<a name="l07112"></a>07112     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_COPPER_LP), board_82571 },
<a name="l07113"></a>07113     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_FIBER), board_82571 },
<a name="l07114"></a>07114     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES), board_82571 },
<a name="l07115"></a>07115     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES_DUAL), board_82571 },
<a name="l07116"></a>07116     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES_QUAD), board_82571 },
<a name="l07117"></a>07117     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82571PT_QUAD_COPPER), board_82571 },
<a name="l07118"></a>07118 
<a name="l07119"></a>07119     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI), board_82572 },
<a name="l07120"></a>07120     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_COPPER), board_82572 },
<a name="l07121"></a>07121     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_FIBER), board_82572 },
<a name="l07122"></a>07122     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_SERDES), board_82572 },
<a name="l07123"></a>07123 
<a name="l07124"></a>07124     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82573E), board_82573 },
<a name="l07125"></a>07125     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82573E_IAMT), board_82573 },
<a name="l07126"></a>07126     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82573L), board_82573 },
<a name="l07127"></a>07127 
<a name="l07128"></a>07128     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82574L), board_82574 },
<a name="l07129"></a>07129     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82574LA), board_82574 },
<a name="l07130"></a>07130     { PCI_VDEVICE(INTEL, E1000_DEV_ID_82583V), board_82583 },
<a name="l07131"></a>07131 
<a name="l07132"></a>07132     { PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_COPPER_DPT),
<a name="l07133"></a>07133       board_80003es2lan },
<a name="l07134"></a>07134     { PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_COPPER_SPT),
<a name="l07135"></a>07135       board_80003es2lan },
<a name="l07136"></a>07136     { PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_SERDES_DPT),
<a name="l07137"></a>07137       board_80003es2lan },
<a name="l07138"></a>07138     { PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_SERDES_SPT),
<a name="l07139"></a>07139       board_80003es2lan },
<a name="l07140"></a>07140 
<a name="l07141"></a>07141     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE), board_ich8lan },
<a name="l07142"></a>07142     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE_G), board_ich8lan },
<a name="l07143"></a>07143     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE_GT), board_ich8lan },
<a name="l07144"></a>07144     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_AMT), board_ich8lan },
<a name="l07145"></a>07145     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_C), board_ich8lan },
<a name="l07146"></a>07146     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_M), board_ich8lan },
<a name="l07147"></a>07147     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_M_AMT), board_ich8lan },
<a name="l07148"></a>07148     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_82567V_3), board_ich8lan },
<a name="l07149"></a>07149 
<a name="l07150"></a>07150     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE), board_ich9lan },
<a name="l07151"></a>07151     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE_G), board_ich9lan },
<a name="l07152"></a>07152     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE_GT), board_ich9lan },
<a name="l07153"></a>07153     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_AMT), board_ich9lan },
<a name="l07154"></a>07154     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_C), board_ich9lan },
<a name="l07155"></a>07155     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_BM), board_ich9lan },
<a name="l07156"></a>07156     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M), board_ich9lan },
<a name="l07157"></a>07157     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M_AMT), board_ich9lan },
<a name="l07158"></a>07158     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M_V), board_ich9lan },
<a name="l07159"></a>07159 
<a name="l07160"></a>07160     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_LM), board_ich9lan },
<a name="l07161"></a>07161     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_LF), board_ich9lan },
<a name="l07162"></a>07162     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_V), board_ich9lan },
<a name="l07163"></a>07163 
<a name="l07164"></a>07164     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_LM), board_ich10lan },
<a name="l07165"></a>07165     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_LF), board_ich10lan },
<a name="l07166"></a>07166     { PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_V), board_ich10lan },
<a name="l07167"></a>07167 
<a name="l07168"></a>07168     { PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_M_HV_LM), board_pchlan },
<a name="l07169"></a>07169     { PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_M_HV_LC), board_pchlan },
<a name="l07170"></a>07170     { PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_D_HV_DM), board_pchlan },
<a name="l07171"></a>07171     { PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_D_HV_DC), board_pchlan },
<a name="l07172"></a>07172 
<a name="l07173"></a>07173     { PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH2_LV_LM), board_pch2lan },
<a name="l07174"></a>07174     { PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH2_LV_V), board_pch2lan },
<a name="l07175"></a>07175 
<a name="l07176"></a>07176     { } <span class="comment">/* terminate list */</span>
<a name="l07177"></a>07177 };
<a name="l07178"></a>07178 MODULE_DEVICE_TABLE(pci, e1000e_pci_tbl);
<a name="l07179"></a>07179 
<a name="l07180"></a>07180 <span class="preprocessor">#ifdef CONFIG_PM_OPS</span>
<a name="l07181"></a>07181 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l07182"></a>07182 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>dev_pm_ops e1000_pm_ops = {
<a name="l07183"></a>07183     SET_SYSTEM_SLEEP_PM_OPS(e1000_suspend, e1000_resume)
<a name="l07184"></a>07184     SET_RUNTIME_PM_OPS(e1000_runtime_suspend,
<a name="l07185"></a>07185                 e1000_runtime_resume, e1000_idle)
<a name="l07186"></a>07186 };
<a name="l07187"></a>07187 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SYSTEM_SLEEP_PM_OPS */</span>
<a name="l07188"></a>07188 <span class="preprocessor">#endif</span>
<a name="l07189"></a>07189 <span class="preprocessor"></span>
<a name="l07190"></a>07190 <span class="comment">/* PCI Device API Driver */</span>
<a name="l07191"></a>07191 <span class="keyword">static</span> <span class="keyword">struct </span>pci_driver e1000_driver = {
<a name="l07192"></a>07192     .name     = e1000e_driver_name,
<a name="l07193"></a>07193     .id_table = e1000e_pci_tbl,
<a name="l07194"></a>07194     .probe    = e1000_probe,
<a name="l07195"></a>07195     .remove   = __devexit_p(e1000_remove),
<a name="l07196"></a>07196 <span class="preprocessor">#ifdef CONFIG_PM_OPS</span>
<a name="l07197"></a>07197 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_SYSTEM_SLEEP_PM_OPS</span>
<a name="l07198"></a>07198 <span class="preprocessor"></span>    .driver.pm = &amp;e1000_pm_ops,
<a name="l07199"></a>07199 <span class="preprocessor">#else</span>
<a name="l07200"></a>07200 <span class="preprocessor"></span>    .suspend  = e1000_suspend,
<a name="l07201"></a>07201     .resume   = e1000_resume,
<a name="l07202"></a>07202 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SYSTEM_SLEEP_PM_OPS */</span>
<a name="l07203"></a>07203 <span class="preprocessor">#endif</span>
<a name="l07204"></a>07204 <span class="preprocessor"></span><span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l07205"></a>07205 <span class="preprocessor"></span>    .shutdown = e1000_shutdown,
<a name="l07206"></a>07206 <span class="preprocessor">#endif</span>
<a name="l07207"></a>07207 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l07208"></a>07208 <span class="preprocessor"></span>    .err_handler = &amp;e1000_err_handler
<a name="l07209"></a>07209 <span class="preprocessor">#endif</span>
<a name="l07210"></a>07210 <span class="preprocessor"></span>};
<a name="l07211"></a>07211 
<a name="l07218"></a>07218 <span class="keyword">static</span> <span class="keywordtype">int</span> __init e1000_init_module(<span class="keywordtype">void</span>)
<a name="l07219"></a>07219 {
<a name="l07220"></a>07220     <span class="keywordtype">int</span> ret;
<a name="l07221"></a>07221     pr_info(<span class="stringliteral">&quot;Intel(R) PRO/1000 Network Driver - %s\n&quot;</span>,
<a name="l07222"></a>07222         e1000e_driver_version);
<a name="l07223"></a>07223     pr_info(<span class="stringliteral">&quot;Copyright(c) 1999 - 2011 Intel Corporation.\n&quot;</span>);
<a name="l07224"></a>07224     ret = pci_register_driver(&amp;e1000_driver);
<a name="l07225"></a>07225 <span class="preprocessor">#ifdef USE_REBOOT_NOTIFIER</span>
<a name="l07226"></a>07226 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ret &gt;= 0)
<a name="l07227"></a>07227         register_reboot_notifier(&amp;e1000_notifier_reboot);
<a name="l07228"></a>07228 <span class="preprocessor">#endif</span>
<a name="l07229"></a>07229 <span class="preprocessor"></span>
<a name="l07230"></a>07230     <span class="keywordflow">return</span> ret;
<a name="l07231"></a>07231 }
<a name="l07232"></a>07232 module_init(e1000_init_module);
<a name="l07233"></a>07233 
<a name="l07240"></a>07240 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit e1000_exit_module(<span class="keywordtype">void</span>)
<a name="l07241"></a>07241 {
<a name="l07242"></a>07242 <span class="preprocessor">#ifdef USE_REBOOT_NOTIFIER</span>
<a name="l07243"></a>07243 <span class="preprocessor"></span>    unregister_reboot_notifier(&amp;e1000_notifier_reboot);
<a name="l07244"></a>07244 <span class="preprocessor">#endif</span>
<a name="l07245"></a>07245 <span class="preprocessor"></span>    pci_unregister_driver(&amp;e1000_driver);
<a name="l07246"></a>07246 }
<a name="l07247"></a>07247 module_exit(e1000_exit_module);
<a name="l07248"></a>07248 
<a name="l07249"></a>07249 
<a name="l07250"></a>07250 MODULE_AUTHOR(<span class="stringliteral">&quot;Intel Corporation, &lt;linux.nics@intel.com&gt;&quot;</span>);
<a name="l07251"></a>07251 MODULE_DESCRIPTION(<span class="stringliteral">&quot;Intel(R) PRO/1000 Network Driver&quot;</span>);
<a name="l07252"></a>07252 MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);
<a name="l07253"></a>07253 MODULE_VERSION(DRV_VERSION);
<a name="l07254"></a>07254 
<a name="l07255"></a>07255 <span class="comment">/* netdev.c */</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:26 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
