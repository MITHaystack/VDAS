<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/broadcom/netxtreme2-5.2.50/bnx2-2.0.8b/src/cnic.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_2eb02fd92a965ecd821875a0a052753b.html">broadcom</a>      </li>
      <li class="navelem"><a class="el" href="dir_0a4992c25a025ec51f35cbf57fa02bf7.html">netxtreme2-5.2.50</a>      </li>
      <li class="navelem"><a class="el" href="dir_d94352c6020f4a4a3e3e416ff14cc181.html">bnx2-2.0.8b</a>      </li>
      <li class="navelem"><a class="el" href="dir_9f298fa21914ce9c277e605185f41295.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">cnic.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* cnic.c: Broadcom CNIC core network driver.</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (c) 2006-2009 Broadcom Corporation</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Portions Copyright (c) VMware, Inc. 2009, All Rights Reserved.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment"> * the Free Software Foundation.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * Original skeleton written by: John(Zongxi) Chen (zongxi@broadcom.com)</span>
<a name="l00012"></a>00012 <span class="comment"> * Modified and maintained by: Michael Chan &lt;mchan@broadcom.com&gt;</span>
<a name="l00013"></a>00013 <span class="comment"> */</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;linux/version.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#if (LINUX_VERSION_CODE &lt; 0x020612)</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/config.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#endif</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;linux/kernel.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;linux/list.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;linux/slab.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;linux/pci.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;linux/init.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;linux/netdevice.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;linux/inetdevice.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;linux/in.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;linux/dma-mapping.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;asm/byteorder.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;linux/delay.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;linux/ethtool.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;linux/if_vlan.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define BCM_VLAN 1</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/ip.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;net/tcp.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/arp.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;net/neighbour.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;net/route.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;net/ipv6.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;net/ip6_route.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;net/ip6_checksum.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;net/addrconf.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#ifdef HAVE_NETEVENT</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/netevent.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#include &lt;scsi/iscsi_proto.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define NEW_BNX2X_HSI 1</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;cnic_if.h&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;bnx2.h&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;../../bnx2x/src/bnx2x_reg.h&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;../../bnx2x/src/bnx2x_fw_defs.h&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;../../bnx2x/src/bnx2x_hsi.h&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;../../current/driver/57xx_iscsi_constants.h&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;../../current/driver/57xx_iscsi_hsi.h&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;cnic.h&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;cnic_defs.h&quot;</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="preprocessor">#define DRV_MODULE_NAME     &quot;cnic&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define PFX DRV_MODULE_NAME &quot;: &quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">char</span> version[] __devinitdata =
<a name="l00073"></a>00073     <span class="stringliteral">&quot;Broadcom NetXtreme II CNIC Driver &quot;</span> DRV_MODULE_NAME <span class="stringliteral">&quot; v&quot;</span> CNIC_MODULE_VERSION <span class="stringliteral">&quot; (&quot;</span> CNIC_MODULE_RELDATE <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 MODULE_AUTHOR(<span class="stringliteral">&quot;Michael Chan &lt;mchan@broadcom.com&gt; and John(Zongxi) &quot;</span>
<a name="l00076"></a>00076           <span class="stringliteral">&quot;Chen (zongxi@broadcom.com&quot;</span>);
<a name="l00077"></a>00077 MODULE_DESCRIPTION(<span class="stringliteral">&quot;Broadcom NetXtreme II CNIC Driver&quot;</span>);
<a name="l00078"></a>00078 MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);
<a name="l00079"></a>00079 MODULE_VERSION(CNIC_MODULE_VERSION);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">static</span> LIST_HEAD(cnic_dev_list);
<a name="l00082"></a>00082 <span class="keyword">static</span> DEFINE_RWLOCK(cnic_dev_lock);
<a name="l00083"></a>00083 <span class="keyword">static</span> DEFINE_MUTEX(cnic_lock);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *cnic_ulp_tbl[MAX_CNIC_ULP_TYPE];
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_service_bnx2(<span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *);
<a name="l00088"></a>00088 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_service_bnx2x(<span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *);
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_ctl(<span class="keywordtype">void</span> *, <span class="keyword">struct</span> <a class="code" href="structcnic__ctl__info.html">cnic_ctl_info</a> *);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__ops.html">cnic_ops</a> cnic_bnx2_ops = {
<a name="l00092"></a>00092     .cnic_owner = THIS_MODULE,
<a name="l00093"></a>00093     .cnic_handler   = cnic_service_bnx2,
<a name="l00094"></a>00094     .cnic_ctl   = cnic_ctl,
<a name="l00095"></a>00095 };
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__ops.html">cnic_ops</a> cnic_bnx2x_ops = {
<a name="l00098"></a>00098     .cnic_owner = THIS_MODULE,
<a name="l00099"></a>00099     .cnic_handler   = cnic_service_bnx2x,
<a name="l00100"></a>00100     .cnic_ctl   = cnic_ctl,
<a name="l00101"></a>00101 };
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> cnic_hold(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105     atomic_inc(&amp;dev-&gt;ref_count);
<a name="l00106"></a>00106 }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> cnic_put(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00109"></a>00109 {
<a name="l00110"></a>00110     atomic_dec(&amp;dev-&gt;ref_count);
<a name="l00111"></a>00111 }
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> csk_hold(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115     atomic_inc(&amp;csk-&gt;ref_count);
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> csk_put(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120     atomic_dec(&amp;csk-&gt;ref_count);
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cnic_from_netdev(<span class="keyword">struct</span> net_device *netdev)
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cdev;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     read_lock(&amp;cnic_dev_lock);
<a name="l00128"></a>00128     list_for_each_entry(cdev, &amp;cnic_dev_list, list) {
<a name="l00129"></a>00129         <span class="keywordflow">if</span> (netdev == cdev-&gt;netdev) {
<a name="l00130"></a>00130             cnic_hold(cdev);
<a name="l00131"></a>00131             read_unlock(&amp;cnic_dev_lock);
<a name="l00132"></a>00132             <span class="keywordflow">return</span> cdev;
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     read_unlock(&amp;cnic_dev_lock);
<a name="l00136"></a>00136     <span class="keywordflow">return</span> NULL;
<a name="l00137"></a>00137 }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ulp_get(<span class="keyword">struct</span> <a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops)
<a name="l00140"></a>00140 {
<a name="l00141"></a>00141     atomic_inc(&amp;ulp_ops-&gt;ref_count);
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ulp_put(<span class="keyword">struct</span> <a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops)
<a name="l00145"></a>00145 {
<a name="l00146"></a>00146     atomic_dec(&amp;ulp_ops-&gt;ref_count);
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_ctx_wr(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 cid_addr, u32 off, u32 val)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00152"></a>00152     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l00153"></a>00153     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__info.html">drv_ctl_info</a> info;
<a name="l00154"></a>00154     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__io.html">drv_ctl_io</a> *io = &amp;info.data.io;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     info.cmd = DRV_CTL_CTX_WR_CMD;
<a name="l00157"></a>00157     io-&gt;cid_addr = cid_addr;
<a name="l00158"></a>00158     io-&gt;offset = off;
<a name="l00159"></a>00159     io-&gt;data = val;
<a name="l00160"></a>00160     ethdev-&gt;drv_ctl(dev-&gt;netdev, &amp;info);
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_ctx_tbl_wr(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 off, dma_addr_t addr)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00166"></a>00166     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l00167"></a>00167     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__info.html">drv_ctl_info</a> info;
<a name="l00168"></a>00168     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__io.html">drv_ctl_io</a> *io = &amp;info.data.io;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     info.cmd = DRV_CTL_CTXTBL_WR_CMD;
<a name="l00171"></a>00171     io-&gt;offset = off;
<a name="l00172"></a>00172     io-&gt;dma_addr = addr;
<a name="l00173"></a>00173     ethdev-&gt;drv_ctl(dev-&gt;netdev, &amp;info);
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_reg_wr_ind(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 off, u32 val)
<a name="l00177"></a>00177 {
<a name="l00178"></a>00178     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00179"></a>00179     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l00180"></a>00180     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__info.html">drv_ctl_info</a> info;
<a name="l00181"></a>00181     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__io.html">drv_ctl_io</a> *io = &amp;info.data.io;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     info.cmd = DRV_CTL_IO_WR_CMD;
<a name="l00184"></a>00184     io-&gt;offset = off;
<a name="l00185"></a>00185     io-&gt;data = val;
<a name="l00186"></a>00186     ethdev-&gt;drv_ctl(dev-&gt;netdev, &amp;info);
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="keyword">static</span> u32 cnic_reg_rd_ind(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 off)
<a name="l00190"></a>00190 {
<a name="l00191"></a>00191     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00192"></a>00192     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l00193"></a>00193     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__info.html">drv_ctl_info</a> info;
<a name="l00194"></a>00194     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__io.html">drv_ctl_io</a> *io = &amp;info.data.io;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196     info.cmd = DRV_CTL_IO_RD_CMD;
<a name="l00197"></a>00197     io-&gt;offset = off;
<a name="l00198"></a>00198     ethdev-&gt;drv_ctl(dev-&gt;netdev, &amp;info);
<a name="l00199"></a>00199     <span class="keywordflow">return</span> io-&gt;data;
<a name="l00200"></a>00200 }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_kwq_completion(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 count)
<a name="l00203"></a>00203 {
<a name="l00204"></a>00204     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00205"></a>00205     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l00206"></a>00206     <span class="keyword">struct </span><a class="code" href="structdrv__ctl__info.html">drv_ctl_info</a> info;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     info.cmd = DRV_CTL_COMPLETION_CMD;
<a name="l00209"></a>00209     info.data.comp.comp_count = count;
<a name="l00210"></a>00210     ethdev-&gt;drv_ctl(dev-&gt;netdev, &amp;info);
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_get_l5_cid(<span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a> *cp, u32 cid, u32 *l5_cid)
<a name="l00214"></a>00214 {
<a name="l00215"></a>00215     u32 i;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_ISCSI_TBL_SZ; i++) {
<a name="l00218"></a>00218         <span class="keywordflow">if</span> (cp-&gt;ctx_tbl[i].cid == cid) {
<a name="l00219"></a>00219             *l5_cid = i;
<a name="l00220"></a>00220             <span class="keywordflow">return</span> 0;
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223     <span class="keywordflow">return</span> -EINVAL;
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_in_use(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229     <span class="keywordflow">return</span> (test_bit(SK_F_INUSE, &amp;csk-&gt;flags));
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_offld_prep(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234     <span class="keywordflow">if</span> (!test_bit(SK_F_CONNECT_START, &amp;csk-&gt;flags))
<a name="l00235"></a>00235         <span class="keywordflow">return</span> 0;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="keywordflow">if</span> (test_and_set_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags))
<a name="l00238"></a>00238         <span class="keywordflow">return</span> 0;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240     <span class="keywordflow">return</span> 1;
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_close_prep(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l00244"></a>00244 {
<a name="l00245"></a>00245     <span class="keywordflow">if</span> (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &amp;csk-&gt;flags))
<a name="l00246"></a>00246         <span class="keywordflow">return</span> 1;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248     <span class="keywordflow">return</span> 0;
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_abort_prep(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253     <span class="keywordflow">while</span> (test_and_set_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags))
<a name="l00254"></a>00254         msleep(1);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keywordflow">if</span> (cnic_close_prep(csk)) {
<a name="l00257"></a>00257         csk-&gt;state = L4_KCQE_OPCODE_VALUE_RESET_COMP;
<a name="l00258"></a>00258         <span class="keywordflow">return</span> 1;
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="keywordflow">return</span> 0;
<a name="l00262"></a>00262 }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="keywordtype">int</span> cnic_register_driver(<span class="keywordtype">int</span> ulp_type, <span class="keyword">struct</span> <a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops)
<a name="l00265"></a>00265 {
<a name="l00266"></a>00266     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <span class="keywordflow">if</span> (ulp_type &gt;= MAX_CNIC_ULP_TYPE) {
<a name="l00269"></a>00269         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_register_driver: Bad type %d\n&quot;</span>,
<a name="l00270"></a>00270                ulp_type);
<a name="l00271"></a>00271         <span class="keywordflow">return</span> -EINVAL;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     mutex_lock(&amp;cnic_lock);
<a name="l00274"></a>00274     <span class="keywordflow">if</span> (cnic_ulp_tbl[ulp_type]) {
<a name="l00275"></a>00275         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_register_driver: Type %d has already &quot;</span>
<a name="l00276"></a>00276                     <span class="stringliteral">&quot;been registered\n&quot;</span>, ulp_type);
<a name="l00277"></a>00277         mutex_unlock(&amp;cnic_lock);
<a name="l00278"></a>00278         <span class="keywordflow">return</span> -EBUSY;
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span>    read_lock(&amp;cnic_dev_lock);
<a name="l00283"></a>00283 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00284"></a>00284     list_for_each_entry(dev, &amp;cnic_dev_list, list) {
<a name="l00285"></a>00285         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287         clear_bit(ULP_F_INIT, &amp;cp-&gt;ulp_flags[ulp_type]);
<a name="l00288"></a>00288     }
<a name="l00289"></a>00289 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span>    read_unlock(&amp;cnic_dev_lock);
<a name="l00291"></a>00291 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     atomic_set(&amp;ulp_ops-&gt;ref_count, 0);
<a name="l00294"></a>00294     rcu_assign_pointer(cnic_ulp_tbl[ulp_type], ulp_ops);
<a name="l00295"></a>00295     mutex_unlock(&amp;cnic_lock);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="comment">/* Prevent race conditions with netdev_event */</span>
<a name="l00298"></a>00298 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span>    rtnl_lock();
<a name="l00300"></a>00300     read_lock(&amp;cnic_dev_lock);
<a name="l00301"></a>00301 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00302"></a>00302     list_for_each_entry(dev, &amp;cnic_dev_list, list) {
<a name="l00303"></a>00303         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         <span class="keywordflow">if</span> (!test_and_set_bit(ULP_F_INIT, &amp;cp-&gt;ulp_flags[ulp_type]))
<a name="l00306"></a>00306             ulp_ops-&gt;cnic_init(dev);
<a name="l00307"></a>00307     }
<a name="l00308"></a>00308 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00309"></a>00309 <span class="preprocessor"></span>    read_unlock(&amp;cnic_dev_lock);
<a name="l00310"></a>00310     rtnl_unlock();
<a name="l00311"></a>00311 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="keywordflow">return</span> 0;
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="keywordtype">int</span> cnic_unregister_driver(<span class="keywordtype">int</span> ulp_type)
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev;
<a name="l00319"></a>00319     <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l00320"></a>00320     <span class="keywordtype">int</span> i = 0;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     <span class="keywordflow">if</span> (ulp_type &gt;= MAX_CNIC_ULP_TYPE) {
<a name="l00323"></a>00323         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_unregister_driver: Bad type %d\n&quot;</span>,
<a name="l00324"></a>00324                ulp_type);
<a name="l00325"></a>00325         <span class="keywordflow">return</span> -EINVAL;
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327     mutex_lock(&amp;cnic_lock);
<a name="l00328"></a>00328     ulp_ops = cnic_ulp_tbl[ulp_type];
<a name="l00329"></a>00329     <span class="keywordflow">if</span> (!ulp_ops) {
<a name="l00330"></a>00330         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_unregister_driver: Type %d has not &quot;</span>
<a name="l00331"></a>00331                     <span class="stringliteral">&quot;been registered\n&quot;</span>, ulp_type);
<a name="l00332"></a>00332         <span class="keywordflow">goto</span> out_unlock;
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span>    read_lock(&amp;cnic_dev_lock);
<a name="l00336"></a>00336 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00337"></a>00337     list_for_each_entry(dev, &amp;cnic_dev_list, list) {
<a name="l00338"></a>00338         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00339"></a>00339         
<a name="l00340"></a>00340         <span class="keywordflow">if</span> (rcu_dereference(cp-&gt;ulp_ops[ulp_type])) {
<a name="l00341"></a>00341             printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_unregister_driver: Type %d &quot;</span>
<a name="l00342"></a>00342                    <span class="stringliteral">&quot;still has devices registered\n&quot;</span>, ulp_type);
<a name="l00343"></a>00343 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00344"></a>00344 <span class="preprocessor"></span>            read_unlock(&amp;cnic_dev_lock);
<a name="l00345"></a>00345 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00346"></a>00346             <span class="keywordflow">goto</span> out_unlock;
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span>    read_unlock(&amp;cnic_dev_lock);
<a name="l00351"></a>00351 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     rcu_assign_pointer(cnic_ulp_tbl[ulp_type], NULL);
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     mutex_unlock(&amp;cnic_lock);
<a name="l00356"></a>00356     synchronize_rcu();
<a name="l00357"></a>00357     <span class="keywordflow">while</span> ((atomic_read(&amp;ulp_ops-&gt;ref_count) != 0) &amp;&amp; (i &lt; 20)) {
<a name="l00358"></a>00358         msleep(100);
<a name="l00359"></a>00359         i++;
<a name="l00360"></a>00360     }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     <span class="keywordflow">if</span> (atomic_read(&amp;ulp_ops-&gt;ref_count) != 0)
<a name="l00363"></a>00363         printk(KERN_WARNING PFX <span class="stringliteral">&quot;%s: Failed waiting for ref count to go&quot;</span>
<a name="l00364"></a>00364             <span class="stringliteral">&quot; to zero.\n&quot;</span>, dev-&gt;netdev-&gt;name);
<a name="l00365"></a>00365     <span class="keywordflow">return</span> 0;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 out_unlock:
<a name="l00368"></a>00368     mutex_unlock(&amp;cnic_lock);
<a name="l00369"></a>00369     <span class="keywordflow">return</span> -EINVAL;
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 EXPORT_SYMBOL(cnic_register_driver);
<a name="l00373"></a>00373 EXPORT_SYMBOL(cnic_unregister_driver);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_register_netdev(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00376"></a>00376 {
<a name="l00377"></a>00377     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00378"></a>00378     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l00379"></a>00379     <span class="keywordtype">int</span> err;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="keywordflow">if</span> (!ethdev)
<a name="l00382"></a>00382         <span class="keywordflow">return</span> -ENODEV;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384     <span class="keywordflow">if</span> (ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_REGD)
<a name="l00385"></a>00385         <span class="keywordflow">return</span> 0;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387     err = ethdev-&gt;drv_register_cnic(dev-&gt;netdev, cp-&gt;cnic_ops, dev);
<a name="l00388"></a>00388     <span class="keywordflow">if</span> (err)
<a name="l00389"></a>00389         printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: register_cnic failed\n&quot;</span>,
<a name="l00390"></a>00390                dev-&gt;netdev-&gt;name);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392     <span class="keywordflow">return</span> err;
<a name="l00393"></a>00393 }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_unregister_netdev(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00396"></a>00396 {
<a name="l00397"></a>00397     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00398"></a>00398     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     <span class="keywordflow">if</span> (!ethdev)
<a name="l00401"></a>00401         <span class="keywordflow">return</span>;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <span class="keywordflow">if</span> (ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_REGD)
<a name="l00404"></a>00404         ethdev-&gt;drv_unregister_cnic(dev-&gt;netdev);
<a name="l00405"></a>00405 }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_start_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *);
<a name="l00408"></a>00408 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_stop_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_register_device(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keywordtype">int</span> ulp_type,
<a name="l00411"></a>00411                 <span class="keywordtype">void</span> *ulp_ctx)
<a name="l00412"></a>00412 {
<a name="l00413"></a>00413     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00414"></a>00414     <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     <span class="keywordflow">if</span> (ulp_type &gt;= MAX_CNIC_ULP_TYPE) {
<a name="l00417"></a>00417         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_register_device: Bad type %d\n&quot;</span>,
<a name="l00418"></a>00418                ulp_type);
<a name="l00419"></a>00419         <span class="keywordflow">return</span> -EINVAL;
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421     mutex_lock(&amp;cnic_lock);
<a name="l00422"></a>00422     <span class="keywordflow">if</span> (cnic_ulp_tbl[ulp_type] == NULL) {
<a name="l00423"></a>00423         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_register_device: Driver with type %d &quot;</span>
<a name="l00424"></a>00424                     <span class="stringliteral">&quot;has not been registered\n&quot;</span>, ulp_type);
<a name="l00425"></a>00425         mutex_unlock(&amp;cnic_lock);
<a name="l00426"></a>00426         <span class="keywordflow">return</span> -EAGAIN;
<a name="l00427"></a>00427     }
<a name="l00428"></a>00428     <span class="keywordflow">if</span> (rcu_dereference(cp-&gt;ulp_ops[ulp_type])) {
<a name="l00429"></a>00429         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_register_device: Type %d has already &quot;</span>
<a name="l00430"></a>00430                <span class="stringliteral">&quot;been registered to this device\n&quot;</span>, ulp_type);
<a name="l00431"></a>00431         mutex_unlock(&amp;cnic_lock);
<a name="l00432"></a>00432         <span class="keywordflow">return</span> -EBUSY;
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     clear_bit(ULP_F_START, &amp;cp-&gt;ulp_flags[ulp_type]);
<a name="l00436"></a>00436     cp-&gt;ulp_handle[ulp_type] = ulp_ctx;
<a name="l00437"></a>00437     ulp_ops = cnic_ulp_tbl[ulp_type];
<a name="l00438"></a>00438     rcu_assign_pointer(cp-&gt;ulp_ops[ulp_type], ulp_ops);
<a name="l00439"></a>00439     cnic_hold(dev);
<a name="l00440"></a>00440     <span class="keywordflow">if</span> (!dev-&gt;use_count) {
<a name="l00441"></a>00441         <span class="keywordflow">if</span> (!test_bit(CNIC_F_IF_GOING_DOWN, &amp;dev-&gt;flags)) {
<a name="l00442"></a>00442             <span class="keywordflow">if</span> (dev-&gt;netdev-&gt;flags &amp; IFF_UP)
<a name="l00443"></a>00443                 set_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags);
<a name="l00444"></a>00444         }
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446     dev-&gt;use_count++;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="keywordflow">if</span> (dev-&gt;use_count == 1) {
<a name="l00449"></a>00449         <span class="keywordflow">if</span> (test_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags)) {
<a name="l00450"></a>00450             <span class="keywordflow">if</span> (cnic_register_netdev(dev) == 0)
<a name="l00451"></a>00451                 cnic_start_hw(dev);
<a name="l00452"></a>00452         }
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="keywordflow">if</span> (test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags))
<a name="l00456"></a>00456         <span class="keywordflow">if</span> (!test_and_set_bit(ULP_F_START, &amp;cp-&gt;ulp_flags[ulp_type]))
<a name="l00457"></a>00457             ulp_ops-&gt;cnic_start(cp-&gt;ulp_handle[ulp_type]);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459     mutex_unlock(&amp;cnic_lock);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461     <span class="keywordflow">return</span> 0;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_unregister_device(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keywordtype">int</span> ulp_type)
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00468"></a>00468     <span class="keywordtype">int</span> i = 0;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (ulp_type &gt;= MAX_CNIC_ULP_TYPE) {
<a name="l00471"></a>00471         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_unregister_device: Bad type %d\n&quot;</span>,
<a name="l00472"></a>00472                ulp_type);
<a name="l00473"></a>00473         <span class="keywordflow">return</span> -EINVAL;
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475     mutex_lock(&amp;cnic_lock);
<a name="l00476"></a>00476     <span class="keywordflow">if</span> (rcu_dereference(cp-&gt;ulp_ops[ulp_type])) {
<a name="l00477"></a>00477         dev-&gt;use_count--;
<a name="l00478"></a>00478         rcu_assign_pointer(cp-&gt;ulp_ops[ulp_type], NULL);
<a name="l00479"></a>00479         <span class="keywordflow">if</span> (dev-&gt;use_count == 0) {
<a name="l00480"></a>00480             cnic_stop_hw(dev);
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482         cnic_put(dev);
<a name="l00483"></a>00483     } <span class="keywordflow">else</span> {
<a name="l00484"></a>00484         printk(KERN_ERR PFX <span class="stringliteral">&quot;cnic_unregister_device: device not &quot;</span>
<a name="l00485"></a>00485                <span class="stringliteral">&quot;registered to this ulp type %d\n&quot;</span>, ulp_type);
<a name="l00486"></a>00486         mutex_unlock(&amp;cnic_lock);
<a name="l00487"></a>00487         <span class="keywordflow">return</span> -EINVAL;
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489     mutex_unlock(&amp;cnic_lock);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     synchronize_rcu();
<a name="l00492"></a>00492 
<a name="l00493"></a>00493     <span class="keywordflow">while</span> (test_bit(ULP_F_CALL_PENDING, &amp;cp-&gt;ulp_flags[ulp_type]) &amp;&amp;
<a name="l00494"></a>00494            i &lt; 20) {
<a name="l00495"></a>00495         msleep(100);
<a name="l00496"></a>00496         i++;
<a name="l00497"></a>00497     }
<a name="l00498"></a>00498     <span class="keywordflow">if</span> (test_bit(ULP_F_CALL_PENDING, &amp;cp-&gt;ulp_flags[ulp_type]))
<a name="l00499"></a>00499         printk(KERN_WARNING PFX <span class="stringliteral">&quot;%s: Failed waiting for ULP up call&quot;</span>
<a name="l00500"></a>00500                     <span class="stringliteral">&quot; to complete.\n&quot;</span>, dev-&gt;netdev-&gt;name);
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="keywordflow">return</span> 0;
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_init_id_tbl(<span class="keyword">struct</span> <a class="code" href="structcnic__id__tbl.html">cnic_id_tbl</a> *id_tbl, u32 size, u32 start_id,
<a name="l00506"></a>00506                 u32 next)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508     id_tbl-&gt;start = start_id;
<a name="l00509"></a>00509     id_tbl-&gt;max = size;
<a name="l00510"></a>00510     id_tbl-&gt;next = next;
<a name="l00511"></a>00511     spin_lock_init(&amp;id_tbl-&gt;lock);
<a name="l00512"></a>00512     id_tbl-&gt;table = kzalloc(DIV_ROUND_UP(size, 32) * 4, GFP_KERNEL);
<a name="l00513"></a>00513     <span class="keywordflow">if</span> (!id_tbl-&gt;table)
<a name="l00514"></a>00514         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00515"></a>00515 
<a name="l00516"></a>00516     <span class="keywordflow">return</span> 0;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="keyword">static</span> u32 cnic_free_id_tbl(<span class="keyword">struct</span> <a class="code" href="structcnic__id__tbl.html">cnic_id_tbl</a> *id_tbl)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521     kfree(id_tbl-&gt;table);
<a name="l00522"></a>00522     id_tbl-&gt;table = NULL;
<a name="l00523"></a>00523     <span class="keywordflow">return</span> id_tbl-&gt;next;
<a name="l00524"></a>00524 }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <span class="comment">/* Returns -1 if not successful */</span>
<a name="l00527"></a>00527 <span class="keyword">static</span> u32 cnic_alloc_new_id(<span class="keyword">struct</span> <a class="code" href="structcnic__id__tbl.html">cnic_id_tbl</a> *id_tbl)
<a name="l00528"></a>00528 {
<a name="l00529"></a>00529     u32 id;
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     spin_lock(&amp;id_tbl-&gt;lock);
<a name="l00532"></a>00532     <span class="keywordtype">id</span> = find_next_zero_bit(id_tbl-&gt;table, id_tbl-&gt;max, id_tbl-&gt;next);
<a name="l00533"></a>00533     <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= id_tbl-&gt;max) {
<a name="l00534"></a>00534         <span class="keywordtype">id</span> = -1;
<a name="l00535"></a>00535         <span class="keywordflow">if</span> (id_tbl-&gt;next != 0) {
<a name="l00536"></a>00536             <span class="keywordtype">id</span> = find_first_zero_bit(id_tbl-&gt;table, id_tbl-&gt;next);
<a name="l00537"></a>00537             <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= id_tbl-&gt;next)
<a name="l00538"></a>00538                 <span class="keywordtype">id</span> = -1;
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540     }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542     <span class="keywordflow">if</span> (id &lt; id_tbl-&gt;max) {
<a name="l00543"></a>00543         set_bit(<span class="keywordtype">id</span>, id_tbl-&gt;table);
<a name="l00544"></a>00544         id_tbl-&gt;next = (<span class="keywordtype">id</span> + 1) &amp; (id_tbl-&gt;max - 1);
<a name="l00545"></a>00545         <span class="keywordtype">id</span> += id_tbl-&gt;start;
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     spin_unlock(&amp;id_tbl-&gt;lock);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550     <span class="keywordflow">return</span> id;
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 <span class="keywordtype">void</span> cnic_free_id(<span class="keyword">struct</span> <a class="code" href="structcnic__id__tbl.html">cnic_id_tbl</a> *id_tbl, u32 <span class="keywordtype">id</span>)
<a name="l00554"></a>00554 {
<a name="l00555"></a>00555     <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == -1)
<a name="l00556"></a>00556         <span class="keywordflow">return</span>;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558     <span class="keywordtype">id</span> -= id_tbl-&gt;start;
<a name="l00559"></a>00559     <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= id_tbl-&gt;max)
<a name="l00560"></a>00560         <span class="keywordflow">return</span>;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     clear_bit(<span class="keywordtype">id</span>, id_tbl-&gt;table);
<a name="l00563"></a>00563 }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_free_dma(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> <a class="code" href="structcnic__dma.html">cnic_dma</a> *dma)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567     <span class="keywordtype">int</span> i;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     <span class="keywordflow">if</span> (!dma-&gt;pg_arr)
<a name="l00570"></a>00570         <span class="keywordflow">return</span>;
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     <span class="keywordflow">for</span> (i = 0; i &lt; dma-&gt;num_pages; i++) {
<a name="l00573"></a>00573         <span class="keywordflow">if</span> (dma-&gt;pg_arr[i]) {
<a name="l00574"></a>00574             pci_free_consistent(dev-&gt;pcidev, BCM_PAGE_SIZE,
<a name="l00575"></a>00575                         dma-&gt;pg_arr[i], dma-&gt;pg_map_arr[i]);
<a name="l00576"></a>00576             dma-&gt;pg_arr[i] = NULL;
<a name="l00577"></a>00577         }
<a name="l00578"></a>00578     }
<a name="l00579"></a>00579     <span class="keywordflow">if</span> (dma-&gt;pgtbl) {
<a name="l00580"></a>00580         pci_free_consistent(dev-&gt;pcidev, dma-&gt;pgtbl_size,
<a name="l00581"></a>00581                     dma-&gt;pgtbl, dma-&gt;pgtbl_map);
<a name="l00582"></a>00582         dma-&gt;pgtbl = NULL;
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584     kfree(dma-&gt;pg_arr);
<a name="l00585"></a>00585     dma-&gt;pg_arr = NULL;
<a name="l00586"></a>00586     dma-&gt;num_pages = 0;
<a name="l00587"></a>00587 }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_setup_page_tbl(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> <a class="code" href="structcnic__dma.html">cnic_dma</a> *dma)
<a name="l00590"></a>00590 {
<a name="l00591"></a>00591     <span class="keywordtype">int</span> i;
<a name="l00592"></a>00592     u32 *page_table = dma-&gt;pgtbl;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594     <span class="keywordflow">for</span> (i = 0; i &lt; dma-&gt;num_pages; i++) {
<a name="l00595"></a>00595         <span class="comment">/* Each entry needs to be in big endian format. */</span>
<a name="l00596"></a>00596         *page_table = (u32) ((u64) dma-&gt;pg_map_arr[i] &gt;&gt; 32);
<a name="l00597"></a>00597         page_table++;
<a name="l00598"></a>00598         *page_table = (u32) dma-&gt;pg_map_arr[i];
<a name="l00599"></a>00599         page_table++;
<a name="l00600"></a>00600     }
<a name="l00601"></a>00601 }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_setup_page_tbl_le(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> <a class="code" href="structcnic__dma.html">cnic_dma</a> *dma)
<a name="l00604"></a>00604 {
<a name="l00605"></a>00605     <span class="keywordtype">int</span> i;
<a name="l00606"></a>00606     u32 *page_table = dma-&gt;pgtbl;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608     <span class="keywordflow">for</span> (i = 0; i &lt; dma-&gt;num_pages; i++) {
<a name="l00609"></a>00609         <span class="comment">/* Each entry needs to be in little endian format. */</span>
<a name="l00610"></a>00610         *page_table = dma-&gt;pg_map_arr[i] &amp; 0xffffffff;
<a name="l00611"></a>00611         page_table++;
<a name="l00612"></a>00612         *page_table = (u32) ((u64) dma-&gt;pg_map_arr[i] &gt;&gt; 32);
<a name="l00613"></a>00613         page_table++;
<a name="l00614"></a>00614     }
<a name="l00615"></a>00615 }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_alloc_dma(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> <a class="code" href="structcnic__dma.html">cnic_dma</a> *dma,
<a name="l00618"></a>00618               <span class="keywordtype">int</span> pages, <span class="keywordtype">int</span> use_pg_tbl)
<a name="l00619"></a>00619 {
<a name="l00620"></a>00620     <span class="keywordtype">int</span> i, size;
<a name="l00621"></a>00621     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623     size = pages * (<span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *) + <span class="keyword">sizeof</span>(dma_addr_t));
<a name="l00624"></a>00624     dma-&gt;pg_arr = kzalloc(size, GFP_ATOMIC);
<a name="l00625"></a>00625     <span class="keywordflow">if</span> (dma-&gt;pg_arr == NULL)
<a name="l00626"></a>00626         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     dma-&gt;pg_map_arr = (dma_addr_t *) (dma-&gt;pg_arr + pages);
<a name="l00629"></a>00629     dma-&gt;num_pages = pages;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="keywordflow">for</span> (i = 0; i &lt; pages; i++) {
<a name="l00632"></a>00632         dma-&gt;pg_arr[i] = pci_alloc_consistent(dev-&gt;pcidev,
<a name="l00633"></a>00633                               BCM_PAGE_SIZE,
<a name="l00634"></a>00634                               &amp;dma-&gt;pg_map_arr[i]);
<a name="l00635"></a>00635         <span class="keywordflow">if</span> (dma-&gt;pg_arr[i] == NULL)
<a name="l00636"></a>00636             <span class="keywordflow">goto</span> error;
<a name="l00637"></a>00637     }
<a name="l00638"></a>00638     <span class="keywordflow">if</span> (!use_pg_tbl)
<a name="l00639"></a>00639         <span class="keywordflow">return</span> 0;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     dma-&gt;pgtbl_size = ((pages * 8) + BCM_PAGE_SIZE - 1) &amp;
<a name="l00642"></a>00642               ~(BCM_PAGE_SIZE - 1);
<a name="l00643"></a>00643     dma-&gt;pgtbl = pci_alloc_consistent(dev-&gt;pcidev, dma-&gt;pgtbl_size,
<a name="l00644"></a>00644                       &amp;dma-&gt;pgtbl_map);
<a name="l00645"></a>00645     <span class="keywordflow">if</span> (dma-&gt;pgtbl == NULL)
<a name="l00646"></a>00646         <span class="keywordflow">goto</span> error;
<a name="l00647"></a>00647 
<a name="l00648"></a>00648     cp-&gt;setup_pgtbl(dev, dma);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     <span class="keywordflow">return</span> 0;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652 error:
<a name="l00653"></a>00653     cnic_free_dma(dev, dma);
<a name="l00654"></a>00654     <span class="keywordflow">return</span> -ENOMEM;
<a name="l00655"></a>00655 }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_free_contex(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00658"></a>00658 {
<a name="l00659"></a>00659     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00660"></a>00660     <span class="keywordtype">int</span> i;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     <span class="keywordflow">for</span> (i = 0; i &lt; cp-&gt;ctx_blks; i++) {
<a name="l00663"></a>00663         <span class="keywordflow">if</span> (cp-&gt;ctx_arr[i].ctx) {
<a name="l00664"></a>00664             pci_free_consistent(dev-&gt;pcidev, cp-&gt;ctx_blk_size,
<a name="l00665"></a>00665                         cp-&gt;ctx_arr[i].ctx,
<a name="l00666"></a>00666                         cp-&gt;ctx_arr[i].mapping);
<a name="l00667"></a>00667             cp-&gt;ctx_arr[i].ctx = NULL;
<a name="l00668"></a>00668         }
<a name="l00669"></a>00669     }
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_free_resc(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00673"></a>00673 {
<a name="l00674"></a>00674     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676     cnic_free_contex(dev);
<a name="l00677"></a>00677     kfree(cp-&gt;ctx_arr);
<a name="l00678"></a>00678     cp-&gt;ctx_arr = NULL;
<a name="l00679"></a>00679     cp-&gt;ctx_blks = 0;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681     cnic_free_dma(dev, &amp;cp-&gt;gbl_buf_info);
<a name="l00682"></a>00682     cnic_free_dma(dev, &amp;cp-&gt;conn_buf_info);
<a name="l00683"></a>00683     cnic_free_dma(dev, &amp;cp-&gt;kwq_info);
<a name="l00684"></a>00684     cnic_free_dma(dev, &amp;cp-&gt;kwq_16_data_info);
<a name="l00685"></a>00685     cnic_free_dma(dev, &amp;cp-&gt;kcq_info);
<a name="l00686"></a>00686     kfree(cp-&gt;iscsi_tbl);
<a name="l00687"></a>00687     cp-&gt;iscsi_tbl = NULL;
<a name="l00688"></a>00688     kfree(cp-&gt;ctx_tbl);
<a name="l00689"></a>00689     cp-&gt;ctx_tbl = NULL;
<a name="l00690"></a>00690 
<a name="l00691"></a>00691     cnic_free_id_tbl(&amp;cp-&gt;cid_tbl);
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_alloc_context(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     <span class="keywordflow">if</span> (CHIP_NUM(cp) == CHIP_NUM_5709) {
<a name="l00699"></a>00699         <span class="keywordtype">int</span> i, k, arr_size;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         cp-&gt;ctx_blk_size = BCM_PAGE_SIZE;
<a name="l00702"></a>00702         cp-&gt;cids_per_blk = BCM_PAGE_SIZE / 128;
<a name="l00703"></a>00703         arr_size = BNX2_MAX_CID / cp-&gt;cids_per_blk *
<a name="l00704"></a>00704                <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structcnic__ctx.html">cnic_ctx</a>);
<a name="l00705"></a>00705         cp-&gt;ctx_arr = kmalloc(arr_size, GFP_KERNEL);
<a name="l00706"></a>00706         <span class="keywordflow">if</span> (cp-&gt;ctx_arr == NULL)
<a name="l00707"></a>00707             <span class="keywordflow">return</span> -ENOMEM;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         memset(cp-&gt;ctx_arr, 0, arr_size);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711         k = 0;
<a name="l00712"></a>00712         <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l00713"></a>00713             u32 j, reg, off, lo, hi;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715             <span class="keywordflow">if</span> (i == 0)
<a name="l00716"></a>00716                 off = BNX2_PG_CTX_MAP;
<a name="l00717"></a>00717             <span class="keywordflow">else</span>
<a name="l00718"></a>00718                 off = BNX2_ISCSI_CTX_MAP;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720             reg = cnic_reg_rd_ind(dev, off);
<a name="l00721"></a>00721             lo = reg &gt;&gt; 16;
<a name="l00722"></a>00722             hi = reg &amp; 0xffff;
<a name="l00723"></a>00723             <span class="keywordflow">for</span> (j = lo; j &lt; hi; j += cp-&gt;cids_per_blk, k++)
<a name="l00724"></a>00724                 cp-&gt;ctx_arr[k].cid = j;
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         cp-&gt;ctx_blks = k;
<a name="l00728"></a>00728         <span class="keywordflow">if</span> (cp-&gt;ctx_blks &gt;= (BNX2_MAX_CID / cp-&gt;cids_per_blk)) {
<a name="l00729"></a>00729             cp-&gt;ctx_blks = 0;
<a name="l00730"></a>00730             <span class="keywordflow">return</span> -ENOMEM;
<a name="l00731"></a>00731         }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733         <span class="keywordflow">for</span> (i = 0; i &lt; cp-&gt;ctx_blks; i++) {
<a name="l00734"></a>00734             cp-&gt;ctx_arr[i].ctx =
<a name="l00735"></a>00735                 pci_alloc_consistent(dev-&gt;pcidev, BCM_PAGE_SIZE,
<a name="l00736"></a>00736                              &amp;cp-&gt;ctx_arr[i].mapping);
<a name="l00737"></a>00737             <span class="keywordflow">if</span> (cp-&gt;ctx_arr[i].ctx == NULL)
<a name="l00738"></a>00738                 <span class="keywordflow">return</span> -ENOMEM;
<a name="l00739"></a>00739         }
<a name="l00740"></a>00740     }
<a name="l00741"></a>00741     <span class="keywordflow">return</span> 0;
<a name="l00742"></a>00742 }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_alloc_bnx2_resc(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00745"></a>00745 {
<a name="l00746"></a>00746     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00747"></a>00747     <span class="keywordtype">int</span> ret;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     ret = cnic_alloc_dma(dev, &amp;cp-&gt;kwq_info, KWQ_PAGE_CNT, 1);
<a name="l00750"></a>00750     <span class="keywordflow">if</span> (ret)
<a name="l00751"></a>00751         <span class="keywordflow">goto</span> error;
<a name="l00752"></a>00752     cp-&gt;kwq = (<span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> **) cp-&gt;kwq_info.pg_arr;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754     ret = cnic_alloc_dma(dev, &amp;cp-&gt;kcq_info, KCQ_PAGE_CNT, 1);
<a name="l00755"></a>00755     <span class="keywordflow">if</span> (ret)
<a name="l00756"></a>00756         <span class="keywordflow">goto</span> error;
<a name="l00757"></a>00757     cp-&gt;kcq = (<span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> **) cp-&gt;kcq_info.pg_arr;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759     ret = cnic_alloc_context(dev);
<a name="l00760"></a>00760     <span class="keywordflow">if</span> (ret)
<a name="l00761"></a>00761         <span class="keywordflow">goto</span> error;
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <span class="keywordflow">return</span> 0;
<a name="l00764"></a>00764     
<a name="l00765"></a>00765 error:
<a name="l00766"></a>00766     cnic_free_resc(dev);
<a name="l00767"></a>00767     <span class="keywordflow">return</span> ret;
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_alloc_bnx2x_context(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00771"></a>00771 {
<a name="l00772"></a>00772     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00773"></a>00773     <span class="keywordtype">int</span> ctx_blk_size = cp-&gt;ethdev-&gt;ctx_blk_size;
<a name="l00774"></a>00774     <span class="keywordtype">int</span> total_mem, blks, i;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     total_mem = BNX2X_ISCSI_CONTEXT_MEM_SIZE * MAX_ISCSI_TBL_SZ;
<a name="l00777"></a>00777     blks = total_mem / ctx_blk_size;
<a name="l00778"></a>00778     <span class="keywordflow">if</span> (total_mem % ctx_blk_size)
<a name="l00779"></a>00779         blks++;
<a name="l00780"></a>00780 
<a name="l00781"></a>00781     <span class="keywordflow">if</span> (blks &gt; cp-&gt;ethdev-&gt;ctx_tbl_len)
<a name="l00782"></a>00782         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     cp-&gt;ctx_arr = kzalloc(blks * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcnic__ctx.html">cnic_ctx</a>), GFP_KERNEL);
<a name="l00785"></a>00785     <span class="keywordflow">if</span> (cp-&gt;ctx_arr == NULL)
<a name="l00786"></a>00786         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     cp-&gt;ctx_blks = blks;
<a name="l00789"></a>00789     cp-&gt;ctx_blk_size = ctx_blk_size;
<a name="l00790"></a>00790     <span class="keywordflow">if</span> (BNX2X_CHIP_IS_E1H(cp-&gt;chip_id))
<a name="l00791"></a>00791         cp-&gt;ctx_align = 0;
<a name="l00792"></a>00792     <span class="keywordflow">else</span>
<a name="l00793"></a>00793         cp-&gt;ctx_align = ctx_blk_size;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795     cp-&gt;cids_per_blk = ctx_blk_size / BNX2X_ISCSI_CONTEXT_MEM_SIZE;
<a name="l00796"></a>00796 
<a name="l00797"></a>00797     <span class="keywordflow">for</span> (i = 0; i &lt; blks; i++) {
<a name="l00798"></a>00798         cp-&gt;ctx_arr[i].ctx =
<a name="l00799"></a>00799             pci_alloc_consistent(dev-&gt;pcidev, cp-&gt;ctx_blk_size,
<a name="l00800"></a>00800                          &amp;cp-&gt;ctx_arr[i].mapping);
<a name="l00801"></a>00801         <span class="keywordflow">if</span> (cp-&gt;ctx_arr[i].ctx == NULL)
<a name="l00802"></a>00802             <span class="keywordflow">return</span> -ENOMEM;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804         <span class="keywordflow">if</span> (cp-&gt;ctx_align &amp;&amp; cp-&gt;ctx_blk_size == ctx_blk_size) {
<a name="l00805"></a>00805             <span class="keywordflow">if</span> (cp-&gt;ctx_arr[i].mapping &amp; (cp-&gt;ctx_align - 1)) {
<a name="l00806"></a>00806                 cnic_free_contex(dev);
<a name="l00807"></a>00807                 cp-&gt;ctx_blk_size += cp-&gt;ctx_align;
<a name="l00808"></a>00808                 i = -1;
<a name="l00809"></a>00809                 <span class="keywordflow">continue</span>;
<a name="l00810"></a>00810             }
<a name="l00811"></a>00811         }
<a name="l00812"></a>00812     }
<a name="l00813"></a>00813     <span class="keywordflow">return</span> 0;
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_alloc_bnx2x_resc(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l00817"></a>00817 {
<a name="l00818"></a>00818     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00819"></a>00819     <span class="keywordtype">int</span> i, j, n, ret, pages;
<a name="l00820"></a>00820     <span class="keyword">struct </span><a class="code" href="structcnic__dma.html">cnic_dma</a> *kwq_16_dma = &amp;cp-&gt;kwq_16_data_info;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822     cp-&gt;iscsi_tbl = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcnic__iscsi.html">cnic_iscsi</a>) * MAX_ISCSI_TBL_SZ,
<a name="l00823"></a>00823                 GFP_KERNEL);
<a name="l00824"></a>00824     <span class="keywordflow">if</span> (!cp-&gt;iscsi_tbl)
<a name="l00825"></a>00825         <span class="keywordflow">goto</span> error;
<a name="l00826"></a>00826 
<a name="l00827"></a>00827     cp-&gt;ctx_tbl = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcnic__context.html">cnic_context</a>) *
<a name="l00828"></a>00828                   MAX_CNIC_L5_CONTEXT, GFP_KERNEL);
<a name="l00829"></a>00829     <span class="keywordflow">if</span> (!cp-&gt;ctx_tbl)
<a name="l00830"></a>00830         <span class="keywordflow">goto</span> error;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_ISCSI_TBL_SZ; i++) {
<a name="l00833"></a>00833         cp-&gt;ctx_tbl[i].proto.iscsi = &amp;cp-&gt;iscsi_tbl[i];
<a name="l00834"></a>00834         cp-&gt;ctx_tbl[i].ulp_proto_id = CNIC_ULP_ISCSI;
<a name="l00835"></a>00835     }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837     pages = PAGE_ALIGN(MAX_CNIC_L5_CONTEXT * CNIC_KWQ16_DATA_SIZE) /
<a name="l00838"></a>00838         PAGE_SIZE;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840     ret = cnic_alloc_dma(dev, kwq_16_dma, pages, 0);
<a name="l00841"></a>00841     <span class="keywordflow">if</span> (ret)
<a name="l00842"></a>00842         <span class="keywordflow">return</span> -ENOMEM;
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     n = PAGE_SIZE / CNIC_KWQ16_DATA_SIZE;
<a name="l00845"></a>00845     <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; MAX_ISCSI_TBL_SZ; i++) {
<a name="l00846"></a>00846         <span class="keywordtype">long</span> off = CNIC_KWQ16_DATA_SIZE * (i % n);
<a name="l00847"></a>00847 
<a name="l00848"></a>00848         cp-&gt;ctx_tbl[i].kwqe_data = kwq_16_dma-&gt;pg_arr[j] + off;
<a name="l00849"></a>00849         cp-&gt;ctx_tbl[i].kwqe_data_mapping = kwq_16_dma-&gt;pg_map_arr[j] +
<a name="l00850"></a>00850                            off;
<a name="l00851"></a>00851 
<a name="l00852"></a>00852         <span class="keywordflow">if</span> ((i % n) == (n - 1))
<a name="l00853"></a>00853             j++;
<a name="l00854"></a>00854     }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856     ret = cnic_alloc_dma(dev, &amp;cp-&gt;kcq_info, KCQ_PAGE_CNT, 0);
<a name="l00857"></a>00857     <span class="keywordflow">if</span> (ret)
<a name="l00858"></a>00858         <span class="keywordflow">goto</span> error;
<a name="l00859"></a>00859     cp-&gt;kcq = (<span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> **) cp-&gt;kcq_info.pg_arr;
<a name="l00860"></a>00860 
<a name="l00861"></a>00861     for (i = 0; i &lt; KCQ_PAGE_CNT; i++) {
<a name="l00862"></a>00862         <span class="keyword">struct </span><a class="code" href="structbnx2x__bd__chain__next.html">bnx2x_bd_chain_next</a> *next =
<a name="l00863"></a>00863             (<span class="keyword">struct </span><a class="code" href="structbnx2x__bd__chain__next.html">bnx2x_bd_chain_next</a> *)
<a name="l00864"></a>00864             &amp;cp-&gt;kcq[i][MAX_KCQE_CNT];
<a name="l00865"></a>00865         <span class="keywordtype">int</span> j = i + 1;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867         if (j &gt;= KCQ_PAGE_CNT)
<a name="l00868"></a>00868             j = 0;
<a name="l00869"></a>00869         next-&gt;addr_hi = (u64) cp-&gt;kcq_info.pg_map_arr[j] &gt;&gt; 32;
<a name="l00870"></a>00870         next-&gt;addr_lo = cp-&gt;kcq_info.pg_map_arr[j] &amp; 0xffffffff;
<a name="l00871"></a>00871     }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873     pages = PAGE_ALIGN(BNX2X_ISCSI_NUM_CONNECTIONS *
<a name="l00874"></a>00874                BNX2X_ISCSI_CONN_BUF_SIZE) / PAGE_SIZE;
<a name="l00875"></a>00875     ret = cnic_alloc_dma(dev, &amp;cp-&gt;conn_buf_info, pages, 1);
<a name="l00876"></a>00876     <span class="keywordflow">if</span> (ret)
<a name="l00877"></a>00877         <span class="keywordflow">goto</span> error;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     pages = PAGE_ALIGN(BNX2X_ISCSI_GLB_BUF_SIZE) / PAGE_SIZE;
<a name="l00880"></a>00880     ret = cnic_alloc_dma(dev, &amp;cp-&gt;gbl_buf_info, pages, 0);
<a name="l00881"></a>00881     <span class="keywordflow">if</span> (ret)
<a name="l00882"></a>00882         <span class="keywordflow">goto</span> error;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     ret = cnic_alloc_bnx2x_context(dev);
<a name="l00885"></a>00885     <span class="keywordflow">if</span> (ret)
<a name="l00886"></a>00886         <span class="keywordflow">goto</span> error;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888     <span class="keywordflow">return</span> 0;
<a name="l00889"></a>00889 
<a name="l00890"></a>00890 error:
<a name="l00891"></a>00891     cnic_free_resc(dev);
<a name="l00892"></a>00892     <span class="keywordflow">return</span> -ENOMEM;
<a name="l00893"></a>00893 }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 <span class="keyword">static</span> <span class="keyword">inline</span> u32 cnic_kwq_avail(<span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a> *cp)
<a name="l00896"></a>00896 {
<a name="l00897"></a>00897     <span class="keywordflow">return</span> (cp-&gt;max_kwq_idx -
<a name="l00898"></a>00898         ((cp-&gt;kwq_prod_idx - cp-&gt;kwq_con_idx) &amp; cp-&gt;max_kwq_idx));
<a name="l00899"></a>00899 }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_submit_bnx2_kwqes(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> <a class="code" href="structkwqe.html">kwqe</a> *wqes[],
<a name="l00902"></a>00902                   u32 num_wqes)
<a name="l00903"></a>00903 {
<a name="l00904"></a>00904     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00905"></a>00905     <span class="keyword">struct </span><a class="code" href="structkwqe.html">kwqe</a> *prod_qe;
<a name="l00906"></a>00906     u16 prod, sw_prod, i;
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     <span class="keywordflow">if</span> (!test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags))
<a name="l00909"></a>00909         <span class="keywordflow">return</span> -EAGAIN;     <span class="comment">/* bnx2 is down */</span>
<a name="l00910"></a>00910 
<a name="l00911"></a>00911     spin_lock_bh(&amp;cp-&gt;cnic_ulp_lock);
<a name="l00912"></a>00912     <span class="keywordflow">if</span> (num_wqes &gt; cnic_kwq_avail(cp) &amp;&amp;
<a name="l00913"></a>00913         !(cp-&gt;cnic_local_flags &amp; CNIC_LCL_FL_KWQ_INIT)) {
<a name="l00914"></a>00914         spin_unlock_bh(&amp;cp-&gt;cnic_ulp_lock);
<a name="l00915"></a>00915         <span class="keywordflow">return</span> -EAGAIN;
<a name="l00916"></a>00916     }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918     cp-&gt;cnic_local_flags &amp;= ~CNIC_LCL_FL_KWQ_INIT;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     prod = cp-&gt;kwq_prod_idx;
<a name="l00921"></a>00921     sw_prod = prod &amp; MAX_KWQ_IDX;
<a name="l00922"></a>00922     <span class="keywordflow">for</span> (i = 0; i &lt; num_wqes; i++) {
<a name="l00923"></a>00923         prod_qe = &amp;cp-&gt;kwq[KWQ_PG(sw_prod)][KWQ_IDX(sw_prod)];
<a name="l00924"></a>00924         memcpy(prod_qe, wqes[i], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structkwqe.html">kwqe</a>));
<a name="l00925"></a>00925         prod++;
<a name="l00926"></a>00926         sw_prod = prod &amp; MAX_KWQ_IDX;
<a name="l00927"></a>00927     }
<a name="l00928"></a>00928     cp-&gt;kwq_prod_idx = prod;
<a name="l00929"></a>00929 
<a name="l00930"></a>00930     CNIC_WR16(dev, cp-&gt;kwq_io_addr, cp-&gt;kwq_prod_idx);
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     spin_unlock_bh(&amp;cp-&gt;cnic_ulp_lock);
<a name="l00933"></a>00933     <span class="keywordflow">return</span> 0;
<a name="l00934"></a>00934 }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936 <span class="keyword">static</span> <span class="keywordtype">void</span> *cnic_get_kwqe_16_data(<span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a> *cp, u32 l5_cid,
<a name="l00937"></a>00937                    <span class="keyword">union</span> <a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> *l5_data)
<a name="l00938"></a>00938 {
<a name="l00939"></a>00939     <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[l5_cid];
<a name="l00940"></a>00940     dma_addr_t map;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942     map = ctx-&gt;kwqe_data_mapping;
<a name="l00943"></a>00943     l5_data-&gt;phy_address.lo = (u64) map &amp; 0xffffffff;
<a name="l00944"></a>00944     l5_data-&gt;phy_address.hi = (u64) map &gt;&gt; 32;
<a name="l00945"></a>00945     <span class="keywordflow">return</span> ctx-&gt;kwqe_data;
<a name="l00946"></a>00946 }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_submit_kwqe_16(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 cmd, u32 cid,
<a name="l00949"></a>00949                 u32 type, <span class="keyword">union</span> <a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> *l5_data)
<a name="l00950"></a>00950 {
<a name="l00951"></a>00951     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00952"></a>00952     <span class="keyword">struct </span><a class="code" href="structl5cm__spe.html">l5cm_spe</a> <a class="code" href="structkwqe.html">kwqe</a>;
<a name="l00953"></a>00953     <span class="keyword">struct </span><a class="code" href="structkwqe__16.html">kwqe_16</a> *kwq[1];
<a name="l00954"></a>00954     <span class="keywordtype">int</span> ret;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956     <a class="code" href="structkwqe.html">kwqe</a>.hdr.conn_and_cmd_data =
<a name="l00957"></a>00957         cpu_to_le32(((cmd &lt;&lt; SPE_HDR_CMD_ID_SHIFT) |
<a name="l00958"></a>00958                  BNX2X_HW_CID(cid, cp-&gt;func)));
<a name="l00959"></a>00959     <a class="code" href="structkwqe.html">kwqe</a>.hdr.type = cpu_to_le16(type);
<a name="l00960"></a>00960     <a class="code" href="structkwqe.html">kwqe</a>.hdr.reserved = 0;
<a name="l00961"></a>00961     <a class="code" href="structkwqe.html">kwqe</a>.data.phy_address.lo = cpu_to_le32(l5_data-&gt;phy_address.lo);
<a name="l00962"></a>00962     <a class="code" href="structkwqe.html">kwqe</a>.data.phy_address.hi = cpu_to_le32(l5_data-&gt;phy_address.hi);
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     kwq[0] = (<span class="keyword">struct </span><a class="code" href="structkwqe__16.html">kwqe_16</a> *) &amp;<a class="code" href="structkwqe.html">kwqe</a>;
<a name="l00965"></a>00965     spin_lock_bh(&amp;cp-&gt;cnic_ulp_lock);
<a name="l00966"></a>00966     ret = cp-&gt;ethdev-&gt;drv_submit_kwqes_16(dev-&gt;netdev, kwq, 1);
<a name="l00967"></a>00967     spin_unlock_bh(&amp;cp-&gt;cnic_ulp_lock);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969     <span class="keywordflow">if</span> (ret == 1)
<a name="l00970"></a>00970         <span class="keywordflow">return</span> 0;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972     <span class="keywordflow">return</span> -EBUSY;
<a name="l00973"></a>00973 }
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_reply_bnx2x_kcqes(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keywordtype">int</span> ulp_type,
<a name="l00976"></a>00976                    <span class="keyword">struct</span> <a class="code" href="structkcqe.html">kcqe</a> *cqes[], u32 num_cqes)
<a name="l00977"></a>00977 {
<a name="l00978"></a>00978     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00979"></a>00979     <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981     rcu_read_lock();
<a name="l00982"></a>00982     ulp_ops = rcu_dereference(cp-&gt;ulp_ops[ulp_type]);
<a name="l00983"></a>00983     <span class="keywordflow">if</span> (likely(ulp_ops)) {
<a name="l00984"></a>00984         ulp_ops-&gt;indicate_kcqes(cp-&gt;ulp_handle[ulp_type],
<a name="l00985"></a>00985                       cqes, num_cqes);
<a name="l00986"></a>00986     }
<a name="l00987"></a>00987     rcu_read_unlock();
<a name="l00988"></a>00988 }
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_iscsi_init1(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> <a class="code" href="structkwqe.html">kwqe</a> *<a class="code" href="structkwqe.html">kwqe</a>)
<a name="l00991"></a>00991 {
<a name="l00992"></a>00992     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l00993"></a>00993     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__init1.html">iscsi_kwqe_init1</a> *req1 = (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__init1.html">iscsi_kwqe_init1</a> *) kwqe;
<a name="l00994"></a>00994     <span class="keywordtype">int</span> func = cp-&gt;func, pages;
<a name="l00995"></a>00995     <span class="keywordtype">int</span> hq_bds;
<a name="l00996"></a>00996 
<a name="l00997"></a>00997     cp-&gt;num_iscsi_tasks = req1-&gt;num_tasks_per_conn;
<a name="l00998"></a>00998     cp-&gt;num_ccells = req1-&gt;num_ccells_per_conn;
<a name="l00999"></a>00999     cp-&gt;task_array_size = BNX2X_ISCSI_TASK_CONTEXT_SIZE *
<a name="l01000"></a>01000                   cp-&gt;num_iscsi_tasks;
<a name="l01001"></a>01001     cp-&gt;r2tq_size = cp-&gt;num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS *
<a name="l01002"></a>01002             BNX2X_ISCSI_R2TQE_SIZE;
<a name="l01003"></a>01003     cp-&gt;hq_size = cp-&gt;num_ccells * BNX2X_ISCSI_HQ_BD_SIZE;
<a name="l01004"></a>01004     pages = PAGE_ALIGN(cp-&gt;hq_size) / PAGE_SIZE;
<a name="l01005"></a>01005     hq_bds = pages * (PAGE_SIZE / BNX2X_ISCSI_HQ_BD_SIZE);
<a name="l01006"></a>01006     cp-&gt;num_cqs = req1-&gt;num_cqs;
<a name="l01007"></a>01007 
<a name="l01008"></a>01008     <span class="keywordflow">if</span> (!dev-&gt;max_iscsi_conn)
<a name="l01009"></a>01009         <span class="keywordflow">return</span> 0;
<a name="l01010"></a>01010 
<a name="l01011"></a>01011     <span class="comment">/* init Tstorm RAM */</span>
<a name="l01012"></a>01012     CNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_RQ_SIZE_OFFSET(func),
<a name="l01013"></a>01013           req1-&gt;rq_num_wqes);
<a name="l01014"></a>01014     CNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_PAGE_SIZE_OFFSET(func),
<a name="l01015"></a>01015           PAGE_SIZE);
<a name="l01016"></a>01016     CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
<a name="l01017"></a>01017          TSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
<a name="l01018"></a>01018     CNIC_WR16(dev, BAR_TSTRORM_INTMEM +
<a name="l01019"></a>01019           TSTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
<a name="l01020"></a>01020           req1-&gt;num_tasks_per_conn);
<a name="l01021"></a>01021 
<a name="l01022"></a>01022     <span class="comment">/* init Ustorm RAM */</span>
<a name="l01023"></a>01023     CNIC_WR16(dev, BAR_USTRORM_INTMEM +
<a name="l01024"></a>01024           USTORM_ISCSI_RQ_BUFFER_SIZE_OFFSET(func),
<a name="l01025"></a>01025           req1-&gt;rq_buffer_size);
<a name="l01026"></a>01026     CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_PAGE_SIZE_OFFSET(func),
<a name="l01027"></a>01027           PAGE_SIZE);
<a name="l01028"></a>01028     CNIC_WR8(dev, BAR_USTRORM_INTMEM +
<a name="l01029"></a>01029          USTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
<a name="l01030"></a>01030     CNIC_WR16(dev, BAR_USTRORM_INTMEM +
<a name="l01031"></a>01031           USTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
<a name="l01032"></a>01032           req1-&gt;num_tasks_per_conn);
<a name="l01033"></a>01033     CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_RQ_SIZE_OFFSET(func),
<a name="l01034"></a>01034           req1-&gt;rq_num_wqes);
<a name="l01035"></a>01035     CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_CQ_SIZE_OFFSET(func),
<a name="l01036"></a>01036           req1-&gt;cq_num_wqes);
<a name="l01037"></a>01037     CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_R2TQ_SIZE_OFFSET(func),
<a name="l01038"></a>01038           cp-&gt;num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);
<a name="l01039"></a>01039 
<a name="l01040"></a>01040     <span class="comment">/* init Xstorm RAM */</span>
<a name="l01041"></a>01041     CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_PAGE_SIZE_OFFSET(func),
<a name="l01042"></a>01042           PAGE_SIZE);
<a name="l01043"></a>01043     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01044"></a>01044          XSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
<a name="l01045"></a>01045     CNIC_WR16(dev, BAR_XSTRORM_INTMEM +
<a name="l01046"></a>01046           XSTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
<a name="l01047"></a>01047           req1-&gt;num_tasks_per_conn);
<a name="l01048"></a>01048     CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_HQ_SIZE_OFFSET(func),
<a name="l01049"></a>01049           hq_bds);
<a name="l01050"></a>01050     CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_SQ_SIZE_OFFSET(func),
<a name="l01051"></a>01051           req1-&gt;num_tasks_per_conn);
<a name="l01052"></a>01052     CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_R2TQ_SIZE_OFFSET(func),
<a name="l01053"></a>01053           cp-&gt;num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055     <span class="comment">/* init Cstorm RAM */</span>
<a name="l01056"></a>01056     CNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_PAGE_SIZE_OFFSET(func),
<a name="l01057"></a>01057           PAGE_SIZE);
<a name="l01058"></a>01058     CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
<a name="l01059"></a>01059          CSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
<a name="l01060"></a>01060     CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
<a name="l01061"></a>01061           CSTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
<a name="l01062"></a>01062           req1-&gt;num_tasks_per_conn);
<a name="l01063"></a>01063     CNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_CQ_SIZE_OFFSET(func),
<a name="l01064"></a>01064           req1-&gt;cq_num_wqes);
<a name="l01065"></a>01065     CNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_HQ_SIZE_OFFSET(func),
<a name="l01066"></a>01066           hq_bds);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068     <span class="keywordflow">return</span> 0;
<a name="l01069"></a>01069 }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_iscsi_init2(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *kwqe)
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__init2.html">iscsi_kwqe_init2</a> *req2 = (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__init2.html">iscsi_kwqe_init2</a> *) kwqe;
<a name="l01074"></a>01074     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01075"></a>01075     <span class="keywordtype">int</span> func = cp-&gt;func;
<a name="l01076"></a>01076     <span class="keyword">struct </span><a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> <a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01077"></a>01077     <span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *cqes[1];
<a name="l01078"></a>01078 
<a name="l01079"></a>01079     memset(&amp;<a class="code" href="structkcqe.html">kcqe</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structkcqe.html">kcqe</a>));
<a name="l01080"></a>01080     <span class="keywordflow">if</span> (!dev-&gt;max_iscsi_conn) {
<a name="l01081"></a>01081         <a class="code" href="structkcqe.html">kcqe</a>.completion_status =
<a name="l01082"></a>01082             ISCSI_KCQE_COMPLETION_STATUS_ISCSI_NOT_SUPPORTED;
<a name="l01083"></a>01083         <span class="keywordflow">goto</span> done;
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085 
<a name="l01086"></a>01086     CNIC_WR(dev, BAR_TSTRORM_INTMEM +
<a name="l01087"></a>01087         TSTORM_ISCSI_ERROR_BITMAP_OFFSET(func), req2-&gt;error_bit_map[0]);
<a name="l01088"></a>01088     CNIC_WR(dev, BAR_TSTRORM_INTMEM +
<a name="l01089"></a>01089         TSTORM_ISCSI_ERROR_BITMAP_OFFSET(func) + 4,
<a name="l01090"></a>01090         req2-&gt;error_bit_map[1]);
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     CNIC_WR16(dev, BAR_USTRORM_INTMEM +
<a name="l01093"></a>01093           USTORM_ISCSI_CQ_SQN_SIZE_OFFSET(func), req2-&gt;max_cq_sqn);
<a name="l01094"></a>01094     CNIC_WR(dev, BAR_USTRORM_INTMEM +
<a name="l01095"></a>01095         USTORM_ISCSI_ERROR_BITMAP_OFFSET(func), req2-&gt;error_bit_map[0]);
<a name="l01096"></a>01096     CNIC_WR(dev, BAR_USTRORM_INTMEM +
<a name="l01097"></a>01097         USTORM_ISCSI_ERROR_BITMAP_OFFSET(func) + 4,
<a name="l01098"></a>01098         req2-&gt;error_bit_map[1]);
<a name="l01099"></a>01099 
<a name="l01100"></a>01100     CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
<a name="l01101"></a>01101           CSTORM_ISCSI_CQ_SQN_SIZE_OFFSET(func), req2-&gt;max_cq_sqn);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103     <a class="code" href="structkcqe.html">kcqe</a>.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 done:
<a name="l01106"></a>01106     <a class="code" href="structkcqe.html">kcqe</a>.op_code = ISCSI_KCQE_OPCODE_INIT;
<a name="l01107"></a>01107     cqes[0] = (<span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *) &amp;<a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01108"></a>01108     cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);
<a name="l01109"></a>01109 
<a name="l01110"></a>01110     <span class="keywordflow">return</span> 0;
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_free_bnx2x_conn_resc(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 l5_cid)
<a name="l01114"></a>01114 {
<a name="l01115"></a>01115     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01116"></a>01116     <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[l5_cid];
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     <span class="keywordflow">if</span> (ctx-&gt;ulp_proto_id == CNIC_ULP_ISCSI) {
<a name="l01119"></a>01119         <span class="keyword">struct </span><a class="code" href="structcnic__iscsi.html">cnic_iscsi</a> *iscsi = ctx-&gt;proto.iscsi;
<a name="l01120"></a>01120 
<a name="l01121"></a>01121         cnic_free_dma(dev, &amp;iscsi-&gt;hq_info);
<a name="l01122"></a>01122         cnic_free_dma(dev, &amp;iscsi-&gt;r2tq_info);
<a name="l01123"></a>01123         cnic_free_dma(dev, &amp;iscsi-&gt;task_array_info);
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     cnic_free_id(&amp;cp-&gt;cid_tbl, ctx-&gt;cid);
<a name="l01126"></a>01126     ctx-&gt;cid = 0;
<a name="l01127"></a>01127 }
<a name="l01128"></a>01128 
<a name="l01129"></a>01129 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_alloc_bnx2x_conn_resc(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 l5_cid)
<a name="l01130"></a>01130 {
<a name="l01131"></a>01131     u32 cid;
<a name="l01132"></a>01132     <span class="keywordtype">int</span> ret, pages;
<a name="l01133"></a>01133     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01134"></a>01134     <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[l5_cid];
<a name="l01135"></a>01135     <span class="keyword">struct </span><a class="code" href="structcnic__iscsi.html">cnic_iscsi</a> *iscsi = ctx-&gt;proto.iscsi;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137     cid = cnic_alloc_new_id(&amp;cp-&gt;cid_tbl);
<a name="l01138"></a>01138     <span class="keywordflow">if</span> (cid == -1) {
<a name="l01139"></a>01139         ret = -ENOMEM;
<a name="l01140"></a>01140         <span class="keywordflow">goto</span> error;
<a name="l01141"></a>01141     }
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     ctx-&gt;cid = cid;
<a name="l01144"></a>01144     pages = PAGE_ALIGN(cp-&gt;task_array_size) / PAGE_SIZE;
<a name="l01145"></a>01145 
<a name="l01146"></a>01146     ret = cnic_alloc_dma(dev, &amp;iscsi-&gt;task_array_info, pages, 1);
<a name="l01147"></a>01147     <span class="keywordflow">if</span> (ret)
<a name="l01148"></a>01148         <span class="keywordflow">goto</span> error;
<a name="l01149"></a>01149 
<a name="l01150"></a>01150     pages = PAGE_ALIGN(cp-&gt;r2tq_size) / PAGE_SIZE;
<a name="l01151"></a>01151     ret = cnic_alloc_dma(dev, &amp;iscsi-&gt;r2tq_info, pages, 1);
<a name="l01152"></a>01152     <span class="keywordflow">if</span> (ret)
<a name="l01153"></a>01153         <span class="keywordflow">goto</span> error;
<a name="l01154"></a>01154 
<a name="l01155"></a>01155     pages = PAGE_ALIGN(cp-&gt;hq_size) / PAGE_SIZE;
<a name="l01156"></a>01156     ret = cnic_alloc_dma(dev, &amp;iscsi-&gt;hq_info, pages, 1);
<a name="l01157"></a>01157     <span class="keywordflow">if</span> (ret)
<a name="l01158"></a>01158         <span class="keywordflow">goto</span> error;
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     <span class="keywordflow">return</span> 0;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162 error:
<a name="l01163"></a>01163     cnic_free_bnx2x_conn_resc(dev, l5_cid);
<a name="l01164"></a>01164     <span class="keywordflow">return</span> ret;
<a name="l01165"></a>01165 }
<a name="l01166"></a>01166 
<a name="l01167"></a>01167 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structiscsi__context.html">iscsi_context</a> *cnic_get_bnx2x_ctx(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 cid,
<a name="l01168"></a>01168                         <span class="keywordtype">int</span> init,
<a name="l01169"></a>01169                         <span class="keyword">struct</span> <a class="code" href="structregpair.html">regpair</a> *ctx_addr)
<a name="l01170"></a>01170 {
<a name="l01171"></a>01171     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01172"></a>01172     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l01173"></a>01173     <span class="keywordtype">int</span> blk = (cid - ethdev-&gt;starting_cid) / cp-&gt;cids_per_blk;
<a name="l01174"></a>01174     <span class="keywordtype">int</span> off = (cid - ethdev-&gt;starting_cid) % cp-&gt;cids_per_blk;
<a name="l01175"></a>01175     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> align_off = 0;
<a name="l01176"></a>01176     dma_addr_t ctx_map;
<a name="l01177"></a>01177     <span class="keyword">struct </span><a class="code" href="structiscsi__context.html">iscsi_context</a> *ctx;
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <span class="keywordflow">if</span> (cp-&gt;ctx_align) {
<a name="l01180"></a>01180         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask = cp-&gt;ctx_align - 1;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182         <span class="keywordflow">if</span> (cp-&gt;ctx_arr[blk].mapping &amp; mask)
<a name="l01183"></a>01183             align_off = cp-&gt;ctx_align -
<a name="l01184"></a>01184                     (cp-&gt;ctx_arr[blk].mapping &amp; mask);
<a name="l01185"></a>01185     }
<a name="l01186"></a>01186     ctx_map = cp-&gt;ctx_arr[blk].mapping + align_off +
<a name="l01187"></a>01187         (off * BNX2X_ISCSI_CONTEXT_MEM_SIZE);
<a name="l01188"></a>01188     ctx = (<span class="keyword">struct </span><a class="code" href="structiscsi__context.html">iscsi_context</a> *) (cp-&gt;ctx_arr[blk].ctx + align_off +
<a name="l01189"></a>01189         (off * BNX2X_ISCSI_CONTEXT_MEM_SIZE));
<a name="l01190"></a>01190     <span class="keywordflow">if</span> (init)
<a name="l01191"></a>01191         memset(ctx, 0, <span class="keyword">sizeof</span>(*ctx));
<a name="l01192"></a>01192 
<a name="l01193"></a>01193     ctx_addr-&gt;lo = ctx_map &amp; 0xffffffff;
<a name="l01194"></a>01194     ctx_addr-&gt;hi = (u64) ctx_map &gt;&gt; 32;
<a name="l01195"></a>01195     <span class="keywordflow">return</span> ctx;
<a name="l01196"></a>01196 }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_setup_bnx2x_ctx(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *wqes[],
<a name="l01199"></a>01199                 u32 num)
<a name="l01200"></a>01200 {
<a name="l01201"></a>01201     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01202"></a>01202     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload1.html">iscsi_kwqe_conn_offload1</a> *req1 =
<a name="l01203"></a>01203             (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload1.html">iscsi_kwqe_conn_offload1</a> *) wqes[0];
<a name="l01204"></a>01204     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload2.html">iscsi_kwqe_conn_offload2</a> *req2 =
<a name="l01205"></a>01205             (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload2.html">iscsi_kwqe_conn_offload2</a> *) wqes[1];
<a name="l01206"></a>01206     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload3.html">iscsi_kwqe_conn_offload3</a> *req3;
<a name="l01207"></a>01207     <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[req1-&gt;iscsi_conn_id];
<a name="l01208"></a>01208     <span class="keyword">struct </span><a class="code" href="structcnic__iscsi.html">cnic_iscsi</a> *iscsi = ctx-&gt;proto.iscsi;
<a name="l01209"></a>01209     u32 cid = ctx-&gt;cid;
<a name="l01210"></a>01210     u32 hw_cid = BNX2X_HW_CID(cid, cp-&gt;func);
<a name="l01211"></a>01211     <span class="keyword">struct </span><a class="code" href="structiscsi__context.html">iscsi_context</a> *ictx;
<a name="l01212"></a>01212     <span class="keyword">struct </span><a class="code" href="structregpair.html">regpair</a> context_addr;
<a name="l01213"></a>01213     <span class="keywordtype">int</span> i, j, n = 2, n_max;
<a name="l01214"></a>01214 
<a name="l01215"></a>01215     ctx-&gt;ctx_flags = 0;
<a name="l01216"></a>01216     <span class="keywordflow">if</span> (!req2-&gt;num_additional_wqes)
<a name="l01217"></a>01217         <span class="keywordflow">return</span> -EINVAL;
<a name="l01218"></a>01218 
<a name="l01219"></a>01219     n_max = req2-&gt;num_additional_wqes + 2;
<a name="l01220"></a>01220 
<a name="l01221"></a>01221     ictx = cnic_get_bnx2x_ctx(dev, cid, 1, &amp;context_addr);
<a name="l01222"></a>01222     <span class="keywordflow">if</span> (ictx == NULL)
<a name="l01223"></a>01223         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01224"></a>01224 
<a name="l01225"></a>01225     req3 = (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload3.html">iscsi_kwqe_conn_offload3</a> *) wqes[n++];
<a name="l01226"></a>01226 
<a name="l01227"></a>01227     ictx-&gt;xstorm_ag_context.hq_prod = 1;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     ictx-&gt;xstorm_st_context.iscsi.first_burst_length =
<a name="l01230"></a>01230         ISCSI_DEF_FIRST_BURST_LEN;
<a name="l01231"></a>01231     ictx-&gt;xstorm_st_context.iscsi.max_send_pdu_length =
<a name="l01232"></a>01232         ISCSI_DEF_MAX_RECV_SEG_LEN;
<a name="l01233"></a>01233     ictx-&gt;xstorm_st_context.iscsi.sq_pbl_base.lo =
<a name="l01234"></a>01234         req1-&gt;sq_page_table_addr_lo;
<a name="l01235"></a>01235     ictx-&gt;xstorm_st_context.iscsi.sq_pbl_base.hi =
<a name="l01236"></a>01236         req1-&gt;sq_page_table_addr_hi;
<a name="l01237"></a>01237     ictx-&gt;xstorm_st_context.iscsi.sq_curr_pbe.lo = req2-&gt;sq_first_pte.hi;
<a name="l01238"></a>01238     ictx-&gt;xstorm_st_context.iscsi.sq_curr_pbe.hi = req2-&gt;sq_first_pte.lo;
<a name="l01239"></a>01239     ictx-&gt;xstorm_st_context.iscsi.hq_pbl_base.lo =
<a name="l01240"></a>01240         iscsi-&gt;hq_info.pgtbl_map &amp; 0xffffffff;
<a name="l01241"></a>01241     ictx-&gt;xstorm_st_context.iscsi.hq_pbl_base.hi =
<a name="l01242"></a>01242         (u64) iscsi-&gt;hq_info.pgtbl_map &gt;&gt; 32;
<a name="l01243"></a>01243     ictx-&gt;xstorm_st_context.iscsi.hq_curr_pbe_base.lo =
<a name="l01244"></a>01244         iscsi-&gt;hq_info.pgtbl[0];
<a name="l01245"></a>01245     ictx-&gt;xstorm_st_context.iscsi.hq_curr_pbe_base.hi =
<a name="l01246"></a>01246         iscsi-&gt;hq_info.pgtbl[1];
<a name="l01247"></a>01247     ictx-&gt;xstorm_st_context.iscsi.r2tq_pbl_base.lo =
<a name="l01248"></a>01248         iscsi-&gt;r2tq_info.pgtbl_map &amp; 0xffffffff;
<a name="l01249"></a>01249     ictx-&gt;xstorm_st_context.iscsi.r2tq_pbl_base.hi =
<a name="l01250"></a>01250         (u64) iscsi-&gt;r2tq_info.pgtbl_map &gt;&gt; 32;
<a name="l01251"></a>01251     ictx-&gt;xstorm_st_context.iscsi.r2tq_curr_pbe_base.lo =
<a name="l01252"></a>01252         iscsi-&gt;r2tq_info.pgtbl[0];
<a name="l01253"></a>01253     ictx-&gt;xstorm_st_context.iscsi.r2tq_curr_pbe_base.hi =
<a name="l01254"></a>01254         iscsi-&gt;r2tq_info.pgtbl[1];
<a name="l01255"></a>01255     ictx-&gt;xstorm_st_context.iscsi.task_pbl_base.lo =
<a name="l01256"></a>01256         iscsi-&gt;task_array_info.pgtbl_map &amp; 0xffffffff;
<a name="l01257"></a>01257     ictx-&gt;xstorm_st_context.iscsi.task_pbl_base.hi =
<a name="l01258"></a>01258         (u64) iscsi-&gt;task_array_info.pgtbl_map &gt;&gt; 32;
<a name="l01259"></a>01259     ictx-&gt;xstorm_st_context.iscsi.task_pbl_cache_idx =
<a name="l01260"></a>01260         BNX2X_ISCSI_PBL_NOT_CACHED;
<a name="l01261"></a>01261 <span class="comment">/*  ictx-&gt;xstorm_st_context.iscsi.max_outstanding_r2ts =</span>
<a name="l01262"></a>01262 <span class="comment">        ISCSI_DEFAULT_MAX_OUTSTANDING_R2T;*/</span>
<a name="l01263"></a>01263     ictx-&gt;xstorm_st_context.iscsi.flags.flags |=
<a name="l01264"></a>01264         XSTORM_ISCSI_CONTEXT_FLAGS_B_IMMEDIATE_DATA;
<a name="l01265"></a>01265     ictx-&gt;xstorm_st_context.iscsi.flags.flags |=
<a name="l01266"></a>01266         XSTORM_ISCSI_CONTEXT_FLAGS_B_INITIAL_R2T;
<a name="l01267"></a>01267 
<a name="l01268"></a>01268     ictx-&gt;tstorm_st_context.iscsi.hdr_bytes_2_fetch = ISCSI_HEADER_SIZE;
<a name="l01269"></a>01269     <span class="comment">/* TSTORM requires the base address of RQ DB &amp; not PTE */</span>
<a name="l01270"></a>01270     ictx-&gt;tstorm_st_context.iscsi.rq_db_phy_addr.lo =
<a name="l01271"></a>01271         req2-&gt;rq_page_table_addr_lo &amp; PAGE_MASK;
<a name="l01272"></a>01272     ictx-&gt;tstorm_st_context.iscsi.rq_db_phy_addr.hi =
<a name="l01273"></a>01273         req2-&gt;rq_page_table_addr_hi;
<a name="l01274"></a>01274     ictx-&gt;tstorm_st_context.iscsi.iscsi_conn_id = req1-&gt;iscsi_conn_id;
<a name="l01275"></a>01275     ictx-&gt;tstorm_st_context.tcp.cwnd = 0x5A8;
<a name="l01276"></a>01276     ictx-&gt;tstorm_st_context.tcp.flags2 |=
<a name="l01277"></a>01277         TSTORM_TCP_ST_CONTEXT_SECTION_DA_EN;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279     ictx-&gt;timers_context.flags |= ISCSI_TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281     ictx-&gt;ustorm_st_context.ring.rq.pbl_base.lo =
<a name="l01282"></a>01282         req2-&gt;rq_page_table_addr_lo;
<a name="l01283"></a>01283     ictx-&gt;ustorm_st_context.ring.rq.pbl_base.hi =
<a name="l01284"></a>01284         req2-&gt;rq_page_table_addr_hi;
<a name="l01285"></a>01285     ictx-&gt;ustorm_st_context.ring.rq.curr_pbe.lo = req3-&gt;qp_first_pte[0].hi;
<a name="l01286"></a>01286     ictx-&gt;ustorm_st_context.ring.rq.curr_pbe.hi = req3-&gt;qp_first_pte[0].lo;
<a name="l01287"></a>01287     ictx-&gt;ustorm_st_context.ring.r2tq.pbl_base.lo =
<a name="l01288"></a>01288         iscsi-&gt;r2tq_info.pgtbl_map &amp; 0xffffffff;
<a name="l01289"></a>01289     ictx-&gt;ustorm_st_context.ring.r2tq.pbl_base.hi =
<a name="l01290"></a>01290         (u64) iscsi-&gt;r2tq_info.pgtbl_map &gt;&gt; 32;
<a name="l01291"></a>01291     ictx-&gt;ustorm_st_context.ring.r2tq.curr_pbe.lo =
<a name="l01292"></a>01292         iscsi-&gt;r2tq_info.pgtbl[0];
<a name="l01293"></a>01293     ictx-&gt;ustorm_st_context.ring.r2tq.curr_pbe.hi =
<a name="l01294"></a>01294         iscsi-&gt;r2tq_info.pgtbl[1];
<a name="l01295"></a>01295     ictx-&gt;ustorm_st_context.ring.cq_pbl_base.lo =
<a name="l01296"></a>01296         req1-&gt;cq_page_table_addr_lo;
<a name="l01297"></a>01297     ictx-&gt;ustorm_st_context.ring.cq_pbl_base.hi =
<a name="l01298"></a>01298         req1-&gt;cq_page_table_addr_hi;
<a name="l01299"></a>01299     ictx-&gt;ustorm_st_context.ring.cq[0].cq_sn = ISCSI_INITIAL_SN;
<a name="l01300"></a>01300     ictx-&gt;ustorm_st_context.ring.cq[0].curr_pbe.lo = req2-&gt;cq_first_pte.hi;
<a name="l01301"></a>01301     ictx-&gt;ustorm_st_context.ring.cq[0].curr_pbe.hi = req2-&gt;cq_first_pte.lo;
<a name="l01302"></a>01302     ictx-&gt;ustorm_st_context.task_pbe_cache_index =
<a name="l01303"></a>01303         BNX2X_ISCSI_PBL_NOT_CACHED;
<a name="l01304"></a>01304     ictx-&gt;ustorm_st_context.task_pdu_cache_index =
<a name="l01305"></a>01305         BNX2X_ISCSI_PDU_HEADER_NOT_CACHED;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307     <span class="keywordflow">for</span> (i = 1, j = 1; i &lt; cp-&gt;num_cqs; i++, j++) {
<a name="l01308"></a>01308         <span class="keywordflow">if</span> (j == 3) {
<a name="l01309"></a>01309             <span class="keywordflow">if</span> (n &gt;= n_max)
<a name="l01310"></a>01310                 <span class="keywordflow">break</span>;
<a name="l01311"></a>01311             req3 = (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload3.html">iscsi_kwqe_conn_offload3</a> *) wqes[n++];
<a name="l01312"></a>01312             j = 0;
<a name="l01313"></a>01313         }
<a name="l01314"></a>01314         ictx-&gt;ustorm_st_context.ring.cq[i].cq_sn = ISCSI_INITIAL_SN;
<a name="l01315"></a>01315         ictx-&gt;ustorm_st_context.ring.cq[i].curr_pbe.lo =
<a name="l01316"></a>01316             req3-&gt;qp_first_pte[j].hi;
<a name="l01317"></a>01317         ictx-&gt;ustorm_st_context.ring.cq[i].curr_pbe.hi =
<a name="l01318"></a>01318             req3-&gt;qp_first_pte[j].lo;
<a name="l01319"></a>01319     }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321     ictx-&gt;ustorm_st_context.task_pbl_base.lo =
<a name="l01322"></a>01322         iscsi-&gt;task_array_info.pgtbl_map &amp; 0xffffffff;
<a name="l01323"></a>01323     ictx-&gt;ustorm_st_context.task_pbl_base.hi =
<a name="l01324"></a>01324         (u64) iscsi-&gt;task_array_info.pgtbl_map &gt;&gt; 32;
<a name="l01325"></a>01325     ictx-&gt;ustorm_st_context.tce_phy_addr.lo =
<a name="l01326"></a>01326         iscsi-&gt;task_array_info.pgtbl[0];
<a name="l01327"></a>01327     ictx-&gt;ustorm_st_context.tce_phy_addr.hi =
<a name="l01328"></a>01328         iscsi-&gt;task_array_info.pgtbl[1];
<a name="l01329"></a>01329     ictx-&gt;ustorm_st_context.iscsi_conn_id = req1-&gt;iscsi_conn_id;
<a name="l01330"></a>01330     ictx-&gt;ustorm_st_context.num_cqs = cp-&gt;num_cqs;
<a name="l01331"></a>01331     ictx-&gt;ustorm_st_context.negotiated_rx |= ISCSI_DEF_MAX_RECV_SEG_LEN;
<a name="l01332"></a>01332     ictx-&gt;ustorm_st_context.negotiated_rx_and_flags |=
<a name="l01333"></a>01333         ISCSI_DEF_MAX_BURST_LEN;
<a name="l01334"></a>01334     ictx-&gt;ustorm_st_context.negotiated_rx |=
<a name="l01335"></a>01335         ISCSI_DEFAULT_MAX_OUTSTANDING_R2T &lt;&lt;
<a name="l01336"></a>01336         USTORM_ISCSI_ST_CONTEXT_MAX_OUTSTANDING_R2TS_SHIFT;
<a name="l01337"></a>01337 
<a name="l01338"></a>01338     ictx-&gt;cstorm_st_context.hq_pbl_base.lo =
<a name="l01339"></a>01339         iscsi-&gt;hq_info.pgtbl_map &amp; 0xffffffff;
<a name="l01340"></a>01340     ictx-&gt;cstorm_st_context.hq_pbl_base.hi =
<a name="l01341"></a>01341         (u64) iscsi-&gt;hq_info.pgtbl_map &gt;&gt; 32;
<a name="l01342"></a>01342     ictx-&gt;cstorm_st_context.hq_curr_pbe.lo = iscsi-&gt;hq_info.pgtbl[0];
<a name="l01343"></a>01343     ictx-&gt;cstorm_st_context.hq_curr_pbe.hi = iscsi-&gt;hq_info.pgtbl[1];
<a name="l01344"></a>01344     ictx-&gt;cstorm_st_context.task_pbl_base.lo =
<a name="l01345"></a>01345         iscsi-&gt;task_array_info.pgtbl_map &amp; 0xffffffff;
<a name="l01346"></a>01346     ictx-&gt;cstorm_st_context.task_pbl_base.hi =
<a name="l01347"></a>01347         (u64) iscsi-&gt;task_array_info.pgtbl_map &gt;&gt; 32;
<a name="l01348"></a>01348     <span class="comment">/* CSTORM and USTORM initialization is different, CSTORM requires</span>
<a name="l01349"></a>01349 <span class="comment">     * CQ DB base &amp; not PTE addr */</span>
<a name="l01350"></a>01350     ictx-&gt;cstorm_st_context.cq_db_base.lo =
<a name="l01351"></a>01351         req1-&gt;cq_page_table_addr_lo &amp; PAGE_MASK;
<a name="l01352"></a>01352     ictx-&gt;cstorm_st_context.cq_db_base.hi = req1-&gt;cq_page_table_addr_hi;
<a name="l01353"></a>01353     ictx-&gt;cstorm_st_context.iscsi_conn_id = req1-&gt;iscsi_conn_id;
<a name="l01354"></a>01354     ictx-&gt;cstorm_st_context.cq_proc_en_bit_map = (1 &lt;&lt; cp-&gt;num_cqs) - 1;
<a name="l01355"></a>01355     <span class="keywordflow">for</span> (i = 0; i &lt; cp-&gt;num_cqs; i++) {
<a name="l01356"></a>01356         ictx-&gt;cstorm_st_context.cq_c_prod_sqn_arr.sqn[i] =
<a name="l01357"></a>01357             ISCSI_INITIAL_SN;
<a name="l01358"></a>01358         ictx-&gt;cstorm_st_context.cq_c_sqn_2_notify_arr.sqn[i] =
<a name="l01359"></a>01359             ISCSI_INITIAL_SN;
<a name="l01360"></a>01360     }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362     ictx-&gt;xstorm_ag_context.cdu_reserved =
<a name="l01363"></a>01363         CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_XCM_AG,
<a name="l01364"></a>01364                        ISCSI_CONNECTION_TYPE);
<a name="l01365"></a>01365     ictx-&gt;ustorm_ag_context.cdu_usage =
<a name="l01366"></a>01366         CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_UCM_AG,
<a name="l01367"></a>01367                        ISCSI_CONNECTION_TYPE);
<a name="l01368"></a>01368     <span class="keywordflow">return</span> 0;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370 }
<a name="l01371"></a>01371 
<a name="l01372"></a>01372 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_iscsi_ofld1(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *wqes[],
<a name="l01373"></a>01373                    u32 num, <span class="keywordtype">int</span> *work)
<a name="l01374"></a>01374 {
<a name="l01375"></a>01375     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload1.html">iscsi_kwqe_conn_offload1</a> *req1;
<a name="l01376"></a>01376     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload2.html">iscsi_kwqe_conn_offload2</a> *req2;
<a name="l01377"></a>01377     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01378"></a>01378     <span class="keyword">struct </span><a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> <a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01379"></a>01379     <span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *cqes[1];
<a name="l01380"></a>01380     u32 l5_cid;
<a name="l01381"></a>01381     <span class="keywordtype">int</span> ret;
<a name="l01382"></a>01382 
<a name="l01383"></a>01383     <span class="keywordflow">if</span> (num &lt; 2) {
<a name="l01384"></a>01384         *work = num;
<a name="l01385"></a>01385         <span class="keywordflow">return</span> -EINVAL;
<a name="l01386"></a>01386     }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388     req1 = (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload1.html">iscsi_kwqe_conn_offload1</a> *) wqes[0];
<a name="l01389"></a>01389     req2 = (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__offload2.html">iscsi_kwqe_conn_offload2</a> *) wqes[1];
<a name="l01390"></a>01390     <span class="keywordflow">if</span> ((num - 2) &lt; req2-&gt;num_additional_wqes) {
<a name="l01391"></a>01391         *work = num;
<a name="l01392"></a>01392         <span class="keywordflow">return</span> -EINVAL;
<a name="l01393"></a>01393     }
<a name="l01394"></a>01394     *work = 2 + req2-&gt;num_additional_wqes;;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396     l5_cid = req1-&gt;iscsi_conn_id;
<a name="l01397"></a>01397     <span class="keywordflow">if</span> (l5_cid &gt;= MAX_ISCSI_TBL_SZ)
<a name="l01398"></a>01398         <span class="keywordflow">return</span> -EINVAL;
<a name="l01399"></a>01399 
<a name="l01400"></a>01400     memset(&amp;<a class="code" href="structkcqe.html">kcqe</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structkcqe.html">kcqe</a>));
<a name="l01401"></a>01401     <a class="code" href="structkcqe.html">kcqe</a>.op_code = ISCSI_KCQE_OPCODE_OFFLOAD_CONN;
<a name="l01402"></a>01402     <a class="code" href="structkcqe.html">kcqe</a>.iscsi_conn_id = l5_cid;
<a name="l01403"></a>01403     <a class="code" href="structkcqe.html">kcqe</a>.completion_status = ISCSI_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405     <span class="keywordflow">if</span> (atomic_inc_return(&amp;cp-&gt;iscsi_conn) &gt; dev-&gt;max_iscsi_conn) {
<a name="l01406"></a>01406         atomic_dec(&amp;cp-&gt;iscsi_conn);
<a name="l01407"></a>01407         ret = 0;
<a name="l01408"></a>01408         <span class="keywordflow">goto</span> done;
<a name="l01409"></a>01409     }
<a name="l01410"></a>01410     ret = cnic_alloc_bnx2x_conn_resc(dev, l5_cid);
<a name="l01411"></a>01411     <span class="keywordflow">if</span> (ret) {
<a name="l01412"></a>01412         atomic_dec(&amp;cp-&gt;iscsi_conn);
<a name="l01413"></a>01413         ret = 0;
<a name="l01414"></a>01414         <span class="keywordflow">goto</span> done;
<a name="l01415"></a>01415     }
<a name="l01416"></a>01416     ret = cnic_setup_bnx2x_ctx(dev, wqes, num);
<a name="l01417"></a>01417     <span class="keywordflow">if</span> (ret &lt; 0) {
<a name="l01418"></a>01418         cnic_free_bnx2x_conn_resc(dev, l5_cid);
<a name="l01419"></a>01419         atomic_dec(&amp;cp-&gt;iscsi_conn);
<a name="l01420"></a>01420         <span class="keywordflow">goto</span> done;
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     <a class="code" href="structkcqe.html">kcqe</a>.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
<a name="l01424"></a>01424     <a class="code" href="structkcqe.html">kcqe</a>.iscsi_conn_context_id = BNX2X_HW_CID(cp-&gt;ctx_tbl[l5_cid].cid,
<a name="l01425"></a>01425                           cp-&gt;func);
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 done:
<a name="l01428"></a>01428     cqes[0] = (<span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *) &amp;<a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01429"></a>01429     cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);
<a name="l01430"></a>01430     <span class="keywordflow">return</span> ret;
<a name="l01431"></a>01431 }
<a name="l01432"></a>01432 
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_iscsi_update(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *kwqe)
<a name="l01435"></a>01435 {
<a name="l01436"></a>01436     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01437"></a>01437     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__update.html">iscsi_kwqe_conn_update</a> *req =
<a name="l01438"></a>01438         (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__update.html">iscsi_kwqe_conn_update</a> *) kwqe;
<a name="l01439"></a>01439     <span class="keywordtype">void</span> *data;
<a name="l01440"></a>01440     <span class="keyword">union </span><a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> l5_data;
<a name="l01441"></a>01441     u32 l5_cid, cid = BNX2X_SW_CID(req-&gt;context_id);
<a name="l01442"></a>01442     <span class="keywordtype">int</span> ret;
<a name="l01443"></a>01443 
<a name="l01444"></a>01444     <span class="keywordflow">if</span> (cnic_get_l5_cid(cp, cid, &amp;l5_cid) != 0)
<a name="l01445"></a>01445         <span class="keywordflow">return</span> -EINVAL;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447     data = cnic_get_kwqe_16_data(cp, l5_cid, &amp;l5_data);
<a name="l01448"></a>01448     <span class="keywordflow">if</span> (!data)
<a name="l01449"></a>01449         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     memcpy(data, kwqe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kwqe));
<a name="l01452"></a>01452 
<a name="l01453"></a>01453     ret = cnic_submit_kwqe_16(dev, ISCSI_RAMROD_CMD_ID_UPDATE_CONN,
<a name="l01454"></a>01454             req-&gt;context_id, ISCSI_CONNECTION_TYPE, &amp;l5_data);
<a name="l01455"></a>01455     <span class="keywordflow">return</span> ret;
<a name="l01456"></a>01456 }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_iscsi_destroy(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *kwqe)
<a name="l01459"></a>01459 {
<a name="l01460"></a>01460     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01461"></a>01461     <span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__destroy.html">iscsi_kwqe_conn_destroy</a> *req =
<a name="l01462"></a>01462         (<span class="keyword">struct </span><a class="code" href="structiscsi__kwqe__conn__destroy.html">iscsi_kwqe_conn_destroy</a> *) kwqe;
<a name="l01463"></a>01463     <span class="keyword">union </span><a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> l5_data;
<a name="l01464"></a>01464     u32 l5_cid = req-&gt;reserved0;
<a name="l01465"></a>01465     <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[l5_cid];
<a name="l01466"></a>01466     <span class="keywordtype">int</span> ret = 0;
<a name="l01467"></a>01467     <span class="keyword">struct </span><a class="code" href="structiscsi__kcqe.html">iscsi_kcqe</a> <a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01468"></a>01468     <span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *cqes[1];
<a name="l01469"></a>01469 
<a name="l01470"></a>01470     <span class="keywordflow">if</span> (!(ctx-&gt;ctx_flags &amp; CTX_FL_OFFLD_START))
<a name="l01471"></a>01471         <span class="keywordflow">goto</span> skip_cfc_delete;
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     <span class="keywordflow">while</span> (!time_after(jiffies, ctx-&gt;timestamp + (2 * HZ)))
<a name="l01474"></a>01474         msleep(250);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476     init_waitqueue_head(&amp;ctx-&gt;waitq);
<a name="l01477"></a>01477     ctx-&gt;wait_cond = 0;
<a name="l01478"></a>01478     memset(&amp;l5_data, 0, <span class="keyword">sizeof</span>(l5_data));
<a name="l01479"></a>01479     ret = cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CFC_DEL,
<a name="l01480"></a>01480                   req-&gt;context_id,
<a name="l01481"></a>01481                   ETH_CONNECTION_TYPE |
<a name="l01482"></a>01482                   (1 &lt;&lt; SPE_HDR_COMMON_RAMROD_SHIFT),
<a name="l01483"></a>01483                   &amp;l5_data);
<a name="l01484"></a>01484     <span class="keywordflow">if</span> (ret == 0)
<a name="l01485"></a>01485         wait_event(ctx-&gt;waitq, ctx-&gt;wait_cond);
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 skip_cfc_delete:
<a name="l01488"></a>01488     cnic_free_bnx2x_conn_resc(dev, l5_cid);
<a name="l01489"></a>01489 
<a name="l01490"></a>01490     atomic_dec(&amp;cp-&gt;iscsi_conn);
<a name="l01491"></a>01491 
<a name="l01492"></a>01492     memset(&amp;<a class="code" href="structkcqe.html">kcqe</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structkcqe.html">kcqe</a>));
<a name="l01493"></a>01493     <a class="code" href="structkcqe.html">kcqe</a>.op_code = ISCSI_KCQE_OPCODE_DESTROY_CONN;
<a name="l01494"></a>01494     <a class="code" href="structkcqe.html">kcqe</a>.iscsi_conn_id = l5_cid;
<a name="l01495"></a>01495     <a class="code" href="structkcqe.html">kcqe</a>.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
<a name="l01496"></a>01496     <a class="code" href="structkcqe.html">kcqe</a>.iscsi_conn_context_id = req-&gt;context_id;
<a name="l01497"></a>01497 
<a name="l01498"></a>01498     cqes[0] = (<span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *) &amp;<a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01499"></a>01499     cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);
<a name="l01500"></a>01500 
<a name="l01501"></a>01501     <span class="keywordflow">return</span> ret;
<a name="l01502"></a>01502 }
<a name="l01503"></a>01503 
<a name="l01504"></a>01504 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_init_storm_conn_bufs(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev,
<a name="l01505"></a>01505                       <span class="keyword">struct</span> <a class="code" href="structl4__kwq__connect__req1.html">l4_kwq_connect_req1</a> *kwqe1,
<a name="l01506"></a>01506                       <span class="keyword">struct</span> <a class="code" href="structl4__kwq__connect__req3.html">l4_kwq_connect_req3</a> *kwqe3,
<a name="l01507"></a>01507                       <span class="keyword">struct</span> <a class="code" href="structl5cm__active__conn__buffer.html">l5cm_active_conn_buffer</a> *conn_buf)
<a name="l01508"></a>01508 {
<a name="l01509"></a>01509     <span class="keyword">struct </span><a class="code" href="structl5cm__conn__addr__params.html">l5cm_conn_addr_params</a> *conn_addr = &amp;conn_buf-&gt;conn_addr_buf;
<a name="l01510"></a>01510     <span class="keyword">struct </span><a class="code" href="structl5cm__xstorm__conn__buffer.html">l5cm_xstorm_conn_buffer</a> *xstorm_buf =
<a name="l01511"></a>01511         &amp;conn_buf-&gt;xstorm_conn_buffer;
<a name="l01512"></a>01512     <span class="keyword">struct </span><a class="code" href="structl5cm__tstorm__conn__buffer.html">l5cm_tstorm_conn_buffer</a> *tstorm_buf =
<a name="l01513"></a>01513         &amp;conn_buf-&gt;tstorm_conn_buffer;
<a name="l01514"></a>01514     <span class="keyword">struct </span><a class="code" href="structregpair.html">regpair</a> context_addr;
<a name="l01515"></a>01515     u32 cid = BNX2X_SW_CID(kwqe1-&gt;cid);
<a name="l01516"></a>01516     <span class="keyword">struct </span>in6_addr src_ip, dst_ip;
<a name="l01517"></a>01517     <span class="keywordtype">int</span> i;
<a name="l01518"></a>01518     u32 *addrp;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520     addrp = (u32 *) &amp;conn_addr-&gt;local_ip_addr;
<a name="l01521"></a>01521     for (i = 0; i &lt; 4; i++, addrp++)
<a name="l01522"></a>01522         src_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);
<a name="l01523"></a>01523 
<a name="l01524"></a>01524     addrp = (u32 *) &amp;conn_addr-&gt;remote_ip_addr;
<a name="l01525"></a>01525     for (i = 0; i &lt; 4; i++, addrp++)
<a name="l01526"></a>01526         dst_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);
<a name="l01527"></a>01527 
<a name="l01528"></a>01528     cnic_get_bnx2x_ctx(dev, cid, 0, &amp;context_addr);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530     xstorm_buf-&gt;context_addr.hi = context_addr.hi;
<a name="l01531"></a>01531     xstorm_buf-&gt;context_addr.lo = context_addr.lo;
<a name="l01532"></a>01532     xstorm_buf-&gt;mss = 0xffff;
<a name="l01533"></a>01533     xstorm_buf-&gt;rcv_buf = kwqe3-&gt;rcv_buf;
<a name="l01534"></a>01534     <span class="keywordflow">if</span> (kwqe1-&gt;tcp_flags &amp; L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE)
<a name="l01535"></a>01535         xstorm_buf-&gt;params |= L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE;
<a name="l01536"></a>01536     xstorm_buf-&gt;pseudo_header_checksum =
<a name="l01537"></a>01537         swab16(~csum_ipv6_magic(&amp;src_ip, &amp;dst_ip, 0, IPPROTO_TCP, 0));
<a name="l01538"></a>01538 
<a name="l01539"></a>01539     <span class="keywordflow">if</span> (!(kwqe1-&gt;tcp_flags &amp; L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK))
<a name="l01540"></a>01540         tstorm_buf-&gt;params |=
<a name="l01541"></a>01541             L5CM_TSTORM_CONN_BUFFER_DELAYED_ACK_ENABLE;
<a name="l01542"></a>01542     <span class="keywordflow">if</span> (kwqe3-&gt;ka_timeout) {
<a name="l01543"></a>01543         tstorm_buf-&gt;ka_enable = 1;
<a name="l01544"></a>01544         tstorm_buf-&gt;ka_timeout = kwqe3-&gt;ka_timeout;
<a name="l01545"></a>01545         tstorm_buf-&gt;ka_interval = kwqe3-&gt;ka_interval;
<a name="l01546"></a>01546         tstorm_buf-&gt;ka_max_probe_count = kwqe3-&gt;ka_max_probe_count;
<a name="l01547"></a>01547     }
<a name="l01548"></a>01548     tstorm_buf-&gt;rcv_buf = kwqe3-&gt;rcv_buf;
<a name="l01549"></a>01549     tstorm_buf-&gt;snd_buf = kwqe3-&gt;snd_buf;
<a name="l01550"></a>01550     tstorm_buf-&gt;max_rt_time = 0xffffffff;
<a name="l01551"></a>01551 }
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_init_bnx2x_mac(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u8 *mac)
<a name="l01554"></a>01554 {
<a name="l01555"></a>01555     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01556"></a>01556     <span class="keywordtype">int</span> func = CNIC_FUNC(cp);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01559"></a>01559          XSTORM_ISCSI_LOCAL_MAC_ADDR0_OFFSET(func), mac[0]);
<a name="l01560"></a>01560     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01561"></a>01561          XSTORM_ISCSI_LOCAL_MAC_ADDR1_OFFSET(func), mac[1]);
<a name="l01562"></a>01562     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01563"></a>01563          XSTORM_ISCSI_LOCAL_MAC_ADDR2_OFFSET(func), mac[2]);
<a name="l01564"></a>01564     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01565"></a>01565          XSTORM_ISCSI_LOCAL_MAC_ADDR3_OFFSET(func), mac[3]);
<a name="l01566"></a>01566     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01567"></a>01567          XSTORM_ISCSI_LOCAL_MAC_ADDR4_OFFSET(func), mac[4]);
<a name="l01568"></a>01568     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01569"></a>01569          XSTORM_ISCSI_LOCAL_MAC_ADDR5_OFFSET(func), mac[5]);
<a name="l01570"></a>01570 
<a name="l01571"></a>01571     CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
<a name="l01572"></a>01572          TSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(func), mac[5]);
<a name="l01573"></a>01573     CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
<a name="l01574"></a>01574          TSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(func) + 1,
<a name="l01575"></a>01575          mac[4]);
<a name="l01576"></a>01576     CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
<a name="l01577"></a>01577          TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func), mac[3]);
<a name="l01578"></a>01578     CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
<a name="l01579"></a>01579          TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func) + 1,
<a name="l01580"></a>01580          mac[2]);
<a name="l01581"></a>01581     CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
<a name="l01582"></a>01582          TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func) + 2,
<a name="l01583"></a>01583          mac[1]);
<a name="l01584"></a>01584     CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
<a name="l01585"></a>01585          TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func) + 3,
<a name="l01586"></a>01586          mac[0]);
<a name="l01587"></a>01587 }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_bnx2x_set_tcp_timestamp(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keywordtype">int</span> tcp_ts)
<a name="l01590"></a>01590 {
<a name="l01591"></a>01591     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01592"></a>01592     u8 xstorm_flags = XSTORM_L5CM_TCP_FLAGS_WND_SCL_EN;
<a name="l01593"></a>01593     u16 tstorm_flags = 0;
<a name="l01594"></a>01594 
<a name="l01595"></a>01595     <span class="keywordflow">if</span> (tcp_ts) {
<a name="l01596"></a>01596         xstorm_flags |= XSTORM_L5CM_TCP_FLAGS_TS_ENABLED;
<a name="l01597"></a>01597         tstorm_flags |= TSTORM_L5CM_TCP_FLAGS_TS_ENABLED;
<a name="l01598"></a>01598     }
<a name="l01599"></a>01599 
<a name="l01600"></a>01600     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l01601"></a>01601          XSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(cp-&gt;func), xstorm_flags);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603     CNIC_WR16(dev, BAR_TSTRORM_INTMEM +
<a name="l01604"></a>01604           TSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(cp-&gt;func), tstorm_flags);
<a name="l01605"></a>01605 }
<a name="l01606"></a>01606 
<a name="l01607"></a>01607 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_connect(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *wqes[],
<a name="l01608"></a>01608                   u32 num, <span class="keywordtype">int</span> *work)
<a name="l01609"></a>01609 {
<a name="l01610"></a>01610     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01611"></a>01611     <span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req1.html">l4_kwq_connect_req1</a> *kwqe1 =
<a name="l01612"></a>01612         (<span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req1.html">l4_kwq_connect_req1</a> *) wqes[0];
<a name="l01613"></a>01613     <span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req3.html">l4_kwq_connect_req3</a> *kwqe3;
<a name="l01614"></a>01614     <span class="keyword">struct </span><a class="code" href="structl5cm__active__conn__buffer.html">l5cm_active_conn_buffer</a> *conn_buf;
<a name="l01615"></a>01615     <span class="keyword">struct </span><a class="code" href="structl5cm__conn__addr__params.html">l5cm_conn_addr_params</a> *conn_addr;
<a name="l01616"></a>01616     <span class="keyword">union </span><a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> l5_data;
<a name="l01617"></a>01617     u32 l5_cid = kwqe1-&gt;pg_cid;
<a name="l01618"></a>01618     <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk = &amp;cp-&gt;csk_tbl[l5_cid];
<a name="l01619"></a>01619     <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[l5_cid];
<a name="l01620"></a>01620 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l01621"></a>01621 <span class="preprocessor"></span>    <span class="keyword">struct </span>neighbour *neigh = csk-&gt;dst-&gt;neighbour;
<a name="l01622"></a>01622 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l01623"></a>01623     <span class="keywordtype">int</span> ret;
<a name="l01624"></a>01624 
<a name="l01625"></a>01625     <span class="keywordflow">if</span> (num &lt; 2) {
<a name="l01626"></a>01626         *work = num;
<a name="l01627"></a>01627         <span class="keywordflow">return</span> -EINVAL;
<a name="l01628"></a>01628     }
<a name="l01629"></a>01629 
<a name="l01630"></a>01630     <span class="keywordflow">if</span> (kwqe1-&gt;conn_flags &amp; L4_KWQ_CONNECT_REQ1_IP_V6)
<a name="l01631"></a>01631         *work = 3;
<a name="l01632"></a>01632     <span class="keywordflow">else</span>
<a name="l01633"></a>01633         *work = 2;
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     <span class="keywordflow">if</span> (num &lt; *work) {
<a name="l01636"></a>01636         *work = num;
<a name="l01637"></a>01637         <span class="keywordflow">return</span> -EINVAL;
<a name="l01638"></a>01638     }
<a name="l01639"></a>01639 
<a name="l01640"></a>01640     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(*conn_buf) &gt; CNIC_KWQ16_DATA_SIZE) {
<a name="l01641"></a>01641         printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: conn_buf size too big\n&quot;</span>,
<a name="l01642"></a>01642                    dev-&gt;netdev-&gt;name);
<a name="l01643"></a>01643         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01644"></a>01644     }
<a name="l01645"></a>01645     conn_buf = cnic_get_kwqe_16_data(cp, l5_cid, &amp;l5_data);
<a name="l01646"></a>01646     <span class="keywordflow">if</span> (!conn_buf)
<a name="l01647"></a>01647         <span class="keywordflow">return</span> -ENOMEM;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649     memset(conn_buf, 0, <span class="keyword">sizeof</span>(*conn_buf));
<a name="l01650"></a>01650 
<a name="l01651"></a>01651     conn_addr = &amp;conn_buf-&gt;conn_addr_buf;
<a name="l01652"></a>01652 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l01653"></a>01653 <span class="preprocessor"></span>    conn_addr-&gt;remote_addr_0 = csk-&gt;ha[0];
<a name="l01654"></a>01654     conn_addr-&gt;remote_addr_1 = csk-&gt;ha[1];
<a name="l01655"></a>01655     conn_addr-&gt;remote_addr_2 = csk-&gt;ha[2];
<a name="l01656"></a>01656     conn_addr-&gt;remote_addr_3 = csk-&gt;ha[3];
<a name="l01657"></a>01657     conn_addr-&gt;remote_addr_4 = csk-&gt;ha[4];
<a name="l01658"></a>01658     conn_addr-&gt;remote_addr_5 = csk-&gt;ha[5];
<a name="l01659"></a>01659 
<a name="l01660"></a>01660 
<a name="l01661"></a>01661     <span class="comment">/* Use the stored MAC address */</span>
<a name="l01662"></a>01662     cnic_init_bnx2x_mac(dev, cp-&gt;srcMACAddr);
<a name="l01663"></a>01663 <span class="preprocessor">#else </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l01664"></a>01664     conn_addr-&gt;remote_addr_0 = neigh-&gt;ha[0];
<a name="l01665"></a>01665     conn_addr-&gt;remote_addr_1 = neigh-&gt;ha[1];
<a name="l01666"></a>01666     conn_addr-&gt;remote_addr_2 = neigh-&gt;ha[2];
<a name="l01667"></a>01667     conn_addr-&gt;remote_addr_3 = neigh-&gt;ha[3];
<a name="l01668"></a>01668     conn_addr-&gt;remote_addr_4 = neigh-&gt;ha[4];
<a name="l01669"></a>01669     conn_addr-&gt;remote_addr_5 = neigh-&gt;ha[5];
<a name="l01670"></a>01670 <span class="preprocessor">#endif </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l01671"></a>01671 
<a name="l01672"></a>01672     <span class="keywordflow">if</span> (kwqe1-&gt;conn_flags &amp; L4_KWQ_CONNECT_REQ1_IP_V6) {
<a name="l01673"></a>01673         <span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req2.html">l4_kwq_connect_req2</a> *kwqe2 =
<a name="l01674"></a>01674             (<span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req2.html">l4_kwq_connect_req2</a> *) wqes[1];
<a name="l01675"></a>01675 
<a name="l01676"></a>01676         conn_addr-&gt;local_ip_addr.ip_addr_hi_hi = kwqe2-&gt;src_ip_v6_4;
<a name="l01677"></a>01677         conn_addr-&gt;local_ip_addr.ip_addr_hi_lo = kwqe2-&gt;src_ip_v6_3;
<a name="l01678"></a>01678         conn_addr-&gt;local_ip_addr.ip_addr_lo_hi = kwqe2-&gt;src_ip_v6_2;
<a name="l01679"></a>01679 
<a name="l01680"></a>01680         conn_addr-&gt;remote_ip_addr.ip_addr_hi_hi = kwqe2-&gt;dst_ip_v6_4;
<a name="l01681"></a>01681         conn_addr-&gt;remote_ip_addr.ip_addr_hi_lo = kwqe2-&gt;dst_ip_v6_3;
<a name="l01682"></a>01682         conn_addr-&gt;remote_ip_addr.ip_addr_lo_hi = kwqe2-&gt;dst_ip_v6_2;
<a name="l01683"></a>01683         conn_addr-&gt;params |= L5CM_CONN_ADDR_PARAMS_IP_VERSION;
<a name="l01684"></a>01684     }
<a name="l01685"></a>01685     kwqe3 = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req3.html">l4_kwq_connect_req3</a> *) wqes[*work - 1];
<a name="l01686"></a>01686 
<a name="l01687"></a>01687     conn_addr-&gt;local_ip_addr.ip_addr_lo_lo = kwqe1-&gt;src_ip;
<a name="l01688"></a>01688     conn_addr-&gt;remote_ip_addr.ip_addr_lo_lo = kwqe1-&gt;dst_ip;
<a name="l01689"></a>01689     conn_addr-&gt;local_tcp_port = kwqe1-&gt;src_port;
<a name="l01690"></a>01690     conn_addr-&gt;remote_tcp_port = kwqe1-&gt;dst_port;
<a name="l01691"></a>01691 
<a name="l01692"></a>01692     conn_addr-&gt;pmtu = kwqe3-&gt;pmtu;
<a name="l01693"></a>01693     cnic_init_storm_conn_bufs(dev, kwqe1, kwqe3, conn_buf);
<a name="l01694"></a>01694 
<a name="l01695"></a>01695     CNIC_WR16(dev, BAR_XSTRORM_INTMEM +
<a name="l01696"></a>01696           XSTORM_ISCSI_LOCAL_VLAN_OFFSET(cp-&gt;func), csk-&gt;vlan_id);
<a name="l01697"></a>01697 
<a name="l01698"></a>01698     cnic_bnx2x_set_tcp_timestamp(dev,
<a name="l01699"></a>01699         kwqe1-&gt;tcp_flags &amp; L4_KWQ_CONNECT_REQ1_TIME_STAMP);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701     ret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_TCP_CONNECT,
<a name="l01702"></a>01702             kwqe1-&gt;cid, ISCSI_CONNECTION_TYPE, &amp;l5_data);
<a name="l01703"></a>01703     <span class="keywordflow">if</span> (!ret)
<a name="l01704"></a>01704         ctx-&gt;ctx_flags |= CTX_FL_OFFLD_START;
<a name="l01705"></a>01705 
<a name="l01706"></a>01706     <span class="keywordflow">return</span> ret;
<a name="l01707"></a>01707 }
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_close(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *kwqe)
<a name="l01710"></a>01710 {
<a name="l01711"></a>01711     <span class="keyword">struct </span><a class="code" href="structl4__kwq__close__req.html">l4_kwq_close_req</a> *req = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__close__req.html">l4_kwq_close_req</a> *) kwqe;
<a name="l01712"></a>01712     <span class="keyword">union </span><a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> l5_data;
<a name="l01713"></a>01713     <span class="keywordtype">int</span> ret;
<a name="l01714"></a>01714 
<a name="l01715"></a>01715     memset(&amp;l5_data, 0, <span class="keyword">sizeof</span>(l5_data));
<a name="l01716"></a>01716     ret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_CLOSE,
<a name="l01717"></a>01717             req-&gt;cid, ISCSI_CONNECTION_TYPE, &amp;l5_data);
<a name="l01718"></a>01718     <span class="keywordflow">return</span> ret;
<a name="l01719"></a>01719 }
<a name="l01720"></a>01720 
<a name="l01721"></a>01721 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_reset(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *kwqe)
<a name="l01722"></a>01722 {
<a name="l01723"></a>01723     <span class="keyword">struct </span><a class="code" href="structl4__kwq__reset__req.html">l4_kwq_reset_req</a> *req = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__reset__req.html">l4_kwq_reset_req</a> *) kwqe;
<a name="l01724"></a>01724     <span class="keyword">union </span><a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> l5_data;
<a name="l01725"></a>01725     <span class="keywordtype">int</span> ret;
<a name="l01726"></a>01726 
<a name="l01727"></a>01727     memset(&amp;l5_data, 0, <span class="keyword">sizeof</span>(l5_data));
<a name="l01728"></a>01728     ret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_ABORT,
<a name="l01729"></a>01729             req-&gt;cid, ISCSI_CONNECTION_TYPE, &amp;l5_data);
<a name="l01730"></a>01730     <span class="keywordflow">return</span> ret;
<a name="l01731"></a>01731 }
<a name="l01732"></a>01732 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_offload_pg(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *kwqe)
<a name="l01733"></a>01733 {
<a name="l01734"></a>01734     <span class="keyword">struct </span><a class="code" href="structl4__kwq__offload__pg.html">l4_kwq_offload_pg</a> *req = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__offload__pg.html">l4_kwq_offload_pg</a> *) kwqe;
<a name="l01735"></a>01735     <span class="keyword">struct </span><a class="code" href="structl4__kcq.html">l4_kcq</a> <a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01736"></a>01736     <span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *cqes[1];
<a name="l01737"></a>01737 
<a name="l01738"></a>01738     memset(&amp;<a class="code" href="structkcqe.html">kcqe</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structkcqe.html">kcqe</a>));
<a name="l01739"></a>01739     <a class="code" href="structkcqe.html">kcqe</a>.pg_host_opaque = req-&gt;host_opaque;
<a name="l01740"></a>01740     <a class="code" href="structkcqe.html">kcqe</a>.pg_cid = req-&gt;host_opaque;
<a name="l01741"></a>01741     <a class="code" href="structkcqe.html">kcqe</a>.op_code = L4_KCQE_OPCODE_VALUE_OFFLOAD_PG;
<a name="l01742"></a>01742     cqes[0] = (<span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *) &amp;<a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01743"></a>01743     cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);
<a name="l01744"></a>01744     <span class="keywordflow">return</span> 0;
<a name="l01745"></a>01745 }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_bnx2x_update_pg(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *kwqe)
<a name="l01748"></a>01748 {
<a name="l01749"></a>01749     <span class="keyword">struct </span><a class="code" href="structl4__kwq__update__pg.html">l4_kwq_update_pg</a> *req = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__update__pg.html">l4_kwq_update_pg</a> *) kwqe;
<a name="l01750"></a>01750     <span class="keyword">struct </span><a class="code" href="structl4__kcq.html">l4_kcq</a> <a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01751"></a>01751     <span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *cqes[1];
<a name="l01752"></a>01752 
<a name="l01753"></a>01753     memset(&amp;<a class="code" href="structkcqe.html">kcqe</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structkcqe.html">kcqe</a>));
<a name="l01754"></a>01754     <a class="code" href="structkcqe.html">kcqe</a>.pg_host_opaque = req-&gt;pg_host_opaque;
<a name="l01755"></a>01755     <a class="code" href="structkcqe.html">kcqe</a>.pg_cid = req-&gt;pg_cid;
<a name="l01756"></a>01756     <a class="code" href="structkcqe.html">kcqe</a>.op_code = L4_KCQE_OPCODE_VALUE_UPDATE_PG;
<a name="l01757"></a>01757     cqes[0] = (<span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *) &amp;<a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01758"></a>01758     cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);
<a name="l01759"></a>01759     <span class="keywordflow">return</span> 0;
<a name="l01760"></a>01760 }
<a name="l01761"></a>01761 
<a name="l01762"></a>01762 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_submit_bnx2x_kwqes(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kwqe *wqes[],
<a name="l01763"></a>01763                    u32 num_wqes)
<a name="l01764"></a>01764 {
<a name="l01765"></a>01765     <span class="keywordtype">int</span> i, work, ret;
<a name="l01766"></a>01766     u32 opcode;
<a name="l01767"></a>01767     <span class="keyword">struct </span>kwqe *kwqe;
<a name="l01768"></a>01768 
<a name="l01769"></a>01769     <span class="keywordflow">if</span> (!test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags))
<a name="l01770"></a>01770         <span class="keywordflow">return</span> -EAGAIN;     <span class="comment">/* bnx2 is down */</span>
<a name="l01771"></a>01771 
<a name="l01772"></a>01772     <span class="keywordflow">for</span> (i = 0; i &lt; num_wqes; ) {
<a name="l01773"></a>01773         kwqe = wqes[i];
<a name="l01774"></a>01774         opcode = KWQE_OPCODE(kwqe-&gt;kwqe_op_flag);
<a name="l01775"></a>01775         work = 1;
<a name="l01776"></a>01776 
<a name="l01777"></a>01777         <span class="keywordflow">switch</span> (opcode) {
<a name="l01778"></a>01778         <span class="keywordflow">case</span> ISCSI_KWQE_OPCODE_INIT1:
<a name="l01779"></a>01779             ret = cnic_bnx2x_iscsi_init1(dev, kwqe);
<a name="l01780"></a>01780             <span class="keywordflow">break</span>;
<a name="l01781"></a>01781         <span class="keywordflow">case</span> ISCSI_KWQE_OPCODE_INIT2:
<a name="l01782"></a>01782             ret = cnic_bnx2x_iscsi_init2(dev, kwqe);
<a name="l01783"></a>01783             <span class="keywordflow">break</span>;
<a name="l01784"></a>01784         <span class="keywordflow">case</span> ISCSI_KWQE_OPCODE_OFFLOAD_CONN1:
<a name="l01785"></a>01785             ret = cnic_bnx2x_iscsi_ofld1(dev, &amp;wqes[i],
<a name="l01786"></a>01786                              num_wqes - i, &amp;work);
<a name="l01787"></a>01787             <span class="keywordflow">break</span>;
<a name="l01788"></a>01788         <span class="keywordflow">case</span> ISCSI_KWQE_OPCODE_UPDATE_CONN:
<a name="l01789"></a>01789             ret = cnic_bnx2x_iscsi_update(dev, kwqe);
<a name="l01790"></a>01790             <span class="keywordflow">break</span>;
<a name="l01791"></a>01791         <span class="keywordflow">case</span> ISCSI_KWQE_OPCODE_DESTROY_CONN:
<a name="l01792"></a>01792             ret = cnic_bnx2x_iscsi_destroy(dev, kwqe);
<a name="l01793"></a>01793             <span class="keywordflow">break</span>;
<a name="l01794"></a>01794         <span class="keywordflow">case</span> L4_KWQE_OPCODE_VALUE_CONNECT1:
<a name="l01795"></a>01795             ret = cnic_bnx2x_connect(dev, &amp;wqes[i], num_wqes - i,
<a name="l01796"></a>01796                          &amp;work);
<a name="l01797"></a>01797             <span class="keywordflow">break</span>;
<a name="l01798"></a>01798         <span class="keywordflow">case</span> L4_KWQE_OPCODE_VALUE_CLOSE:
<a name="l01799"></a>01799             ret = cnic_bnx2x_close(dev, kwqe);
<a name="l01800"></a>01800             <span class="keywordflow">break</span>;
<a name="l01801"></a>01801         <span class="keywordflow">case</span> L4_KWQE_OPCODE_VALUE_RESET:
<a name="l01802"></a>01802             ret = cnic_bnx2x_reset(dev, kwqe);
<a name="l01803"></a>01803             <span class="keywordflow">break</span>;
<a name="l01804"></a>01804         <span class="keywordflow">case</span> L4_KWQE_OPCODE_VALUE_OFFLOAD_PG:
<a name="l01805"></a>01805             ret = cnic_bnx2x_offload_pg(dev, kwqe);
<a name="l01806"></a>01806             <span class="keywordflow">break</span>;
<a name="l01807"></a>01807         <span class="keywordflow">case</span> L4_KWQE_OPCODE_VALUE_UPDATE_PG:
<a name="l01808"></a>01808             ret = cnic_bnx2x_update_pg(dev, kwqe);
<a name="l01809"></a>01809             <span class="keywordflow">break</span>;
<a name="l01810"></a>01810         <span class="keywordflow">case</span> L4_KWQE_OPCODE_VALUE_UPLOAD_PG:
<a name="l01811"></a>01811             ret = 0;
<a name="l01812"></a>01812             <span class="keywordflow">break</span>;
<a name="l01813"></a>01813         <span class="keywordflow">default</span>:
<a name="l01814"></a>01814             ret = 0;
<a name="l01815"></a>01815             printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: Unknown type of KWQE(0x%x)\n&quot;</span>,
<a name="l01816"></a>01816                    dev-&gt;netdev-&gt;name, opcode);
<a name="l01817"></a>01817             <span class="keywordflow">break</span>;
<a name="l01818"></a>01818         }
<a name="l01819"></a>01819         <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l01820"></a>01820             printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: KWQE(0x%x) failed\n&quot;</span>,
<a name="l01821"></a>01821                    dev-&gt;netdev-&gt;name, opcode);
<a name="l01822"></a>01822         i += work;
<a name="l01823"></a>01823     }
<a name="l01824"></a>01824     <span class="keywordflow">return</span> 0;
<a name="l01825"></a>01825 }
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 <span class="keyword">static</span> <span class="keywordtype">void</span> service_kcqes(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keywordtype">int</span> num_cqes)
<a name="l01828"></a>01828 {
<a name="l01829"></a>01829     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01830"></a>01830     <span class="keywordtype">int</span> i, j;
<a name="l01831"></a>01831 
<a name="l01832"></a>01832     i = 0;
<a name="l01833"></a>01833     j = 1;
<a name="l01834"></a>01834     <span class="keywordflow">while</span> (num_cqes) {
<a name="l01835"></a>01835         <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l01836"></a>01836         <span class="keywordtype">int</span> ulp_type;
<a name="l01837"></a>01837         u32 kcqe_op_flag = cp-&gt;completed_kcq[i]-&gt;kcqe_op_flag;
<a name="l01838"></a>01838         u32 kcqe_layer = kcqe_op_flag &amp; KCQE_FLAGS_LAYER_MASK;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840         <span class="keywordflow">if</span> (unlikely(kcqe_op_flag &amp; KCQE_RAMROD_COMPLETION))
<a name="l01841"></a>01841             cnic_kwq_completion(dev, 1);
<a name="l01842"></a>01842 
<a name="l01843"></a>01843         <span class="keywordflow">while</span> (j &lt; num_cqes) {
<a name="l01844"></a>01844             u32 next_op = cp-&gt;completed_kcq[i + j]-&gt;kcqe_op_flag;
<a name="l01845"></a>01845 
<a name="l01846"></a>01846             <span class="keywordflow">if</span> ((next_op &amp; KCQE_FLAGS_LAYER_MASK) != kcqe_layer)
<a name="l01847"></a>01847                 <span class="keywordflow">break</span>;
<a name="l01848"></a>01848 
<a name="l01849"></a>01849             <span class="keywordflow">if</span> (unlikely(next_op &amp; KCQE_RAMROD_COMPLETION))
<a name="l01850"></a>01850                 cnic_kwq_completion(dev, 1);
<a name="l01851"></a>01851             j++;
<a name="l01852"></a>01852         }
<a name="l01853"></a>01853 
<a name="l01854"></a>01854         <span class="keywordflow">if</span> (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_RDMA)
<a name="l01855"></a>01855             ulp_type = CNIC_ULP_RDMA;
<a name="l01856"></a>01856         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_ISCSI)
<a name="l01857"></a>01857             ulp_type = CNIC_ULP_ISCSI;
<a name="l01858"></a>01858         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L4)
<a name="l01859"></a>01859             ulp_type = CNIC_ULP_L4;
<a name="l01860"></a>01860         <span class="keywordflow">else</span> {
<a name="l01861"></a>01861             printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: Unknown type of KCQE(0x%x)\n&quot;</span>,
<a name="l01862"></a>01862                    dev-&gt;netdev-&gt;name, kcqe_op_flag);
<a name="l01863"></a>01863             <span class="keywordflow">goto</span> end;
<a name="l01864"></a>01864         }
<a name="l01865"></a>01865 
<a name="l01866"></a>01866         rcu_read_lock();
<a name="l01867"></a>01867         ulp_ops = rcu_dereference(cp-&gt;ulp_ops[ulp_type]);
<a name="l01868"></a>01868         <span class="keywordflow">if</span> (likely(ulp_ops)) {
<a name="l01869"></a>01869             ulp_ops-&gt;indicate_kcqes(cp-&gt;ulp_handle[ulp_type],
<a name="l01870"></a>01870                           cp-&gt;completed_kcq + i, j);
<a name="l01871"></a>01871         }
<a name="l01872"></a>01872         rcu_read_unlock();
<a name="l01873"></a>01873 end:
<a name="l01874"></a>01874         num_cqes -= j;
<a name="l01875"></a>01875         i += j;
<a name="l01876"></a>01876         j = 1;
<a name="l01877"></a>01877     }
<a name="l01878"></a>01878     <span class="keywordflow">return</span>;
<a name="l01879"></a>01879 }
<a name="l01880"></a>01880 
<a name="l01881"></a>01881 <span class="keyword">static</span> u16 cnic_bnx2_next_idx(u16 idx)
<a name="l01882"></a>01882 {
<a name="l01883"></a>01883     <span class="keywordflow">return</span> (idx + 1);
<a name="l01884"></a>01884 }
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 <span class="keyword">static</span> u16 cnic_bnx2_hw_idx(u16 idx)
<a name="l01887"></a>01887 {
<a name="l01888"></a>01888     <span class="keywordflow">return</span> idx;
<a name="l01889"></a>01889 }
<a name="l01890"></a>01890 
<a name="l01891"></a>01891 <span class="keyword">static</span> u16 cnic_bnx2x_next_idx(u16 idx)
<a name="l01892"></a>01892 {
<a name="l01893"></a>01893     idx++;
<a name="l01894"></a>01894     <span class="keywordflow">if</span> ((idx &amp; MAX_KCQE_CNT) == MAX_KCQE_CNT)
<a name="l01895"></a>01895         idx++;
<a name="l01896"></a>01896 
<a name="l01897"></a>01897     <span class="keywordflow">return</span> idx;
<a name="l01898"></a>01898 }
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 <span class="keyword">static</span> u16 cnic_bnx2x_hw_idx(u16 idx)
<a name="l01901"></a>01901 {
<a name="l01902"></a>01902     <span class="keywordflow">if</span> ((idx &amp; MAX_KCQE_CNT) == MAX_KCQE_CNT)
<a name="l01903"></a>01903         idx++;
<a name="l01904"></a>01904     <span class="keywordflow">return</span> idx;
<a name="l01905"></a>01905 }
<a name="l01906"></a>01906 
<a name="l01907"></a>01907 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_get_kcqes(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u16 hw_prod, u16 *sw_prod)
<a name="l01908"></a>01908 {
<a name="l01909"></a>01909     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01910"></a>01910     u16 i, ri, last;
<a name="l01911"></a>01911     <span class="keyword">struct </span><a class="code" href="structkcqe.html">kcqe</a> *<a class="code" href="structkcqe.html">kcqe</a>;
<a name="l01912"></a>01912     <span class="keywordtype">int</span> kcqe_cnt = 0, last_cnt = 0;
<a name="l01913"></a>01913 
<a name="l01914"></a>01914     i = ri = last = *sw_prod;
<a name="l01915"></a>01915     ri &amp;= MAX_KCQ_IDX;
<a name="l01916"></a>01916 
<a name="l01917"></a>01917     <span class="keywordflow">while</span> ((i != hw_prod) &amp;&amp; (kcqe_cnt &lt; MAX_COMPLETED_KCQE)) {
<a name="l01918"></a>01918         kcqe = &amp;cp-&gt;kcq[KCQ_PG(ri)][KCQ_IDX(ri)];
<a name="l01919"></a>01919         cp-&gt;completed_kcq[kcqe_cnt++] = kcqe;
<a name="l01920"></a>01920         i = cp-&gt;next_idx(i);
<a name="l01921"></a>01921         ri = i &amp; MAX_KCQ_IDX;
<a name="l01922"></a>01922         <span class="keywordflow">if</span> (likely(!(kcqe-&gt;kcqe_op_flag &amp; KCQE_FLAGS_NEXT))) {
<a name="l01923"></a>01923             last_cnt = kcqe_cnt;
<a name="l01924"></a>01924             last = i;
<a name="l01925"></a>01925         }
<a name="l01926"></a>01926     }
<a name="l01927"></a>01927 
<a name="l01928"></a>01928     *sw_prod = last;
<a name="l01929"></a>01929     <span class="keywordflow">return</span> last_cnt;
<a name="l01930"></a>01930 }
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_service_bnx2(<span class="keywordtype">void</span> *data, <span class="keywordtype">void</span> *status_blk)
<a name="l01933"></a>01933 {
<a name="l01934"></a>01934     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = data;
<a name="l01935"></a>01935     <span class="keyword">struct </span><a class="code" href="structstatus__block.html">status_block</a> *sblk = status_blk;
<a name="l01936"></a>01936     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01937"></a>01937     u32 status_idx = sblk-&gt;status_idx;
<a name="l01938"></a>01938     u16 hw_prod, sw_prod;
<a name="l01939"></a>01939     <span class="keywordtype">int</span> kcqe_cnt;
<a name="l01940"></a>01940 
<a name="l01941"></a>01941     <span class="keywordflow">if</span> (unlikely(!test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags)))
<a name="l01942"></a>01942         <span class="keywordflow">return</span> status_idx;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944     cp-&gt;kwq_con_idx = *cp-&gt;kwq_con_idx_ptr;
<a name="l01945"></a>01945 
<a name="l01946"></a>01946     hw_prod = sblk-&gt;status_completion_producer_index;
<a name="l01947"></a>01947     sw_prod = cp-&gt;kcq_prod_idx;
<a name="l01948"></a>01948     <span class="keywordflow">while</span> (sw_prod != hw_prod) {
<a name="l01949"></a>01949         kcqe_cnt = cnic_get_kcqes(dev, hw_prod, &amp;sw_prod);
<a name="l01950"></a>01950         <span class="keywordflow">if</span> (kcqe_cnt == 0)
<a name="l01951"></a>01951             <span class="keywordflow">goto</span> done;
<a name="l01952"></a>01952 
<a name="l01953"></a>01953         service_kcqes(dev, kcqe_cnt);
<a name="l01954"></a>01954 
<a name="l01955"></a>01955         <span class="comment">/* Tell compiler that status_blk fields can change. */</span>
<a name="l01956"></a>01956         barrier();
<a name="l01957"></a>01957         <span class="keywordflow">if</span> (status_idx != sblk-&gt;status_idx) {
<a name="l01958"></a>01958             status_idx = sblk-&gt;status_idx;
<a name="l01959"></a>01959             cp-&gt;kwq_con_idx = *cp-&gt;kwq_con_idx_ptr;
<a name="l01960"></a>01960             hw_prod = sblk-&gt;status_completion_producer_index;
<a name="l01961"></a>01961         } <span class="keywordflow">else</span>
<a name="l01962"></a>01962             <span class="keywordflow">break</span>;
<a name="l01963"></a>01963     }
<a name="l01964"></a>01964 
<a name="l01965"></a>01965 done:
<a name="l01966"></a>01966     CNIC_WR16(dev, cp-&gt;kcq_io_addr, sw_prod);
<a name="l01967"></a>01967 
<a name="l01968"></a>01968     cp-&gt;kcq_prod_idx = sw_prod;
<a name="l01969"></a>01969     <span class="keywordflow">return</span> status_idx;
<a name="l01970"></a>01970 }
<a name="l01971"></a>01971 
<a name="l01972"></a>01972 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_service_bnx2_msix(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l01973"></a>01973 {
<a name="l01974"></a>01974     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = (<span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *) data;
<a name="l01975"></a>01975     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l01976"></a>01976     <span class="keyword">struct </span><a class="code" href="structstatus__block__msix.html">status_block_msix</a> *status_blk = cp-&gt;bnx2_status_blk;
<a name="l01977"></a>01977     u32 status_idx = status_blk-&gt;status_idx;
<a name="l01978"></a>01978     u16 hw_prod, sw_prod;
<a name="l01979"></a>01979     <span class="keywordtype">int</span> kcqe_cnt;
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     cp-&gt;kwq_con_idx = status_blk-&gt;status_cmd_consumer_index;
<a name="l01982"></a>01982 
<a name="l01983"></a>01983     hw_prod = status_blk-&gt;status_completion_producer_index;
<a name="l01984"></a>01984     sw_prod = cp-&gt;kcq_prod_idx;
<a name="l01985"></a>01985     <span class="keywordflow">while</span> (sw_prod != hw_prod) {
<a name="l01986"></a>01986         kcqe_cnt = cnic_get_kcqes(dev, hw_prod, &amp;sw_prod);
<a name="l01987"></a>01987         <span class="keywordflow">if</span> (kcqe_cnt == 0)
<a name="l01988"></a>01988             <span class="keywordflow">goto</span> done;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990         service_kcqes(dev, kcqe_cnt);
<a name="l01991"></a>01991 
<a name="l01992"></a>01992         <span class="comment">/* Tell compiler that status_blk fields can change. */</span>
<a name="l01993"></a>01993         barrier();
<a name="l01994"></a>01994         <span class="keywordflow">if</span> (status_idx != status_blk-&gt;status_idx) {
<a name="l01995"></a>01995             status_idx = status_blk-&gt;status_idx;
<a name="l01996"></a>01996             cp-&gt;kwq_con_idx = status_blk-&gt;status_cmd_consumer_index;
<a name="l01997"></a>01997             hw_prod = status_blk-&gt;status_completion_producer_index;
<a name="l01998"></a>01998         } <span class="keywordflow">else</span>
<a name="l01999"></a>01999             <span class="keywordflow">break</span>;
<a name="l02000"></a>02000     }
<a name="l02001"></a>02001 
<a name="l02002"></a>02002 done:
<a name="l02003"></a>02003     CNIC_WR16(dev, cp-&gt;kcq_io_addr, sw_prod);
<a name="l02004"></a>02004 
<a name="l02005"></a>02005     cp-&gt;kcq_prod_idx = sw_prod;
<a name="l02006"></a>02006     cp-&gt;last_status_idx = status_idx;
<a name="l02007"></a>02007     CNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp-&gt;int_num |
<a name="l02008"></a>02008         BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp-&gt;last_status_idx);
<a name="l02009"></a>02009 }
<a name="l02010"></a>02010 
<a name="l02011"></a>02011 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= 0x20613)</span>
<a name="l02012"></a>02012 <span class="preprocessor"></span><span class="keyword">static</span> irqreturn_t <a class="code" href="structcnic__irq.html">cnic_irq</a>(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_instance)
<a name="l02013"></a>02013 <span class="preprocessor">#else</span>
<a name="l02014"></a>02014 <span class="preprocessor"></span><span class="keyword">static</span> irqreturn_t <a class="code" href="structcnic__irq.html">cnic_irq</a>(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_instance, <span class="keyword">struct</span> pt_regs *regs)
<a name="l02015"></a>02015 <span class="preprocessor">#endif</span>
<a name="l02016"></a>02016 <span class="preprocessor"></span>{
<a name="l02017"></a>02017     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = dev_instance;
<a name="l02018"></a>02018     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02019"></a>02019     u16 prod = cp-&gt;kcq_prod_idx &amp; MAX_KCQ_IDX;
<a name="l02020"></a>02020 
<a name="l02021"></a>02021     <span class="keywordflow">if</span> (cp-&gt;ack_int)
<a name="l02022"></a>02022         cp-&gt;ack_int(dev);
<a name="l02023"></a>02023 
<a name="l02024"></a>02024     prefetch(cp-&gt;status_blk);
<a name="l02025"></a>02025     prefetch(&amp;cp-&gt;kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);
<a name="l02026"></a>02026 
<a name="l02027"></a>02027     <span class="keywordflow">if</span> (likely(test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags)))
<a name="l02028"></a>02028         tasklet_schedule(&amp;cp-&gt;cnic_irq_task);
<a name="l02029"></a>02029 
<a name="l02030"></a>02030     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02031"></a>02031 }
<a name="l02032"></a>02032 
<a name="l02033"></a>02033 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> cnic_ack_bnx2x_int(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u8 <span class="keywordtype">id</span>, u8 storm,
<a name="l02034"></a>02034                       u16 index, u8 op, u8 update)
<a name="l02035"></a>02035 {
<a name="l02036"></a>02036     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02037"></a>02037     u32 hc_addr = (HC_REG_COMMAND_REG + CNIC_PORT(cp) * 32 +
<a name="l02038"></a>02038                COMMAND_REG_INT_ACK);
<a name="l02039"></a>02039     <span class="keyword">struct </span><a class="code" href="structigu__ack__register.html">igu_ack_register</a> igu_ack;
<a name="l02040"></a>02040 
<a name="l02041"></a>02041     igu_ack.status_block_index = index;
<a name="l02042"></a>02042     igu_ack.sb_id_and_flags =
<a name="l02043"></a>02043             ((<span class="keywordtype">id</span> &lt;&lt; IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT) |
<a name="l02044"></a>02044              (storm &lt;&lt; IGU_ACK_REGISTER_STORM_ID_SHIFT) |
<a name="l02045"></a>02045              (update &lt;&lt; IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT) |
<a name="l02046"></a>02046              (op &lt;&lt; IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT));
<a name="l02047"></a>02047 
<a name="l02048"></a>02048     CNIC_WR(dev, hc_addr, (*(u32 *)&amp;igu_ack));
<a name="l02049"></a>02049 }
<a name="l02050"></a>02050 
<a name="l02051"></a>02051 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_ack_bnx2x_msix(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l02052"></a>02052 {
<a name="l02053"></a>02053     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02054"></a>02054 
<a name="l02055"></a>02055     cnic_ack_bnx2x_int(dev, cp-&gt;status_blk_num, CSTORM_ID, 0,
<a name="l02056"></a>02056                IGU_INT_DISABLE, 0);
<a name="l02057"></a>02057 }
<a name="l02058"></a>02058 
<a name="l02059"></a>02059 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_service_bnx2x_bh(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l02060"></a>02060 {
<a name="l02061"></a>02061     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = (<span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *) data;
<a name="l02062"></a>02062     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02063"></a>02063     u16 hw_prod, sw_prod;
<a name="l02064"></a>02064 <span class="preprocessor">#ifdef NEW_BNX2X_HSI</span>
<a name="l02065"></a>02065 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structcstorm__status__block__c.html">cstorm_status_block_c</a> *sblk =
<a name="l02066"></a>02066         &amp;cp-&gt;bnx2x_status_blk-&gt;c_status_block;
<a name="l02067"></a>02067 <span class="preprocessor">#else</span>
<a name="l02068"></a>02068 <span class="preprocessor"></span>    <span class="keyword">struct </span>cstorm_status_block *sblk =
<a name="l02069"></a>02069         &amp;cp-&gt;bnx2x_status_blk-&gt;c_status_block;
<a name="l02070"></a>02070 <span class="preprocessor">#endif</span>
<a name="l02071"></a>02071 <span class="preprocessor"></span>    u32 status_idx = sblk-&gt;status_block_index;
<a name="l02072"></a>02072     <span class="keywordtype">int</span> kcqe_cnt;
<a name="l02073"></a>02073 
<a name="l02074"></a>02074     <span class="keywordflow">if</span> (unlikely(!test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags)))
<a name="l02075"></a>02075         <span class="keywordflow">return</span>;
<a name="l02076"></a>02076 
<a name="l02077"></a>02077     hw_prod = sblk-&gt;index_values[HC_INDEX_C_ISCSI_EQ_CONS];
<a name="l02078"></a>02078     hw_prod = cp-&gt;hw_idx(hw_prod);
<a name="l02079"></a>02079     sw_prod = cp-&gt;kcq_prod_idx;
<a name="l02080"></a>02080     <span class="keywordflow">while</span> (sw_prod != hw_prod) {
<a name="l02081"></a>02081         u32 kcq_diff;
<a name="l02082"></a>02082         <span class="keywordflow">if</span>(hw_prod &lt; sw_prod)
<a name="l02083"></a>02083             kcq_diff = (65536 + hw_prod) - sw_prod;
<a name="l02084"></a>02084         <span class="keywordflow">else</span>
<a name="l02085"></a>02085             kcq_diff = hw_prod - sw_prod;
<a name="l02086"></a>02086 
<a name="l02087"></a>02087         <span class="keywordflow">if</span> (kcq_diff &gt; MAX_KCQ_IDX)
<a name="l02088"></a>02088             printk(KERN_WARNING PFX
<a name="l02089"></a>02089                 <span class="stringliteral">&quot;%s: kcq abs(hw_prod(%d) - sw_prod(%d))&quot;</span>
<a name="l02090"></a>02090                 <span class="stringliteral">&quot; &gt; MAX_KCQ_IDX(%lu)\n&quot;</span>,
<a name="l02091"></a>02091                 dev-&gt;netdev-&gt;name,
<a name="l02092"></a>02092                 hw_prod, sw_prod, MAX_KCQ_IDX);
<a name="l02093"></a>02093 
<a name="l02094"></a>02094         kcqe_cnt = cnic_get_kcqes(dev, hw_prod, &amp;sw_prod);
<a name="l02095"></a>02095         <span class="keywordflow">if</span> (kcqe_cnt == 0)
<a name="l02096"></a>02096             <span class="keywordflow">goto</span> done;
<a name="l02097"></a>02097 
<a name="l02098"></a>02098         CNIC_WR16(dev, cp-&gt;kcq_io_addr, sw_prod + MAX_KCQ_IDX);
<a name="l02099"></a>02099         service_kcqes(dev, kcqe_cnt);
<a name="l02100"></a>02100 
<a name="l02101"></a>02101         <span class="comment">/* Tell compiler that sblk fields can change. */</span>
<a name="l02102"></a>02102         barrier();
<a name="l02103"></a>02103         <span class="keywordflow">if</span> (status_idx == sblk-&gt;status_block_index)
<a name="l02104"></a>02104             <span class="keywordflow">break</span>;
<a name="l02105"></a>02105 
<a name="l02106"></a>02106         status_idx = sblk-&gt;status_block_index;
<a name="l02107"></a>02107         hw_prod = sblk-&gt;index_values[HC_INDEX_C_ISCSI_EQ_CONS];
<a name="l02108"></a>02108         hw_prod = cp-&gt;hw_idx(hw_prod);
<a name="l02109"></a>02109     }
<a name="l02110"></a>02110 
<a name="l02111"></a>02111 done:
<a name="l02112"></a>02112     cnic_ack_bnx2x_int(dev, cp-&gt;status_blk_num, CSTORM_ID,
<a name="l02113"></a>02113                status_idx, IGU_INT_ENABLE, 1);
<a name="l02114"></a>02114 
<a name="l02115"></a>02115     cp-&gt;kcq_prod_idx = sw_prod;
<a name="l02116"></a>02116     <span class="keywordflow">return</span>;
<a name="l02117"></a>02117 }
<a name="l02118"></a>02118 
<a name="l02119"></a>02119 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_service_bnx2x(<span class="keywordtype">void</span> *data, <span class="keywordtype">void</span> *status_blk)
<a name="l02120"></a>02120 {
<a name="l02121"></a>02121     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = data;
<a name="l02122"></a>02122     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02123"></a>02123     u16 prod = cp-&gt;kcq_prod_idx &amp; MAX_KCQ_IDX;
<a name="l02124"></a>02124 
<a name="l02125"></a>02125     <span class="keywordflow">if</span> (likely(test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags))) {
<a name="l02126"></a>02126         prefetch(cp-&gt;status_blk);
<a name="l02127"></a>02127         prefetch(&amp;cp-&gt;kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);
<a name="l02128"></a>02128 
<a name="l02129"></a>02129         tasklet_schedule(&amp;cp-&gt;cnic_irq_task);
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131     <span class="keywordflow">return</span> 0;
<a name="l02132"></a>02132 }
<a name="l02133"></a>02133 
<a name="l02134"></a>02134 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_ulp_stop(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l02135"></a>02135 {
<a name="l02136"></a>02136     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02137"></a>02137     <span class="keywordtype">int</span> if_type;
<a name="l02138"></a>02138 
<a name="l02139"></a>02139     <span class="keywordflow">for</span> (if_type = 0; if_type &lt; MAX_CNIC_ULP_TYPE; if_type++) {
<a name="l02140"></a>02140         <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142         mutex_lock(&amp;cnic_lock);
<a name="l02143"></a>02143         ulp_ops = cp-&gt;ulp_ops[if_type];
<a name="l02144"></a>02144         <span class="keywordflow">if</span> (!ulp_ops) {
<a name="l02145"></a>02145             mutex_unlock(&amp;cnic_lock);
<a name="l02146"></a>02146             <span class="keywordflow">continue</span>;
<a name="l02147"></a>02147         }
<a name="l02148"></a>02148         set_bit(ULP_F_CALL_PENDING, &amp;cp-&gt;ulp_flags[if_type]);
<a name="l02149"></a>02149         mutex_unlock(&amp;cnic_lock);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         <span class="keywordflow">if</span> (test_and_clear_bit(ULP_F_START, &amp;cp-&gt;ulp_flags[if_type]))
<a name="l02152"></a>02152             ulp_ops-&gt;cnic_stop(cp-&gt;ulp_handle[if_type]);
<a name="l02153"></a>02153 
<a name="l02154"></a>02154         clear_bit(ULP_F_CALL_PENDING, &amp;cp-&gt;ulp_flags[if_type]);
<a name="l02155"></a>02155     }
<a name="l02156"></a>02156 }
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_ulp_start(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l02159"></a>02159 {
<a name="l02160"></a>02160     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02161"></a>02161     <span class="keywordtype">int</span> if_type;
<a name="l02162"></a>02162 
<a name="l02163"></a>02163     <span class="keywordflow">for</span> (if_type = 0; if_type &lt; MAX_CNIC_ULP_TYPE; if_type++) {
<a name="l02164"></a>02164         <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l02165"></a>02165 
<a name="l02166"></a>02166         mutex_lock(&amp;cnic_lock);
<a name="l02167"></a>02167         ulp_ops = cp-&gt;ulp_ops[if_type];
<a name="l02168"></a>02168         <span class="keywordflow">if</span> (!ulp_ops || !ulp_ops-&gt;cnic_start) {
<a name="l02169"></a>02169             mutex_unlock(&amp;cnic_lock);
<a name="l02170"></a>02170             <span class="keywordflow">continue</span>;
<a name="l02171"></a>02171         }
<a name="l02172"></a>02172         set_bit(ULP_F_CALL_PENDING, &amp;cp-&gt;ulp_flags[if_type]);
<a name="l02173"></a>02173         mutex_unlock(&amp;cnic_lock);
<a name="l02174"></a>02174 
<a name="l02175"></a>02175         <span class="keywordflow">if</span> (!test_and_set_bit(ULP_F_START, &amp;cp-&gt;ulp_flags[if_type]))
<a name="l02176"></a>02176             ulp_ops-&gt;cnic_start(cp-&gt;ulp_handle[if_type]);
<a name="l02177"></a>02177 
<a name="l02178"></a>02178         clear_bit(ULP_F_CALL_PENDING, &amp;cp-&gt;ulp_flags[if_type]);
<a name="l02179"></a>02179     }
<a name="l02180"></a>02180 }
<a name="l02181"></a>02181 
<a name="l02182"></a>02182 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_ctl(<span class="keywordtype">void</span> *data, <span class="keyword">struct</span> <a class="code" href="structcnic__ctl__info.html">cnic_ctl_info</a> *info)
<a name="l02183"></a>02183 {
<a name="l02184"></a>02184     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = data;
<a name="l02185"></a>02185 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l02186"></a>02186 <span class="preprocessor"></span>    <span class="keywordtype">int</span> i;
<a name="l02187"></a>02187 <span class="preprocessor">#endif </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l02188"></a>02188 
<a name="l02189"></a>02189     <span class="keywordflow">switch</span> (info-&gt;cmd) {
<a name="l02190"></a>02190     <span class="keywordflow">case</span> CNIC_CTL_STOP_CMD:
<a name="l02191"></a>02191         cnic_hold(dev);
<a name="l02192"></a>02192 
<a name="l02193"></a>02193         <span class="keywordflow">if</span> (test_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags)) {
<a name="l02194"></a>02194             clear_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags);
<a name="l02195"></a>02195             cnic_ulp_stop(dev);
<a name="l02196"></a>02196 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l02197"></a>02197 <span class="preprocessor"></span>            cnic_stop_hw(dev);
<a name="l02198"></a>02198 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02199"></a>02199         }
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l02202"></a>02202 <span class="preprocessor"></span>        i = 0;
<a name="l02203"></a>02203         <span class="keywordflow">while</span> ((atomic_read(&amp;dev-&gt;ref_count) &gt; 1) &amp;&amp; i &lt; 100) {
<a name="l02204"></a>02204             msleep(100);
<a name="l02205"></a>02205             i++;
<a name="l02206"></a>02206         }
<a name="l02207"></a>02207         <span class="keywordflow">if</span> (atomic_read(&amp;dev-&gt;ref_count) &gt; 1)
<a name="l02208"></a>02208             printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: cnic device did not unregister&quot;</span>
<a name="l02209"></a>02209                     <span class="stringliteral">&quot; during stop event.\n&quot;</span>, dev-&gt;netdev-&gt;name);
<a name="l02210"></a>02210 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l02211"></a>02211         cnic_put(dev);
<a name="l02212"></a>02212         <span class="keywordflow">break</span>;
<a name="l02213"></a>02213     <span class="keywordflow">case</span> CNIC_CTL_START_CMD:
<a name="l02214"></a>02214         cnic_hold(dev);
<a name="l02215"></a>02215 
<a name="l02216"></a>02216         set_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags);
<a name="l02217"></a>02217         <span class="keywordflow">if</span> (dev-&gt;use_count) {
<a name="l02218"></a>02218             <span class="keywordflow">if</span> (!cnic_start_hw(dev))
<a name="l02219"></a>02219                 cnic_ulp_start(dev);
<a name="l02220"></a>02220         }
<a name="l02221"></a>02221         cnic_put(dev);
<a name="l02222"></a>02222         <span class="keywordflow">break</span>;
<a name="l02223"></a>02223     <span class="keywordflow">case</span> CNIC_CTL_COMPLETION_CMD: {
<a name="l02224"></a>02224         u32 cid = BNX2X_SW_CID(info-&gt;data.comp.cid);
<a name="l02225"></a>02225         u32 l5_cid;
<a name="l02226"></a>02226         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02227"></a>02227         
<a name="l02228"></a>02228         <span class="keywordflow">if</span> (cnic_get_l5_cid(cp, cid, &amp;l5_cid) == 0) {
<a name="l02229"></a>02229             <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[l5_cid];
<a name="l02230"></a>02230 
<a name="l02231"></a>02231             ctx-&gt;wait_cond = 1;
<a name="l02232"></a>02232             wake_up(&amp;ctx-&gt;waitq);
<a name="l02233"></a>02233         }
<a name="l02234"></a>02234         <span class="keywordflow">break</span>;
<a name="l02235"></a>02235     }
<a name="l02236"></a>02236     <span class="keywordflow">default</span>:
<a name="l02237"></a>02237         <span class="keywordflow">return</span> -EINVAL;
<a name="l02238"></a>02238     }
<a name="l02239"></a>02239     <span class="keywordflow">return</span> 0;
<a name="l02240"></a>02240 }
<a name="l02241"></a>02241 
<a name="l02242"></a>02242 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_ulp_init(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l02243"></a>02243 {
<a name="l02244"></a>02244     <span class="keywordtype">int</span> i;
<a name="l02245"></a>02245     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02246"></a>02246 
<a name="l02247"></a>02247     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CNIC_ULP_TYPE_EXT; i++) {
<a name="l02248"></a>02248         <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l02249"></a>02249 
<a name="l02250"></a>02250         mutex_lock(&amp;cnic_lock);
<a name="l02251"></a>02251         ulp_ops = cnic_ulp_tbl[i];
<a name="l02252"></a>02252         <span class="keywordflow">if</span> (!ulp_ops || !ulp_ops-&gt;cnic_init) {
<a name="l02253"></a>02253             mutex_unlock(&amp;cnic_lock);
<a name="l02254"></a>02254             <span class="keywordflow">continue</span>;
<a name="l02255"></a>02255         }
<a name="l02256"></a>02256         ulp_get(ulp_ops);
<a name="l02257"></a>02257         mutex_unlock(&amp;cnic_lock);
<a name="l02258"></a>02258 
<a name="l02259"></a>02259         <span class="keywordflow">if</span> (!test_and_set_bit(ULP_F_INIT, &amp;cp-&gt;ulp_flags[i]))
<a name="l02260"></a>02260             ulp_ops-&gt;cnic_init(dev);
<a name="l02261"></a>02261 
<a name="l02262"></a>02262         ulp_put(ulp_ops);
<a name="l02263"></a>02263     }
<a name="l02264"></a>02264 }
<a name="l02265"></a>02265 
<a name="l02266"></a>02266 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_ulp_exit(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l02267"></a>02267 {
<a name="l02268"></a>02268     <span class="keywordtype">int</span> i;
<a name="l02269"></a>02269     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02270"></a>02270 
<a name="l02271"></a>02271     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CNIC_ULP_TYPE_EXT; i++) {
<a name="l02272"></a>02272         <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l02273"></a>02273 
<a name="l02274"></a>02274         mutex_lock(&amp;cnic_lock);
<a name="l02275"></a>02275         ulp_ops = cnic_ulp_tbl[i];
<a name="l02276"></a>02276         <span class="keywordflow">if</span> (!ulp_ops || !ulp_ops-&gt;cnic_exit) {
<a name="l02277"></a>02277             mutex_unlock(&amp;cnic_lock);
<a name="l02278"></a>02278             <span class="keywordflow">continue</span>;
<a name="l02279"></a>02279         }
<a name="l02280"></a>02280         ulp_get(ulp_ops);
<a name="l02281"></a>02281         mutex_unlock(&amp;cnic_lock);
<a name="l02282"></a>02282 
<a name="l02283"></a>02283         <span class="keywordflow">if</span> (test_and_clear_bit(ULP_F_INIT, &amp;cp-&gt;ulp_flags[i]))
<a name="l02284"></a>02284             ulp_ops-&gt;cnic_exit(dev);
<a name="l02285"></a>02285 
<a name="l02286"></a>02286         ulp_put(ulp_ops);
<a name="l02287"></a>02287     }
<a name="l02288"></a>02288 }
<a name="l02289"></a>02289 
<a name="l02290"></a>02290 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_queue_work(<span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a> *cp, u32 work_type, <span class="keywordtype">void</span> *data)
<a name="l02291"></a>02291 {
<a name="l02292"></a>02292     <span class="keyword">struct </span><a class="code" href="structcnic__work__node.html">cnic_work_node</a> *node;
<a name="l02293"></a>02293     <span class="keywordtype">int</span> bytes = <span class="keyword">sizeof</span>(u32 *);
<a name="l02294"></a>02294 
<a name="l02295"></a>02295     spin_lock_bh(&amp;cp-&gt;wr_lock);
<a name="l02296"></a>02296 
<a name="l02297"></a>02297     node = &amp;cp-&gt;cnic_work_ring[cp-&gt;cnic_wr_prod];
<a name="l02298"></a>02298     node-&gt;work_type = work_type;
<a name="l02299"></a>02299     <span class="keywordflow">if</span> (work_type == WORK_TYPE_KCQE)
<a name="l02300"></a>02300         bytes = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>kcqe);
<a name="l02301"></a>02301     <span class="keywordflow">if</span> (work_type == WORK_TYPE_REDIRECT)
<a name="l02302"></a>02302         bytes = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structcnic__redirect__entry.html">cnic_redirect_entry</a>);
<a name="l02303"></a>02303     memcpy(&amp;node-&gt;work_data, data, bytes);
<a name="l02304"></a>02304     cp-&gt;cnic_wr_prod++;
<a name="l02305"></a>02305     cp-&gt;cnic_wr_prod &amp;= WORK_RING_SIZE_MASK;
<a name="l02306"></a>02306 
<a name="l02307"></a>02307     spin_unlock_bh(&amp;cp-&gt;wr_lock);
<a name="l02308"></a>02308     <span class="keywordflow">return</span> 0;
<a name="l02309"></a>02309 }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_offload_pg(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02312"></a>02312 {
<a name="l02313"></a>02313     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l02314"></a>02314     <span class="keyword">struct </span><a class="code" href="structl4__kwq__offload__pg.html">l4_kwq_offload_pg</a> *l4kwqe;
<a name="l02315"></a>02315     <span class="keyword">struct </span>kwqe *wqes[1];
<a name="l02316"></a>02316 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l02317"></a>02317 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02318"></a>02318 <span class="preprocessor">#else  </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02319"></a>02319     <span class="keyword">struct </span>neighbour *neigh = csk-&gt;dst-&gt;neighbour;
<a name="l02320"></a>02320     <span class="keyword">struct </span>net_device *netdev = neigh-&gt;dev;
<a name="l02321"></a>02321 <span class="preprocessor">#endif </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l02322"></a>02322 
<a name="l02323"></a>02323 <span class="preprocessor">#ifndef HAVE_NETEVENT</span>
<a name="l02324"></a>02324 <span class="preprocessor"></span><span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l02325"></a>02325 <span class="preprocessor"></span>    memcpy(csk-&gt;old_ha, &amp;neigh-&gt;ha[0], 6);
<a name="l02326"></a>02326 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02327"></a>02327 <span class="preprocessor">#endif</span>
<a name="l02328"></a>02328 <span class="preprocessor"></span>    l4kwqe = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__offload__pg.html">l4_kwq_offload_pg</a> *) &amp;csk-&gt;kwqe1;
<a name="l02329"></a>02329     memset(l4kwqe, 0, <span class="keyword">sizeof</span>(*l4kwqe));
<a name="l02330"></a>02330     wqes[0] = (<span class="keyword">struct </span>kwqe *) l4kwqe;
<a name="l02331"></a>02331 
<a name="l02332"></a>02332     l4kwqe-&gt;op_code = L4_KWQE_OPCODE_VALUE_OFFLOAD_PG;
<a name="l02333"></a>02333     l4kwqe-&gt;flags =
<a name="l02334"></a>02334         L4_LAYER_CODE &lt;&lt; L4_KWQ_OFFLOAD_PG_LAYER_CODE_SHIFT;
<a name="l02335"></a>02335     l4kwqe-&gt;l2hdr_nbytes = ETH_HLEN;
<a name="l02336"></a>02336 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l02337"></a>02337 <span class="preprocessor"></span>    l4kwqe-&gt;da0 = csk-&gt;ha[0];
<a name="l02338"></a>02338     l4kwqe-&gt;da1 = csk-&gt;ha[1];
<a name="l02339"></a>02339     l4kwqe-&gt;da2 = csk-&gt;ha[2];
<a name="l02340"></a>02340     l4kwqe-&gt;da3 = csk-&gt;ha[3];
<a name="l02341"></a>02341     l4kwqe-&gt;da4 = csk-&gt;ha[4];
<a name="l02342"></a>02342     l4kwqe-&gt;da5 = csk-&gt;ha[5];
<a name="l02343"></a>02343 
<a name="l02344"></a>02344     l4kwqe-&gt;sa0 = cp-&gt;srcMACAddr[0];
<a name="l02345"></a>02345     l4kwqe-&gt;sa1 = cp-&gt;srcMACAddr[1];
<a name="l02346"></a>02346     l4kwqe-&gt;sa2 = cp-&gt;srcMACAddr[2];
<a name="l02347"></a>02347     l4kwqe-&gt;sa3 = cp-&gt;srcMACAddr[3];
<a name="l02348"></a>02348     l4kwqe-&gt;sa4 = cp-&gt;srcMACAddr[4];
<a name="l02349"></a>02349     l4kwqe-&gt;sa5 = cp-&gt;srcMACAddr[5];
<a name="l02350"></a>02350 <span class="preprocessor">#else  </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02351"></a>02351     l4kwqe-&gt;da0 = neigh-&gt;ha[0];
<a name="l02352"></a>02352     l4kwqe-&gt;da1 = neigh-&gt;ha[1];
<a name="l02353"></a>02353     l4kwqe-&gt;da2 = neigh-&gt;ha[2];
<a name="l02354"></a>02354     l4kwqe-&gt;da3 = neigh-&gt;ha[3];
<a name="l02355"></a>02355     l4kwqe-&gt;da4 = neigh-&gt;ha[4];
<a name="l02356"></a>02356     l4kwqe-&gt;da5 = neigh-&gt;ha[5];
<a name="l02357"></a>02357 
<a name="l02358"></a>02358     l4kwqe-&gt;sa0 = netdev-&gt;dev_addr[0];
<a name="l02359"></a>02359     l4kwqe-&gt;sa1 = netdev-&gt;dev_addr[1];
<a name="l02360"></a>02360     l4kwqe-&gt;sa2 = netdev-&gt;dev_addr[2];
<a name="l02361"></a>02361     l4kwqe-&gt;sa3 = netdev-&gt;dev_addr[3];
<a name="l02362"></a>02362     l4kwqe-&gt;sa4 = netdev-&gt;dev_addr[4];
<a name="l02363"></a>02363     l4kwqe-&gt;sa5 = netdev-&gt;dev_addr[5];
<a name="l02364"></a>02364 <span class="preprocessor">#endif </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l02365"></a>02365 
<a name="l02366"></a>02366     l4kwqe-&gt;etype = ETH_P_IP;
<a name="l02367"></a>02367         
<a name="l02368"></a>02368         <span class="comment">/* All offloaded connections shall show an ipid of 0x8000+ */</span>
<a name="l02369"></a>02369         l4kwqe-&gt;ipid_start = 0x8000;
<a name="l02370"></a>02370         l4kwqe-&gt;ipid_count = 0;
<a name="l02371"></a>02371     l4kwqe-&gt;host_opaque = csk-&gt;l5_cid;
<a name="l02372"></a>02372 
<a name="l02373"></a>02373     <span class="keywordflow">if</span> (csk-&gt;vlan_id) {
<a name="l02374"></a>02374         l4kwqe-&gt;pg_flags |= L4_KWQ_OFFLOAD_PG_VLAN_TAGGING;
<a name="l02375"></a>02375         l4kwqe-&gt;vlan_tag = csk-&gt;vlan_id;
<a name="l02376"></a>02376         l4kwqe-&gt;l2hdr_nbytes += 4;
<a name="l02377"></a>02377     }
<a name="l02378"></a>02378 
<a name="l02379"></a>02379     <span class="keywordflow">return</span> (dev-&gt;submit_kwqes(dev, wqes, 1));
<a name="l02380"></a>02380 }
<a name="l02381"></a>02381 
<a name="l02382"></a>02382 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l02383"></a>02383 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_update_pg(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02384"></a>02384 {
<a name="l02385"></a>02385     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l02386"></a>02386     <span class="keyword">struct </span><a class="code" href="structl4__kwq__update__pg.html">l4_kwq_update_pg</a> *l4kwqe;
<a name="l02387"></a>02387     <span class="keyword">struct </span>kwqe *wqes[1];
<a name="l02388"></a>02388     <span class="keyword">struct </span>neighbour *neigh = csk-&gt;dst-&gt;neighbour;
<a name="l02389"></a>02389 
<a name="l02390"></a>02390 <span class="preprocessor">#ifndef HAVE_NETEVENT</span>
<a name="l02391"></a>02391 <span class="preprocessor"></span>    memcpy(csk-&gt;old_ha, &amp;neigh-&gt;ha[0], 6);
<a name="l02392"></a>02392 <span class="preprocessor">#endif</span>
<a name="l02393"></a>02393 <span class="preprocessor"></span>    l4kwqe = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__update__pg.html">l4_kwq_update_pg</a> *) &amp;csk-&gt;kwqe1;
<a name="l02394"></a>02394     memset(l4kwqe, 0, <span class="keyword">sizeof</span>(*l4kwqe));
<a name="l02395"></a>02395     wqes[0] = (<span class="keyword">struct </span>kwqe *) l4kwqe;
<a name="l02396"></a>02396 
<a name="l02397"></a>02397     l4kwqe-&gt;opcode = L4_KWQE_OPCODE_VALUE_UPDATE_PG;
<a name="l02398"></a>02398     l4kwqe-&gt;flags =
<a name="l02399"></a>02399         L4_LAYER_CODE &lt;&lt; L4_KWQ_UPDATE_PG_LAYER_CODE_SHIFT;
<a name="l02400"></a>02400     l4kwqe-&gt;pg_cid = csk-&gt;pg_cid;
<a name="l02401"></a>02401     l4kwqe-&gt;da0 = neigh-&gt;ha[0];
<a name="l02402"></a>02402     l4kwqe-&gt;da1 = neigh-&gt;ha[1];
<a name="l02403"></a>02403     l4kwqe-&gt;da2 = neigh-&gt;ha[2];
<a name="l02404"></a>02404     l4kwqe-&gt;da3 = neigh-&gt;ha[3];
<a name="l02405"></a>02405     l4kwqe-&gt;da4 = neigh-&gt;ha[4];
<a name="l02406"></a>02406     l4kwqe-&gt;da5 = neigh-&gt;ha[5];
<a name="l02407"></a>02407 
<a name="l02408"></a>02408     l4kwqe-&gt;pg_host_opaque = csk-&gt;l5_cid;
<a name="l02409"></a>02409     l4kwqe-&gt;pg_valids = L4_KWQ_UPDATE_PG_VALIDS_DA;
<a name="l02410"></a>02410 
<a name="l02411"></a>02411     <span class="keywordflow">return</span> (dev-&gt;submit_kwqes(dev, wqes, 1));
<a name="l02412"></a>02412 }
<a name="l02413"></a>02413 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02414"></a>02414 
<a name="l02415"></a>02415 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_upload_pg(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02416"></a>02416 {
<a name="l02417"></a>02417     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l02418"></a>02418     <span class="keyword">struct </span><a class="code" href="structl4__kwq__upload.html">l4_kwq_upload</a> *l4kwqe;
<a name="l02419"></a>02419     <span class="keyword">struct </span>kwqe *wqes[1];
<a name="l02420"></a>02420 
<a name="l02421"></a>02421     l4kwqe = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__upload.html">l4_kwq_upload</a> *) &amp;csk-&gt;kwqe1;
<a name="l02422"></a>02422     memset(l4kwqe, 0, <span class="keyword">sizeof</span>(*l4kwqe));
<a name="l02423"></a>02423     wqes[0] = (<span class="keyword">struct </span>kwqe *) l4kwqe;
<a name="l02424"></a>02424 
<a name="l02425"></a>02425     l4kwqe-&gt;opcode = L4_KWQE_OPCODE_VALUE_UPLOAD_PG;
<a name="l02426"></a>02426     l4kwqe-&gt;flags =
<a name="l02427"></a>02427         L4_LAYER_CODE &lt;&lt; L4_KWQ_UPLOAD_LAYER_CODE_SHIFT;
<a name="l02428"></a>02428     l4kwqe-&gt;cid = csk-&gt;pg_cid;
<a name="l02429"></a>02429 
<a name="l02430"></a>02430     <span class="keywordflow">return</span> (dev-&gt;submit_kwqes(dev, wqes, 1));
<a name="l02431"></a>02431 }
<a name="l02432"></a>02432 
<a name="l02433"></a>02433 <span class="preprocessor">#ifdef HAVE_NETEVENT</span>
<a name="l02434"></a>02434 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> cnic_redirect(<span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a> *cp, <span class="keyword">struct</span> dst_entry *<span class="keyword">new</span>,
<a name="l02435"></a>02435               <span class="keyword">struct</span> dst_entry *old)
<a name="l02436"></a>02436 {
<a name="l02437"></a>02437     <span class="keywordtype">int</span> i, found = 0;
<a name="l02438"></a>02438 
<a name="l02439"></a>02439     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CM_SK_TBL_SZ &amp;&amp; !found; i++) {
<a name="l02440"></a>02440         <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk;
<a name="l02441"></a>02441         <span class="keyword">struct </span><a class="code" href="structcnic__redirect__entry.html">cnic_redirect_entry</a> cnic_redir;
<a name="l02442"></a>02442 
<a name="l02443"></a>02443         csk = &amp;cp-&gt;csk_tbl[i];
<a name="l02444"></a>02444         csk_hold(csk);
<a name="l02445"></a>02445         <span class="keywordflow">if</span> (cnic_in_use(csk) &amp;&amp; csk-&gt;dst == old) {
<a name="l02446"></a>02446             found = 1;
<a name="l02447"></a>02447             dst_hold(<span class="keyword">new</span>);
<a name="l02448"></a>02448             dst_hold(old);
<a name="l02449"></a>02449 
<a name="l02450"></a>02450             cnic_redir.old_dst = old;
<a name="l02451"></a>02451             cnic_redir.new_dst = <span class="keyword">new</span>;
<a name="l02452"></a>02452             cnic_queue_work(cp, WORK_TYPE_REDIRECT, &amp;cnic_redir);
<a name="l02453"></a>02453             tasklet_schedule(&amp;cp-&gt;cnic_task);
<a name="l02454"></a>02454         }
<a name="l02455"></a>02455         csk_put(csk);
<a name="l02456"></a>02456     }
<a name="l02457"></a>02457 }
<a name="l02458"></a>02458 
<a name="l02459"></a>02459 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_update_neigh(<span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a> *cp, <span class="keyword">struct</span> neighbour *neigh)
<a name="l02460"></a>02460 {
<a name="l02461"></a>02461     <span class="keywordtype">int</span> i, found = 0;
<a name="l02462"></a>02462 
<a name="l02463"></a>02463     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CM_SK_TBL_SZ &amp;&amp; !found; i++) {
<a name="l02464"></a>02464         <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk;
<a name="l02465"></a>02465 
<a name="l02466"></a>02466         csk = &amp;cp-&gt;csk_tbl[i];
<a name="l02467"></a>02467         csk_hold(csk);
<a name="l02468"></a>02468         <span class="keywordflow">if</span> (cnic_in_use(csk) &amp;&amp; csk-&gt;dst) {
<a name="l02469"></a>02469             <span class="keywordflow">if</span> (csk-&gt;dst-&gt;neighbour == neigh) {
<a name="l02470"></a>02470                 found = 1;
<a name="l02471"></a>02471                 neigh_hold(neigh);
<a name="l02472"></a>02472 
<a name="l02473"></a>02473                 cnic_queue_work(cp, WORK_TYPE_NEIGH_UPDATE,
<a name="l02474"></a>02474                         &amp;neigh);
<a name="l02475"></a>02475                 tasklet_schedule(&amp;cp-&gt;cnic_task);
<a name="l02476"></a>02476             }
<a name="l02477"></a>02477         }
<a name="l02478"></a>02478         csk_put(csk);
<a name="l02479"></a>02479     }
<a name="l02480"></a>02480 }
<a name="l02481"></a>02481 
<a name="l02482"></a>02482 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_net_callback(<span class="keyword">struct</span> notifier_block *<span class="keyword">this</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l02483"></a>02483     <span class="keywordtype">void</span> *ptr)
<a name="l02484"></a>02484 {
<a name="l02485"></a>02485     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = container_of(<span class="keyword">this</span>, <span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a>, cm_nb);
<a name="l02486"></a>02486 
<a name="l02487"></a>02487     <span class="keywordflow">if</span> (event == NETEVENT_NEIGH_UPDATE) {
<a name="l02488"></a>02488         <span class="keyword">struct </span>neighbour *neigh = ptr;
<a name="l02489"></a>02489 
<a name="l02490"></a>02490         cnic_update_neigh(cp, neigh);
<a name="l02491"></a>02491 
<a name="l02492"></a>02492     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event == NETEVENT_REDIRECT) {
<a name="l02493"></a>02493         <span class="keyword">struct </span>netevent_redirect *netevent = ptr;
<a name="l02494"></a>02494         <span class="keyword">struct </span>dst_entry *old_dst = netevent-&gt;old;
<a name="l02495"></a>02495         <span class="keyword">struct </span>dst_entry *new_dst = netevent-&gt;new;
<a name="l02496"></a>02496 
<a name="l02497"></a>02497         cnic_redirect(cp, new_dst, old_dst);
<a name="l02498"></a>02498     }
<a name="l02499"></a>02499     <span class="keywordflow">return</span> 0;
<a name="l02500"></a>02500 }
<a name="l02501"></a>02501 <span class="preprocessor">#endif</span>
<a name="l02502"></a>02502 <span class="preprocessor"></span>
<a name="l02503"></a>02503 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_conn_req(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02504"></a>02504 {
<a name="l02505"></a>02505     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l02506"></a>02506     <span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req1.html">l4_kwq_connect_req1</a> *l4kwqe1;
<a name="l02507"></a>02507     <span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req2.html">l4_kwq_connect_req2</a> *l4kwqe2;
<a name="l02508"></a>02508     <span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req3.html">l4_kwq_connect_req3</a> *l4kwqe3;
<a name="l02509"></a>02509     <span class="keyword">struct </span>kwqe *wqes[3];
<a name="l02510"></a>02510     u8 tcp_flags = 0;
<a name="l02511"></a>02511     <span class="keywordtype">int</span> num_wqes = 2;
<a name="l02512"></a>02512 
<a name="l02513"></a>02513     l4kwqe1 = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req1.html">l4_kwq_connect_req1</a> *) &amp;csk-&gt;kwqe1;
<a name="l02514"></a>02514     l4kwqe2 = (<span class="keyword">struct</span> <a class="code" href="structl4__kwq__connect__req2.html">l4_kwq_connect_req2</a> *) &amp;csk-&gt;kwqe2;
<a name="l02515"></a>02515     l4kwqe3 = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__connect__req3.html">l4_kwq_connect_req3</a> *) &amp;csk-&gt;kwqe3;
<a name="l02516"></a>02516     memset(l4kwqe1, 0, <span class="keyword">sizeof</span>(*l4kwqe1));
<a name="l02517"></a>02517     memset(l4kwqe2, 0, <span class="keyword">sizeof</span>(*l4kwqe2));
<a name="l02518"></a>02518     memset(l4kwqe3, 0, <span class="keyword">sizeof</span>(*l4kwqe3));
<a name="l02519"></a>02519 
<a name="l02520"></a>02520     l4kwqe3-&gt;op_code = L4_KWQE_OPCODE_VALUE_CONNECT3;
<a name="l02521"></a>02521     l4kwqe3-&gt;flags =
<a name="l02522"></a>02522         L4_LAYER_CODE &lt;&lt; L4_KWQ_CONNECT_REQ3_LAYER_CODE_SHIFT;
<a name="l02523"></a>02523     l4kwqe3-&gt;ka_timeout = csk-&gt;ka_timeout;
<a name="l02524"></a>02524     l4kwqe3-&gt;ka_interval = csk-&gt;ka_interval;
<a name="l02525"></a>02525     l4kwqe3-&gt;ka_max_probe_count = csk-&gt;ka_max_probe_count;
<a name="l02526"></a>02526     l4kwqe3-&gt;tos = csk-&gt;tos;
<a name="l02527"></a>02527     l4kwqe3-&gt;ttl = csk-&gt;ttl;
<a name="l02528"></a>02528     l4kwqe3-&gt;snd_seq_scale = csk-&gt;snd_seq_scale;
<a name="l02529"></a>02529     l4kwqe3-&gt;pmtu = csk-&gt;pmtu;
<a name="l02530"></a>02530     l4kwqe3-&gt;rcv_buf = csk-&gt;rcv_buf;
<a name="l02531"></a>02531     l4kwqe3-&gt;snd_buf = csk-&gt;snd_buf;
<a name="l02532"></a>02532     l4kwqe3-&gt;seed = csk-&gt;seed;
<a name="l02533"></a>02533 
<a name="l02534"></a>02534     wqes[0] = (<span class="keyword">struct </span>kwqe *) l4kwqe1;
<a name="l02535"></a>02535     <span class="keywordflow">if</span> (test_bit(SK_F_IPV6, &amp;csk-&gt;flags)) {
<a name="l02536"></a>02536         wqes[1] = (<span class="keyword">struct </span>kwqe *) l4kwqe2;
<a name="l02537"></a>02537         wqes[2] = (<span class="keyword">struct </span>kwqe *) l4kwqe3;
<a name="l02538"></a>02538         num_wqes = 3;
<a name="l02539"></a>02539 
<a name="l02540"></a>02540         l4kwqe1-&gt;conn_flags = L4_KWQ_CONNECT_REQ1_IP_V6;
<a name="l02541"></a>02541         l4kwqe2-&gt;op_code = L4_KWQE_OPCODE_VALUE_CONNECT2;
<a name="l02542"></a>02542         l4kwqe2-&gt;flags =
<a name="l02543"></a>02543             L4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT |
<a name="l02544"></a>02544             L4_LAYER_CODE &lt;&lt; L4_KWQ_CONNECT_REQ2_LAYER_CODE_SHIFT;
<a name="l02545"></a>02545         l4kwqe2-&gt;src_ip_v6_2 = be32_to_cpu(csk-&gt;src_ip[1]);
<a name="l02546"></a>02546         l4kwqe2-&gt;src_ip_v6_3 = be32_to_cpu(csk-&gt;src_ip[2]);
<a name="l02547"></a>02547         l4kwqe2-&gt;src_ip_v6_4 = be32_to_cpu(csk-&gt;src_ip[3]);
<a name="l02548"></a>02548         l4kwqe2-&gt;dst_ip_v6_2 = be32_to_cpu(csk-&gt;dst_ip[1]);
<a name="l02549"></a>02549         l4kwqe2-&gt;dst_ip_v6_3 = be32_to_cpu(csk-&gt;dst_ip[2]);
<a name="l02550"></a>02550         l4kwqe2-&gt;dst_ip_v6_4 = be32_to_cpu(csk-&gt;dst_ip[3]);
<a name="l02551"></a>02551         l4kwqe3-&gt;mss = l4kwqe3-&gt;pmtu - <span class="keyword">sizeof</span>(<span class="keyword">struct </span>ipv6hdr) -
<a name="l02552"></a>02552                    sizeof(struct <a class="code" href="structtcphdr.html">tcphdr</a>);
<a name="l02553"></a>02553     } <span class="keywordflow">else</span> {
<a name="l02554"></a>02554         wqes[1] = (<span class="keyword">struct </span>kwqe *) l4kwqe3;
<a name="l02555"></a>02555         l4kwqe3-&gt;mss = l4kwqe3-&gt;pmtu - <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a>) -
<a name="l02556"></a>02556                    sizeof(struct <a class="code" href="structtcphdr.html">tcphdr</a>);
<a name="l02557"></a>02557     }
<a name="l02558"></a>02558 
<a name="l02559"></a>02559     l4kwqe1-&gt;op_code = L4_KWQE_OPCODE_VALUE_CONNECT1;
<a name="l02560"></a>02560     l4kwqe1-&gt;flags =
<a name="l02561"></a>02561         (L4_LAYER_CODE &lt;&lt; L4_KWQ_CONNECT_REQ1_LAYER_CODE_SHIFT) |
<a name="l02562"></a>02562          L4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT;
<a name="l02563"></a>02563     l4kwqe1-&gt;cid = csk-&gt;cid;
<a name="l02564"></a>02564     l4kwqe1-&gt;pg_cid = csk-&gt;pg_cid;
<a name="l02565"></a>02565     l4kwqe1-&gt;src_ip = be32_to_cpu(csk-&gt;src_ip[0]);
<a name="l02566"></a>02566     l4kwqe1-&gt;dst_ip = be32_to_cpu(csk-&gt;dst_ip[0]);
<a name="l02567"></a>02567     l4kwqe1-&gt;src_port = be16_to_cpu(csk-&gt;src_port);
<a name="l02568"></a>02568     l4kwqe1-&gt;dst_port = be16_to_cpu(csk-&gt;dst_port);
<a name="l02569"></a>02569     <span class="keywordflow">if</span> (csk-&gt;tcp_flags &amp; SK_TCP_NO_DELAY_ACK)
<a name="l02570"></a>02570         tcp_flags |= L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK;
<a name="l02571"></a>02571     <span class="keywordflow">if</span> (csk-&gt;tcp_flags &amp; SK_TCP_KEEP_ALIVE)
<a name="l02572"></a>02572         tcp_flags |= L4_KWQ_CONNECT_REQ1_KEEP_ALIVE;
<a name="l02573"></a>02573     <span class="keywordflow">if</span> (csk-&gt;tcp_flags &amp; SK_TCP_NAGLE)
<a name="l02574"></a>02574         tcp_flags |= L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE;
<a name="l02575"></a>02575     <span class="keywordflow">if</span> (csk-&gt;tcp_flags &amp; SK_TCP_TIMESTAMP)
<a name="l02576"></a>02576         tcp_flags |= L4_KWQ_CONNECT_REQ1_TIME_STAMP;
<a name="l02577"></a>02577     <span class="keywordflow">if</span> (csk-&gt;tcp_flags &amp; SK_TCP_SACK)
<a name="l02578"></a>02578         tcp_flags |= L4_KWQ_CONNECT_REQ1_SACK;
<a name="l02579"></a>02579     <span class="keywordflow">if</span> (csk-&gt;tcp_flags &amp; SK_TCP_SEG_SCALING)
<a name="l02580"></a>02580         tcp_flags |= L4_KWQ_CONNECT_REQ1_SEG_SCALING;
<a name="l02581"></a>02581     
<a name="l02582"></a>02582     l4kwqe1-&gt;tcp_flags = tcp_flags;
<a name="l02583"></a>02583 
<a name="l02584"></a>02584     <span class="keywordflow">return</span> (dev-&gt;submit_kwqes(dev, wqes, num_wqes));
<a name="l02585"></a>02585 }
<a name="l02586"></a>02586 
<a name="l02587"></a>02587 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_close_req(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02588"></a>02588 {
<a name="l02589"></a>02589     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l02590"></a>02590     <span class="keyword">struct </span><a class="code" href="structl4__kwq__close__req.html">l4_kwq_close_req</a> *l4kwqe;
<a name="l02591"></a>02591     <span class="keyword">struct </span>kwqe *wqes[1];
<a name="l02592"></a>02592 
<a name="l02593"></a>02593     l4kwqe = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__close__req.html">l4_kwq_close_req</a> *) &amp;csk-&gt;kwqe2;
<a name="l02594"></a>02594     memset(l4kwqe, 0, <span class="keyword">sizeof</span>(*l4kwqe));
<a name="l02595"></a>02595     wqes[0] = (<span class="keyword">struct </span>kwqe *) l4kwqe;
<a name="l02596"></a>02596 
<a name="l02597"></a>02597     l4kwqe-&gt;op_code = L4_KWQE_OPCODE_VALUE_CLOSE;
<a name="l02598"></a>02598     l4kwqe-&gt;flags = L4_LAYER_CODE &lt;&lt; L4_KWQ_CLOSE_REQ_LAYER_CODE_SHIFT;
<a name="l02599"></a>02599     l4kwqe-&gt;cid = csk-&gt;cid;
<a name="l02600"></a>02600 
<a name="l02601"></a>02601     <span class="keywordflow">return</span> (dev-&gt;submit_kwqes(dev, wqes, 1));
<a name="l02602"></a>02602 }
<a name="l02603"></a>02603 
<a name="l02604"></a>02604 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_abort_req(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02605"></a>02605 {
<a name="l02606"></a>02606     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l02607"></a>02607     <span class="keyword">struct </span><a class="code" href="structl4__kwq__reset__req.html">l4_kwq_reset_req</a> *l4kwqe;
<a name="l02608"></a>02608     <span class="keyword">struct </span>kwqe *wqes[1];
<a name="l02609"></a>02609 
<a name="l02610"></a>02610     l4kwqe = (<span class="keyword">struct </span><a class="code" href="structl4__kwq__reset__req.html">l4_kwq_reset_req</a> *) &amp;csk-&gt;kwqe2;
<a name="l02611"></a>02611     memset(l4kwqe, 0, <span class="keyword">sizeof</span>(*l4kwqe));
<a name="l02612"></a>02612     wqes[0] = (<span class="keyword">struct </span>kwqe *) l4kwqe;
<a name="l02613"></a>02613 
<a name="l02614"></a>02614     l4kwqe-&gt;op_code = L4_KWQE_OPCODE_VALUE_RESET;
<a name="l02615"></a>02615     l4kwqe-&gt;flags = L4_LAYER_CODE &lt;&lt; L4_KWQ_RESET_REQ_LAYER_CODE_SHIFT;
<a name="l02616"></a>02616     l4kwqe-&gt;cid = csk-&gt;cid;
<a name="l02617"></a>02617 
<a name="l02618"></a>02618     <span class="keywordflow">return</span> (dev-&gt;submit_kwqes(dev, wqes, 1));
<a name="l02619"></a>02619 }
<a name="l02620"></a>02620 
<a name="l02621"></a>02621 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_create(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keywordtype">int</span> ulp_type, u32 cid,
<a name="l02622"></a>02622               u32 l5_cid, <span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> **csk, <span class="keywordtype">void</span> *context)
<a name="l02623"></a>02623 {
<a name="l02624"></a>02624     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02625"></a>02625     <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk1;
<a name="l02626"></a>02626 
<a name="l02627"></a>02627     <span class="keywordflow">if</span> (l5_cid &gt;= MAX_CM_SK_TBL_SZ)
<a name="l02628"></a>02628         <span class="keywordflow">return</span> -EINVAL;
<a name="l02629"></a>02629         
<a name="l02630"></a>02630     csk1 = &amp;cp-&gt;csk_tbl[l5_cid];
<a name="l02631"></a>02631     <span class="keywordflow">if</span> (atomic_read(&amp;csk1-&gt;ref_count))
<a name="l02632"></a>02632         <span class="keywordflow">return</span> -EAGAIN;
<a name="l02633"></a>02633 
<a name="l02634"></a>02634     <span class="keywordflow">if</span> (test_and_set_bit(SK_F_INUSE, &amp;csk1-&gt;flags))
<a name="l02635"></a>02635         <span class="keywordflow">return</span> -EBUSY;
<a name="l02636"></a>02636 
<a name="l02637"></a>02637     csk1-&gt;dev = dev;
<a name="l02638"></a>02638     csk1-&gt;cid = cid;
<a name="l02639"></a>02639     csk1-&gt;l5_cid = l5_cid;
<a name="l02640"></a>02640     csk1-&gt;ulp_type = ulp_type;
<a name="l02641"></a>02641     csk1-&gt;context = context;
<a name="l02642"></a>02642 
<a name="l02643"></a>02643     csk1-&gt;ka_timeout = DEF_KA_TIMEOUT;
<a name="l02644"></a>02644     csk1-&gt;ka_interval = DEF_KA_INTERVAL;
<a name="l02645"></a>02645     csk1-&gt;ka_max_probe_count = DEF_KA_MAX_PROBE_COUNT;
<a name="l02646"></a>02646     csk1-&gt;tos = DEF_TOS;
<a name="l02647"></a>02647     csk1-&gt;ttl = DEF_TTL;
<a name="l02648"></a>02648     csk1-&gt;snd_seq_scale = DEF_SND_SEQ_SCALE;
<a name="l02649"></a>02649     csk1-&gt;rcv_buf = DEF_RCV_BUF;
<a name="l02650"></a>02650     csk1-&gt;snd_buf = DEF_SND_BUF;
<a name="l02651"></a>02651     csk1-&gt;seed = DEF_SEED;
<a name="l02652"></a>02652 
<a name="l02653"></a>02653     *csk = csk1;
<a name="l02654"></a>02654 
<a name="l02655"></a>02655     <span class="keywordflow">return</span> 0;
<a name="l02656"></a>02656 }
<a name="l02657"></a>02657 
<a name="l02658"></a>02658 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_cleanup(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02659"></a>02659 {
<a name="l02660"></a>02660 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l02661"></a>02661 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (csk-&gt;dst) {
<a name="l02662"></a>02662         <span class="keywordflow">if</span> (csk-&gt;dst-&gt;neighbour)
<a name="l02663"></a>02663             neigh_release(csk-&gt;dst-&gt;neighbour);
<a name="l02664"></a>02664         dst_release(csk-&gt;dst);
<a name="l02665"></a>02665         csk-&gt;dst = NULL;
<a name="l02666"></a>02666     }
<a name="l02667"></a>02667     csk-&gt;src_port = 0;
<a name="l02668"></a>02668 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02669"></a>02669     <span class="keywordflow">if</span> (csk-&gt;src_port) {
<a name="l02670"></a>02670         <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l02671"></a>02671         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02672"></a>02672 
<a name="l02673"></a>02673         cnic_free_id(&amp;cp-&gt;csk_port_tbl, ntohs(csk-&gt;src_port));
<a name="l02674"></a>02674         csk-&gt;src_port = 0;
<a name="l02675"></a>02675     }
<a name="l02676"></a>02676 }
<a name="l02677"></a>02677 
<a name="l02678"></a>02678 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_close_conn(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02679"></a>02679 {
<a name="l02680"></a>02680     <span class="keywordflow">if</span> (test_bit(SK_F_PG_OFFLD_COMPLETE, &amp;csk-&gt;flags)) {
<a name="l02681"></a>02681         cnic_cm_upload_pg(csk);
<a name="l02682"></a>02682         clear_bit(SK_F_PG_OFFLD_COMPLETE, &amp;csk-&gt;flags);
<a name="l02683"></a>02683     }
<a name="l02684"></a>02684     cnic_cm_cleanup(csk);
<a name="l02685"></a>02685     smp_mb__before_clear_bit();
<a name="l02686"></a>02686     clear_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags);
<a name="l02687"></a>02687 }
<a name="l02688"></a>02688 
<a name="l02689"></a>02689 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_destroy(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02690"></a>02690 {
<a name="l02691"></a>02691     <span class="keywordflow">if</span> (!cnic_in_use(csk))
<a name="l02692"></a>02692         <span class="keywordflow">return</span> -EINVAL;
<a name="l02693"></a>02693 
<a name="l02694"></a>02694     csk_hold(csk);
<a name="l02695"></a>02695     clear_bit(SK_F_INUSE, &amp;csk-&gt;flags);
<a name="l02696"></a>02696     smp_mb__after_clear_bit();
<a name="l02697"></a>02697     <span class="keywordflow">while</span> (atomic_read(&amp;csk-&gt;ref_count) != 1)
<a name="l02698"></a>02698         msleep(1);
<a name="l02699"></a>02699     cnic_cm_cleanup(csk);
<a name="l02700"></a>02700 
<a name="l02701"></a>02701     csk-&gt;flags = 0;
<a name="l02702"></a>02702     csk_put(csk);
<a name="l02703"></a>02703     <span class="keywordflow">return</span> 0;
<a name="l02704"></a>02704 }
<a name="l02705"></a>02705 
<a name="l02706"></a>02706 <span class="keyword">static</span> <span class="keyword">inline</span> u16 cnic_get_vlan(<span class="keyword">struct</span> net_device *dev,
<a name="l02707"></a>02707                 <span class="keyword">struct</span> net_device **vlan_dev)
<a name="l02708"></a>02708 {
<a name="l02709"></a>02709 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l02710"></a>02710 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (dev-&gt;priv_flags &amp; IFF_802_1Q_VLAN) {
<a name="l02711"></a>02711 <span class="preprocessor">#ifdef VLAN_DEV_INFO</span>
<a name="l02712"></a>02712 <span class="preprocessor"></span>        *vlan_dev = VLAN_DEV_INFO(dev)-&gt;real_dev;
<a name="l02713"></a>02713         <span class="keywordflow">return</span> VLAN_DEV_INFO(dev)-&gt;vlan_id;
<a name="l02714"></a>02714 <span class="preprocessor">#else</span>
<a name="l02715"></a>02715 <span class="preprocessor"></span><span class="preprocessor">#ifdef VLAN_TX_COOKIE_MAGIC</span>
<a name="l02716"></a>02716 <span class="preprocessor"></span>        *vlan_dev = vlan_dev_info(dev)-&gt;real_dev;
<a name="l02717"></a>02717         <span class="keywordflow">return</span> vlan_dev_info(dev)-&gt;vlan_id;
<a name="l02718"></a>02718 <span class="preprocessor">#else</span>
<a name="l02719"></a>02719 <span class="preprocessor"></span>        *vlan_dev = vlan_dev_real_dev(dev);
<a name="l02720"></a>02720         <span class="keywordflow">return</span> vlan_dev_vlan_id(dev);
<a name="l02721"></a>02721 <span class="preprocessor">#endif</span>
<a name="l02722"></a>02722 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02723"></a>02723 <span class="preprocessor"></span>    }
<a name="l02724"></a>02724 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02725"></a>02725     *vlan_dev = dev;
<a name="l02726"></a>02726     <span class="keywordflow">return</span> 0;
<a name="l02727"></a>02727 }
<a name="l02728"></a>02728 
<a name="l02729"></a>02729 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l02730"></a>02730 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> cnic_get_v4_route(<span class="keyword">struct</span> sockaddr_in *dst_addr,
<a name="l02731"></a>02731                  <span class="keyword">struct</span> sockaddr_in *src_addr,
<a name="l02732"></a>02732                  <span class="keyword">struct</span> dst_entry **dst)
<a name="l02733"></a>02733 {
<a name="l02734"></a>02734     <span class="keyword">struct </span>flowi fl;
<a name="l02735"></a>02735     <span class="keywordtype">int</span> err;
<a name="l02736"></a>02736     <span class="keyword">struct </span>rtable *rt;
<a name="l02737"></a>02737 
<a name="l02738"></a>02738     memset(&amp;fl, 0, <span class="keyword">sizeof</span>(fl));
<a name="l02739"></a>02739     fl.nl_u.ip4_u.daddr = dst_addr-&gt;sin_addr.s_addr;
<a name="l02740"></a>02740     <span class="keywordflow">if</span> (src_addr)
<a name="l02741"></a>02741         fl.nl_u.ip4_u.saddr = src_addr-&gt;sin_addr.s_addr;
<a name="l02742"></a>02742 
<a name="l02743"></a>02743 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= 0x020619)</span>
<a name="l02744"></a>02744 <span class="preprocessor"></span>    err = ip_route_output_key(&amp;init_net, &amp;rt, &amp;fl);
<a name="l02745"></a>02745 <span class="preprocessor">#else</span>
<a name="l02746"></a>02746 <span class="preprocessor"></span>    err = ip_route_output_key(&amp;rt, &amp;fl);
<a name="l02747"></a>02747 <span class="preprocessor">#endif</span>
<a name="l02748"></a>02748 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!err)
<a name="l02749"></a>02749         *dst = &amp;rt-&gt;u.dst;
<a name="l02750"></a>02750     <span class="keywordflow">return</span> err;
<a name="l02751"></a>02751 }
<a name="l02752"></a>02752 
<a name="l02753"></a>02753 <span class="preprocessor">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
<a name="l02754"></a>02754 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span>dst_entry *cnic_ip6_rte_output(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> flowi *fl)
<a name="l02755"></a>02755 {
<a name="l02756"></a>02756 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= 0x02061a)</span>
<a name="l02757"></a>02757 <span class="preprocessor"></span>    <span class="keyword">struct </span>dst_entry *(*fn)(<span class="keyword">struct </span>net *, <span class="keyword">struct </span>sock *, <span class="keyword">struct </span>flowi *);
<a name="l02758"></a>02758 <span class="preprocessor">#else</span>
<a name="l02759"></a>02759 <span class="preprocessor"></span>    <span class="keyword">struct </span>dst_entry *(*fn)(<span class="keyword">struct </span>sock *, <span class="keyword">struct </span>flowi *);
<a name="l02760"></a>02760 <span class="preprocessor">#endif</span>
<a name="l02761"></a>02761 <span class="preprocessor"></span>    <span class="keyword">struct </span>dst_entry *dst = NULL;
<a name="l02762"></a>02762 
<a name="l02763"></a>02763     fn = symbol_get(ip6_route_output);
<a name="l02764"></a>02764     <span class="keywordflow">if</span> (fn) {
<a name="l02765"></a>02765 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= 0x02061a)</span>
<a name="l02766"></a>02766 <span class="preprocessor"></span>        dst = (*fn)(&amp;init_net, sk, fl);
<a name="l02767"></a>02767 <span class="preprocessor">#else</span>
<a name="l02768"></a>02768 <span class="preprocessor"></span>        dst = (*fn)(sk, fl);
<a name="l02769"></a>02769 <span class="preprocessor">#endif</span>
<a name="l02770"></a>02770 <span class="preprocessor"></span>        symbol_put(ip6_route_output);
<a name="l02771"></a>02771     }
<a name="l02772"></a>02772     <span class="keywordflow">return</span> dst;
<a name="l02773"></a>02773 }
<a name="l02774"></a>02774 
<a name="l02775"></a>02775 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_ipv6_addr_type(<span class="keyword">const</span> <span class="keyword">struct</span> in6_addr *addr)
<a name="l02776"></a>02776 {
<a name="l02777"></a>02777     int (*fn)(<span class="keyword">const</span> <span class="keyword">struct </span>in6_addr *addr);
<a name="l02778"></a>02778     <span class="keywordtype">int</span> type = 0;
<a name="l02779"></a>02779 
<a name="l02780"></a>02780     fn = symbol_get(__ipv6_addr_type);
<a name="l02781"></a>02781     <span class="keywordflow">if</span> (fn) {
<a name="l02782"></a>02782         type = fn(addr) &amp; 0xffff;
<a name="l02783"></a>02783         symbol_put(__ipv6_addr_type);
<a name="l02784"></a>02784     }
<a name="l02785"></a>02785     <span class="keywordflow">return</span> type;
<a name="l02786"></a>02786 }
<a name="l02787"></a>02787 
<a name="l02788"></a>02788 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_ipv6_get_saddr(<span class="keyword">struct</span> dst_entry *dst,
<a name="l02789"></a>02789                    <span class="keyword">const</span> <span class="keyword">struct</span> in6_addr *daddr,
<a name="l02790"></a>02790                    <span class="keyword">struct</span> in6_addr *saddr)
<a name="l02791"></a>02791 {
<a name="l02792"></a>02792     <span class="keywordtype">int</span> rc = -ENOENT;
<a name="l02793"></a>02793 
<a name="l02794"></a>02794 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= 0x02061b)</span>
<a name="l02795"></a>02795 <span class="preprocessor"></span>    int (*fn)(<span class="keyword">struct </span>net *, <span class="keyword">struct </span>net_device *,
<a name="l02796"></a>02796           <span class="keyword">const</span> <span class="keyword">struct </span>in6_addr *daddr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> prefs,
<a name="l02797"></a>02797           <span class="keyword">struct </span>in6_addr *saddr);
<a name="l02798"></a>02798 
<a name="l02799"></a>02799     fn = symbol_get(ipv6_dev_get_saddr);
<a name="l02800"></a>02800     <span class="keywordflow">if</span> (fn) {
<a name="l02801"></a>02801         rc = fn(&amp;init_net, dst-&gt;dev, daddr, 0, saddr);
<a name="l02802"></a>02802         symbol_put(ipv6_dev_get_saddr);
<a name="l02803"></a>02803     }
<a name="l02804"></a>02804 
<a name="l02805"></a>02805 <span class="preprocessor">#elif (LINUX_VERSION_CODE &gt;= 0x02061a)</span>
<a name="l02806"></a>02806 <span class="preprocessor"></span>    int (*fn)(<span class="keyword">struct </span>net_device *,
<a name="l02807"></a>02807           <span class="keyword">const</span> <span class="keyword">struct </span>in6_addr *daddr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> prefs,
<a name="l02808"></a>02808           <span class="keyword">struct </span>in6_addr *saddr);
<a name="l02809"></a>02809 
<a name="l02810"></a>02810     fn = symbol_get(ipv6_dev_get_saddr);
<a name="l02811"></a>02811     <span class="keywordflow">if</span> (fn) {
<a name="l02812"></a>02812         rc = fn(dst-&gt;dev, daddr, 0, saddr);
<a name="l02813"></a>02813         symbol_put(ipv6_dev_get_saddr);
<a name="l02814"></a>02814     }
<a name="l02815"></a>02815 
<a name="l02816"></a>02816 <span class="preprocessor">#else</span>
<a name="l02817"></a>02817 <span class="preprocessor"></span>    int (*fn)(<span class="keyword">struct </span>dst_entry *,
<a name="l02818"></a>02818           <span class="keyword">struct </span>in6_addr *daddr, <span class="keyword">struct </span>in6_addr *saddr);
<a name="l02819"></a>02819 
<a name="l02820"></a>02820     fn = symbol_get(ipv6_get_saddr);
<a name="l02821"></a>02821     <span class="keywordflow">if</span> (fn) {
<a name="l02822"></a>02822         rc = fn(dst, (<span class="keyword">struct</span> in6_addr *) daddr, saddr);
<a name="l02823"></a>02823         symbol_put(ipv6_get_saddr);
<a name="l02824"></a>02824     }
<a name="l02825"></a>02825 <span class="preprocessor">#endif</span>
<a name="l02826"></a>02826 <span class="preprocessor"></span>    <span class="keywordflow">return</span> rc;
<a name="l02827"></a>02827 }
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 <span class="preprocessor">#endif</span>
<a name="l02830"></a>02830 <span class="preprocessor"></span>
<a name="l02831"></a>02831 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_get_v6_route(<span class="keyword">struct</span> sockaddr_in6 *dst_addr,
<a name="l02832"></a>02832                  <span class="keyword">struct</span> sockaddr_in6 *src_addr,
<a name="l02833"></a>02833                  <span class="keyword">struct</span> dst_entry **dst)
<a name="l02834"></a>02834 {
<a name="l02835"></a>02835 <span class="preprocessor">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
<a name="l02836"></a>02836 <span class="preprocessor"></span>    <span class="keyword">struct </span>flowi fl;
<a name="l02837"></a>02837 
<a name="l02838"></a>02838     memset(&amp;fl, 0, <span class="keyword">sizeof</span>(fl));
<a name="l02839"></a>02839     ipv6_addr_copy(&amp;fl.fl6_dst, &amp;dst_addr-&gt;sin6_addr);
<a name="l02840"></a>02840     <span class="keywordflow">if</span> (cnic_ipv6_addr_type(&amp;fl.fl6_dst) &amp; IPV6_ADDR_LINKLOCAL)
<a name="l02841"></a>02841         fl.oif = dst_addr-&gt;sin6_scope_id;
<a name="l02842"></a>02842 
<a name="l02843"></a>02843     <span class="keywordflow">if</span> (src_addr)
<a name="l02844"></a>02844         ipv6_addr_copy(&amp;fl.fl6_src, &amp;src_addr-&gt;sin6_addr);
<a name="l02845"></a>02845 
<a name="l02846"></a>02846     *dst = cnic_ip6_rte_output(NULL, &amp;fl);
<a name="l02847"></a>02847     <span class="keywordflow">if</span> (*dst)
<a name="l02848"></a>02848         <span class="keywordflow">return</span> 0;
<a name="l02849"></a>02849 <span class="preprocessor">#endif</span>
<a name="l02850"></a>02850 <span class="preprocessor"></span>
<a name="l02851"></a>02851     <span class="keywordflow">return</span> -ENETUNREACH;
<a name="l02852"></a>02852 }
<a name="l02853"></a>02853 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02854"></a>02854 
<a name="l02855"></a>02855 <span class="preprocessor">#if defined  (__VMKLNX__)</span>
<a name="l02856"></a>02856 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cnic_cm_select_dev(vmk_IscsiNetHandle iscsiNetHandle,
<a name="l02857"></a>02857                        <span class="keyword">struct</span> sockaddr_in *dst_addr,
<a name="l02858"></a>02858                        <span class="keywordtype">int</span> ulp_type)
<a name="l02859"></a>02859 {
<a name="l02860"></a>02860     <span class="keywordtype">char</span> devName[IFNAMSIZ];
<a name="l02861"></a>02861     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev;
<a name="l02862"></a>02862     <span class="keywordtype">int</span> found = 0;
<a name="l02863"></a>02863     VMK_ReturnStatus status;
<a name="l02864"></a>02864 
<a name="l02865"></a>02865     status = vmk_IscsiTransportGetUplink(iscsiNetHandle, devName);
<a name="l02866"></a>02866     <span class="keywordflow">if</span> (status != VMK_OK) 
<a name="l02867"></a>02867         <span class="keywordflow">return</span> NULL;
<a name="l02868"></a>02868 
<a name="l02869"></a>02869     list_for_each_entry(dev, &amp;cnic_dev_list, list) {
<a name="l02870"></a>02870         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l02871"></a>02871 
<a name="l02872"></a>02872         <span class="keywordflow">if</span> (dev-&gt;netdev &amp;&amp; test_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags)) {
<a name="l02873"></a>02873             <span class="keywordflow">if</span> (!strcmp(dev-&gt;netdev-&gt;name, devName)) {
<a name="l02874"></a>02874                 found = 1;
<a name="l02875"></a>02875                             <span class="comment">/* Retrieve the source MAC */</span>
<a name="l02876"></a>02876                             <span class="keywordflow">if</span> ((status = vmk_IscsiTransportGetSrcMAC(
<a name="l02877"></a>02877                                         iscsiNetHandle,
<a name="l02878"></a>02878                     cp-&gt;srcMACAddr)) != VMK_OK) {
<a name="l02879"></a>02879                     printk(KERN_ALERT <span class="stringliteral">&quot;%s Get SRC MAC failed %d\n&quot;</span>,
<a name="l02880"></a>02880                         dev-&gt;netdev-&gt;name, status);
<a name="l02881"></a>02881                     found = 0;
<a name="l02882"></a>02882                     <span class="keywordflow">break</span>;
<a name="l02883"></a>02883                 }
<a name="l02884"></a>02884                 <span class="comment">/* Next hop (arp) resolve */</span>
<a name="l02885"></a>02885                 <span class="keywordflow">if</span> ((status = vmk_IscsiTransportGetNextHopMAC(
<a name="l02886"></a>02886                     iscsiNetHandle, 
<a name="l02887"></a>02887                     cp-&gt;nextHopMACAddr)) != VMK_OK) {
<a name="l02888"></a>02888                     printk(KERN_ALERT <span class="stringliteral">&quot;%s Get next hop MAC failed %d\n&quot;</span>,
<a name="l02889"></a>02889                         dev-&gt;netdev-&gt;name, status);
<a name="l02890"></a>02890                     found = 0;
<a name="l02891"></a>02891                     <span class="keywordflow">break</span>;
<a name="l02892"></a>02892                 }
<a name="l02893"></a>02893                 <span class="comment">/* Retrieve the source IP Address */</span>
<a name="l02894"></a>02894                 <span class="keywordflow">if</span> ((status = vmk_IscsiTransportGetSrcIP(
<a name="l02895"></a>02895                     iscsiNetHandle,
<a name="l02896"></a>02896                     &amp;cp-&gt;srcFamily, 
<a name="l02897"></a>02897                     cp-&gt;srcIPAddr)) != VMK_OK) {
<a name="l02898"></a>02898                     printk(KERN_ALERT <span class="stringliteral">&quot;%s Get SRC IP failed %d\n&quot;</span>,
<a name="l02899"></a>02899                         dev-&gt;netdev-&gt;name, status);
<a name="l02900"></a>02900                     found = 0;
<a name="l02901"></a>02901                     <span class="keywordflow">break</span>;
<a name="l02902"></a>02902                 }
<a name="l02903"></a>02903                 <span class="comment">/* Path MTU */</span>
<a name="l02904"></a>02904                 <span class="keywordflow">if</span> ((status = vmk_IscsiTransportGetPmtu(
<a name="l02905"></a>02905                     iscsiNetHandle,
<a name="l02906"></a>02906                     &amp;cp-&gt;pmtu)) != VMK_OK) {
<a name="l02907"></a>02907                     printk(KERN_ALERT <span class="stringliteral">&quot;%s Get PMTU failed %d\n&quot;</span>,
<a name="l02908"></a>02908                         dev-&gt;netdev-&gt;name, status);
<a name="l02909"></a>02909                     cp-&gt;pmtu = 1500;
<a name="l02910"></a>02910                 }
<a name="l02911"></a>02911                 <span class="comment">/* VLAN Tag */</span>
<a name="l02912"></a>02912                 <span class="keywordflow">if</span> ((status = vmk_IscsiTransportGetVlan(
<a name="l02913"></a>02913                     iscsiNetHandle,
<a name="l02914"></a>02914                     &amp;cp-&gt;vlan_id)) != VMK_OK) {
<a name="l02915"></a>02915                     printk(KERN_ALERT <span class="stringliteral">&quot;%s Get vlan ID failed %d\n&quot;</span>,
<a name="l02916"></a>02916                         dev-&gt;netdev-&gt;name, status);
<a name="l02917"></a>02917                     cp-&gt;vlan_id = 0;
<a name="l02918"></a>02918                 }
<a name="l02919"></a>02919 
<a name="l02920"></a>02920 
<a name="l02921"></a>02921                 <span class="comment">/* Allocate TCP ports, only once per device */</span>
<a name="l02922"></a>02922                 <span class="keywordflow">if</span> (cp-&gt;csk_port_tbl.table)
<a name="l02923"></a>02923                     <span class="keywordflow">break</span>;
<a name="l02924"></a>02924 
<a name="l02925"></a>02925                 cp-&gt;cnic_local_port_nr = MAX_CM_SK_TBL_SZ;
<a name="l02926"></a>02926                 cp-&gt;cnic_local_port_min = 1;
<a name="l02927"></a>02927                 status = vmk_IscsiTransportGetPortReservation(
<a name="l02928"></a>02928                         iscsiNetHandle,
<a name="l02929"></a>02929                         &amp;cp-&gt;cnic_local_port_nr,
<a name="l02930"></a>02930                         &amp;cp-&gt;cnic_local_port_min);
<a name="l02931"></a>02931                 <span class="keywordflow">if</span> (status == VMK_OK) {
<a name="l02932"></a>02932                     cnic_init_id_tbl(&amp;cp-&gt;csk_port_tbl, 
<a name="l02933"></a>02933                         cp-&gt;cnic_local_port_nr, 
<a name="l02934"></a>02934                         cp-&gt;cnic_local_port_min,
<a name="l02935"></a>02935                         cp-&gt;next_tcp_port);
<a name="l02936"></a>02936                 } <span class="keywordflow">else</span> {
<a name="l02937"></a>02937                     found = 0; 
<a name="l02938"></a>02938                     printk(KERN_ALERT <span class="stringliteral">&quot;%s TCP port alloc failed %d\n&quot;</span>,
<a name="l02939"></a>02939                         dev-&gt;netdev-&gt;name, status);
<a name="l02940"></a>02940                 }
<a name="l02941"></a>02941                 <span class="keywordflow">break</span>;
<a name="l02942"></a>02942             }
<a name="l02943"></a>02943         }
<a name="l02944"></a>02944     }
<a name="l02945"></a>02945 
<a name="l02946"></a>02946     <span class="keywordflow">if</span> (!found)
<a name="l02947"></a>02947         dev = NULL;
<a name="l02948"></a>02948     <span class="keywordflow">return</span> dev;
<a name="l02949"></a>02949 }
<a name="l02950"></a>02950 
<a name="l02951"></a>02951 <span class="preprocessor">#else  </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l02952"></a>02952 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cnic_cm_select_dev(<span class="keyword">struct</span> sockaddr_in *dst_addr,
<a name="l02953"></a>02953                        <span class="keywordtype">int</span> ulp_type)
<a name="l02954"></a>02954 {
<a name="l02955"></a>02955     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = NULL;
<a name="l02956"></a>02956     <span class="keyword">struct </span>dst_entry *dst;
<a name="l02957"></a>02957     <span class="keyword">struct </span>net_device *netdev = NULL;
<a name="l02958"></a>02958     <span class="keywordtype">int</span> err = -ENETUNREACH;
<a name="l02959"></a>02959 
<a name="l02960"></a>02960     <span class="keywordflow">if</span> (dst_addr-&gt;sin_family == AF_INET)
<a name="l02961"></a>02961         err = cnic_get_v4_route(dst_addr, NULL, &amp;dst);
<a name="l02962"></a>02962     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dst_addr-&gt;sin_family == AF_INET6) {
<a name="l02963"></a>02963         <span class="keyword">struct </span>sockaddr_in6 *dst_addr6 =
<a name="l02964"></a>02964             (<span class="keyword">struct </span>sockaddr_in6 *) dst_addr;
<a name="l02965"></a>02965 
<a name="l02966"></a>02966         err = cnic_get_v6_route(dst_addr6, NULL, &amp;dst);
<a name="l02967"></a>02967     } <span class="keywordflow">else</span>
<a name="l02968"></a>02968         <span class="keywordflow">return</span> NULL;
<a name="l02969"></a>02969 
<a name="l02970"></a>02970     <span class="keywordflow">if</span> (err)
<a name="l02971"></a>02971         <span class="keywordflow">return</span> NULL;
<a name="l02972"></a>02972 
<a name="l02973"></a>02973     <span class="keywordflow">if</span> (!dst-&gt;dev)
<a name="l02974"></a>02974         <span class="keywordflow">goto</span> done;
<a name="l02975"></a>02975 
<a name="l02976"></a>02976     cnic_get_vlan(dst-&gt;dev, &amp;netdev);
<a name="l02977"></a>02977 
<a name="l02978"></a>02978     dev = cnic_from_netdev(netdev);
<a name="l02979"></a>02979 
<a name="l02980"></a>02980 done:
<a name="l02981"></a>02981     dst_release(dst);
<a name="l02982"></a>02982     <span class="keywordflow">if</span> (dev)
<a name="l02983"></a>02983         cnic_put(dev);
<a name="l02984"></a>02984     <span class="keywordflow">return</span> dev;
<a name="l02985"></a>02985 }
<a name="l02986"></a>02986 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l02989"></a>02989 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> cnic_resolve_addr(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l02990"></a>02990 {
<a name="l02991"></a>02991     <span class="keyword">struct </span>neighbour *neigh = csk-&gt;dst-&gt;neighbour;
<a name="l02992"></a>02992     <span class="keywordtype">int</span> err = 0;
<a name="l02993"></a>02993 <span class="preprocessor">#ifndef HAVE_NETEVENT</span>
<a name="l02994"></a>02994 <span class="preprocessor"></span>    <span class="keywordtype">int</span> retry = 0;
<a name="l02995"></a>02995 <span class="preprocessor">#endif</span>
<a name="l02996"></a>02996 <span class="preprocessor"></span>
<a name="l02997"></a>02997     <span class="keywordflow">if</span> (neigh-&gt;nud_state &amp; NUD_VALID) {
<a name="l02998"></a>02998         err = -EINVAL;
<a name="l02999"></a>02999         <span class="keywordflow">if</span> (cnic_offld_prep(csk))
<a name="l03000"></a>03000             err = cnic_cm_offload_pg(csk);
<a name="l03001"></a>03001         <span class="keywordflow">goto</span> done;
<a name="l03002"></a>03002     }
<a name="l03003"></a>03003 
<a name="l03004"></a>03004     set_bit(SK_F_NDISC_WAITING, &amp;csk-&gt;flags);
<a name="l03005"></a>03005     neigh_event_send(neigh, NULL);
<a name="l03006"></a>03006 <span class="preprocessor">#ifndef HAVE_NETEVENT</span>
<a name="l03007"></a>03007 <span class="preprocessor"></span>    <span class="keywordflow">while</span> (!(neigh-&gt;nud_state &amp; NUD_VALID) &amp;&amp; (retry &lt; 3)) {
<a name="l03008"></a>03008         msleep(1000);
<a name="l03009"></a>03009         retry++;
<a name="l03010"></a>03010     }
<a name="l03011"></a>03011     <span class="keywordflow">if</span> (!(neigh-&gt;nud_state &amp; NUD_VALID))
<a name="l03012"></a>03012         err = -ETIMEDOUT;
<a name="l03013"></a>03013     <span class="keywordflow">else</span> {
<a name="l03014"></a>03014         err = -EINVAL;
<a name="l03015"></a>03015         <span class="keywordflow">if</span> (cnic_offld_prep(csk))
<a name="l03016"></a>03016             err = cnic_cm_offload_pg(csk);
<a name="l03017"></a>03017     }
<a name="l03018"></a>03018     clear_bit(SK_F_NDISC_WAITING, &amp;csk-&gt;flags);
<a name="l03019"></a>03019 <span class="preprocessor">#endif</span>
<a name="l03020"></a>03020 <span class="preprocessor"></span>done:
<a name="l03021"></a>03021     <span class="keywordflow">return</span> err;
<a name="l03022"></a>03022 }
<a name="l03023"></a>03023 
<a name="l03024"></a>03024 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_get_route(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk, <span class="keyword">struct</span> <a class="code" href="structcnic__sockaddr.html">cnic_sockaddr</a> *saddr)
<a name="l03025"></a>03025 {
<a name="l03026"></a>03026     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l03027"></a>03027     <span class="keywordtype">int</span> is_v6, err;
<a name="l03028"></a>03028     <span class="keyword">struct </span>dst_entry *dst;
<a name="l03029"></a>03029     <span class="keyword">struct </span>net_device *realdev;
<a name="l03030"></a>03030 
<a name="l03031"></a>03031     <span class="keywordflow">if</span> (saddr-&gt;local.v6.sin6_family == AF_INET6 &amp;&amp;
<a name="l03032"></a>03032         saddr-&gt;remote.v6.sin6_family == AF_INET6)
<a name="l03033"></a>03033         is_v6 = 1;
<a name="l03034"></a>03034     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (saddr-&gt;local.v4.sin_family == AF_INET &amp;&amp;
<a name="l03035"></a>03035          saddr-&gt;remote.v4.sin_family == AF_INET)
<a name="l03036"></a>03036         is_v6 = 0;
<a name="l03037"></a>03037     <span class="keywordflow">else</span>
<a name="l03038"></a>03038         <span class="keywordflow">return</span> -EINVAL;
<a name="l03039"></a>03039 
<a name="l03040"></a>03040     clear_bit(SK_F_IPV6, &amp;csk-&gt;flags);
<a name="l03041"></a>03041 
<a name="l03042"></a>03042     <span class="keywordflow">if</span> (is_v6) {
<a name="l03043"></a>03043 <span class="preprocessor">#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)</span>
<a name="l03044"></a>03044 <span class="preprocessor"></span>        set_bit(SK_F_IPV6, &amp;csk-&gt;flags);
<a name="l03045"></a>03045         err = cnic_get_v6_route(&amp;saddr-&gt;remote.v6,
<a name="l03046"></a>03046                     &amp;saddr-&gt;local.v6, &amp;dst);
<a name="l03047"></a>03047         <span class="keywordflow">if</span> (err)
<a name="l03048"></a>03048             <span class="keywordflow">return</span> err;
<a name="l03049"></a>03049 
<a name="l03050"></a>03050         <span class="keywordflow">if</span> (!dst || dst-&gt;error || !dst-&gt;dev)
<a name="l03051"></a>03051             <span class="keywordflow">goto</span> err_out;
<a name="l03052"></a>03052 
<a name="l03053"></a>03053         cnic_ipv6_get_saddr(dst, &amp;saddr-&gt;remote.v6.sin6_addr,
<a name="l03054"></a>03054                     &amp;saddr-&gt;local.v6.sin6_addr);
<a name="l03055"></a>03055 
<a name="l03056"></a>03056         memcpy(&amp;csk-&gt;src_ip[0], &amp;saddr-&gt;local.v6.sin6_addr,
<a name="l03057"></a>03057                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr));
<a name="l03058"></a>03058         memcpy(&amp;csk-&gt;dst_ip[0], &amp;saddr-&gt;remote.v6.sin6_addr,
<a name="l03059"></a>03059                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr));
<a name="l03060"></a>03060         csk-&gt;src_port = saddr-&gt;local.v6.sin6_port;
<a name="l03061"></a>03061         csk-&gt;dst_port = saddr-&gt;remote.v6.sin6_port;
<a name="l03062"></a>03062 <span class="preprocessor">#else</span>
<a name="l03063"></a>03063 <span class="preprocessor"></span>        <span class="keywordflow">return</span> -ENETUNREACH;
<a name="l03064"></a>03064 <span class="preprocessor">#endif</span>
<a name="l03065"></a>03065 <span class="preprocessor"></span>
<a name="l03066"></a>03066     } <span class="keywordflow">else</span> {
<a name="l03067"></a>03067         err = cnic_get_v4_route(&amp;saddr-&gt;remote.v4, &amp;saddr-&gt;local.v4,
<a name="l03068"></a>03068                     &amp;dst);
<a name="l03069"></a>03069         <span class="keywordflow">if</span> (err)
<a name="l03070"></a>03070             <span class="keywordflow">return</span> err;
<a name="l03071"></a>03071 
<a name="l03072"></a>03072         <span class="keywordflow">if</span> (!dst || dst-&gt;error || !dst-&gt;dev)
<a name="l03073"></a>03073             <span class="keywordflow">goto</span> err_out;
<a name="l03074"></a>03074 
<a name="l03075"></a>03075         csk-&gt;dst_ip[0] = saddr-&gt;remote.v4.sin_addr.s_addr;
<a name="l03076"></a>03076         csk-&gt;src_ip[0] = saddr-&gt;local.v4.sin_addr.s_addr;
<a name="l03077"></a>03077         csk-&gt;src_port = saddr-&gt;local.v4.sin_port;
<a name="l03078"></a>03078         csk-&gt;dst_port = saddr-&gt;remote.v4.sin_port;
<a name="l03079"></a>03079 
<a name="l03080"></a>03080         <span class="keywordflow">if</span> (csk-&gt;src_ip[0] == 0) {
<a name="l03081"></a>03081             csk-&gt;src_ip[0] =
<a name="l03082"></a>03082                 inet_select_addr(dst-&gt;dev, csk-&gt;dst_ip[0],
<a name="l03083"></a>03083                          RT_SCOPE_LINK);
<a name="l03084"></a>03084         }
<a name="l03085"></a>03085     }
<a name="l03086"></a>03086 
<a name="l03087"></a>03087     csk-&gt;vlan_id = cnic_get_vlan(dst-&gt;dev, &amp;realdev);
<a name="l03088"></a>03088     <span class="keywordflow">if</span> (realdev != dev-&gt;netdev)
<a name="l03089"></a>03089         <span class="keywordflow">goto</span> err_out;
<a name="l03090"></a>03090 
<a name="l03091"></a>03091     csk-&gt;dst = dst;
<a name="l03092"></a>03092     csk-&gt;pmtu = dst_mtu(csk-&gt;dst);
<a name="l03093"></a>03093     <span class="keywordflow">return</span> 0;
<a name="l03094"></a>03094 
<a name="l03095"></a>03095 err_out:
<a name="l03096"></a>03096     dst_release(dst);
<a name="l03097"></a>03097     <span class="keywordflow">return</span> -ENETUNREACH;
<a name="l03098"></a>03098 }
<a name="l03099"></a>03099 <span class="preprocessor">#else </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l03100"></a>03100 
<a name="l03101"></a>03101 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_get_route(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk, <span class="keyword">struct</span> <a class="code" href="structcnic__sockaddr.html">cnic_sockaddr</a> *saddr)
<a name="l03102"></a>03102 {
<a name="l03103"></a>03103     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l03104"></a>03104     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03105"></a>03105     <span class="keywordtype">int</span> err;
<a name="l03106"></a>03106     <span class="keywordtype">int</span> local_port;
<a name="l03107"></a>03107 
<a name="l03108"></a>03108     <span class="keywordflow">if</span> (saddr-&gt;local.v4.sin_family != AF_INET &amp;&amp;
<a name="l03109"></a>03109         saddr-&gt;remote.v4.sin_family != AF_INET6)
<a name="l03110"></a>03110         <span class="keywordflow">return</span> -EINVAL;
<a name="l03111"></a>03111 
<a name="l03112"></a>03112     <span class="comment">/* Use stored next hop MAC address */</span>
<a name="l03113"></a>03113     <span class="keywordflow">if</span> (!cp-&gt;nextHopMACAddr[0] &amp;&amp; !cp-&gt;nextHopMACAddr[1] &amp;&amp;
<a name="l03114"></a>03114         !cp-&gt;nextHopMACAddr[2]) {
<a name="l03115"></a>03115         printk(KERN_ALERT <span class="stringliteral">&quot;Zero next hop address, aborting\n&quot;</span>);
<a name="l03116"></a>03116         <span class="keywordflow">return</span> -EINVAL;
<a name="l03117"></a>03117     }
<a name="l03118"></a>03118 
<a name="l03119"></a>03119     <span class="keywordflow">if</span> (!cnic_offld_prep(csk))
<a name="l03120"></a>03120         <span class="keywordflow">return</span> -EINVAL;
<a name="l03121"></a>03121 
<a name="l03122"></a>03122     clear_bit(SK_F_IPV6, &amp;csk-&gt;flags);
<a name="l03123"></a>03123 
<a name="l03124"></a>03124     memcpy(csk-&gt;ha, cp-&gt;nextHopMACAddr, 6);
<a name="l03125"></a>03125     local_port = cnic_alloc_new_id(&amp;cp-&gt;csk_port_tbl);
<a name="l03126"></a>03126     <span class="keywordflow">if</span> (local_port == -1) {
<a name="l03127"></a>03127         clear_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags);
<a name="l03128"></a>03128         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03129"></a>03129     }
<a name="l03130"></a>03130 
<a name="l03131"></a>03131     csk-&gt;pmtu = cp-&gt;pmtu;
<a name="l03132"></a>03132 
<a name="l03133"></a>03133     csk-&gt;src_ip[0] = *((vmk_uint32 *)cp-&gt;srcIPAddr);
<a name="l03134"></a>03134     csk-&gt;dst_ip[0] = saddr-&gt;remote.v4.sin_addr.s_addr;
<a name="l03135"></a>03135     csk-&gt;src_port = htons(local_port);
<a name="l03136"></a>03136     csk-&gt;dst_port = saddr-&gt;remote.v4.sin_port;
<a name="l03137"></a>03137 
<a name="l03138"></a>03138     csk-&gt;vlan_id = cp-&gt;vlan_id;
<a name="l03139"></a>03139 
<a name="l03140"></a>03140     err = cnic_cm_offload_pg(csk);
<a name="l03141"></a>03141 
<a name="l03142"></a>03142     <span class="keywordflow">return</span> err;
<a name="l03143"></a>03143 }
<a name="l03144"></a>03144 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03145"></a>03145 
<a name="l03146"></a>03146 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_init_csk_state(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l03147"></a>03147 {
<a name="l03148"></a>03148     csk-&gt;state = 0;
<a name="l03149"></a>03149     clear_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags);
<a name="l03150"></a>03150     clear_bit(SK_F_CLOSING, &amp;csk-&gt;flags);
<a name="l03151"></a>03151 }
<a name="l03152"></a>03152 
<a name="l03153"></a>03153 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_connect(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk, <span class="keyword">struct</span> <a class="code" href="structcnic__sockaddr.html">cnic_sockaddr</a> *saddr)
<a name="l03154"></a>03154 {
<a name="l03155"></a>03155 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03156"></a>03156 <span class="preprocessor"></span>    <span class="keyword">struct </span>neighbour *neigh;
<a name="l03157"></a>03157 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03158"></a>03158     <span class="keywordtype">int</span> err = 0;
<a name="l03159"></a>03159 
<a name="l03160"></a>03160     <span class="keywordflow">if</span> (!cnic_in_use(csk))
<a name="l03161"></a>03161         <span class="keywordflow">return</span> -EINVAL;
<a name="l03162"></a>03162 
<a name="l03163"></a>03163     <span class="keywordflow">if</span> (test_and_set_bit(SK_F_CONNECT_START, &amp;csk-&gt;flags))
<a name="l03164"></a>03164         <span class="keywordflow">return</span> -EINVAL;
<a name="l03165"></a>03165 
<a name="l03166"></a>03166     cnic_init_csk_state(csk);
<a name="l03167"></a>03167 
<a name="l03168"></a>03168     err = cnic_get_route(csk, saddr);
<a name="l03169"></a>03169     <span class="keywordflow">if</span> (err)
<a name="l03170"></a>03170         <span class="keywordflow">goto</span> err_out;
<a name="l03171"></a>03171 
<a name="l03172"></a>03172 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03173"></a>03173 <span class="preprocessor"></span>    neigh = csk-&gt;dst-&gt;neighbour;
<a name="l03174"></a>03174     <span class="keywordflow">if</span> (!neigh)
<a name="l03175"></a>03175         <span class="keywordflow">goto</span> err_out;
<a name="l03176"></a>03176 
<a name="l03177"></a>03177     neigh_hold(neigh);
<a name="l03178"></a>03178 
<a name="l03179"></a>03179     err = cnic_resolve_addr(csk);
<a name="l03180"></a>03180     <span class="keywordflow">if</span> (!err)
<a name="l03181"></a>03181         <span class="keywordflow">return</span> 0;
<a name="l03182"></a>03182 
<a name="l03183"></a>03183     neigh_release(neigh);
<a name="l03184"></a>03184 
<a name="l03185"></a>03185 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03186"></a>03186 err_out:
<a name="l03187"></a>03187 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03188"></a>03188 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (csk-&gt;dst) {
<a name="l03189"></a>03189         dst_release(csk-&gt;dst);
<a name="l03190"></a>03190         csk-&gt;dst = NULL;
<a name="l03191"></a>03191     }
<a name="l03192"></a>03192 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03193"></a>03193     clear_bit(SK_F_CONNECT_START, &amp;csk-&gt;flags);
<a name="l03194"></a>03194     <span class="keywordflow">return</span> err;
<a name="l03195"></a>03195 }
<a name="l03196"></a>03196 
<a name="l03197"></a>03197 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_abort(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l03198"></a>03198 {
<a name="l03199"></a>03199     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = csk-&gt;dev-&gt;cnic_priv;
<a name="l03200"></a>03200     u32 opcode;
<a name="l03201"></a>03201 
<a name="l03202"></a>03202     <span class="keywordflow">if</span> (!cnic_in_use(csk))
<a name="l03203"></a>03203         <span class="keywordflow">return</span> -EINVAL;
<a name="l03204"></a>03204 
<a name="l03205"></a>03205     clear_bit(SK_F_NDISC_WAITING, &amp;csk-&gt;flags);
<a name="l03206"></a>03206     clear_bit(SK_F_CONNECT_START, &amp;csk-&gt;flags);
<a name="l03207"></a>03207     smp_mb__after_clear_bit();
<a name="l03208"></a>03208     <span class="keywordflow">if</span> (cnic_abort_prep(csk))
<a name="l03209"></a>03209         <span class="keywordflow">return</span> (cnic_cm_abort_req(csk));
<a name="l03210"></a>03210 
<a name="l03211"></a>03211     <span class="comment">/* Getting here means that we haven&#39;t started connect, or</span>
<a name="l03212"></a>03212 <span class="comment">     * connect was not successful.</span>
<a name="l03213"></a>03213 <span class="comment">     */</span>
<a name="l03214"></a>03214 
<a name="l03215"></a>03215     csk-&gt;state = L4_KCQE_OPCODE_VALUE_RESET_COMP;
<a name="l03216"></a>03216     <span class="keywordflow">if</span> (test_bit(SK_F_PG_OFFLD_COMPLETE, &amp;csk-&gt;flags))
<a name="l03217"></a>03217         opcode = csk-&gt;state;
<a name="l03218"></a>03218     <span class="keywordflow">else</span>
<a name="l03219"></a>03219         opcode = L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD;
<a name="l03220"></a>03220     cp-&gt;close_conn(csk, opcode);
<a name="l03221"></a>03221 
<a name="l03222"></a>03222     <span class="keywordflow">return</span> 0;
<a name="l03223"></a>03223 }
<a name="l03224"></a>03224 
<a name="l03225"></a>03225 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_close(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l03226"></a>03226 {
<a name="l03227"></a>03227     <span class="keywordflow">if</span> (!cnic_in_use(csk))
<a name="l03228"></a>03228         <span class="keywordflow">return</span> -EINVAL;
<a name="l03229"></a>03229 
<a name="l03230"></a>03230     <span class="keywordflow">if</span> (cnic_close_prep(csk)) {
<a name="l03231"></a>03231         csk-&gt;state = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;
<a name="l03232"></a>03232         <span class="keywordflow">return</span> (cnic_cm_close_req(csk));
<a name="l03233"></a>03233     }
<a name="l03234"></a>03234     <span class="keywordflow">return</span> 0;
<a name="l03235"></a>03235 }
<a name="l03236"></a>03236 
<a name="l03237"></a>03237 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_upcall(<span class="keyword">struct</span> <a class="code" href="structcnic__local.html">cnic_local</a> *cp, <span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk,
<a name="l03238"></a>03238                u8 opcode)
<a name="l03239"></a>03239 {
<a name="l03240"></a>03240     <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l03241"></a>03241     <span class="keywordtype">int</span> ulp_type = csk-&gt;ulp_type;
<a name="l03242"></a>03242 
<a name="l03243"></a>03243     rcu_read_lock();
<a name="l03244"></a>03244     ulp_ops = rcu_dereference(cp-&gt;ulp_ops[ulp_type]);
<a name="l03245"></a>03245     <span class="keywordflow">if</span> (ulp_ops) {
<a name="l03246"></a>03246         <span class="keywordflow">if</span> (opcode == L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE)
<a name="l03247"></a>03247             ulp_ops-&gt;cm_connect_complete(csk);
<a name="l03248"></a>03248         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)
<a name="l03249"></a>03249             ulp_ops-&gt;cm_close_complete(csk);
<a name="l03250"></a>03250         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED)
<a name="l03251"></a>03251             ulp_ops-&gt;cm_remote_abort(csk);
<a name="l03252"></a>03252         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opcode == L4_KCQE_OPCODE_VALUE_RESET_COMP)
<a name="l03253"></a>03253             ulp_ops-&gt;cm_abort_complete(csk);
<a name="l03254"></a>03254         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED)
<a name="l03255"></a>03255             ulp_ops-&gt;cm_remote_close(csk);
<a name="l03256"></a>03256     }
<a name="l03257"></a>03257     rcu_read_unlock();
<a name="l03258"></a>03258 }
<a name="l03259"></a>03259 
<a name="l03260"></a>03260 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_set_pg(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk)
<a name="l03261"></a>03261 {
<a name="l03262"></a>03262 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03263"></a>03263 <span class="preprocessor"></span>    <span class="keyword">struct </span>neighbour *neigh = csk-&gt;dst-&gt;neighbour;
<a name="l03264"></a>03264     <span class="keywordtype">int</span> valid = neigh-&gt;nud_state &amp; NUD_VALID;
<a name="l03265"></a>03265 
<a name="l03266"></a>03266     <span class="keywordflow">if</span> (!valid) {
<a name="l03267"></a>03267         <span class="keywordflow">if</span> (test_and_clear_bit(SK_F_NDISC_WAITING, &amp;csk-&gt;flags)) {
<a name="l03268"></a>03268             clear_bit(SK_F_CONNECT_START, &amp;csk-&gt;flags);
<a name="l03269"></a>03269             cnic_cm_cleanup(csk);
<a name="l03270"></a>03270             <span class="keywordflow">return</span> -ETIMEDOUT;
<a name="l03271"></a>03271         }
<a name="l03272"></a>03272     }
<a name="l03273"></a>03273 
<a name="l03274"></a>03274     <span class="keywordflow">if</span> (cnic_offld_prep(csk)) {
<a name="l03275"></a>03275         <span class="keywordflow">if</span> (test_bit(SK_F_PG_OFFLD_COMPLETE, &amp;csk-&gt;flags))
<a name="l03276"></a>03276             cnic_cm_update_pg(csk);
<a name="l03277"></a>03277         <span class="keywordflow">else</span>
<a name="l03278"></a>03278             cnic_cm_offload_pg(csk);
<a name="l03279"></a>03279     }
<a name="l03280"></a>03280     clear_bit(SK_F_NDISC_WAITING, &amp;csk-&gt;flags);
<a name="l03281"></a>03281 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03282"></a>03282     <span class="keywordflow">return</span> 0;
<a name="l03283"></a>03283 }
<a name="l03284"></a>03284 
<a name="l03285"></a>03285 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_process_neigh(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> neighbour *neigh)
<a name="l03286"></a>03286 {
<a name="l03287"></a>03287 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03288"></a>03288 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03289"></a>03289     <span class="keywordtype">int</span> i;
<a name="l03290"></a>03290 
<a name="l03291"></a>03291     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CM_SK_TBL_SZ; i++) {
<a name="l03292"></a>03292         <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk;
<a name="l03293"></a>03293         <span class="keywordtype">int</span> abort = 0;
<a name="l03294"></a>03294 
<a name="l03295"></a>03295         csk = &amp;cp-&gt;csk_tbl[i];
<a name="l03296"></a>03296         csk_hold(csk);
<a name="l03297"></a>03297         <span class="keywordflow">if</span> (cnic_in_use(csk) &amp;&amp; csk-&gt;dst &amp;&amp;
<a name="l03298"></a>03298             csk-&gt;dst-&gt;neighbour == neigh) {
<a name="l03299"></a>03299             <span class="keywordflow">if</span> (cnic_cm_set_pg(csk))
<a name="l03300"></a>03300                 abort = 1;
<a name="l03301"></a>03301         }
<a name="l03302"></a>03302         <span class="keywordflow">if</span> (abort)
<a name="l03303"></a>03303             cnic_cm_upcall(cp, csk,
<a name="l03304"></a>03304                 L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);
<a name="l03305"></a>03305         csk_put(csk);
<a name="l03306"></a>03306     }
<a name="l03307"></a>03307     neigh_release(neigh);
<a name="l03308"></a>03308 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03309"></a>03309 }
<a name="l03310"></a>03310 
<a name="l03311"></a>03311 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_process_redirect(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev,
<a name="l03312"></a>03312                      <span class="keyword">struct</span> <a class="code" href="structcnic__redirect__entry.html">cnic_redirect_entry</a> *redir)
<a name="l03313"></a>03313 {
<a name="l03314"></a>03314 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03315"></a>03315 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03316"></a>03316     <span class="keywordtype">int</span> i;
<a name="l03317"></a>03317 
<a name="l03318"></a>03318     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CM_SK_TBL_SZ; i++) {
<a name="l03319"></a>03319         <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk;
<a name="l03320"></a>03320         <span class="keywordtype">int</span> abort = 0;
<a name="l03321"></a>03321 
<a name="l03322"></a>03322         csk = &amp;cp-&gt;csk_tbl[i];
<a name="l03323"></a>03323         csk_hold(csk);
<a name="l03324"></a>03324         <span class="keywordflow">if</span> (cnic_in_use(csk) &amp;&amp; csk-&gt;dst == redir-&gt;old_dst) {
<a name="l03325"></a>03325             csk-&gt;dst = redir-&gt;new_dst;
<a name="l03326"></a>03326             dst_hold(csk-&gt;dst);
<a name="l03327"></a>03327             neigh_hold(csk-&gt;dst-&gt;neighbour);
<a name="l03328"></a>03328             <span class="keywordflow">if</span> (redir-&gt;old_dst-&gt;neighbour);
<a name="l03329"></a>03329                 neigh_release(redir-&gt;old_dst-&gt;neighbour);
<a name="l03330"></a>03330             dst_release(redir-&gt;old_dst);
<a name="l03331"></a>03331             <span class="keywordflow">if</span> (cnic_cm_set_pg(csk))
<a name="l03332"></a>03332                 abort = 1;
<a name="l03333"></a>03333         }
<a name="l03334"></a>03334         <span class="keywordflow">if</span> (abort)
<a name="l03335"></a>03335             cnic_cm_upcall(cp, csk,
<a name="l03336"></a>03336                 L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);
<a name="l03337"></a>03337         csk_put(csk);
<a name="l03338"></a>03338     }
<a name="l03339"></a>03339 
<a name="l03340"></a>03340     dst_release(redir-&gt;new_dst);
<a name="l03341"></a>03341     dst_release(redir-&gt;old_dst);
<a name="l03342"></a>03342 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03343"></a>03343 }
<a name="l03344"></a>03344 
<a name="l03345"></a>03345 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_process_offld_pg(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> <a class="code" href="structl4__kcq.html">l4_kcq</a> *kcqe)
<a name="l03346"></a>03346 {
<a name="l03347"></a>03347     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03348"></a>03348     u32 l5_cid = kcqe-&gt;pg_host_opaque;
<a name="l03349"></a>03349     u8 opcode = kcqe-&gt;op_code;
<a name="l03350"></a>03350     <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk = &amp;cp-&gt;csk_tbl[l5_cid];
<a name="l03351"></a>03351 
<a name="l03352"></a>03352     csk_hold(csk);
<a name="l03353"></a>03353     <span class="keywordflow">if</span> (!cnic_in_use(csk))
<a name="l03354"></a>03354         <span class="keywordflow">goto</span> done;
<a name="l03355"></a>03355 
<a name="l03356"></a>03356     <span class="keywordflow">if</span> (opcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {
<a name="l03357"></a>03357         clear_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags);
<a name="l03358"></a>03358         <span class="keywordflow">goto</span> done;
<a name="l03359"></a>03359     }
<a name="l03360"></a>03360     <span class="comment">/* Possible PG kcqe status:  SUCCESS, OFFLOADED_PG, or CTX_ALLOC_FAIL */</span>
<a name="l03361"></a>03361     <span class="keywordflow">if</span> (kcqe-&gt;status == L4_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAIL) {
<a name="l03362"></a>03362         clear_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags);
<a name="l03363"></a>03363         cnic_cm_upcall(cp, csk,
<a name="l03364"></a>03364                    L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);
<a name="l03365"></a>03365         <span class="keywordflow">goto</span> done;
<a name="l03366"></a>03366     }
<a name="l03367"></a>03367 
<a name="l03368"></a>03368     csk-&gt;pg_cid = kcqe-&gt;pg_cid;
<a name="l03369"></a>03369     set_bit(SK_F_PG_OFFLD_COMPLETE, &amp;csk-&gt;flags);
<a name="l03370"></a>03370     cnic_cm_conn_req(csk);
<a name="l03371"></a>03371 
<a name="l03372"></a>03372 done:
<a name="l03373"></a>03373     csk_put(csk);
<a name="l03374"></a>03374 }
<a name="l03375"></a>03375 
<a name="l03376"></a>03376 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_process_kcqe(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keyword">struct</span> kcqe *kcqe)
<a name="l03377"></a>03377 {
<a name="l03378"></a>03378     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03379"></a>03379     <span class="keyword">struct </span><a class="code" href="structl4__kcq.html">l4_kcq</a> *l4kcqe = (<span class="keyword">struct </span><a class="code" href="structl4__kcq.html">l4_kcq</a> *) kcqe;
<a name="l03380"></a>03380     u8 opcode = l4kcqe-&gt;op_code;
<a name="l03381"></a>03381     u32 l5_cid;
<a name="l03382"></a>03382     <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk;
<a name="l03383"></a>03383 
<a name="l03384"></a>03384     <span class="keywordflow">if</span> (opcode == L4_KCQE_OPCODE_VALUE_OFFLOAD_PG ||
<a name="l03385"></a>03385         opcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {
<a name="l03386"></a>03386         cnic_cm_process_offld_pg(dev, l4kcqe);
<a name="l03387"></a>03387         <span class="keywordflow">return</span>;
<a name="l03388"></a>03388     }
<a name="l03389"></a>03389 
<a name="l03390"></a>03390     l5_cid = l4kcqe-&gt;conn_id;
<a name="l03391"></a>03391     <span class="comment">/* Hack */</span>
<a name="l03392"></a>03392     <span class="keywordflow">if</span> (opcode &amp; 0x80)
<a name="l03393"></a>03393         l5_cid = l4kcqe-&gt;cid;
<a name="l03394"></a>03394     <span class="keywordflow">if</span> (l5_cid &gt;= MAX_CM_SK_TBL_SZ)
<a name="l03395"></a>03395         <span class="keywordflow">return</span>;
<a name="l03396"></a>03396 
<a name="l03397"></a>03397     csk = &amp;cp-&gt;csk_tbl[l5_cid];
<a name="l03398"></a>03398     csk_hold(csk);
<a name="l03399"></a>03399 
<a name="l03400"></a>03400     <span class="keywordflow">if</span> (!cnic_in_use(csk)) {
<a name="l03401"></a>03401         csk_put(csk);
<a name="l03402"></a>03402         <span class="keywordflow">return</span>;
<a name="l03403"></a>03403     }
<a name="l03404"></a>03404 
<a name="l03405"></a>03405     <span class="keywordflow">switch</span> (opcode) {
<a name="l03406"></a>03406     <span class="keywordflow">case</span> L5CM_RAMROD_CMD_ID_TCP_CONNECT:
<a name="l03407"></a>03407         <span class="keywordflow">if</span> (l4kcqe-&gt;status != 0) {
<a name="l03408"></a>03408             clear_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags);
<a name="l03409"></a>03409             cnic_cm_upcall(cp, csk,
<a name="l03410"></a>03410                        L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);
<a name="l03411"></a>03411         }
<a name="l03412"></a>03412         <span class="keywordflow">break</span>;
<a name="l03413"></a>03413     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE:
<a name="l03414"></a>03414         <span class="keywordflow">if</span> (l4kcqe-&gt;status == 0)
<a name="l03415"></a>03415             set_bit(SK_F_OFFLD_COMPLETE, &amp;csk-&gt;flags);
<a name="l03416"></a>03416 
<a name="l03417"></a>03417         smp_mb__before_clear_bit();
<a name="l03418"></a>03418         clear_bit(SK_F_OFFLD_SCHED, &amp;csk-&gt;flags);
<a name="l03419"></a>03419         cnic_cm_upcall(cp, csk, opcode);
<a name="l03420"></a>03420         <span class="keywordflow">break</span>;
<a name="l03421"></a>03421 
<a name="l03422"></a>03422     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:
<a name="l03423"></a>03423         <span class="keywordflow">if</span> (test_bit(CNIC_F_BNX2_CLASS, &amp;dev-&gt;flags)) {
<a name="l03424"></a>03424             cnic_cm_upcall(cp, csk, opcode);
<a name="l03425"></a>03425             <span class="keywordflow">break</span>;
<a name="l03426"></a>03426         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &amp;csk-&gt;flags))
<a name="l03427"></a>03427             csk-&gt;state = opcode;
<a name="l03428"></a>03428         <span class="comment">/* fall through */</span>
<a name="l03429"></a>03429     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_CLOSE_COMP:
<a name="l03430"></a>03430     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_RESET_COMP:
<a name="l03431"></a>03431     <span class="keywordflow">case</span> L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:
<a name="l03432"></a>03432     <span class="keywordflow">case</span> L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:
<a name="l03433"></a>03433         cp-&gt;close_conn(csk, opcode);
<a name="l03434"></a>03434         <span class="keywordflow">break</span>;
<a name="l03435"></a>03435 
<a name="l03436"></a>03436     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED:
<a name="l03437"></a>03437         cnic_cm_upcall(cp, csk, opcode);
<a name="l03438"></a>03438         <span class="keywordflow">break</span>;
<a name="l03439"></a>03439     }
<a name="l03440"></a>03440     csk_put(csk);
<a name="l03441"></a>03441 }
<a name="l03442"></a>03442 
<a name="l03443"></a>03443 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_indicate_kcqe(<span class="keywordtype">void</span> *data, <span class="keyword">struct</span> kcqe *kcqe[], u32 num_cqe)
<a name="l03444"></a>03444 {
<a name="l03445"></a>03445     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = data;
<a name="l03446"></a>03446     <span class="keywordtype">int</span> i;
<a name="l03447"></a>03447     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03448"></a>03448 
<a name="l03449"></a>03449     <span class="keywordflow">for</span> (i = 0; i &lt; num_cqe; i++)
<a name="l03450"></a>03450         cnic_queue_work(cp, WORK_TYPE_KCQE, kcqe[i]);
<a name="l03451"></a>03451 
<a name="l03452"></a>03452     tasklet_schedule(&amp;cp-&gt;cnic_task);
<a name="l03453"></a>03453 }
<a name="l03454"></a>03454 
<a name="l03455"></a>03455 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_indicate_event(<span class="keywordtype">void</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event)
<a name="l03456"></a>03456 {
<a name="l03457"></a>03457 }
<a name="l03458"></a>03458 
<a name="l03459"></a>03459 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_dummy(<span class="keywordtype">void</span> *data)
<a name="l03460"></a>03460 {
<a name="l03461"></a>03461 }
<a name="l03462"></a>03462 
<a name="l03463"></a>03463 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> cm_ulp_ops = {
<a name="l03464"></a>03464     .cnic_start     = cnic_cm_dummy,
<a name="l03465"></a>03465     .cnic_stop      = cnic_cm_dummy,
<a name="l03466"></a>03466     .indicate_kcqes     = cnic_cm_indicate_kcqe,
<a name="l03467"></a>03467     .indicate_netevent  = cnic_cm_indicate_event,
<a name="l03468"></a>03468     .indicate_inetevent = cnic_cm_indicate_event,
<a name="l03469"></a>03469 };
<a name="l03470"></a>03470 
<a name="l03471"></a>03471 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_task(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l03472"></a>03472 {
<a name="l03473"></a>03473     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = (<span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *) data;
<a name="l03474"></a>03474     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = cp-&gt;dev;
<a name="l03475"></a>03475     u32 cons = cp-&gt;cnic_wr_cons;
<a name="l03476"></a>03476     u32 prod = cp-&gt;cnic_wr_prod;
<a name="l03477"></a>03477 
<a name="l03478"></a>03478     <span class="keywordflow">while</span> (cons != prod) {
<a name="l03479"></a>03479         <span class="keyword">struct </span><a class="code" href="structcnic__work__node.html">cnic_work_node</a> *node;
<a name="l03480"></a>03480 
<a name="l03481"></a>03481         node = &amp;cp-&gt;cnic_work_ring[cons];
<a name="l03482"></a>03482         <span class="keywordflow">if</span> (node-&gt;work_type == WORK_TYPE_KCQE)
<a name="l03483"></a>03483             cnic_cm_process_kcqe(dev, &amp;node-&gt;work_data.kcqe);
<a name="l03484"></a>03484         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node-&gt;work_type == WORK_TYPE_NEIGH_UPDATE)
<a name="l03485"></a>03485             cnic_cm_process_neigh(dev, node-&gt;work_data.neigh);
<a name="l03486"></a>03486         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node-&gt;work_type == WORK_TYPE_REDIRECT)
<a name="l03487"></a>03487             cnic_cm_process_redirect(dev,
<a name="l03488"></a>03488                 &amp;node-&gt;work_data.cnic_redir);
<a name="l03489"></a>03489         cons++;
<a name="l03490"></a>03490         cons &amp;= WORK_RING_SIZE_MASK;
<a name="l03491"></a>03491     }
<a name="l03492"></a>03492     cp-&gt;cnic_wr_cons = cons;
<a name="l03493"></a>03493 }
<a name="l03494"></a>03494 
<a name="l03495"></a>03495 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_free_dev(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03496"></a>03496 {
<a name="l03497"></a>03497     <span class="keywordtype">int</span> i = 0;
<a name="l03498"></a>03498 
<a name="l03499"></a>03499     <span class="keywordflow">while</span> ((atomic_read(&amp;dev-&gt;ref_count) != 0) &amp;&amp; i &lt; 10) {
<a name="l03500"></a>03500         msleep(100);
<a name="l03501"></a>03501         i++;
<a name="l03502"></a>03502     }
<a name="l03503"></a>03503     <span class="keywordflow">if</span> (atomic_read(&amp;dev-&gt;ref_count) != 0)
<a name="l03504"></a>03504         printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: Failed waiting for ref count to go&quot;</span>
<a name="l03505"></a>03505                     <span class="stringliteral">&quot; to zero.\n&quot;</span>, dev-&gt;netdev-&gt;name);
<a name="l03506"></a>03506 
<a name="l03507"></a>03507     printk(KERN_INFO PFX <span class="stringliteral">&quot;Removed CNIC device: %s\n&quot;</span>, dev-&gt;netdev-&gt;name);
<a name="l03508"></a>03508     dev_put(dev-&gt;netdev);
<a name="l03509"></a>03509     kfree(dev);
<a name="l03510"></a>03510 }
<a name="l03511"></a>03511 
<a name="l03512"></a>03512 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_free_mem(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03513"></a>03513 {
<a name="l03514"></a>03514     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03515"></a>03515 
<a name="l03516"></a>03516     kfree(cp-&gt;csk_tbl);
<a name="l03517"></a>03517     cp-&gt;csk_tbl = NULL;
<a name="l03518"></a>03518     cp-&gt;next_tcp_port = cnic_free_id_tbl(&amp;cp-&gt;csk_port_tbl);
<a name="l03519"></a>03519 }
<a name="l03520"></a>03520 
<a name="l03521"></a>03521 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_alloc_mem(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03522"></a>03522 {
<a name="l03523"></a>03523     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03524"></a>03524 
<a name="l03525"></a>03525     cp-&gt;csk_tbl = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a>) * MAX_CM_SK_TBL_SZ,
<a name="l03526"></a>03526                   GFP_KERNEL);
<a name="l03527"></a>03527     <span class="keywordflow">if</span> (!cp-&gt;csk_tbl)
<a name="l03528"></a>03528         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03529"></a>03529     memset(cp-&gt;csk_tbl, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a>) * MAX_CM_SK_TBL_SZ);
<a name="l03530"></a>03530 
<a name="l03531"></a>03531     <span class="keywordflow">return</span> 0;
<a name="l03532"></a>03532 }
<a name="l03533"></a>03533 
<a name="l03534"></a>03534 <span class="preprocessor">#ifndef HAVE_NETEVENT</span>
<a name="l03535"></a>03535 <span class="preprocessor"></span><span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03536"></a>03536 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> cnic_timer(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l03537"></a>03537 {
<a name="l03538"></a>03538     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = (<span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *) data;
<a name="l03539"></a>03539     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = cp-&gt;dev;
<a name="l03540"></a>03540     <span class="keywordtype">int</span> i, found = 0;
<a name="l03541"></a>03541     <span class="keyword">struct </span>neighbour *neigh = NULL;
<a name="l03542"></a>03542 
<a name="l03543"></a>03543     <span class="keywordflow">if</span> (!test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags))
<a name="l03544"></a>03544         <span class="keywordflow">return</span>;
<a name="l03545"></a>03545 
<a name="l03546"></a>03546     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CM_SK_TBL_SZ &amp;&amp; !found; i++) {
<a name="l03547"></a>03547         <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk;
<a name="l03548"></a>03548 
<a name="l03549"></a>03549         csk = &amp;cp-&gt;csk_tbl[i];
<a name="l03550"></a>03550         csk_hold(csk);
<a name="l03551"></a>03551         <span class="keywordflow">if</span> (cnic_in_use(csk) &amp;&amp; csk-&gt;dst &amp;&amp;
<a name="l03552"></a>03552             test_bit(SK_F_PG_OFFLD_COMPLETE, &amp;csk-&gt;flags)) {
<a name="l03553"></a>03553             neigh = csk-&gt;dst-&gt;neighbour;
<a name="l03554"></a>03554             <span class="keywordflow">if</span> (memcmp(csk-&gt;old_ha, neigh-&gt;ha, 6)) {
<a name="l03555"></a>03555                 found = 1;
<a name="l03556"></a>03556                 neigh_hold(neigh);
<a name="l03557"></a>03557 
<a name="l03558"></a>03558                 cnic_queue_work(cp, WORK_TYPE_NEIGH_UPDATE,
<a name="l03559"></a>03559                         &amp;neigh);
<a name="l03560"></a>03560                 tasklet_schedule(&amp;cp-&gt;cnic_task);
<a name="l03561"></a>03561             }
<a name="l03562"></a>03562         }
<a name="l03563"></a>03563         csk_put(csk);
<a name="l03564"></a>03564     }
<a name="l03565"></a>03565 
<a name="l03566"></a>03566     cp-&gt;cnic_timer.expires = jiffies + cp-&gt;cnic_timer_off;
<a name="l03567"></a>03567     add_timer(&amp;cp-&gt;cnic_timer);
<a name="l03568"></a>03568 }
<a name="l03569"></a>03569 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03570"></a>03570 <span class="preprocessor">#endif</span>
<a name="l03571"></a>03571 <span class="preprocessor"></span>
<a name="l03572"></a>03572 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_ready_to_close(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk, u32 opcode)
<a name="l03573"></a>03573 {
<a name="l03574"></a>03574     <span class="keywordflow">if</span> ((opcode == csk-&gt;state) ||
<a name="l03575"></a>03575         (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED &amp;&amp;
<a name="l03576"></a>03576          csk-&gt;state == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)) {
<a name="l03577"></a>03577         <span class="keywordflow">if</span> (!test_and_set_bit(SK_F_CLOSING, &amp;csk-&gt;flags))
<a name="l03578"></a>03578             <span class="keywordflow">return</span> 1;
<a name="l03579"></a>03579     }
<a name="l03580"></a>03580     <span class="comment">/* 57710+ only  workaround to handle unsolicited RESET_COMP</span>
<a name="l03581"></a>03581 <span class="comment">     * which will be treated like a RESET RCVD notification</span>
<a name="l03582"></a>03582 <span class="comment">     * which triggers the clean up procedure</span>
<a name="l03583"></a>03583 <span class="comment">     */</span>
<a name="l03584"></a>03584     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((opcode != csk-&gt;state) &amp;&amp; 
<a name="l03585"></a>03585          (opcode == L4_KCQE_OPCODE_VALUE_RESET_COMP)) {
<a name="l03586"></a>03586         <span class="keywordflow">if</span> (!test_and_set_bit(SK_F_CLOSING, &amp;csk-&gt;flags)) {
<a name="l03587"></a>03587             csk-&gt;state = L4_KCQE_OPCODE_VALUE_RESET_RECEIVED;
<a name="l03588"></a>03588             <span class="keywordflow">return</span> 1;
<a name="l03589"></a>03589         }
<a name="l03590"></a>03590     }
<a name="l03591"></a>03591     <span class="keywordflow">return</span> 0;
<a name="l03592"></a>03592 }
<a name="l03593"></a>03593 
<a name="l03594"></a>03594 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_close_bnx2_conn(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk, u32 opcode)
<a name="l03595"></a>03595 {
<a name="l03596"></a>03596     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l03597"></a>03597     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03598"></a>03598 
<a name="l03599"></a>03599     clear_bit(SK_F_CONNECT_START, &amp;csk-&gt;flags);
<a name="l03600"></a>03600     cnic_close_conn(csk);
<a name="l03601"></a>03601     cnic_cm_upcall(cp, csk, opcode);
<a name="l03602"></a>03602 }
<a name="l03603"></a>03603 
<a name="l03604"></a>03604 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_stop_bnx2_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03605"></a>03605 {
<a name="l03606"></a>03606 }
<a name="l03607"></a>03607 
<a name="l03608"></a>03608 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_init_bnx2_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03609"></a>03609 {
<a name="l03610"></a>03610     u32 seed;
<a name="l03611"></a>03611 
<a name="l03612"></a>03612 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= 0x020612)</span>
<a name="l03613"></a>03613 <span class="preprocessor"></span>    get_random_bytes(&amp;seed, 4);
<a name="l03614"></a>03614 <span class="preprocessor">#else</span>
<a name="l03615"></a>03615 <span class="preprocessor"></span>    seed = 0x12345678;
<a name="l03616"></a>03616 <span class="preprocessor">#endif</span>
<a name="l03617"></a>03617 <span class="preprocessor"></span>    cnic_ctx_wr(dev, 45, 0, seed);
<a name="l03618"></a>03618     <span class="keywordflow">return</span> 0;
<a name="l03619"></a>03619 }
<a name="l03620"></a>03620 
<a name="l03621"></a>03621 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_close_bnx2x_conn(<span class="keyword">struct</span> <a class="code" href="structcnic__sock.html">cnic_sock</a> *csk, u32 opcode)
<a name="l03622"></a>03622 {
<a name="l03623"></a>03623     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev = csk-&gt;dev;
<a name="l03624"></a>03624     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03625"></a>03625     <span class="keyword">struct </span><a class="code" href="structcnic__context.html">cnic_context</a> *ctx = &amp;cp-&gt;ctx_tbl[csk-&gt;l5_cid];
<a name="l03626"></a>03626     <span class="keyword">union </span><a class="code" href="unionl5cm__specific__data.html">l5cm_specific_data</a> l5_data;
<a name="l03627"></a>03627     u32 cmd = 0;
<a name="l03628"></a>03628     <span class="keywordtype">int</span> close_complete = 0;
<a name="l03629"></a>03629 
<a name="l03630"></a>03630     <span class="keywordflow">switch</span> (opcode) {
<a name="l03631"></a>03631     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:
<a name="l03632"></a>03632     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_CLOSE_COMP:
<a name="l03633"></a>03633     <span class="keywordflow">case</span> L4_KCQE_OPCODE_VALUE_RESET_COMP:
<a name="l03634"></a>03634         <span class="keywordflow">if</span> (cnic_ready_to_close(csk, opcode))
<a name="l03635"></a>03635             cmd = L5CM_RAMROD_CMD_ID_SEARCHER_DELETE;
<a name="l03636"></a>03636         <span class="keywordflow">break</span>;
<a name="l03637"></a>03637     <span class="keywordflow">case</span> L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:
<a name="l03638"></a>03638         cmd = L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD;
<a name="l03639"></a>03639         <span class="keywordflow">break</span>;
<a name="l03640"></a>03640     <span class="keywordflow">case</span> L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:
<a name="l03641"></a>03641         close_complete = 1;
<a name="l03642"></a>03642         <span class="keywordflow">break</span>;
<a name="l03643"></a>03643     }
<a name="l03644"></a>03644     <span class="keywordflow">if</span> (cmd) {
<a name="l03645"></a>03645         memset(&amp;l5_data, 0, <span class="keyword">sizeof</span>(l5_data));
<a name="l03646"></a>03646 
<a name="l03647"></a>03647         cnic_submit_kwqe_16(dev, cmd, csk-&gt;cid, ISCSI_CONNECTION_TYPE,
<a name="l03648"></a>03648                     &amp;l5_data);
<a name="l03649"></a>03649     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (close_complete) {
<a name="l03650"></a>03650         ctx-&gt;timestamp = jiffies;
<a name="l03651"></a>03651         cnic_close_conn(csk);
<a name="l03652"></a>03652         cnic_cm_upcall(cp, csk, csk-&gt;state);
<a name="l03653"></a>03653     }
<a name="l03654"></a>03654 }
<a name="l03655"></a>03655 
<a name="l03656"></a>03656 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_cm_stop_bnx2x_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03657"></a>03657 {
<a name="l03658"></a>03658 }
<a name="l03659"></a>03659 
<a name="l03660"></a>03660 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_init_bnx2x_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03661"></a>03661 {
<a name="l03662"></a>03662     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03663"></a>03663     <span class="keywordtype">int</span> func = CNIC_FUNC(cp);
<a name="l03664"></a>03664     <span class="keyword">struct </span>net_device *netdev = dev-&gt;netdev;
<a name="l03665"></a>03665 
<a name="l03666"></a>03666     cnic_init_bnx2x_mac(dev, netdev-&gt;dev_addr);
<a name="l03667"></a>03667     cnic_bnx2x_set_tcp_timestamp(dev, 1);
<a name="l03668"></a>03668 
<a name="l03669"></a>03669     CNIC_WR16(dev, BAR_XSTRORM_INTMEM +
<a name="l03670"></a>03670           XSTORM_ISCSI_LOCAL_VLAN_OFFSET(func), 0);
<a name="l03671"></a>03671 
<a name="l03672"></a>03672     CNIC_WR(dev, BAR_XSTRORM_INTMEM +
<a name="l03673"></a>03673         XSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_ENABLED_OFFSET(func), 1);
<a name="l03674"></a>03674     CNIC_WR(dev, BAR_XSTRORM_INTMEM +
<a name="l03675"></a>03675         XSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_MAX_COUNT_OFFSET(func),
<a name="l03676"></a>03676         DEF_MAX_DA_COUNT);
<a name="l03677"></a>03677 
<a name="l03678"></a>03678     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l03679"></a>03679          XSTORM_ISCSI_TCP_VARS_TTL_OFFSET(func), DEF_TTL);
<a name="l03680"></a>03680     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l03681"></a>03681          XSTORM_ISCSI_TCP_VARS_TOS_OFFSET(func), DEF_TOS);
<a name="l03682"></a>03682     CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
<a name="l03683"></a>03683          XSTORM_ISCSI_TCP_VARS_ADV_WND_SCL_OFFSET(func), 2);
<a name="l03684"></a>03684     CNIC_WR(dev, BAR_XSTRORM_INTMEM +
<a name="l03685"></a>03685         XSTORM_TCP_TX_SWS_TIMER_VAL_OFFSET(func), DEF_SWS_TIMER);
<a name="l03686"></a>03686 
<a name="l03687"></a>03687     CNIC_WR(dev, BAR_TSTRORM_INTMEM + TSTORM_TCP_MAX_CWND_OFFSET(func),
<a name="l03688"></a>03688         DEF_MAX_CWND);
<a name="l03689"></a>03689     <span class="keywordflow">return</span> 0;
<a name="l03690"></a>03690 }
<a name="l03691"></a>03691 
<a name="l03692"></a>03692 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_open(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03693"></a>03693 {
<a name="l03694"></a>03694     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03695"></a>03695     <span class="keywordtype">int</span> err;
<a name="l03696"></a>03696 
<a name="l03697"></a>03697     err = cnic_cm_alloc_mem(dev);
<a name="l03698"></a>03698     <span class="keywordflow">if</span> (err)
<a name="l03699"></a>03699         <span class="keywordflow">return</span> err;
<a name="l03700"></a>03700 
<a name="l03701"></a>03701     err = cp-&gt;start_cm(dev);
<a name="l03702"></a>03702 
<a name="l03703"></a>03703     <span class="keywordflow">if</span> (err)
<a name="l03704"></a>03704         <span class="keywordflow">goto</span> err_out;
<a name="l03705"></a>03705 
<a name="l03706"></a>03706     spin_lock_init(&amp;cp-&gt;wr_lock);
<a name="l03707"></a>03707 
<a name="l03708"></a>03708     tasklet_init(&amp;cp-&gt;cnic_task, cnic_task, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) cp);
<a name="l03709"></a>03709 
<a name="l03710"></a>03710 <span class="preprocessor">#ifdef HAVE_NETEVENT</span>
<a name="l03711"></a>03711 <span class="preprocessor"></span>    cp-&gt;cm_nb.notifier_call = cnic_net_callback;
<a name="l03712"></a>03712     register_netevent_notifier(&amp;cp-&gt;cm_nb);
<a name="l03713"></a>03713 <span class="preprocessor">#else</span>
<a name="l03714"></a>03714 <span class="preprocessor"></span><span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03715"></a>03715 <span class="preprocessor"></span>    init_timer(&amp;cp-&gt;cnic_timer);
<a name="l03716"></a>03716     cp-&gt;cnic_timer_off = 2 * HZ;
<a name="l03717"></a>03717     cp-&gt;cnic_timer.expires = jiffies + cp-&gt;cnic_timer_off;
<a name="l03718"></a>03718     cp-&gt;cnic_timer.data = (<span class="keywordtype">unsigned</span> long) cp;
<a name="l03719"></a>03719     cp-&gt;cnic_timer.function = cnic_timer;
<a name="l03720"></a>03720     add_timer(&amp;cp-&gt;cnic_timer);
<a name="l03721"></a>03721 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03722"></a>03722 <span class="preprocessor">#endif</span>
<a name="l03723"></a>03723 <span class="preprocessor"></span>
<a name="l03724"></a>03724     dev-&gt;cm_create = cnic_cm_create;
<a name="l03725"></a>03725     dev-&gt;cm_destroy = cnic_cm_destroy;
<a name="l03726"></a>03726     dev-&gt;cm_connect = cnic_cm_connect;
<a name="l03727"></a>03727     dev-&gt;cm_abort = cnic_cm_abort;
<a name="l03728"></a>03728     dev-&gt;cm_close = cnic_cm_close;
<a name="l03729"></a>03729     dev-&gt;cm_select_dev = cnic_cm_select_dev;
<a name="l03730"></a>03730 
<a name="l03731"></a>03731     cp-&gt;ulp_handle[CNIC_ULP_L4] = dev;
<a name="l03732"></a>03732     rcu_assign_pointer(cp-&gt;ulp_ops[CNIC_ULP_L4], &amp;cm_ulp_ops);
<a name="l03733"></a>03733     <span class="keywordflow">return</span> 0;
<a name="l03734"></a>03734 
<a name="l03735"></a>03735 err_out:
<a name="l03736"></a>03736     cnic_cm_free_mem(dev);
<a name="l03737"></a>03737     <span class="keywordflow">return</span> err;
<a name="l03738"></a>03738 }
<a name="l03739"></a>03739 
<a name="l03740"></a>03740 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_cm_shutdown(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03741"></a>03741 {
<a name="l03742"></a>03742     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03743"></a>03743     <span class="keywordtype">int</span> i;
<a name="l03744"></a>03744 
<a name="l03745"></a>03745     cp-&gt;stop_cm(dev);
<a name="l03746"></a>03746 
<a name="l03747"></a>03747 <span class="preprocessor">#ifdef HAVE_NETEVENT</span>
<a name="l03748"></a>03748 <span class="preprocessor"></span>    unregister_netevent_notifier(&amp;cp-&gt;cm_nb);
<a name="l03749"></a>03749 <span class="preprocessor">#else</span>
<a name="l03750"></a>03750 <span class="preprocessor"></span><span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l03751"></a>03751 <span class="preprocessor"></span>    del_timer_sync(&amp;cp-&gt;cnic_timer);
<a name="l03752"></a>03752 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l03753"></a>03753 <span class="preprocessor">#endif</span>
<a name="l03754"></a>03754 <span class="preprocessor"></span>
<a name="l03755"></a>03755     tasklet_kill(&amp;cp-&gt;cnic_task);
<a name="l03756"></a>03756 
<a name="l03757"></a>03757     <span class="keywordflow">if</span> (!cp-&gt;csk_tbl)
<a name="l03758"></a>03758         <span class="keywordflow">return</span> 0;
<a name="l03759"></a>03759 
<a name="l03760"></a>03760     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CM_SK_TBL_SZ; i++) {
<a name="l03761"></a>03761         <span class="keyword">struct </span><a class="code" href="structcnic__sock.html">cnic_sock</a> *csk = &amp;cp-&gt;csk_tbl[i];
<a name="l03762"></a>03762 
<a name="l03763"></a>03763         clear_bit(SK_F_INUSE, &amp;csk-&gt;flags);
<a name="l03764"></a>03764         cnic_cm_cleanup(csk);
<a name="l03765"></a>03765     }
<a name="l03766"></a>03766     cnic_cm_free_mem(dev);
<a name="l03767"></a>03767 
<a name="l03768"></a>03768     <span class="keywordflow">return</span> 0;
<a name="l03769"></a>03769 }
<a name="l03770"></a>03770 
<a name="l03771"></a>03771 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_init_context(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, u32 cid)
<a name="l03772"></a>03772 {
<a name="l03773"></a>03773     u32 cid_addr;
<a name="l03774"></a>03774     <span class="keywordtype">int</span> i;
<a name="l03775"></a>03775 
<a name="l03776"></a>03776     cid_addr = GET_CID_ADDR(cid);
<a name="l03777"></a>03777 
<a name="l03778"></a>03778     <span class="keywordflow">for</span> (i = 0; i &lt; CTX_SIZE; i += 4)
<a name="l03779"></a>03779         cnic_ctx_wr(dev, cid_addr, i, 0);
<a name="l03780"></a>03780 }
<a name="l03781"></a>03781 
<a name="l03782"></a>03782 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_setup_5709_context(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev, <span class="keywordtype">int</span> valid)
<a name="l03783"></a>03783 {
<a name="l03784"></a>03784     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03785"></a>03785     <span class="keywordtype">int</span> ret = 0, i;
<a name="l03786"></a>03786     u32 valid_bit = valid ? BNX2_CTX_HOST_PAGE_TBL_DATA0_VALID : 0;
<a name="l03787"></a>03787 
<a name="l03788"></a>03788     <span class="keywordflow">if</span> (CHIP_NUM(cp) != CHIP_NUM_5709)
<a name="l03789"></a>03789         <span class="keywordflow">return</span> 0;
<a name="l03790"></a>03790 
<a name="l03791"></a>03791     <span class="keywordflow">for</span> (i = 0; i &lt; cp-&gt;ctx_blks; i++) {
<a name="l03792"></a>03792         <span class="keywordtype">int</span> j;
<a name="l03793"></a>03793         u32 idx = cp-&gt;ctx_arr[i].cid / cp-&gt;cids_per_blk;
<a name="l03794"></a>03794         u32 val;
<a name="l03795"></a>03795 
<a name="l03796"></a>03796         memset(cp-&gt;ctx_arr[i].ctx, 0, BCM_PAGE_SIZE);
<a name="l03797"></a>03797 
<a name="l03798"></a>03798         CNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA0,
<a name="l03799"></a>03799             (cp-&gt;ctx_arr[i].mapping &amp; 0xffffffff) | valid_bit);
<a name="l03800"></a>03800         CNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA1,
<a name="l03801"></a>03801             (u64) cp-&gt;ctx_arr[i].mapping &gt;&gt; 32);
<a name="l03802"></a>03802         CNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL, idx |
<a name="l03803"></a>03803             BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ);
<a name="l03804"></a>03804         <span class="keywordflow">for</span> (j = 0; j &lt; 10; j++) {
<a name="l03805"></a>03805 
<a name="l03806"></a>03806             val = CNIC_RD(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL);
<a name="l03807"></a>03807             <span class="keywordflow">if</span> (!(val &amp; BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ))
<a name="l03808"></a>03808                 <span class="keywordflow">break</span>;
<a name="l03809"></a>03809             udelay(5);
<a name="l03810"></a>03810         }
<a name="l03811"></a>03811         <span class="keywordflow">if</span> (val &amp; BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ) {
<a name="l03812"></a>03812             ret = -EBUSY;
<a name="l03813"></a>03813             <span class="keywordflow">break</span>;
<a name="l03814"></a>03814         }
<a name="l03815"></a>03815     }
<a name="l03816"></a>03816     <span class="keywordflow">return</span> ret;
<a name="l03817"></a>03817 }
<a name="l03818"></a>03818 
<a name="l03819"></a>03819 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_free_irq(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03820"></a>03820 {
<a name="l03821"></a>03821     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03822"></a>03822     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l03823"></a>03823 
<a name="l03824"></a>03824     <span class="keywordflow">if</span> (ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_USING_MSIX) {
<a name="l03825"></a>03825         cp-&gt;disable_int_sync(dev);
<a name="l03826"></a>03826         tasklet_kill(&amp;cp-&gt;cnic_irq_task);
<a name="l03827"></a>03827         free_irq(ethdev-&gt;irq_arr[0].vector, dev);
<a name="l03828"></a>03828     }
<a name="l03829"></a>03829 }
<a name="l03830"></a>03830 
<a name="l03831"></a>03831 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_init_bnx2_irq(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03832"></a>03832 {
<a name="l03833"></a>03833     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03834"></a>03834     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l03835"></a>03835 
<a name="l03836"></a>03836     <span class="keywordflow">if</span> (ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_USING_MSIX) {
<a name="l03837"></a>03837         <span class="keywordtype">int</span> err, i = 0;
<a name="l03838"></a>03838         <span class="keywordtype">int</span> sblk_num = cp-&gt;status_blk_num;
<a name="l03839"></a>03839         u32 base = ((sblk_num - 1) * BNX2_HC_SB_CONFIG_SIZE) +
<a name="l03840"></a>03840                BNX2_HC_SB_CONFIG_1;
<a name="l03841"></a>03841 
<a name="l03842"></a>03842         CNIC_WR(dev, base, BNX2_HC_SB_CONFIG_1_ONE_SHOT);
<a name="l03843"></a>03843 
<a name="l03844"></a>03844         CNIC_WR(dev, base + BNX2_HC_COMP_PROD_TRIP_OFF, (2 &lt;&lt; 16) | 8);
<a name="l03845"></a>03845         CNIC_WR(dev, base + BNX2_HC_COM_TICKS_OFF, (64 &lt;&lt; 16) | 220);
<a name="l03846"></a>03846         CNIC_WR(dev, base + BNX2_HC_CMD_TICKS_OFF, (64 &lt;&lt; 16) | 220);
<a name="l03847"></a>03847 
<a name="l03848"></a>03848         cp-&gt;bnx2_status_blk = cp-&gt;status_blk;
<a name="l03849"></a>03849         cp-&gt;last_status_idx = cp-&gt;bnx2_status_blk-&gt;status_idx;
<a name="l03850"></a>03850         tasklet_init(&amp;cp-&gt;cnic_irq_task, cnic_service_bnx2_msix,
<a name="l03851"></a>03851                  (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) dev);
<a name="l03852"></a>03852         err = request_irq(ethdev-&gt;irq_arr[0].vector, <a class="code" href="structcnic__irq.html">cnic_irq</a>, 0,
<a name="l03853"></a>03853                   <span class="stringliteral">&quot;cnic&quot;</span>, dev);
<a name="l03854"></a>03854         <span class="keywordflow">if</span> (err) {
<a name="l03855"></a>03855             tasklet_disable(&amp;cp-&gt;cnic_irq_task);
<a name="l03856"></a>03856             <span class="keywordflow">return</span> err;
<a name="l03857"></a>03857         }
<a name="l03858"></a>03858         <span class="keywordflow">while</span> (cp-&gt;bnx2_status_blk-&gt;status_completion_producer_index &amp;&amp;
<a name="l03859"></a>03859                i &lt; 10) {
<a name="l03860"></a>03860             CNIC_WR(dev, BNX2_HC_COALESCE_NOW,
<a name="l03861"></a>03861                 1 &lt;&lt; (11 + sblk_num));
<a name="l03862"></a>03862             udelay(10);
<a name="l03863"></a>03863             i++;
<a name="l03864"></a>03864             barrier();
<a name="l03865"></a>03865         }
<a name="l03866"></a>03866         <span class="keywordflow">if</span> (cp-&gt;bnx2_status_blk-&gt;status_completion_producer_index) {
<a name="l03867"></a>03867             cnic_free_irq(dev);
<a name="l03868"></a>03868             <span class="keywordflow">goto</span> failed;
<a name="l03869"></a>03869         }
<a name="l03870"></a>03870 
<a name="l03871"></a>03871     } <span class="keywordflow">else</span> {
<a name="l03872"></a>03872         <span class="keyword">struct </span><a class="code" href="structstatus__block.html">status_block</a> *sblk = cp-&gt;status_blk;
<a name="l03873"></a>03873         u32 hc_cmd = CNIC_RD(dev, BNX2_HC_COMMAND);
<a name="l03874"></a>03874         <span class="keywordtype">int</span> i = 0;
<a name="l03875"></a>03875 
<a name="l03876"></a>03876         <span class="keywordflow">while</span> (sblk-&gt;status_completion_producer_index &amp;&amp; i &lt; 10) {
<a name="l03877"></a>03877             CNIC_WR(dev, BNX2_HC_COMMAND,
<a name="l03878"></a>03878                 hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);
<a name="l03879"></a>03879             udelay(10);
<a name="l03880"></a>03880             i++;
<a name="l03881"></a>03881             barrier();
<a name="l03882"></a>03882         }
<a name="l03883"></a>03883         <span class="keywordflow">if</span> (sblk-&gt;status_completion_producer_index)
<a name="l03884"></a>03884             <span class="keywordflow">goto</span> failed;
<a name="l03885"></a>03885 
<a name="l03886"></a>03886     }
<a name="l03887"></a>03887     <span class="keywordflow">return</span> 0;
<a name="l03888"></a>03888 
<a name="l03889"></a>03889 failed:
<a name="l03890"></a>03890     printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: &quot;</span> <span class="stringliteral">&quot;KCQ index not resetting to 0.\n&quot;</span>,
<a name="l03891"></a>03891            dev-&gt;netdev-&gt;name);
<a name="l03892"></a>03892     <span class="keywordflow">return</span> -EBUSY;
<a name="l03893"></a>03893 }
<a name="l03894"></a>03894 
<a name="l03895"></a>03895 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_enable_bnx2_int(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03896"></a>03896 {
<a name="l03897"></a>03897     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03898"></a>03898     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l03899"></a>03899 
<a name="l03900"></a>03900     <span class="keywordflow">if</span> (!(ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_USING_MSIX))
<a name="l03901"></a>03901         <span class="keywordflow">return</span>;
<a name="l03902"></a>03902 
<a name="l03903"></a>03903     CNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp-&gt;int_num |
<a name="l03904"></a>03904         BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp-&gt;last_status_idx);
<a name="l03905"></a>03905 }
<a name="l03906"></a>03906 
<a name="l03907"></a>03907 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_disable_bnx2_int_sync(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03908"></a>03908 {
<a name="l03909"></a>03909     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03910"></a>03910     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l03911"></a>03911 
<a name="l03912"></a>03912     <span class="keywordflow">if</span> (!(ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_USING_MSIX))
<a name="l03913"></a>03913         <span class="keywordflow">return</span>;
<a name="l03914"></a>03914 
<a name="l03915"></a>03915     CNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp-&gt;int_num |
<a name="l03916"></a>03916         BNX2_PCICFG_INT_ACK_CMD_MASK_INT);
<a name="l03917"></a>03917     CNIC_RD(dev, BNX2_PCICFG_INT_ACK_CMD);
<a name="l03918"></a>03918     synchronize_irq(ethdev-&gt;irq_arr[0].vector);
<a name="l03919"></a>03919 }
<a name="l03920"></a>03920 
<a name="l03921"></a>03921 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_get_bnx2_iscsi_info(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03922"></a>03922 {
<a name="l03923"></a>03923     u32 max_conn;
<a name="l03924"></a>03924 
<a name="l03925"></a>03925     max_conn = cnic_reg_rd_ind(dev, BNX2_FW_MAX_ISCSI_CONN);
<a name="l03926"></a>03926     dev-&gt;max_iscsi_conn = max_conn;
<a name="l03927"></a>03927 }
<a name="l03928"></a>03928 
<a name="l03929"></a>03929 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_start_bnx2_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l03930"></a>03930 {
<a name="l03931"></a>03931     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l03932"></a>03932     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l03933"></a>03933     <span class="keyword">struct </span><a class="code" href="structstatus__block.html">status_block</a> *sblk = cp-&gt;status_blk;
<a name="l03934"></a>03934     u32 val;
<a name="l03935"></a>03935     <span class="keywordtype">int</span> err;
<a name="l03936"></a>03936 
<a name="l03937"></a>03937     val = CNIC_RD(dev, BNX2_MQ_CONFIG);
<a name="l03938"></a>03938     val &amp;= ~BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE;
<a name="l03939"></a>03939     <span class="keywordflow">if</span> (BCM_PAGE_BITS &gt; 12)
<a name="l03940"></a>03940         val |= (12 - 8)  &lt;&lt; 4;
<a name="l03941"></a>03941     <span class="keywordflow">else</span>
<a name="l03942"></a>03942         val |= (BCM_PAGE_BITS - 8)  &lt;&lt; 4;
<a name="l03943"></a>03943 
<a name="l03944"></a>03944     CNIC_WR(dev, BNX2_MQ_CONFIG, val);
<a name="l03945"></a>03945 
<a name="l03946"></a>03946     CNIC_WR(dev, BNX2_HC_COMP_PROD_TRIP, (2 &lt;&lt; 16) | 8);
<a name="l03947"></a>03947     CNIC_WR(dev, BNX2_HC_COM_TICKS, (64 &lt;&lt; 16) | 220);
<a name="l03948"></a>03948     CNIC_WR(dev, BNX2_HC_CMD_TICKS, (64 &lt;&lt; 16) | 220);
<a name="l03949"></a>03949 
<a name="l03950"></a>03950     err = cnic_setup_5709_context(dev, 1);
<a name="l03951"></a>03951     <span class="keywordflow">if</span> (err)
<a name="l03952"></a>03952         <span class="keywordflow">return</span> err;
<a name="l03953"></a>03953 
<a name="l03954"></a>03954     cnic_init_context(dev, KWQ_CID);
<a name="l03955"></a>03955     cnic_init_context(dev, KCQ_CID);
<a name="l03956"></a>03956 
<a name="l03957"></a>03957     cp-&gt;kwq_cid_addr = GET_CID_ADDR(KWQ_CID);
<a name="l03958"></a>03958     cp-&gt;kwq_io_addr = MB_GET_CID_ADDR(KWQ_CID) + L5_KRNLQ_HOST_QIDX;
<a name="l03959"></a>03959 
<a name="l03960"></a>03960     cp-&gt;max_kwq_idx = MAX_KWQ_IDX;
<a name="l03961"></a>03961     cp-&gt;kwq_prod_idx = 0;
<a name="l03962"></a>03962     cp-&gt;kwq_con_idx = 0;
<a name="l03963"></a>03963     cp-&gt;cnic_local_flags |= CNIC_LCL_FL_KWQ_INIT;
<a name="l03964"></a>03964 
<a name="l03965"></a>03965     <span class="keywordflow">if</span> (CHIP_NUM(cp) == CHIP_NUM_5706 || CHIP_NUM(cp) == CHIP_NUM_5708)
<a name="l03966"></a>03966         cp-&gt;kwq_con_idx_ptr = &amp;sblk-&gt;status_rx_quick_consumer_index15;
<a name="l03967"></a>03967     <span class="keywordflow">else</span>
<a name="l03968"></a>03968         cp-&gt;kwq_con_idx_ptr = &amp;sblk-&gt;status_cmd_consumer_index;
<a name="l03969"></a>03969 
<a name="l03970"></a>03970     <span class="comment">/* Initialize the kernel work queue context. */</span>
<a name="l03971"></a>03971     val = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |
<a name="l03972"></a>03972           (BCM_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;
<a name="l03973"></a>03973     cnic_ctx_wr(dev, cp-&gt;kwq_cid_addr, L5_KRNLQ_TYPE, val);
<a name="l03974"></a>03974     
<a name="l03975"></a>03975     val = (BCM_PAGE_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">struct </span>kwqe) - 1) &lt;&lt; 16;
<a name="l03976"></a>03976     cnic_ctx_wr(dev, cp-&gt;kwq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);
<a name="l03977"></a>03977     
<a name="l03978"></a>03978     val = ((BCM_PAGE_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">struct </span>kwqe)) &lt;&lt; 16) | KWQ_PAGE_CNT;
<a name="l03979"></a>03979     cnic_ctx_wr(dev, cp-&gt;kwq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);
<a name="l03980"></a>03980     
<a name="l03981"></a>03981     val = (u32) ((u64) cp-&gt;kwq_info.pgtbl_map &gt;&gt; 32);
<a name="l03982"></a>03982     cnic_ctx_wr(dev, cp-&gt;kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);
<a name="l03983"></a>03983     
<a name="l03984"></a>03984     val = (u32) cp-&gt;kwq_info.pgtbl_map;
<a name="l03985"></a>03985     cnic_ctx_wr(dev, cp-&gt;kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);
<a name="l03986"></a>03986 
<a name="l03987"></a>03987     cp-&gt;kcq_cid_addr = GET_CID_ADDR(KCQ_CID);
<a name="l03988"></a>03988     cp-&gt;kcq_io_addr = MB_GET_CID_ADDR(KCQ_CID) + L5_KRNLQ_HOST_QIDX;
<a name="l03989"></a>03989     
<a name="l03990"></a>03990     cp-&gt;kcq_prod_idx = 0;
<a name="l03991"></a>03991     
<a name="l03992"></a>03992     <span class="comment">/* Initialize the kernel complete queue context. */</span>
<a name="l03993"></a>03993     val = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |
<a name="l03994"></a>03994           (BCM_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;
<a name="l03995"></a>03995     cnic_ctx_wr(dev, cp-&gt;kcq_cid_addr, L5_KRNLQ_TYPE, val);
<a name="l03996"></a>03996     
<a name="l03997"></a>03997     val = (BCM_PAGE_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">struct </span>kcqe) - 1) &lt;&lt; 16;
<a name="l03998"></a>03998     cnic_ctx_wr(dev, cp-&gt;kcq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);
<a name="l03999"></a>03999     
<a name="l04000"></a>04000     val = ((BCM_PAGE_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">struct </span>kcqe)) &lt;&lt; 16) | KCQ_PAGE_CNT;
<a name="l04001"></a>04001     cnic_ctx_wr(dev, cp-&gt;kcq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);
<a name="l04002"></a>04002     
<a name="l04003"></a>04003     val = (u32) ((u64) cp-&gt;kcq_info.pgtbl_map &gt;&gt; 32);
<a name="l04004"></a>04004     cnic_ctx_wr(dev, cp-&gt;kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);
<a name="l04005"></a>04005     
<a name="l04006"></a>04006     val = (u32) cp-&gt;kcq_info.pgtbl_map;
<a name="l04007"></a>04007     cnic_ctx_wr(dev, cp-&gt;kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);
<a name="l04008"></a>04008 
<a name="l04009"></a>04009     cp-&gt;int_num = 0;
<a name="l04010"></a>04010     <span class="keywordflow">if</span> (ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_USING_MSIX) {
<a name="l04011"></a>04011         u32 sb_id = cp-&gt;status_blk_num;
<a name="l04012"></a>04012         u32 sb = BNX2_L2CTX_L5_STATUSB_NUM(sb_id);
<a name="l04013"></a>04013 
<a name="l04014"></a>04014         cp-&gt;int_num = sb_id &lt;&lt; BNX2_PCICFG_INT_ACK_CMD_INT_NUM_SHIFT;
<a name="l04015"></a>04015         cnic_ctx_wr(dev, cp-&gt;kwq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);
<a name="l04016"></a>04016         cnic_ctx_wr(dev, cp-&gt;kcq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);
<a name="l04017"></a>04017     }
<a name="l04018"></a>04018 
<a name="l04019"></a>04019     <span class="comment">/* Enable Commnad Scheduler notification when we write to the</span>
<a name="l04020"></a>04020 <span class="comment">     * host producer index of the kernel contexts. */</span>
<a name="l04021"></a>04021     CNIC_WR(dev, BNX2_MQ_KNL_CMD_MASK1, 2);
<a name="l04022"></a>04022 
<a name="l04023"></a>04023     <span class="comment">/* Enable Command Scheduler notification when we write to either</span>
<a name="l04024"></a>04024 <span class="comment">     * the Send Queue or Receive Queue producer indexes of the kernel</span>
<a name="l04025"></a>04025 <span class="comment">     * bypass contexts. */</span>
<a name="l04026"></a>04026     CNIC_WR(dev, BNX2_MQ_KNL_BYP_CMD_MASK1, 7);
<a name="l04027"></a>04027     CNIC_WR(dev, BNX2_MQ_KNL_BYP_WRITE_MASK1, 7);
<a name="l04028"></a>04028 
<a name="l04029"></a>04029     <span class="comment">/* Notify COM when the driver post an application buffer. */</span>
<a name="l04030"></a>04030     CNIC_WR(dev, BNX2_MQ_KNL_RX_V2P_MASK2, 0x2000);
<a name="l04031"></a>04031 
<a name="l04032"></a>04032     <span class="comment">/* Set the CP and COM doorbells.  These two processors polls the</span>
<a name="l04033"></a>04033 <span class="comment">     * doorbell for a non zero value before running.  This must be done</span>
<a name="l04034"></a>04034 <span class="comment">     * after setting up the kernel queue contexts. */</span>
<a name="l04035"></a>04035     val = cnic_reg_rd_ind(dev, BNX2_CP_SCRATCH + 0x20);
<a name="l04036"></a>04036     cnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, val | 1);
<a name="l04037"></a>04037 
<a name="l04038"></a>04038     val = cnic_reg_rd_ind(dev, BNX2_COM_SCRATCH + 0x20);
<a name="l04039"></a>04039     cnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, val | 1);
<a name="l04040"></a>04040 
<a name="l04041"></a>04041     err = cnic_init_bnx2_irq(dev);
<a name="l04042"></a>04042     <span class="keywordflow">if</span> (err) {
<a name="l04043"></a>04043         printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: cnic_init_irq failed\n&quot;</span>,
<a name="l04044"></a>04044                dev-&gt;netdev-&gt;name);
<a name="l04045"></a>04045 
<a name="l04046"></a>04046         val = cnic_reg_rd_ind(dev, BNX2_CP_SCRATCH + 0x20);
<a name="l04047"></a>04047         cnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, val &amp; ~0x1);
<a name="l04048"></a>04048 
<a name="l04049"></a>04049         val = cnic_reg_rd_ind(dev, BNX2_COM_SCRATCH + 0x20);
<a name="l04050"></a>04050         cnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, val &amp; ~0x1);
<a name="l04051"></a>04051 
<a name="l04052"></a>04052         <span class="keywordflow">return</span> err;
<a name="l04053"></a>04053     }
<a name="l04054"></a>04054 
<a name="l04055"></a>04055     cnic_get_bnx2_iscsi_info(dev);
<a name="l04056"></a>04056 
<a name="l04057"></a>04057     <span class="keywordflow">return</span> 0;
<a name="l04058"></a>04058 }
<a name="l04059"></a>04059 
<a name="l04060"></a>04060 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_setup_bnx2x_context(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04061"></a>04061 {
<a name="l04062"></a>04062     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04063"></a>04063     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l04064"></a>04064     u32 start_offset = ethdev-&gt;ctx_tbl_offset;
<a name="l04065"></a>04065     <span class="keywordtype">int</span> i;
<a name="l04066"></a>04066 
<a name="l04067"></a>04067     <span class="keywordflow">for</span> (i = 0; i &lt; cp-&gt;ctx_blks; i++) {
<a name="l04068"></a>04068         <span class="keyword">struct </span><a class="code" href="structcnic__ctx.html">cnic_ctx</a> *ctx = &amp;cp-&gt;ctx_arr[i];
<a name="l04069"></a>04069         dma_addr_t map = ctx-&gt;mapping;
<a name="l04070"></a>04070 
<a name="l04071"></a>04071         <span class="keywordflow">if</span> (cp-&gt;ctx_align) {
<a name="l04072"></a>04072             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask = cp-&gt;ctx_align - 1;
<a name="l04073"></a>04073 
<a name="l04074"></a>04074             map = (map + mask) &amp; ~mask;
<a name="l04075"></a>04075         }
<a name="l04076"></a>04076 
<a name="l04077"></a>04077         cnic_ctx_tbl_wr(dev, start_offset + i, map);
<a name="l04078"></a>04078     }
<a name="l04079"></a>04079 }
<a name="l04080"></a>04080 
<a name="l04081"></a>04081 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_init_bnx2x_irq(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04082"></a>04082 {
<a name="l04083"></a>04083     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04084"></a>04084     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l04085"></a>04085     <span class="keywordtype">int</span> err = 0;
<a name="l04086"></a>04086 
<a name="l04087"></a>04087     cp-&gt;bnx2x_status_blk = cp-&gt;status_blk;
<a name="l04088"></a>04088     memset(cp-&gt;bnx2x_status_blk, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structhost__status__block.html">host_status_block</a>));
<a name="l04089"></a>04089 
<a name="l04090"></a>04090     tasklet_init(&amp;cp-&gt;cnic_irq_task, cnic_service_bnx2x_bh,
<a name="l04091"></a>04091              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) dev);
<a name="l04092"></a>04092     <span class="keywordflow">if</span> (ethdev-&gt;drv_state &amp; CNIC_DRV_STATE_USING_MSIX) {
<a name="l04093"></a>04093         err = request_irq(ethdev-&gt;irq_arr[0].vector, <a class="code" href="structcnic__irq.html">cnic_irq</a>, 0,
<a name="l04094"></a>04094                   <span class="stringliteral">&quot;cnic&quot;</span>, dev);
<a name="l04095"></a>04095         <span class="keywordflow">if</span> (err)
<a name="l04096"></a>04096             tasklet_disable(&amp;cp-&gt;cnic_irq_task);
<a name="l04097"></a>04097     }
<a name="l04098"></a>04098     <span class="keywordflow">return</span> err;
<a name="l04099"></a>04099 }
<a name="l04100"></a>04100 
<a name="l04101"></a>04101 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_enable_bnx2x_int(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04102"></a>04102 {
<a name="l04103"></a>04103     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04104"></a>04104     u8 sb_id = cp-&gt;status_blk_num;
<a name="l04105"></a>04105     <span class="keywordtype">int</span> port = CNIC_PORT(cp);
<a name="l04106"></a>04106 
<a name="l04107"></a>04107 <span class="preprocessor">#ifdef NEW_BNX2X_HSI</span>
<a name="l04108"></a>04108 <span class="preprocessor"></span>    CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
<a name="l04109"></a>04109          CSTORM_SB_HC_TIMEOUT_C_OFFSET(port, sb_id,
<a name="l04110"></a>04110                            HC_INDEX_C_ISCSI_EQ_CONS),
<a name="l04111"></a>04111          64 / 12);
<a name="l04112"></a>04112     CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
<a name="l04113"></a>04113           CSTORM_SB_HC_DISABLE_C_OFFSET(port, sb_id,
<a name="l04114"></a>04114                             HC_INDEX_C_ISCSI_EQ_CONS), 0);
<a name="l04115"></a>04115 <span class="preprocessor">#else</span>
<a name="l04116"></a>04116 <span class="preprocessor"></span>    CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
<a name="l04117"></a>04117          CSTORM_SB_HC_TIMEOUT_OFFSET(port, sb_id,
<a name="l04118"></a>04118                          HC_INDEX_C_ISCSI_EQ_CONS),
<a name="l04119"></a>04119          64 / 12);
<a name="l04120"></a>04120     CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
<a name="l04121"></a>04121           CSTORM_SB_HC_DISABLE_OFFSET(port, sb_id,
<a name="l04122"></a>04122                           HC_INDEX_C_ISCSI_EQ_CONS), 0);
<a name="l04123"></a>04123 <span class="preprocessor">#endif</span>
<a name="l04124"></a>04124 <span class="preprocessor"></span>}
<a name="l04125"></a>04125 
<a name="l04126"></a>04126 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_disable_bnx2x_int_sync(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04127"></a>04127 {
<a name="l04128"></a>04128 }
<a name="l04129"></a>04129 
<a name="l04130"></a>04130 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_get_bnx2x_iscsi_info(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04131"></a>04131 {
<a name="l04132"></a>04132     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04133"></a>04133     u32 base, addr, val;
<a name="l04134"></a>04134     <span class="keywordtype">int</span> port = CNIC_PORT(cp);
<a name="l04135"></a>04135 
<a name="l04136"></a>04136     dev-&gt;max_iscsi_conn = 0;
<a name="l04137"></a>04137     base = CNIC_RD(dev, MISC_REG_SHARED_MEM_ADDR);
<a name="l04138"></a>04138     <span class="keywordflow">if</span> (base &lt; 0xa0000 || base &gt;= 0xc0000)
<a name="l04139"></a>04139         <span class="keywordflow">return</span>;
<a name="l04140"></a>04140 
<a name="l04141"></a>04141     addr = BNX2X_SHMEM_ADDR(base, validity_map[port]);
<a name="l04142"></a>04142     val = CNIC_RD(dev, addr);
<a name="l04143"></a>04143 
<a name="l04144"></a>04144     <span class="keywordflow">if</span> (!(val &amp; SHR_MEM_VALIDITY_LIC_NO_KEY_IN_EFFECT)) {
<a name="l04145"></a>04145         u16 val16;
<a name="l04146"></a>04146 
<a name="l04147"></a>04147         addr = BNX2X_SHMEM_ADDR(base,
<a name="l04148"></a>04148                 drv_lic_key[port].max_iscsi_init_conn);
<a name="l04149"></a>04149         val16 = CNIC_RD16(dev, addr);
<a name="l04150"></a>04150 
<a name="l04151"></a>04151         <span class="keywordflow">if</span> (val16)
<a name="l04152"></a>04152             val16 ^= 0x1e1e;
<a name="l04153"></a>04153         dev-&gt;max_iscsi_conn = val16;
<a name="l04154"></a>04154     }
<a name="l04155"></a>04155     <span class="keywordflow">if</span> (BNX2X_CHIP_IS_E1H(cp-&gt;chip_id)) {
<a name="l04156"></a>04156         <span class="keywordtype">int</span> func = CNIC_FUNC(cp);
<a name="l04157"></a>04157 
<a name="l04158"></a>04158         addr = BNX2X_SHMEM_ADDR(base,
<a name="l04159"></a>04159                 <a class="code" href="structmf__cfg.html">mf_cfg</a>.func_mf_config[func].e1hov_tag);
<a name="l04160"></a>04160         val = CNIC_RD(dev, addr);
<a name="l04161"></a>04161         val &amp;= FUNC_MF_CFG_E1HOV_TAG_MASK;
<a name="l04162"></a>04162         <span class="keywordflow">if</span> (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {
<a name="l04163"></a>04163             addr = BNX2X_SHMEM_ADDR(base,
<a name="l04164"></a>04164                 <a class="code" href="structmf__cfg.html">mf_cfg</a>.func_mf_config[func].config);
<a name="l04165"></a>04165             val = CNIC_RD(dev, addr);
<a name="l04166"></a>04166             val &amp;= FUNC_MF_CFG_PROTOCOL_MASK;
<a name="l04167"></a>04167             <span class="keywordflow">if</span> (val != FUNC_MF_CFG_PROTOCOL_ISCSI)
<a name="l04168"></a>04168                 dev-&gt;max_iscsi_conn = 0;
<a name="l04169"></a>04169         }
<a name="l04170"></a>04170     }
<a name="l04171"></a>04171 }
<a name="l04172"></a>04172 
<a name="l04173"></a>04173 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_start_bnx2x_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04174"></a>04174 {
<a name="l04175"></a>04175     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04176"></a>04176     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l04177"></a>04177     <span class="keywordtype">int</span> func = CNIC_FUNC(cp), ret, i;
<a name="l04178"></a>04178     <span class="keywordtype">int</span> port = CNIC_PORT(cp);
<a name="l04179"></a>04179     u32 start_cid = ethdev-&gt;starting_cid;
<a name="l04180"></a>04180     u16 eq_idx;
<a name="l04181"></a>04181     u8 sb_id = cp-&gt;status_blk_num;
<a name="l04182"></a>04182 
<a name="l04183"></a>04183     ret = cnic_init_id_tbl(&amp;cp-&gt;cid_tbl, MAX_ISCSI_TBL_SZ, start_cid, 0);
<a name="l04184"></a>04184 
<a name="l04185"></a>04185     <span class="keywordflow">if</span> (ret)
<a name="l04186"></a>04186         <span class="keywordflow">return</span> -ENOMEM;
<a name="l04187"></a>04187 
<a name="l04188"></a>04188     cp-&gt;kcq_io_addr = BAR_CSTRORM_INTMEM +
<a name="l04189"></a>04189               CSTORM_ISCSI_EQ_PROD_OFFSET(func, 0);
<a name="l04190"></a>04190     cp-&gt;kcq_prod_idx = 0;
<a name="l04191"></a>04191 
<a name="l04192"></a>04192     cnic_get_bnx2x_iscsi_info(dev);
<a name="l04193"></a>04193 
<a name="l04194"></a>04194     <span class="comment">/* Only 1 EQ */</span>
<a name="l04195"></a>04195     CNIC_WR16(dev, cp-&gt;kcq_io_addr, MAX_KCQ_IDX);
<a name="l04196"></a>04196     CNIC_WR(dev, BAR_CSTRORM_INTMEM + 
<a name="l04197"></a>04197         CSTORM_ISCSI_EQ_CONS_OFFSET(func, 0), 0);
<a name="l04198"></a>04198     CNIC_WR(dev, BAR_CSTRORM_INTMEM +
<a name="l04199"></a>04199         CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(func, 0),
<a name="l04200"></a>04200         cp-&gt;kcq_info.pg_map_arr[1] &amp; 0xffffffff);
<a name="l04201"></a>04201     CNIC_WR(dev, BAR_CSTRORM_INTMEM +
<a name="l04202"></a>04202         CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(func, 0) + 4,
<a name="l04203"></a>04203         (u64) cp-&gt;kcq_info.pg_map_arr[1] &gt;&gt; 32);
<a name="l04204"></a>04204     CNIC_WR(dev, BAR_CSTRORM_INTMEM +
<a name="l04205"></a>04205         CSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(func, 0),
<a name="l04206"></a>04206         cp-&gt;kcq_info.pg_map_arr[0] &amp; 0xffffffff);
<a name="l04207"></a>04207     CNIC_WR(dev, BAR_CSTRORM_INTMEM +
<a name="l04208"></a>04208         CSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(func, 0) + 4,
<a name="l04209"></a>04209         (u64) cp-&gt;kcq_info.pg_map_arr[0] &gt;&gt; 32);
<a name="l04210"></a>04210     CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
<a name="l04211"></a>04211         CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_VALID_OFFSET(func, 0), 1);
<a name="l04212"></a>04212     CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
<a name="l04213"></a>04213         CSTORM_ISCSI_EQ_SB_NUM_OFFSET(func, 0), cp-&gt;status_blk_num);
<a name="l04214"></a>04214     CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
<a name="l04215"></a>04215         CSTORM_ISCSI_EQ_SB_INDEX_OFFSET(func, 0),
<a name="l04216"></a>04216         HC_INDEX_C_ISCSI_EQ_CONS);
<a name="l04217"></a>04217 
<a name="l04218"></a>04218     <span class="keywordflow">for</span> (i = 0; i &lt; cp-&gt;conn_buf_info.num_pages; i++) {
<a name="l04219"></a>04219         CNIC_WR(dev, BAR_TSTRORM_INTMEM +
<a name="l04220"></a>04220             TSTORM_ISCSI_CONN_BUF_PBL_OFFSET(func, i),
<a name="l04221"></a>04221             cp-&gt;conn_buf_info.pgtbl[2 * i]);
<a name="l04222"></a>04222         CNIC_WR(dev, BAR_TSTRORM_INTMEM +
<a name="l04223"></a>04223             TSTORM_ISCSI_CONN_BUF_PBL_OFFSET(func, i) + 4,
<a name="l04224"></a>04224             cp-&gt;conn_buf_info.pgtbl[(2 * i) + 1]);
<a name="l04225"></a>04225     }
<a name="l04226"></a>04226 
<a name="l04227"></a>04227     CNIC_WR(dev, BAR_USTRORM_INTMEM +
<a name="l04228"></a>04228         USTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(func),
<a name="l04229"></a>04229         cp-&gt;gbl_buf_info.pg_map_arr[0] &amp; 0xffffffff);
<a name="l04230"></a>04230     CNIC_WR(dev, BAR_USTRORM_INTMEM +
<a name="l04231"></a>04231         USTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(func) + 4,
<a name="l04232"></a>04232         (u64) cp-&gt;gbl_buf_info.pg_map_arr[0] &gt;&gt; 32);
<a name="l04233"></a>04233 
<a name="l04234"></a>04234     cnic_setup_bnx2x_context(dev);
<a name="l04235"></a>04235 
<a name="l04236"></a>04236 <span class="preprocessor">#ifdef NEW_BNX2X_HSI</span>
<a name="l04237"></a>04237 <span class="preprocessor"></span>    eq_idx = CNIC_RD16(dev, BAR_CSTRORM_INTMEM +
<a name="l04238"></a>04238                CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET(port, sb_id) +
<a name="l04239"></a>04239                offsetof(<span class="keyword">struct</span> <a class="code" href="structcstorm__status__block__c.html">cstorm_status_block_c</a>,
<a name="l04240"></a>04240                     index_values[HC_INDEX_C_ISCSI_EQ_CONS]));
<a name="l04241"></a>04241 <span class="preprocessor">#else</span>
<a name="l04242"></a>04242 <span class="preprocessor"></span>    eq_idx = CNIC_RD16(dev, BAR_CSTRORM_INTMEM +
<a name="l04243"></a>04243                CSTORM_SB_HOST_STATUS_BLOCK_OFFSET(port, sb_id) +
<a name="l04244"></a>04244                offsetof(<span class="keyword">struct</span> cstorm_status_block,
<a name="l04245"></a>04245                     index_values[HC_INDEX_C_ISCSI_EQ_CONS]));
<a name="l04246"></a>04246 <span class="preprocessor">#endif</span>
<a name="l04247"></a>04247 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (eq_idx != 0) {
<a name="l04248"></a>04248         printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: EQ cons index %x != 0\n&quot;</span>,
<a name="l04249"></a>04249                dev-&gt;netdev-&gt;name, eq_idx);
<a name="l04250"></a>04250         <span class="keywordflow">return</span> -EBUSY;
<a name="l04251"></a>04251     }
<a name="l04252"></a>04252     ret = cnic_init_bnx2x_irq(dev);
<a name="l04253"></a>04253     <span class="keywordflow">if</span> (ret)
<a name="l04254"></a>04254         <span class="keywordflow">return</span> ret;
<a name="l04255"></a>04255 
<a name="l04256"></a>04256     <span class="keywordflow">return</span> 0;
<a name="l04257"></a>04257 }
<a name="l04258"></a>04258 
<a name="l04259"></a>04259 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_start_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04260"></a>04260 {
<a name="l04261"></a>04261     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04262"></a>04262     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = cp-&gt;ethdev;
<a name="l04263"></a>04263     <span class="keywordtype">int</span> err;
<a name="l04264"></a>04264 
<a name="l04265"></a>04265     <span class="keywordflow">if</span> (test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags))
<a name="l04266"></a>04266         <span class="keywordflow">return</span> -EALREADY;
<a name="l04267"></a>04267 
<a name="l04268"></a>04268 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04269"></a>04269 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!try_module_get(ethdev-&gt;drv_owner))
<a name="l04270"></a>04270         <span class="keywordflow">return</span> -EBUSY;
<a name="l04271"></a>04271 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04272"></a>04272 
<a name="l04273"></a>04273     dev-&gt;regview = ethdev-&gt;io_base;
<a name="l04274"></a>04274     cp-&gt;chip_id = ethdev-&gt;chip_id;
<a name="l04275"></a>04275     pci_dev_get(dev-&gt;pcidev);
<a name="l04276"></a>04276     cp-&gt;func = PCI_FUNC(dev-&gt;pcidev-&gt;devfn);
<a name="l04277"></a>04277     cp-&gt;status_blk = ethdev-&gt;irq_arr[0].status_blk;
<a name="l04278"></a>04278     cp-&gt;status_blk_num = ethdev-&gt;irq_arr[0].status_blk_num;
<a name="l04279"></a>04279 
<a name="l04280"></a>04280     err = cp-&gt;alloc_resc(dev);
<a name="l04281"></a>04281     <span class="keywordflow">if</span> (err) {
<a name="l04282"></a>04282         printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: allocate resource failure\n&quot;</span>,
<a name="l04283"></a>04283                dev-&gt;netdev-&gt;name);
<a name="l04284"></a>04284         <span class="keywordflow">goto</span> err1;
<a name="l04285"></a>04285     }
<a name="l04286"></a>04286 
<a name="l04287"></a>04287     err = cp-&gt;start_hw(dev);
<a name="l04288"></a>04288     <span class="keywordflow">if</span> (err)
<a name="l04289"></a>04289         <span class="keywordflow">goto</span> err1;
<a name="l04290"></a>04290 
<a name="l04291"></a>04291     err = cnic_cm_open(dev);
<a name="l04292"></a>04292     <span class="keywordflow">if</span> (err)
<a name="l04293"></a>04293         <span class="keywordflow">goto</span> err1;
<a name="l04294"></a>04294 
<a name="l04295"></a>04295     set_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags);
<a name="l04296"></a>04296 
<a name="l04297"></a>04297     cp-&gt;enable_int(dev);
<a name="l04298"></a>04298 
<a name="l04299"></a>04299     <span class="keywordflow">return</span> 0;
<a name="l04300"></a>04300 
<a name="l04301"></a>04301 err1:
<a name="l04302"></a>04302     cp-&gt;free_resc(dev);
<a name="l04303"></a>04303     pci_dev_put(dev-&gt;pcidev);
<a name="l04304"></a>04304 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04305"></a>04305 <span class="preprocessor"></span>    module_put(ethdev-&gt;drv_owner);
<a name="l04306"></a>04306 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04307"></a>04307     <span class="keywordflow">return</span> err;
<a name="l04308"></a>04308 }
<a name="l04309"></a>04309 
<a name="l04310"></a>04310 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_stop_bnx2_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04311"></a>04311 {
<a name="l04312"></a>04312     u32 val;
<a name="l04313"></a>04313 
<a name="l04314"></a>04314     cnic_disable_bnx2_int_sync(dev);
<a name="l04315"></a>04315 
<a name="l04316"></a>04316     val = cnic_reg_rd_ind(dev, BNX2_CP_SCRATCH + 0x20);
<a name="l04317"></a>04317     cnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, val &amp; ~0x1);
<a name="l04318"></a>04318 
<a name="l04319"></a>04319     val = cnic_reg_rd_ind(dev, BNX2_COM_SCRATCH + 0x20);
<a name="l04320"></a>04320     cnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, val &amp; ~0x1);
<a name="l04321"></a>04321 
<a name="l04322"></a>04322     cnic_init_context(dev, KWQ_CID);
<a name="l04323"></a>04323     cnic_init_context(dev, KCQ_CID);
<a name="l04324"></a>04324 
<a name="l04325"></a>04325     cnic_setup_5709_context(dev, 0);
<a name="l04326"></a>04326     cnic_free_irq(dev);
<a name="l04327"></a>04327 
<a name="l04328"></a>04328     cnic_free_resc(dev);
<a name="l04329"></a>04329 }
<a name="l04330"></a>04330 
<a name="l04331"></a>04331 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_stop_bnx2x_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04332"></a>04332 {
<a name="l04333"></a>04333     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04334"></a>04334     u8 sb_id = cp-&gt;status_blk_num;
<a name="l04335"></a>04335     <span class="keywordtype">int</span> port = CNIC_PORT(cp);
<a name="l04336"></a>04336 
<a name="l04337"></a>04337     cnic_free_irq(dev);
<a name="l04338"></a>04338 <span class="preprocessor">#ifdef NEW_BNX2X_HSI</span>
<a name="l04339"></a>04339 <span class="preprocessor"></span>    CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
<a name="l04340"></a>04340           CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET(port, sb_id) +
<a name="l04341"></a>04341           offsetof(<span class="keyword">struct</span> <a class="code" href="structcstorm__status__block__c.html">cstorm_status_block_c</a>,
<a name="l04342"></a>04342                index_values[HC_INDEX_C_ISCSI_EQ_CONS]),
<a name="l04343"></a>04343           0);
<a name="l04344"></a>04344 <span class="preprocessor">#else</span>
<a name="l04345"></a>04345 <span class="preprocessor"></span>    CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
<a name="l04346"></a>04346           CSTORM_SB_HOST_STATUS_BLOCK_OFFSET(port, sb_id) +
<a name="l04347"></a>04347           offsetof(<span class="keyword">struct</span> cstorm_status_block,
<a name="l04348"></a>04348                index_values[HC_INDEX_C_ISCSI_EQ_CONS]),
<a name="l04349"></a>04349           0);
<a name="l04350"></a>04350 <span class="preprocessor">#endif</span>
<a name="l04351"></a>04351 <span class="preprocessor"></span>    CNIC_WR(dev, BAR_CSTRORM_INTMEM + 
<a name="l04352"></a>04352         CSTORM_ISCSI_EQ_CONS_OFFSET(cp-&gt;func, 0), 0);
<a name="l04353"></a>04353     CNIC_WR16(dev, cp-&gt;kcq_io_addr, 0);
<a name="l04354"></a>04354     cnic_free_resc(dev);
<a name="l04355"></a>04355 }
<a name="l04356"></a>04356 
<a name="l04357"></a>04357 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_stop_hw(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev)
<a name="l04358"></a>04358 {
<a name="l04359"></a>04359     <span class="keywordflow">if</span> (test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags)) {
<a name="l04360"></a>04360         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04361"></a>04361 
<a name="l04362"></a>04362         clear_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags);
<a name="l04363"></a>04363         rcu_assign_pointer(cp-&gt;ulp_ops[CNIC_ULP_L4], NULL);
<a name="l04364"></a>04364         synchronize_rcu();
<a name="l04365"></a>04365         cnic_cm_shutdown(dev);
<a name="l04366"></a>04366         cp-&gt;stop_hw(dev);
<a name="l04367"></a>04367         pci_dev_put(dev-&gt;pcidev);
<a name="l04368"></a>04368 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04369"></a>04369 <span class="preprocessor"></span>        module_put(cp-&gt;ethdev-&gt;drv_owner);
<a name="l04370"></a>04370 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04371"></a>04371     }
<a name="l04372"></a>04372 }
<a name="l04373"></a>04373 
<a name="l04374"></a>04374 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *alloc_cnic(<span class="keyword">struct</span> net_device *dev)
<a name="l04375"></a>04375 {
<a name="l04376"></a>04376     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cdev;
<a name="l04377"></a>04377     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp;
<a name="l04378"></a>04378     <span class="keywordtype">int</span> alloc_size;
<a name="l04379"></a>04379 
<a name="l04380"></a>04380     alloc_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a>) + sizeof(struct <a class="code" href="structcnic__local.html">cnic_local</a>);
<a name="l04381"></a>04381 
<a name="l04382"></a>04382     cdev = kmalloc(alloc_size , GFP_KERNEL);
<a name="l04383"></a>04383     <span class="keywordflow">if</span> (cdev == NULL) {
<a name="l04384"></a>04384         printk(KERN_ERR PFX <span class="stringliteral">&quot;%s: allocate dev struct failure\n&quot;</span>,
<a name="l04385"></a>04385                dev-&gt;name);
<a name="l04386"></a>04386         <span class="keywordflow">return</span> NULL;
<a name="l04387"></a>04387     }
<a name="l04388"></a>04388     memset(cdev, 0, alloc_size);
<a name="l04389"></a>04389 
<a name="l04390"></a>04390     cdev-&gt;netdev = dev;
<a name="l04391"></a>04391     cdev-&gt;cnic_priv = (<span class="keywordtype">char</span> *)cdev + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a>);
<a name="l04392"></a>04392     cdev-&gt;register_device = cnic_register_device;
<a name="l04393"></a>04393     cdev-&gt;unregister_device = cnic_unregister_device;
<a name="l04394"></a>04394     cp = cdev-&gt;cnic_priv;
<a name="l04395"></a>04395     cp-&gt;dev = cdev;
<a name="l04396"></a>04396 
<a name="l04397"></a>04397     spin_lock_init(&amp;cp-&gt;cnic_ulp_lock);
<a name="l04398"></a>04398     printk(KERN_INFO PFX <span class="stringliteral">&quot;Added CNIC device: %s\n&quot;</span>, dev-&gt;name);
<a name="l04399"></a>04399 
<a name="l04400"></a>04400     <span class="keywordflow">return</span> cdev;
<a name="l04401"></a>04401 }
<a name="l04402"></a>04402 
<a name="l04403"></a>04403 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *init_bnx2_cnic(<span class="keyword">struct</span> net_device *dev)
<a name="l04404"></a>04404 {
<a name="l04405"></a>04405     <span class="keyword">struct </span>pci_dev *pdev;
<a name="l04406"></a>04406     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cdev;
<a name="l04407"></a>04407     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp;
<a name="l04408"></a>04408     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = NULL;
<a name="l04409"></a>04409     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *(*probe)(<span class="keyword">struct </span>net_device *) = NULL;
<a name="l04410"></a>04410 
<a name="l04411"></a>04411 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l04412"></a>04412 <span class="preprocessor"></span>    probe = vmk_ModuleGetSymbol(<span class="stringliteral">&quot;bnx2_cnic_probe&quot;</span>);
<a name="l04413"></a>04413 <span class="preprocessor">#else  </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04414"></a>04414     probe = symbol_get(bnx2_cnic_probe);
<a name="l04415"></a>04415 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l04416"></a>04416     <span class="keywordflow">if</span> (probe) {
<a name="l04417"></a>04417         ethdev = (*probe)(dev);
<a name="l04418"></a>04418 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04419"></a>04419 <span class="preprocessor"></span>        symbol_put(bnx2_cnic_probe);
<a name="l04420"></a>04420 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l04421"></a>04421     }
<a name="l04422"></a>04422     <span class="keywordflow">if</span> (!ethdev)
<a name="l04423"></a>04423         <span class="keywordflow">return</span> NULL;
<a name="l04424"></a>04424 
<a name="l04425"></a>04425     pdev = ethdev-&gt;pdev;
<a name="l04426"></a>04426     <span class="keywordflow">if</span> (!pdev)
<a name="l04427"></a>04427         <span class="keywordflow">return</span> NULL;
<a name="l04428"></a>04428 
<a name="l04429"></a>04429     dev_hold(dev);
<a name="l04430"></a>04430     pci_dev_get(pdev);
<a name="l04431"></a>04431     <span class="keywordflow">if</span> (pdev-&gt;device == PCI_DEVICE_ID_NX2_5709 ||
<a name="l04432"></a>04432         pdev-&gt;device == PCI_DEVICE_ID_NX2_5709S) {
<a name="l04433"></a>04433         u8 rev;
<a name="l04434"></a>04434 
<a name="l04435"></a>04435         pci_read_config_byte(pdev, PCI_REVISION_ID, &amp;rev);
<a name="l04436"></a>04436         <span class="keywordflow">if</span> (rev &lt; 0x10) {
<a name="l04437"></a>04437             pci_dev_put(pdev);
<a name="l04438"></a>04438             <span class="keywordflow">goto</span> cnic_err;
<a name="l04439"></a>04439         }
<a name="l04440"></a>04440     }
<a name="l04441"></a>04441     pci_dev_put(pdev);
<a name="l04442"></a>04442 
<a name="l04443"></a>04443     cdev = alloc_cnic(dev);
<a name="l04444"></a>04444     <span class="keywordflow">if</span> (cdev == NULL)
<a name="l04445"></a>04445         <span class="keywordflow">goto</span> cnic_err;
<a name="l04446"></a>04446 
<a name="l04447"></a>04447     set_bit(CNIC_F_BNX2_CLASS, &amp;cdev-&gt;flags);
<a name="l04448"></a>04448     cdev-&gt;submit_kwqes = cnic_submit_bnx2_kwqes;
<a name="l04449"></a>04449 
<a name="l04450"></a>04450     cp = cdev-&gt;cnic_priv;
<a name="l04451"></a>04451     cp-&gt;ethdev = ethdev;
<a name="l04452"></a>04452     cdev-&gt;pcidev = pdev;
<a name="l04453"></a>04453 
<a name="l04454"></a>04454     cp-&gt;cnic_ops = &amp;cnic_bnx2_ops;
<a name="l04455"></a>04455     cp-&gt;start_hw = cnic_start_bnx2_hw;
<a name="l04456"></a>04456     cp-&gt;stop_hw = cnic_stop_bnx2_hw;
<a name="l04457"></a>04457     cp-&gt;setup_pgtbl = cnic_setup_page_tbl;
<a name="l04458"></a>04458     cp-&gt;alloc_resc = cnic_alloc_bnx2_resc;
<a name="l04459"></a>04459     cp-&gt;free_resc = cnic_free_resc;
<a name="l04460"></a>04460     cp-&gt;start_cm = cnic_cm_init_bnx2_hw;
<a name="l04461"></a>04461     cp-&gt;stop_cm = cnic_cm_stop_bnx2_hw;
<a name="l04462"></a>04462     cp-&gt;enable_int = cnic_enable_bnx2_int;
<a name="l04463"></a>04463     cp-&gt;disable_int_sync = cnic_disable_bnx2_int_sync;
<a name="l04464"></a>04464     cp-&gt;close_conn = cnic_close_bnx2_conn;
<a name="l04465"></a>04465     cp-&gt;next_idx = cnic_bnx2_next_idx;
<a name="l04466"></a>04466     cp-&gt;hw_idx = cnic_bnx2_hw_idx;
<a name="l04467"></a>04467     <span class="keywordflow">return</span> cdev;
<a name="l04468"></a>04468 
<a name="l04469"></a>04469 cnic_err:
<a name="l04470"></a>04470     dev_put(dev);
<a name="l04471"></a>04471     <span class="keywordflow">return</span> NULL;
<a name="l04472"></a>04472 }
<a name="l04473"></a>04473 
<a name="l04474"></a>04474 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *init_bnx2x_cnic(<span class="keyword">struct</span> net_device *dev)
<a name="l04475"></a>04475 {
<a name="l04476"></a>04476     <span class="keyword">struct </span>pci_dev *pdev;
<a name="l04477"></a>04477     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cdev;
<a name="l04478"></a>04478     <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp;
<a name="l04479"></a>04479     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *ethdev = NULL;
<a name="l04480"></a>04480     <span class="keyword">struct </span><a class="code" href="structcnic__eth__dev.html">cnic_eth_dev</a> *(*probe)(<span class="keyword">struct </span>net_device *) = NULL;
<a name="l04481"></a>04481 
<a name="l04482"></a>04482 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l04483"></a>04483 <span class="preprocessor"></span>    probe = vmk_ModuleGetSymbol(<span class="stringliteral">&quot;bnx2x_cnic_probe&quot;</span>);
<a name="l04484"></a>04484 <span class="preprocessor">#else </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04485"></a>04485     probe = symbol_get(bnx2x_cnic_probe);
<a name="l04486"></a>04486 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l04487"></a>04487     <span class="keywordflow">if</span> (probe) {
<a name="l04488"></a>04488         ethdev = (*probe)(dev);
<a name="l04489"></a>04489 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04490"></a>04490 <span class="preprocessor"></span>        symbol_put(bnx2x_cnic_probe);
<a name="l04491"></a>04491 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l04492"></a>04492     }
<a name="l04493"></a>04493     <span class="keywordflow">if</span> (!ethdev)
<a name="l04494"></a>04494         <span class="keywordflow">return</span> NULL;
<a name="l04495"></a>04495 
<a name="l04496"></a>04496     pdev = ethdev-&gt;pdev;
<a name="l04497"></a>04497     <span class="keywordflow">if</span> (!pdev)
<a name="l04498"></a>04498         <span class="keywordflow">return</span> NULL;
<a name="l04499"></a>04499 
<a name="l04500"></a>04500     dev_hold(dev);
<a name="l04501"></a>04501     cdev = alloc_cnic(dev);
<a name="l04502"></a>04502     <span class="keywordflow">if</span> (cdev == NULL) {
<a name="l04503"></a>04503         dev_put(dev);
<a name="l04504"></a>04504         <span class="keywordflow">return</span> NULL;
<a name="l04505"></a>04505     }
<a name="l04506"></a>04506 
<a name="l04507"></a>04507     set_bit(CNIC_F_BNX2X_CLASS, &amp;cdev-&gt;flags);
<a name="l04508"></a>04508     cdev-&gt;submit_kwqes = cnic_submit_bnx2x_kwqes;
<a name="l04509"></a>04509 
<a name="l04510"></a>04510     cp = cdev-&gt;cnic_priv;
<a name="l04511"></a>04511     cp-&gt;ethdev = ethdev;
<a name="l04512"></a>04512     cdev-&gt;pcidev = pdev;
<a name="l04513"></a>04513 
<a name="l04514"></a>04514     cp-&gt;cnic_ops = &amp;cnic_bnx2x_ops;
<a name="l04515"></a>04515     cp-&gt;start_hw = cnic_start_bnx2x_hw;
<a name="l04516"></a>04516     cp-&gt;stop_hw = cnic_stop_bnx2x_hw;
<a name="l04517"></a>04517     cp-&gt;setup_pgtbl = cnic_setup_page_tbl_le;
<a name="l04518"></a>04518     cp-&gt;alloc_resc = cnic_alloc_bnx2x_resc;
<a name="l04519"></a>04519     cp-&gt;free_resc = cnic_free_resc;
<a name="l04520"></a>04520     cp-&gt;start_cm = cnic_cm_init_bnx2x_hw;
<a name="l04521"></a>04521     cp-&gt;stop_cm = cnic_cm_stop_bnx2x_hw;
<a name="l04522"></a>04522     cp-&gt;enable_int = cnic_enable_bnx2x_int;
<a name="l04523"></a>04523     cp-&gt;disable_int_sync = cnic_disable_bnx2x_int_sync;
<a name="l04524"></a>04524     cp-&gt;ack_int = cnic_ack_bnx2x_msix;
<a name="l04525"></a>04525     cp-&gt;close_conn = cnic_close_bnx2x_conn;
<a name="l04526"></a>04526     cp-&gt;next_idx = cnic_bnx2x_next_idx;
<a name="l04527"></a>04527     cp-&gt;hw_idx = cnic_bnx2x_hw_idx;
<a name="l04528"></a>04528     <span class="keywordflow">return</span> cdev;
<a name="l04529"></a>04529 }
<a name="l04530"></a>04530 
<a name="l04531"></a>04531 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *is_cnic_dev(<span class="keyword">struct</span> net_device *dev)
<a name="l04532"></a>04532 {
<a name="l04533"></a>04533     <span class="keyword">struct </span>ethtool_drvinfo drvinfo;
<a name="l04534"></a>04534     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *cdev = NULL;
<a name="l04535"></a>04535 
<a name="l04536"></a>04536     <span class="keywordflow">if</span> (dev-&gt;ethtool_ops &amp;&amp; dev-&gt;ethtool_ops-&gt;get_drvinfo) {
<a name="l04537"></a>04537         memset(&amp;drvinfo, 0, <span class="keyword">sizeof</span>(drvinfo));
<a name="l04538"></a>04538         dev-&gt;ethtool_ops-&gt;get_drvinfo(dev, &amp;drvinfo);
<a name="l04539"></a>04539         
<a name="l04540"></a>04540         <span class="keywordflow">if</span> (!strcmp(drvinfo.driver, <span class="stringliteral">&quot;bnx2&quot;</span>))
<a name="l04541"></a>04541             cdev = init_bnx2_cnic(dev);
<a name="l04542"></a>04542         <span class="keywordflow">if</span> (!strcmp(drvinfo.driver, <span class="stringliteral">&quot;bnx2x&quot;</span>))
<a name="l04543"></a>04543             cdev = init_bnx2x_cnic(dev);
<a name="l04544"></a>04544         <span class="keywordflow">if</span> (cdev) {
<a name="l04545"></a>04545 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04546"></a>04546 <span class="preprocessor"></span>            write_lock(&amp;cnic_dev_lock);
<a name="l04547"></a>04547 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04548"></a>04548             list_add(&amp;cdev-&gt;list, &amp;cnic_dev_list);
<a name="l04549"></a>04549 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04550"></a>04550 <span class="preprocessor"></span>            write_unlock(&amp;cnic_dev_lock);
<a name="l04551"></a>04551 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04552"></a>04552         }
<a name="l04553"></a>04553     }
<a name="l04554"></a>04554     <span class="keywordflow">return</span> cdev;
<a name="l04555"></a>04555 }
<a name="l04556"></a>04556 
<a name="l04560"></a>04560 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04561"></a>04561 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> cnic_ip_event(<span class="keyword">struct</span> notifier_block *<span class="keyword">this</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l04562"></a>04562                          <span class="keywordtype">void</span> *ptr)
<a name="l04563"></a>04563 {
<a name="l04564"></a>04564     <span class="keyword">struct </span>in_ifaddr *ifa = (<span class="keyword">struct </span>in_ifaddr *) ptr;
<a name="l04565"></a>04565     <span class="keyword">struct </span>net_device *netdev = (<span class="keyword">struct </span>net_device *) ifa-&gt;ifa_dev-&gt;dev;
<a name="l04566"></a>04566     <span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a> *dev;
<a name="l04567"></a>04567     <span class="keywordtype">int</span> if_type;
<a name="l04568"></a>04568     u32 my_dev = 0;
<a name="l04569"></a>04569 
<a name="l04570"></a>04570     read_lock(&amp;cnic_dev_lock);
<a name="l04571"></a>04571     list_for_each_entry(dev, &amp;cnic_dev_list, list) {
<a name="l04572"></a>04572         <span class="keywordflow">if</span> (netdev == dev-&gt;netdev) {
<a name="l04573"></a>04573             my_dev = 1;
<a name="l04574"></a>04574             cnic_hold(dev);
<a name="l04575"></a>04575             <span class="keywordflow">break</span>;
<a name="l04576"></a>04576         }
<a name="l04577"></a>04577     }
<a name="l04578"></a>04578     read_unlock(&amp;cnic_dev_lock);
<a name="l04579"></a>04579 
<a name="l04580"></a>04580     <span class="keywordflow">if</span> (my_dev) {
<a name="l04581"></a>04581         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04582"></a>04582 
<a name="l04583"></a>04583         rcu_read_lock();
<a name="l04584"></a>04584         <span class="keywordflow">for</span> (if_type = 0; if_type &lt; MAX_CNIC_ULP_TYPE; if_type++) {
<a name="l04585"></a>04585             <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l04586"></a>04586 
<a name="l04587"></a>04587             ulp_ops = rcu_dereference(cp-&gt;ulp_ops[if_type]);
<a name="l04588"></a>04588             <span class="keywordflow">if</span> (ulp_ops) {
<a name="l04589"></a>04589                 <span class="keywordtype">void</span> *ctx = cp-&gt;ulp_handle[if_type];
<a name="l04590"></a>04590 
<a name="l04591"></a>04591                 ulp_ops-&gt;indicate_inetevent(ctx, event);
<a name="l04592"></a>04592             }
<a name="l04593"></a>04593         }
<a name="l04594"></a>04594         rcu_read_unlock();
<a name="l04595"></a>04595 
<a name="l04596"></a>04596         cnic_put(dev);
<a name="l04597"></a>04597     }
<a name="l04598"></a>04598 
<a name="l04599"></a>04599     <span class="keywordflow">return</span> NOTIFY_DONE;
<a name="l04600"></a>04600 }
<a name="l04601"></a>04601 
<a name="l04605"></a>04605 <span class="keyword">static</span> <span class="keywordtype">int</span> cnic_netdev_event(<span class="keyword">struct</span> notifier_block *<span class="keyword">this</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l04606"></a>04606                              <span class="keywordtype">void</span> *ptr)
<a name="l04607"></a>04607 {
<a name="l04608"></a>04608     <span class="keyword">struct </span>net_device *netdev = ptr;
<a name="l04609"></a>04609     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev;
<a name="l04610"></a>04610     <span class="keywordtype">int</span> if_type;
<a name="l04611"></a>04611     <span class="keywordtype">int</span> new_dev = 0;
<a name="l04612"></a>04612 
<a name="l04613"></a>04613     dev = cnic_from_netdev(netdev);
<a name="l04614"></a>04614 
<a name="l04615"></a>04615     <span class="keywordflow">if</span> (!dev &amp;&amp; (event == NETDEV_REGISTER || event == NETDEV_UP)) {
<a name="l04616"></a>04616         <span class="comment">/* Check for the hot-plug device */</span>
<a name="l04617"></a>04617         dev = is_cnic_dev(netdev);
<a name="l04618"></a>04618         <span class="keywordflow">if</span> (dev) {
<a name="l04619"></a>04619             new_dev = 1;
<a name="l04620"></a>04620             cnic_hold(dev);
<a name="l04621"></a>04621         }
<a name="l04622"></a>04622     }
<a name="l04623"></a>04623     <span class="keywordflow">if</span> (dev) {
<a name="l04624"></a>04624         <span class="keyword">struct </span><a class="code" href="structcnic__local.html">cnic_local</a> *cp = dev-&gt;cnic_priv;
<a name="l04625"></a>04625 
<a name="l04626"></a>04626         <span class="keywordflow">if</span> (new_dev)
<a name="l04627"></a>04627             cnic_ulp_init(dev);
<a name="l04628"></a>04628         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event == NETDEV_UNREGISTER)
<a name="l04629"></a>04629             cnic_ulp_exit(dev);
<a name="l04630"></a>04630 
<a name="l04631"></a>04631         <span class="keywordflow">if</span> (event == NETDEV_UP) {
<a name="l04632"></a>04632             <span class="keywordflow">if</span> (cnic_register_netdev(dev) != 0) {
<a name="l04633"></a>04633                 cnic_put(dev);
<a name="l04634"></a>04634                 <span class="keywordflow">goto</span> done;
<a name="l04635"></a>04635             }
<a name="l04636"></a>04636             set_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags);
<a name="l04637"></a>04637             <span class="keywordflow">if</span> (dev-&gt;use_count) {
<a name="l04638"></a>04638                 <span class="keywordflow">if</span> (!cnic_start_hw(dev))
<a name="l04639"></a>04639                     cnic_ulp_start(dev);
<a name="l04640"></a>04640             }
<a name="l04641"></a>04641         }
<a name="l04642"></a>04642 
<a name="l04643"></a>04643         rcu_read_lock();
<a name="l04644"></a>04644         <span class="keywordflow">for</span> (if_type = 0; if_type &lt; MAX_CNIC_ULP_TYPE; if_type++) {
<a name="l04645"></a>04645             <span class="keyword">struct </span><a class="code" href="structcnic__ulp__ops.html">cnic_ulp_ops</a> *ulp_ops;
<a name="l04646"></a>04646             <span class="keywordtype">void</span> *ctx;
<a name="l04647"></a>04647 
<a name="l04648"></a>04648             ulp_ops = rcu_dereference(cp-&gt;ulp_ops[if_type]);
<a name="l04649"></a>04649             <span class="keywordflow">if</span> (!ulp_ops || !ulp_ops-&gt;indicate_netevent)
<a name="l04650"></a>04650                 <span class="keywordflow">continue</span>;
<a name="l04651"></a>04651 
<a name="l04652"></a>04652             ctx = cp-&gt;ulp_handle[if_type];
<a name="l04653"></a>04653 
<a name="l04654"></a>04654             ulp_ops-&gt;indicate_netevent(ctx, event);
<a name="l04655"></a>04655         }
<a name="l04656"></a>04656         rcu_read_unlock();
<a name="l04657"></a>04657 
<a name="l04658"></a>04658         <span class="keywordflow">if</span> (event == NETDEV_GOING_DOWN) {
<a name="l04659"></a>04659             clear_bit(CNIC_F_IF_UP, &amp;dev-&gt;flags);
<a name="l04660"></a>04660             set_bit(CNIC_F_IF_GOING_DOWN, &amp;dev-&gt;flags);
<a name="l04661"></a>04661             cnic_ulp_stop(dev);
<a name="l04662"></a>04662             cnic_stop_hw(dev);
<a name="l04663"></a>04663         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event == NETDEV_DOWN) {
<a name="l04664"></a>04664             clear_bit(CNIC_F_IF_GOING_DOWN, &amp;dev-&gt;flags);
<a name="l04665"></a>04665             cnic_unregister_netdev(dev);
<a name="l04666"></a>04666         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event == NETDEV_UNREGISTER) {
<a name="l04667"></a>04667             write_lock(&amp;cnic_dev_lock);
<a name="l04668"></a>04668             list_del_init(&amp;dev-&gt;list);
<a name="l04669"></a>04669             write_unlock(&amp;cnic_dev_lock);
<a name="l04670"></a>04670 
<a name="l04671"></a>04671             cnic_put(dev);
<a name="l04672"></a>04672             cnic_free_dev(dev);
<a name="l04673"></a>04673             <span class="keywordflow">goto</span> done;
<a name="l04674"></a>04674         }
<a name="l04675"></a>04675         cnic_put(dev);
<a name="l04676"></a>04676     }
<a name="l04677"></a>04677 done:
<a name="l04678"></a>04678     <span class="keywordflow">return</span> NOTIFY_DONE;
<a name="l04679"></a>04679 }
<a name="l04680"></a>04680 
<a name="l04681"></a>04681 <span class="keyword">static</span> <span class="keyword">struct </span>notifier_block cnic_ip_notifier = {
<a name="l04682"></a>04682     cnic_ip_event,
<a name="l04683"></a>04683     0
<a name="l04684"></a>04684 };
<a name="l04685"></a>04685 
<a name="l04686"></a>04686 <span class="keyword">static</span> <span class="keyword">struct </span>notifier_block cnic_netdev_notifier = {
<a name="l04687"></a>04687     cnic_netdev_event,
<a name="l04688"></a>04688     0
<a name="l04689"></a>04689 };
<a name="l04690"></a>04690 <span class="preprocessor">#endif </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04691"></a>04691 
<a name="l04692"></a>04692 <span class="keyword">static</span> <span class="keywordtype">void</span> cnic_release(<span class="keywordtype">void</span>)
<a name="l04693"></a>04693 {
<a name="l04694"></a>04694     <span class="keyword">struct </span><a class="code" href="structcnic__dev.html">cnic_dev</a> *dev;
<a name="l04695"></a>04695 
<a name="l04696"></a>04696     <span class="keywordflow">while</span> (!list_empty(&amp;cnic_dev_list)) {
<a name="l04697"></a>04697         dev = list_entry(cnic_dev_list.next, <span class="keyword">struct</span> <a class="code" href="structcnic__dev.html">cnic_dev</a>, list);
<a name="l04698"></a>04698         <span class="keywordflow">if</span> (test_bit(CNIC_F_CNIC_UP, &amp;dev-&gt;flags))
<a name="l04699"></a>04699             cnic_stop_hw(dev);
<a name="l04700"></a>04700 
<a name="l04701"></a>04701         cnic_unregister_netdev(dev);
<a name="l04702"></a>04702         list_del_init(&amp;dev-&gt;list);
<a name="l04703"></a>04703         cnic_free_dev(dev);
<a name="l04704"></a>04704     }
<a name="l04705"></a>04705 }
<a name="l04706"></a>04706 
<a name="l04707"></a>04707 <span class="keyword">static</span> <span class="keywordtype">int</span> __init cnic_init(<span class="keywordtype">void</span>)
<a name="l04708"></a>04708 {
<a name="l04709"></a>04709     <span class="keywordtype">int</span> rc = 0;
<a name="l04710"></a>04710 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l04711"></a>04711 <span class="preprocessor"></span>    <span class="keyword">struct </span>net_device *dev;
<a name="l04712"></a>04712 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l04713"></a>04713 
<a name="l04714"></a>04714     printk(KERN_INFO <span class="stringliteral">&quot;%s&quot;</span>, version);
<a name="l04715"></a>04715 
<a name="l04716"></a>04716 <span class="preprocessor">#if defined (__VMKLNX__)</span>
<a name="l04717"></a>04717 <span class="preprocessor"></span>    <span class="comment">/* Find Teton devices */</span>
<a name="l04718"></a>04718 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= 0x020618)</span>
<a name="l04719"></a>04719 <span class="preprocessor"></span>    for_each_netdev(&amp;init_net, dev)
<a name="l04720"></a>04720 <span class="preprocessor">#elif (LINUX_VERSION_CODE &gt;= 0x20616)</span>
<a name="l04721"></a>04721 <span class="preprocessor"></span>    for_each_netdev(dev)
<a name="l04722"></a>04722 <span class="preprocessor">#else</span>
<a name="l04723"></a>04723 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (dev = dev_base; dev; dev = dev-&gt;next)
<a name="l04724"></a>04724 #endif
<a name="l04725"></a>04725         is_cnic_dev(dev);
<a name="l04726"></a>04726 
<a name="l04727"></a>04727 <span class="preprocessor">#else  </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04728"></a>04728 
<a name="l04729"></a>04729     rc = register_inetaddr_notifier(&amp;cnic_ip_notifier);
<a name="l04730"></a>04730     <span class="keywordflow">if</span> (rc)
<a name="l04731"></a>04731         cnic_release();
<a name="l04732"></a>04732     rc = register_netdevice_notifier(&amp;cnic_netdev_notifier);
<a name="l04733"></a>04733     <span class="keywordflow">if</span> (rc) {
<a name="l04734"></a>04734         unregister_inetaddr_notifier(&amp;cnic_ip_notifier);
<a name="l04735"></a>04735         cnic_release();
<a name="l04736"></a>04736     }
<a name="l04737"></a>04737 <span class="preprocessor">#endif  </span><span class="comment">/* defined (__VMKLNX__) */</span>
<a name="l04738"></a>04738     <span class="keywordflow">return</span> rc;
<a name="l04739"></a>04739 }
<a name="l04740"></a>04740 
<a name="l04741"></a>04741 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit cnic_exit(<span class="keywordtype">void</span>)
<a name="l04742"></a>04742 {
<a name="l04743"></a>04743 <span class="preprocessor">#if !defined (__VMKLNX__)</span>
<a name="l04744"></a>04744 <span class="preprocessor"></span>    unregister_inetaddr_notifier(&amp;cnic_ip_notifier);
<a name="l04745"></a>04745     unregister_netdevice_notifier(&amp;cnic_netdev_notifier);
<a name="l04746"></a>04746 <span class="preprocessor">#endif  </span><span class="comment">/* !defined (__VMKLNX__) */</span>
<a name="l04747"></a>04747     cnic_release();
<a name="l04748"></a>04748     <span class="keywordflow">return</span>;
<a name="l04749"></a>04749 }
<a name="l04750"></a>04750 
<a name="l04751"></a>04751 module_init(cnic_init);
<a name="l04752"></a>04752 module_exit(cnic_exit);
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:20 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
