<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/userland/libpcap-1.1.1-ring/pcap-usb-linux.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_e1ebd79ad454b9bb4e17c3fdb9c56974.html">userland</a>      </li>
      <li class="navelem"><a class="el" href="dir_3e8db0da4aaaf3c3907d9d42dee971d2.html">libpcap-1.1.1-ring</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">pcap-usb-linux.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2006 Paolo Abeni (Italy)</span>
<a name="l00003"></a>00003 <span class="comment"> * All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00006"></a>00006 <span class="comment"> * modification, are permitted provided that the following conditions</span>
<a name="l00007"></a>00007 <span class="comment"> * are met:</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="l00010"></a>00010 <span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<a name="l00011"></a>00011 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00012"></a>00012 <span class="comment"> * notice, this list of conditions and the following disclaimer in the</span>
<a name="l00013"></a>00013 <span class="comment"> * documentation and/or other materials provided with the distribution.</span>
<a name="l00014"></a>00014 <span class="comment"> * 3. The name of the author may not be used to endorse or promote </span>
<a name="l00015"></a>00015 <span class="comment"> * products derived from this software without specific prior written </span>
<a name="l00016"></a>00016 <span class="comment"> * permission.</span>
<a name="l00017"></a>00017 <span class="comment"> *</span>
<a name="l00018"></a>00018 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00019"></a>00019 <span class="comment"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00020"></a>00020 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00021"></a>00021 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00022"></a>00022 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00023"></a>00023 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00024"></a>00024 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00028"></a>00028 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * USB sniffing API implementation for Linux platform</span>
<a name="l00031"></a>00031 <span class="comment"> * By Paolo Abeni &lt;paolo.abeni@email.it&gt;</span>
<a name="l00032"></a>00032 <span class="comment"> * Modifications: Kris Katterjohn &lt;katterjohn@gmail.com&gt;</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> */</span>
<a name="l00035"></a>00035 <span class="preprocessor">#ifndef lint</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> rcsid[] _U_ =
<a name="l00037"></a>00037     <span class="stringliteral">&quot;@(#) $Header: /tcpdump/master/libpcap/pcap-usb-linux.c,v 1.33 2008-12-23 21:38:50 guy Exp $ (LBL)&quot;</span>;
<a name="l00038"></a>00038 <span class="preprocessor">#endif</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span> 
<a name="l00040"></a>00040 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#include &quot;config.h&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#endif</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;pcap-int.h&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;pcap-usb-linux.h&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;pcap/usb.h&quot;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#ifdef NEED_STRERROR_H</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#include &quot;strerror.h&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;dirent.h&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;byteswap.h&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;sys/mman.h&gt;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#ifdef HAVE_LINUX_USBDEVICE_FS_H</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/usbdevice_fs.h&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#endif</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a>00067 <span class="preprocessor">#define USB_IFACE &quot;usbmon&quot;</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define USB_TEXT_DIR_OLD &quot;/sys/kernel/debug/usbmon&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#define USB_TEXT_DIR &quot;/sys/kernel/debug/usb/usbmon&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define SYS_USB_BUS_DIR &quot;/sys/bus/usb/devices&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#define PROC_USB_BUS_DIR &quot;/proc/bus/usb&quot;</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#define USB_LINE_LEN 4096</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span>
<a name="l00074"></a>00074 <span class="preprocessor">#if __BYTE_ORDER == __LITTLE_ENDIAN</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define htols(s) s</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define htoll(l) l</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#define htol64(ll) ll</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#define htols(s) bswap_16(s)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#define htoll(l) bswap_32(l)</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#define htol64(ll) bswap_64(ll)</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a><a class="code" href="structmon__bin__stats.html">00084</a> <span class="keyword">struct </span><a class="code" href="structmon__bin__stats.html">mon_bin_stats</a> {
<a name="l00085"></a>00085     u_int32_t queued;
<a name="l00086"></a>00086     u_int32_t dropped;
<a name="l00087"></a>00087 };
<a name="l00088"></a>00088 
<a name="l00089"></a><a class="code" href="structmon__bin__get.html">00089</a> <span class="keyword">struct </span><a class="code" href="structmon__bin__get.html">mon_bin_get</a> {
<a name="l00090"></a>00090     <a class="code" href="struct__usb__header.html">pcap_usb_header</a> *hdr;
<a name="l00091"></a>00091     <span class="keywordtype">void</span> *data;
<a name="l00092"></a>00092     <span class="keywordtype">size_t</span> data_len;   <span class="comment">/* Length of data (can be zero) */</span>
<a name="l00093"></a>00093 };
<a name="l00094"></a>00094 
<a name="l00095"></a><a class="code" href="structmon__bin__mfetch.html">00095</a> <span class="keyword">struct </span><a class="code" href="structmon__bin__mfetch.html">mon_bin_mfetch</a> {
<a name="l00096"></a>00096     int32_t *offvec;   <span class="comment">/* Vector of events fetched */</span>
<a name="l00097"></a>00097     int32_t nfetch;    <span class="comment">/* Number of events to fetch (out: fetched) */</span>
<a name="l00098"></a>00098     int32_t nflush;    <span class="comment">/* Number of events to flush */</span>
<a name="l00099"></a>00099 };
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="preprocessor">#define MON_IOC_MAGIC 0x92</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="preprocessor">#define MON_IOCQ_URB_LEN _IO(MON_IOC_MAGIC, 1)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#define MON_IOCX_URB  _IOWR(MON_IOC_MAGIC, 2, struct mon_bin_hdr)</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#define MON_IOCG_STATS _IOR(MON_IOC_MAGIC, 3, struct mon_bin_stats)</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#define MON_IOCT_RING_SIZE _IO(MON_IOC_MAGIC, 4)</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#define MON_IOCQ_RING_SIZE _IO(MON_IOC_MAGIC, 5)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#define MON_IOCX_GET   _IOW(MON_IOC_MAGIC, 6, struct mon_bin_get)</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#define MON_IOCX_MFETCH _IOWR(MON_IOC_MAGIC, 7, struct mon_bin_mfetch)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="preprocessor">#define MON_IOCH_MFLUSH _IO(MON_IOC_MAGIC, 8)</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>
<a name="l00112"></a>00112 <span class="preprocessor">#define MON_BIN_SETUP   0x1 </span><span class="comment">/* setup hdr is present*/</span>
<a name="l00113"></a>00113 <span class="preprocessor">#define MON_BIN_SETUP_ZERO  0x2 </span><span class="comment">/* setup buffer is not available */</span>
<a name="l00114"></a>00114 <span class="preprocessor">#define MON_BIN_DATA_ZERO   0x4 </span><span class="comment">/* data buffer is not available */</span>
<a name="l00115"></a>00115 <span class="preprocessor">#define MON_BIN_ERROR   0x8</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="comment">/* forward declaration */</span>
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_activate(<a class="code" href="structpcap.html">pcap_t</a> *);
<a name="l00119"></a>00119 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_stats_linux(<a class="code" href="structpcap.html">pcap_t</a> *, <span class="keyword">struct</span> <a class="code" href="structpcap__stat.html">pcap_stat</a> *);
<a name="l00120"></a>00120 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_stats_linux_bin(<a class="code" href="structpcap.html">pcap_t</a> *, <span class="keyword">struct</span> <a class="code" href="structpcap__stat.html">pcap_stat</a> *);
<a name="l00121"></a>00121 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_read_linux(<a class="code" href="structpcap.html">pcap_t</a> *, <span class="keywordtype">int</span> , pcap_handler , u_char *);
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_read_linux_bin(<a class="code" href="structpcap.html">pcap_t</a> *, <span class="keywordtype">int</span> , pcap_handler , u_char *);
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_read_linux_mmap(<a class="code" href="structpcap.html">pcap_t</a> *, <span class="keywordtype">int</span> , pcap_handler , u_char *);
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_inject_linux(<a class="code" href="structpcap.html">pcap_t</a> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keywordtype">size_t</span>);
<a name="l00125"></a>00125 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_setfilter_linux(<a class="code" href="structpcap.html">pcap_t</a> *, <span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *);
<a name="l00126"></a>00126 <span class="keyword">static</span> <span class="keywordtype">int</span> usb_setdirection_linux(<a class="code" href="structpcap.html">pcap_t</a> *, pcap_direction_t);
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keywordtype">void</span> usb_cleanup_linux_mmap(<a class="code" href="structpcap.html">pcap_t</a> *);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="comment">/* facility to add an USB device to the device list*/</span>
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00131"></a>00131 usb_dev_add(<a class="code" href="structpcap__if.html">pcap_if_t</a>** alldevsp, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *err_str)
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133     <span class="keywordtype">char</span> dev_name[10];
<a name="l00134"></a>00134     <span class="keywordtype">char</span> dev_descr[30]; 
<a name="l00135"></a>00135     snprintf(dev_name, 10, USB_IFACE<span class="stringliteral">&quot;%d&quot;</span>, n);
<a name="l00136"></a>00136     snprintf(dev_descr, 30, <span class="stringliteral">&quot;USB bus number %d&quot;</span>, n);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="keywordflow">if</span> (pcap_add_if(alldevsp, dev_name, 0, 
<a name="l00139"></a>00139         dev_descr, err_str) &lt; 0)
<a name="l00140"></a>00140         <span class="keywordflow">return</span> -1;
<a name="l00141"></a>00141     <span class="keywordflow">return</span> 0; 
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keywordtype">int</span> 
<a name="l00145"></a>00145 usb_platform_finddevs(<a class="code" href="structpcap__if.html">pcap_if_t</a> **alldevsp, <span class="keywordtype">char</span> *err_str)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147     <span class="keyword">struct </span>dirent* data;
<a name="l00148"></a>00148     <span class="keywordtype">int</span> ret = 0;
<a name="l00149"></a>00149     DIR* dir;
<a name="l00150"></a>00150     <span class="keywordtype">int</span> n;
<a name="l00151"></a>00151     <span class="keywordtype">char</span>* name;
<a name="l00152"></a>00152     <span class="keywordtype">size_t</span> len;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     <span class="comment">/* try scanning sysfs usb bus directory */</span>
<a name="l00155"></a>00155     dir = opendir(SYS_USB_BUS_DIR);
<a name="l00156"></a>00156     <span class="keywordflow">if</span> (dir != NULL) {
<a name="l00157"></a>00157         <span class="keywordflow">while</span> ((ret == 0) &amp;&amp; ((data = readdir(dir)) != 0)) {
<a name="l00158"></a>00158             name = data-&gt;d_name;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160             <span class="keywordflow">if</span> (strncmp(name, <span class="stringliteral">&quot;usb&quot;</span>, 3) != 0)
<a name="l00161"></a>00161                 <span class="keywordflow">continue</span>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163             <span class="keywordflow">if</span> (sscanf(&amp;name[3], <span class="stringliteral">&quot;%d&quot;</span>, &amp;n) == 0) 
<a name="l00164"></a>00164                 <span class="keywordflow">continue</span>;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166             ret = usb_dev_add(alldevsp, n, err_str);
<a name="l00167"></a>00167         }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         closedir(dir);
<a name="l00170"></a>00170         <span class="keywordflow">return</span> ret;
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173     <span class="comment">/* that didn&#39;t work; try scanning procfs usb bus directory */</span>
<a name="l00174"></a>00174     dir = opendir(PROC_USB_BUS_DIR);
<a name="l00175"></a>00175     <span class="keywordflow">if</span> (dir != NULL) {
<a name="l00176"></a>00176         <span class="keywordflow">while</span> ((ret == 0) &amp;&amp; ((data = readdir(dir)) != 0)) {
<a name="l00177"></a>00177             name = data-&gt;d_name;
<a name="l00178"></a>00178             len = strlen(name);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180             <span class="comment">/* if this file name does not end with a number it&#39;s not of our interest */</span>
<a name="l00181"></a>00181             <span class="keywordflow">if</span> ((len &lt; 1) || !isdigit(name[--len]))
<a name="l00182"></a>00182                 <span class="keywordflow">continue</span>;
<a name="l00183"></a>00183             <span class="keywordflow">while</span> (isdigit(name[--len]));
<a name="l00184"></a>00184             <span class="keywordflow">if</span> (sscanf(&amp;name[len+1], <span class="stringliteral">&quot;%d&quot;</span>, &amp;n) != 1) 
<a name="l00185"></a>00185                 <span class="keywordflow">continue</span>;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187             ret = usb_dev_add(alldevsp, n, err_str);
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190         closedir(dir);
<a name="l00191"></a>00191         <span class="keywordflow">return</span> ret;
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     <span class="comment">/* neither of them worked */</span>
<a name="l00195"></a>00195     <span class="keywordflow">return</span> 0;
<a name="l00196"></a>00196 }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="keyword">static</span> 
<a name="l00199"></a>00199 <span class="keywordtype">int</span> usb_mmap(<a class="code" href="structpcap.html">pcap_t</a>* handle)
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     <span class="keywordtype">int</span> len = ioctl(handle-&gt;fd, MON_IOCQ_RING_SIZE);
<a name="l00202"></a>00202     <span class="keywordflow">if</span> (len &lt; 0) 
<a name="l00203"></a>00203         <span class="keywordflow">return</span> 0;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205     handle-&gt;md.mmapbuflen = len;
<a name="l00206"></a>00206     handle-&gt;md.mmapbuf = mmap(0, handle-&gt;md.mmapbuflen, PROT_READ,
<a name="l00207"></a>00207         MAP_SHARED, handle-&gt;fd, 0);
<a name="l00208"></a>00208     <span class="keywordflow">return</span> handle-&gt;md.mmapbuf != MAP_FAILED;
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="preprocessor">#define CTRL_TIMEOUT    (5*1000)        </span><span class="comment">/* milliseconds */</span>
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="preprocessor">#define USB_DIR_IN      0x80</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span><span class="preprocessor">#define USB_TYPE_STANDARD   0x00</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span><span class="preprocessor">#define USB_RECIP_DEVICE    0x00</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>
<a name="l00217"></a>00217 <span class="preprocessor">#define USB_REQ_GET_DESCRIPTOR  6</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>
<a name="l00219"></a>00219 <span class="preprocessor">#define USB_DT_DEVICE       1</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>
<a name="l00221"></a>00221 <span class="comment">/* probe the descriptors of the devices attached to the bus */</span>
<a name="l00222"></a>00222 <span class="comment">/* the descriptors will end up in the captured packet stream */</span>
<a name="l00223"></a>00223 <span class="comment">/* and be decoded by external apps like wireshark */</span>
<a name="l00224"></a>00224 <span class="comment">/* without these identifying probes packet data can&#39;t be fully decoded */</span>
<a name="l00225"></a>00225 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00226"></a>00226 probe_devices(<span class="keywordtype">int</span> bus)
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228     <span class="keyword">struct </span>usbdevfs_ctrltransfer ctrl;
<a name="l00229"></a>00229     <span class="keyword">struct </span>dirent* data;
<a name="l00230"></a>00230     <span class="keywordtype">int</span> ret = 0;
<a name="l00231"></a>00231     <span class="keywordtype">char</span> buf[40];
<a name="l00232"></a>00232     DIR* dir;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     <span class="comment">/* scan usb bus directories for device nodes */</span>
<a name="l00235"></a>00235     snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;/dev/bus/usb/%03d&quot;</span>, bus);
<a name="l00236"></a>00236     dir = opendir(buf);
<a name="l00237"></a>00237     <span class="keywordflow">if</span> (!dir)
<a name="l00238"></a>00238         <span class="keywordflow">return</span>;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240     <span class="keywordflow">while</span> ((ret &gt;= 0) &amp;&amp; ((data = readdir(dir)) != 0)) {
<a name="l00241"></a>00241         <span class="keywordtype">int</span> fd;
<a name="l00242"></a>00242         <span class="keywordtype">char</span>* name = data-&gt;d_name;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244         <span class="keywordflow">if</span> (name[0] == <span class="charliteral">&#39;.&#39;</span>)
<a name="l00245"></a>00245             <span class="keywordflow">continue</span>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;/dev/bus/usb/%03d/%s&quot;</span>, bus, data-&gt;d_name);
<a name="l00248"></a>00248         
<a name="l00249"></a>00249         fd = open(buf, O_RDWR);
<a name="l00250"></a>00250         <span class="keywordflow">if</span> (fd == -1)
<a name="l00251"></a>00251             <span class="keywordflow">continue</span>;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         <span class="comment">/*</span>
<a name="l00254"></a>00254 <span class="comment">         * Sigh.  Different kernels have different member names</span>
<a name="l00255"></a>00255 <span class="comment">         * for this structure.</span>
<a name="l00256"></a>00256 <span class="comment">         */</span>
<a name="l00257"></a>00257 <span class="preprocessor">#ifdef HAVE_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span>        ctrl.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;
<a name="l00259"></a>00259         ctrl.bRequest = USB_REQ_GET_DESCRIPTOR;
<a name="l00260"></a>00260         ctrl.wValue = USB_DT_DEVICE &lt;&lt; 8;
<a name="l00261"></a>00261         ctrl.wIndex = 0;
<a name="l00262"></a>00262         ctrl.wLength = <span class="keyword">sizeof</span>(buf);
<a name="l00263"></a>00263 <span class="preprocessor">#else</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span>        ctrl.requesttype = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;
<a name="l00265"></a>00265         ctrl.request = USB_REQ_GET_DESCRIPTOR;
<a name="l00266"></a>00266         ctrl.value = USB_DT_DEVICE &lt;&lt; 8;
<a name="l00267"></a>00267         ctrl.index = 0;
<a name="l00268"></a>00268         ctrl.length = <span class="keyword">sizeof</span>(buf);
<a name="l00269"></a>00269 <span class="preprocessor">#endif</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span>        ctrl.data = buf;
<a name="l00271"></a>00271         ctrl.timeout = CTRL_TIMEOUT;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273         ret = ioctl(fd, USBDEVFS_CONTROL, &amp;ctrl);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         close(fd);
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277     closedir(dir);
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <a class="code" href="structpcap.html">pcap_t</a> *
<a name="l00281"></a>00281 usb_create(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdevice.html">device</a>, <span class="keywordtype">char</span> *ebuf)
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283     <a class="code" href="structpcap.html">pcap_t</a> *p;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     p = pcap_create_common(device, ebuf);
<a name="l00286"></a>00286     <span class="keywordflow">if</span> (p == NULL)
<a name="l00287"></a>00287         <span class="keywordflow">return</span> (NULL);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     p-&gt;activate_op = usb_activate;
<a name="l00290"></a>00290     <span class="keywordflow">return</span> (p);
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00294"></a>00294 usb_activate(<a class="code" href="structpcap.html">pcap_t</a>* handle)
<a name="l00295"></a>00295 {
<a name="l00296"></a>00296     <span class="keywordtype">char</span>        full_path[USB_LINE_LEN];
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="comment">/* Initialize some components of the pcap structure. */</span>
<a name="l00299"></a>00299     handle-&gt;bufsize = handle-&gt;snapshot;
<a name="l00300"></a>00300     handle-&gt;offset = 0;
<a name="l00301"></a>00301     handle-&gt;linktype = DLT_USB_LINUX;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     handle-&gt;inject_op = usb_inject_linux;
<a name="l00304"></a>00304     handle-&gt;setfilter_op = usb_setfilter_linux;
<a name="l00305"></a>00305     handle-&gt;setdirection_op = usb_setdirection_linux;
<a name="l00306"></a>00306     handle-&gt;set_datalink_op = NULL; <span class="comment">/* can&#39;t change data link type */</span>
<a name="l00307"></a>00307     handle-&gt;getnonblock_op = pcap_getnonblock_fd;
<a name="l00308"></a>00308     handle-&gt;setnonblock_op = pcap_setnonblock_fd;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="comment">/*get usb bus index from device name */</span>
<a name="l00311"></a>00311     <span class="keywordflow">if</span> (sscanf(handle-&gt;opt.source, USB_IFACE<span class="stringliteral">&quot;%d&quot;</span>, &amp;handle-&gt;md.ifindex) != 1)
<a name="l00312"></a>00312     {
<a name="l00313"></a>00313         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00314"></a>00314             <span class="stringliteral">&quot;Can&#39;t get USB bus index from %s&quot;</span>, handle-&gt;opt.source);
<a name="l00315"></a>00315         <span class="keywordflow">return</span> PCAP_ERROR;
<a name="l00316"></a>00316     }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     <span class="comment">/*now select the read method: try to open binary interface */</span>
<a name="l00319"></a>00319     snprintf(full_path, USB_LINE_LEN, LINUX_USB_MON_DEV<span class="stringliteral">&quot;%d&quot;</span>, handle-&gt;md.ifindex);  
<a name="l00320"></a>00320     handle-&gt;fd = open(full_path, O_RDONLY, 0);
<a name="l00321"></a>00321     <span class="keywordflow">if</span> (handle-&gt;fd &gt;= 0)
<a name="l00322"></a>00322     {
<a name="l00323"></a>00323         <span class="keywordflow">if</span> (handle-&gt;opt.rfmon) {
<a name="l00324"></a>00324             <span class="comment">/*</span>
<a name="l00325"></a>00325 <span class="comment">             * Monitor mode doesn&#39;t apply to USB devices.</span>
<a name="l00326"></a>00326 <span class="comment">             */</span>
<a name="l00327"></a>00327             close(handle-&gt;fd);
<a name="l00328"></a>00328             <span class="keywordflow">return</span> PCAP_ERROR_RFMON_NOTSUP;
<a name="l00329"></a>00329         }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         <span class="comment">/* binary api is available, try to use fast mmap access */</span>
<a name="l00332"></a>00332         <span class="keywordflow">if</span> (usb_mmap(handle)) {
<a name="l00333"></a>00333             handle-&gt;linktype = DLT_USB_LINUX_MMAPPED;
<a name="l00334"></a>00334             handle-&gt;stats_op = usb_stats_linux_bin;
<a name="l00335"></a>00335             handle-&gt;read_op = usb_read_linux_mmap;
<a name="l00336"></a>00336             handle-&gt;cleanup_op = usb_cleanup_linux_mmap;
<a name="l00337"></a>00337             probe_devices(handle-&gt;md.ifindex);
<a name="l00338"></a>00338 
<a name="l00339"></a>00339             <span class="comment">/*</span>
<a name="l00340"></a>00340 <span class="comment">             * &quot;handle-&gt;fd&quot; is a real file, so &quot;select()&quot; and</span>
<a name="l00341"></a>00341 <span class="comment">             * &quot;poll()&quot; work on it.</span>
<a name="l00342"></a>00342 <span class="comment">             */</span>
<a name="l00343"></a>00343             handle-&gt;selectable_fd = handle-&gt;fd;
<a name="l00344"></a>00344             <span class="keywordflow">return</span> 0;
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         <span class="comment">/* can&#39;t mmap, use plain binary interface access */</span>
<a name="l00348"></a>00348         handle-&gt;stats_op = usb_stats_linux_bin;
<a name="l00349"></a>00349         handle-&gt;read_op = usb_read_linux_bin;
<a name="l00350"></a>00350         probe_devices(handle-&gt;md.ifindex);
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     <span class="keywordflow">else</span> {
<a name="l00353"></a>00353         <span class="comment">/*Binary interface not available, try open text interface */</span>
<a name="l00354"></a>00354         snprintf(full_path, USB_LINE_LEN, USB_TEXT_DIR<span class="stringliteral">&quot;/%dt&quot;</span>, handle-&gt;md.ifindex);  
<a name="l00355"></a>00355         handle-&gt;fd = open(full_path, O_RDONLY, 0);
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (handle-&gt;fd &lt; 0)
<a name="l00357"></a>00357         {
<a name="l00358"></a>00358             <span class="keywordflow">if</span> (errno == ENOENT)
<a name="l00359"></a>00359             {
<a name="l00360"></a>00360                 <span class="comment">/*</span>
<a name="l00361"></a>00361 <span class="comment">                 * Not found at the new location; try</span>
<a name="l00362"></a>00362 <span class="comment">                 * the old location.</span>
<a name="l00363"></a>00363 <span class="comment">                 */</span>
<a name="l00364"></a>00364                 snprintf(full_path, USB_LINE_LEN, USB_TEXT_DIR_OLD<span class="stringliteral">&quot;/%dt&quot;</span>, handle-&gt;md.ifindex);  
<a name="l00365"></a>00365                 handle-&gt;fd = open(full_path, O_RDONLY, 0);
<a name="l00366"></a>00366             }
<a name="l00367"></a>00367             <span class="keywordflow">if</span> (handle-&gt;fd &lt; 0) {
<a name="l00368"></a>00368                 <span class="comment">/* no more fallback, give it up*/</span>
<a name="l00369"></a>00369                 snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00370"></a>00370                     <span class="stringliteral">&quot;Can&#39;t open USB bus file %s: %s&quot;</span>, full_path, strerror(errno));
<a name="l00371"></a>00371                 <span class="keywordflow">return</span> PCAP_ERROR;
<a name="l00372"></a>00372             }
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         <span class="keywordflow">if</span> (handle-&gt;opt.rfmon) {
<a name="l00376"></a>00376             <span class="comment">/*</span>
<a name="l00377"></a>00377 <span class="comment">             * Monitor mode doesn&#39;t apply to USB devices.</span>
<a name="l00378"></a>00378 <span class="comment">             */</span>
<a name="l00379"></a>00379             close(handle-&gt;fd);
<a name="l00380"></a>00380             <span class="keywordflow">return</span> PCAP_ERROR_RFMON_NOTSUP;
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         handle-&gt;stats_op = usb_stats_linux;
<a name="l00384"></a>00384         handle-&gt;read_op = usb_read_linux;
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387     <span class="comment">/*</span>
<a name="l00388"></a>00388 <span class="comment">     * &quot;handle-&gt;fd&quot; is a real file, so &quot;select()&quot; and &quot;poll()&quot;</span>
<a name="l00389"></a>00389 <span class="comment">     * work on it.</span>
<a name="l00390"></a>00390 <span class="comment">     */</span>
<a name="l00391"></a>00391     handle-&gt;selectable_fd = handle-&gt;fd;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393     <span class="comment">/* for plain binary access and text access we need to allocate the read</span>
<a name="l00394"></a>00394 <span class="comment">     * buffer */</span>
<a name="l00395"></a>00395     handle-&gt;buffer = malloc(handle-&gt;bufsize);
<a name="l00396"></a>00396     <span class="keywordflow">if</span> (!handle-&gt;buffer) {
<a name="l00397"></a>00397         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00398"></a>00398              <span class="stringliteral">&quot;malloc: %s&quot;</span>, pcap_strerror(errno));
<a name="l00399"></a>00399         close(handle-&gt;fd);
<a name="l00400"></a>00400         <span class="keywordflow">return</span> PCAP_ERROR;
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402     <span class="keywordflow">return</span> 0;
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> 
<a name="l00406"></a>00406 ascii_to_int(<span class="keywordtype">char</span> c)
<a name="l00407"></a>00407 {
<a name="l00408"></a>00408     <span class="keywordflow">return</span> c &lt; <span class="charliteral">&#39;A&#39;</span> ? c- <span class="charliteral">&#39;0&#39;</span>: ((c&lt;<span class="charliteral">&#39;a&#39;</span>) ? c - <span class="charliteral">&#39;A&#39;</span> + 10: c-<span class="charliteral">&#39;a&#39;</span>+10);
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="comment">/*</span>
<a name="l00412"></a>00412 <span class="comment"> * see &lt;linux-kernel-source&gt;/Documentation/usb/usbmon.txt and </span>
<a name="l00413"></a>00413 <span class="comment"> * &lt;linux-kernel-source&gt;/drivers/usb/mon/mon_text.c for urb string </span>
<a name="l00414"></a>00414 <span class="comment"> * format description</span>
<a name="l00415"></a>00415 <span class="comment"> */</span>
<a name="l00416"></a>00416 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00417"></a>00417 usb_read_linux(<a class="code" href="structpcap.html">pcap_t</a> *handle, <span class="keywordtype">int</span> max_packets, pcap_handler callback, u_char *user)
<a name="l00418"></a>00418 {
<a name="l00419"></a>00419     <span class="comment">/* see:</span>
<a name="l00420"></a>00420 <span class="comment">    * /usr/src/linux/Documentation/usb/usbmon.txt </span>
<a name="l00421"></a>00421 <span class="comment">    * for message format</span>
<a name="l00422"></a>00422 <span class="comment">    */</span>
<a name="l00423"></a>00423     <span class="keywordtype">unsigned</span> timestamp;
<a name="l00424"></a>00424     <span class="keywordtype">int</span> tag, cnt, ep_num, dev_addr, dummy, ret, urb_len, data_len;
<a name="l00425"></a>00425     <span class="keywordtype">char</span> etype, pipeid1, pipeid2, status[16], urb_tag, line[USB_LINE_LEN];
<a name="l00426"></a>00426     <span class="keywordtype">char</span> *<span class="keywordtype">string</span> = line;
<a name="l00427"></a>00427     u_char * rawdata = handle-&gt;buffer;
<a name="l00428"></a>00428     <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> pkth;
<a name="l00429"></a>00429     <a class="code" href="struct__usb__header.html">pcap_usb_header</a>* uhdr = (<a class="code" href="struct__usb__header.html">pcap_usb_header</a>*)handle-&gt;buffer;
<a name="l00430"></a>00430     u_char urb_transfer=0;
<a name="l00431"></a>00431     <span class="keywordtype">int</span> incoming=0;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">/* ignore interrupt system call errors */</span>
<a name="l00434"></a>00434     <span class="keywordflow">do</span> {
<a name="l00435"></a>00435         ret = read(handle-&gt;fd, line, USB_LINE_LEN - 1);
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (handle-&gt;break_loop)
<a name="l00437"></a>00437         {
<a name="l00438"></a>00438             handle-&gt;break_loop = 0;
<a name="l00439"></a>00439             <span class="keywordflow">return</span> -2;
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441     } <span class="keywordflow">while</span> ((ret == -1) &amp;&amp; (errno == EINTR));
<a name="l00442"></a>00442     <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l00443"></a>00443     {
<a name="l00444"></a>00444         <span class="keywordflow">if</span> (errno == EAGAIN)
<a name="l00445"></a>00445             <span class="keywordflow">return</span> 0;   <span class="comment">/* no data there */</span>
<a name="l00446"></a>00446 
<a name="l00447"></a>00447         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00448"></a>00448             <span class="stringliteral">&quot;Can&#39;t read from fd %d: %s&quot;</span>, handle-&gt;fd, strerror(errno));
<a name="l00449"></a>00449         <span class="keywordflow">return</span> -1;
<a name="l00450"></a>00450     }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452     <span class="comment">/* read urb header; %n argument may increment return value, but it&#39;s </span>
<a name="l00453"></a>00453 <span class="comment">    * not mandatory, so does not count on it*/</span>
<a name="l00454"></a>00454     <span class="keywordtype">string</span>[ret] = 0;
<a name="l00455"></a>00455     ret = sscanf(<span class="keywordtype">string</span>, <span class="stringliteral">&quot;%x %d %c %c%c:%d:%d %s%n&quot;</span>, &amp;tag, &amp;timestamp, &amp;etype, 
<a name="l00456"></a>00456         &amp;pipeid1, &amp;pipeid2, &amp;dev_addr, &amp;ep_num, status, 
<a name="l00457"></a>00457         &amp;cnt);
<a name="l00458"></a>00458     <span class="keywordflow">if</span> (ret &lt; 8)
<a name="l00459"></a>00459     {
<a name="l00460"></a>00460         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00461"></a>00461             <span class="stringliteral">&quot;Can&#39;t parse USB bus message &#39;%s&#39;, too few tokens (expected 8 got %d)&quot;</span>,
<a name="l00462"></a>00462             <span class="keywordtype">string</span>, ret);
<a name="l00463"></a>00463         <span class="keywordflow">return</span> -1;
<a name="l00464"></a>00464     }
<a name="l00465"></a>00465     uhdr-&gt;id = tag;
<a name="l00466"></a>00466     uhdr-&gt;device_address = dev_addr;
<a name="l00467"></a>00467     uhdr-&gt;bus_id = handle-&gt;md.ifindex;
<a name="l00468"></a>00468     uhdr-&gt;status = 0;
<a name="l00469"></a>00469     <span class="keywordtype">string</span> += cnt;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     <span class="comment">/* don&#39;t use usbmon provided timestamp, since it have low precision*/</span>
<a name="l00472"></a>00472     <span class="keywordflow">if</span> (gettimeofday(&amp;pkth.ts, NULL) &lt; 0) 
<a name="l00473"></a>00473     {
<a name="l00474"></a>00474         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00475"></a>00475             <span class="stringliteral">&quot;Can&#39;t get timestamp for message &#39;%s&#39; %d:%s&quot;</span>, 
<a name="l00476"></a>00476             <span class="keywordtype">string</span>, errno, strerror(errno));
<a name="l00477"></a>00477         <span class="keywordflow">return</span> -1;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479     uhdr-&gt;ts_sec = pkth.ts.tv_sec;
<a name="l00480"></a>00480     uhdr-&gt;ts_usec = pkth.ts.tv_usec;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="comment">/* parse endpoint information */</span>
<a name="l00483"></a>00483     <span class="keywordflow">if</span> (pipeid1 == <span class="charliteral">&#39;C&#39;</span>)
<a name="l00484"></a>00484         urb_transfer = URB_CONTROL;
<a name="l00485"></a>00485     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pipeid1 == <span class="charliteral">&#39;Z&#39;</span>)
<a name="l00486"></a>00486         urb_transfer = URB_ISOCHRONOUS;
<a name="l00487"></a>00487     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pipeid1 == <span class="charliteral">&#39;I&#39;</span>)
<a name="l00488"></a>00488         urb_transfer = URB_INTERRUPT;
<a name="l00489"></a>00489     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pipeid1 == <span class="charliteral">&#39;B&#39;</span>)
<a name="l00490"></a>00490         urb_transfer = URB_BULK;
<a name="l00491"></a>00491     <span class="keywordflow">if</span> (pipeid2 == <span class="charliteral">&#39;i&#39;</span>) {
<a name="l00492"></a>00492         ep_num |= URB_TRANSFER_IN;
<a name="l00493"></a>00493         incoming = 1;
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495     <span class="keywordflow">if</span> (etype == <span class="charliteral">&#39;C&#39;</span>)
<a name="l00496"></a>00496         incoming = !incoming;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498     <span class="comment">/* direction check*/</span>
<a name="l00499"></a>00499     <span class="keywordflow">if</span> (incoming)
<a name="l00500"></a>00500     {
<a name="l00501"></a>00501         <span class="keywordflow">if</span> (handle-&gt;direction == PCAP_D_OUT)
<a name="l00502"></a>00502             <span class="keywordflow">return</span> 0;
<a name="l00503"></a>00503     }
<a name="l00504"></a>00504     <span class="keywordflow">else</span>
<a name="l00505"></a>00505         <span class="keywordflow">if</span> (handle-&gt;direction == PCAP_D_IN)
<a name="l00506"></a>00506             <span class="keywordflow">return</span> 0;
<a name="l00507"></a>00507     uhdr-&gt;event_type = etype;
<a name="l00508"></a>00508     uhdr-&gt;transfer_type = urb_transfer;
<a name="l00509"></a>00509     uhdr-&gt;endpoint_number = ep_num;
<a name="l00510"></a>00510     pkth.caplen = <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header.html">pcap_usb_header</a>);
<a name="l00511"></a>00511     rawdata += <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header.html">pcap_usb_header</a>);
<a name="l00512"></a>00512 
<a name="l00513"></a>00513     <span class="comment">/* check if this is a setup packet */</span>
<a name="l00514"></a>00514     ret = sscanf(status, <span class="stringliteral">&quot;%d&quot;</span>, &amp;dummy);
<a name="l00515"></a>00515     <span class="keywordflow">if</span> (ret != 1)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517         <span class="comment">/* this a setup packet, setup data can be filled with underscore if</span>
<a name="l00518"></a>00518 <span class="comment">        * usbmon has not been able to read them, so we must parse this fields as </span>
<a name="l00519"></a>00519 <span class="comment">        * strings */</span>
<a name="l00520"></a>00520         <a class="code" href="struct__usb__setup.html">pcap_usb_setup</a>* shdr;
<a name="l00521"></a>00521         <span class="keywordtype">char</span> str1[3], str2[3], str3[5], str4[5], str5[5];
<a name="l00522"></a>00522         ret = sscanf(<span class="keywordtype">string</span>, <span class="stringliteral">&quot;%s %s %s %s %s%n&quot;</span>, str1, str2, str3, str4, 
<a name="l00523"></a>00523         str5, &amp;cnt);
<a name="l00524"></a>00524         <span class="keywordflow">if</span> (ret &lt; 5)
<a name="l00525"></a>00525         {
<a name="l00526"></a>00526             snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00527"></a>00527                 <span class="stringliteral">&quot;Can&#39;t parse USB bus message &#39;%s&#39;, too few tokens (expected 5 got %d)&quot;</span>,
<a name="l00528"></a>00528                 <span class="keywordtype">string</span>, ret);
<a name="l00529"></a>00529             <span class="keywordflow">return</span> -1;
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531         <span class="keywordtype">string</span> += cnt;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         <span class="comment">/* try to convert to corresponding integer */</span>
<a name="l00534"></a>00534         shdr = &amp;uhdr-&gt;setup;
<a name="l00535"></a>00535         shdr-&gt;bmRequestType = strtoul(str1, 0, 16);
<a name="l00536"></a>00536         shdr-&gt;bRequest = strtoul(str2, 0, 16);
<a name="l00537"></a>00537         shdr-&gt;wValue = htols(strtoul(str3, 0, 16));
<a name="l00538"></a>00538         shdr-&gt;wIndex = htols(strtoul(str4, 0, 16));
<a name="l00539"></a>00539         shdr-&gt;wLength = htols(strtoul(str5, 0, 16));
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         uhdr-&gt;setup_flag = 0;
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543     <span class="keywordflow">else</span> 
<a name="l00544"></a>00544         uhdr-&gt;setup_flag = 1;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546     <span class="comment">/* read urb data */</span>
<a name="l00547"></a>00547     ret = sscanf(<span class="keywordtype">string</span>, <span class="stringliteral">&quot; %d%n&quot;</span>, &amp;urb_len, &amp;cnt);
<a name="l00548"></a>00548     <span class="keywordflow">if</span> (ret &lt; 1)
<a name="l00549"></a>00549     {
<a name="l00550"></a>00550         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00551"></a>00551           <span class="stringliteral">&quot;Can&#39;t parse urb length from &#39;%s&#39;&quot;</span>, <span class="keywordtype">string</span>);
<a name="l00552"></a>00552         <span class="keywordflow">return</span> -1;
<a name="l00553"></a>00553     }
<a name="l00554"></a>00554     <span class="keywordtype">string</span> += cnt;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="comment">/* urb tag is not present if urb length is 0, so we can stop here </span>
<a name="l00557"></a>00557 <span class="comment">     * text parsing */</span>
<a name="l00558"></a>00558     pkth.len = urb_len+pkth.caplen;
<a name="l00559"></a>00559     uhdr-&gt;urb_len = urb_len;
<a name="l00560"></a>00560     uhdr-&gt;data_flag = 1;
<a name="l00561"></a>00561     data_len = 0;
<a name="l00562"></a>00562     <span class="keywordflow">if</span> (uhdr-&gt;urb_len == 0)
<a name="l00563"></a>00563         <span class="keywordflow">goto</span> got;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565     <span class="comment">/* check for data presence; data is present if and only if urb tag is &#39;=&#39; */</span>
<a name="l00566"></a>00566     <span class="keywordflow">if</span> (sscanf(<span class="keywordtype">string</span>, <span class="stringliteral">&quot; %c&quot;</span>, &amp;urb_tag) != 1)
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00569"></a>00569             <span class="stringliteral">&quot;Can&#39;t parse urb tag from &#39;%s&#39;&quot;</span>, <span class="keywordtype">string</span>);
<a name="l00570"></a>00570         <span class="keywordflow">return</span> -1;
<a name="l00571"></a>00571     }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     <span class="keywordflow">if</span> (urb_tag != <span class="charliteral">&#39;=&#39;</span>) 
<a name="l00574"></a>00574         <span class="keywordflow">goto</span> got;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     <span class="comment">/* skip urb tag and following space */</span>
<a name="l00577"></a>00577     <span class="keywordtype">string</span> += 3;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="comment">/* if we reach this point we got some urb data*/</span>
<a name="l00580"></a>00580     uhdr-&gt;data_flag = 0;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582     <span class="comment">/* read all urb data; if urb length is greater then the usbmon internal </span>
<a name="l00583"></a>00583 <span class="comment">     * buffer length used by the kernel to spool the URB, we get only</span>
<a name="l00584"></a>00584 <span class="comment">     * a partial information.</span>
<a name="l00585"></a>00585 <span class="comment">     * At least until linux 2.6.17 there is no way to set usbmon intenal buffer</span>
<a name="l00586"></a>00586 <span class="comment">     * length and default value is 130. */</span>
<a name="l00587"></a>00587     <span class="keywordflow">while</span> ((<span class="keywordtype">string</span>[0] != 0) &amp;&amp; (<span class="keywordtype">string</span>[1] != 0) &amp;&amp; (pkth.caplen &lt; handle-&gt;snapshot))
<a name="l00588"></a>00588     {
<a name="l00589"></a>00589         rawdata[0] = ascii_to_int(<span class="keywordtype">string</span>[0]) * 16 + ascii_to_int(<span class="keywordtype">string</span>[1]);
<a name="l00590"></a>00590         rawdata++;
<a name="l00591"></a>00591         <span class="keywordtype">string</span>+=2;
<a name="l00592"></a>00592         <span class="keywordflow">if</span> (<span class="keywordtype">string</span>[0] == <span class="charliteral">&#39; &#39;</span>)
<a name="l00593"></a>00593             <span class="keywordtype">string</span>++;
<a name="l00594"></a>00594         pkth.caplen++;
<a name="l00595"></a>00595         data_len++;
<a name="l00596"></a>00596     }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 got:
<a name="l00599"></a>00599     uhdr-&gt;data_len = data_len;
<a name="l00600"></a>00600     handle-&gt;md.packets_read++;
<a name="l00601"></a>00601     <span class="keywordflow">if</span> (pkth.caplen &gt; handle-&gt;snapshot)
<a name="l00602"></a>00602         pkth.caplen = handle-&gt;snapshot;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     callback(user, &amp;pkth, handle-&gt;buffer);
<a name="l00605"></a>00605     <span class="keywordflow">return</span> 1;
<a name="l00606"></a>00606 }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00609"></a>00609 usb_inject_linux(<a class="code" href="structpcap.html">pcap_t</a> *handle, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">size_t</span> size)
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611     snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE, <span class="stringliteral">&quot;inject not supported on &quot;</span>
<a name="l00612"></a>00612         <span class="stringliteral">&quot;USB devices&quot;</span>);
<a name="l00613"></a>00613     <span class="keywordflow">return</span> (-1);
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00617"></a>00617 usb_stats_linux(<a class="code" href="structpcap.html">pcap_t</a> *handle, <span class="keyword">struct</span> <a class="code" href="structpcap__stat.html">pcap_stat</a> *stats)
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619     <span class="keywordtype">int</span> dummy, ret, consumed, cnt;
<a name="l00620"></a>00620     <span class="keywordtype">char</span> <span class="keywordtype">string</span>[USB_LINE_LEN];
<a name="l00621"></a>00621     <span class="keywordtype">char</span> token[USB_LINE_LEN];
<a name="l00622"></a>00622     <span class="keywordtype">char</span> * ptr = string;
<a name="l00623"></a>00623     <span class="keywordtype">int</span> fd;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     snprintf(<span class="keywordtype">string</span>, USB_LINE_LEN, USB_TEXT_DIR<span class="stringliteral">&quot;/%ds&quot;</span>, handle-&gt;md.ifindex);
<a name="l00626"></a>00626     fd = open(<span class="keywordtype">string</span>, O_RDONLY, 0);
<a name="l00627"></a>00627     <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l00628"></a>00628     {
<a name="l00629"></a>00629         <span class="keywordflow">if</span> (errno == ENOENT)
<a name="l00630"></a>00630         {
<a name="l00631"></a>00631             <span class="comment">/*</span>
<a name="l00632"></a>00632 <span class="comment">             * Not found at the new location; try the old</span>
<a name="l00633"></a>00633 <span class="comment">             * location.</span>
<a name="l00634"></a>00634 <span class="comment">             */</span>
<a name="l00635"></a>00635             snprintf(<span class="keywordtype">string</span>, USB_LINE_LEN, USB_TEXT_DIR_OLD<span class="stringliteral">&quot;/%ds&quot;</span>, handle-&gt;md.ifindex);
<a name="l00636"></a>00636             fd = open(<span class="keywordtype">string</span>, O_RDONLY, 0);
<a name="l00637"></a>00637         }
<a name="l00638"></a>00638         <span class="keywordflow">if</span> (fd &lt; 0) {
<a name="l00639"></a>00639             snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00640"></a>00640                 <span class="stringliteral">&quot;Can&#39;t open USB stats file %s: %s&quot;</span>, 
<a name="l00641"></a>00641                 <span class="keywordtype">string</span>, strerror(errno));
<a name="l00642"></a>00642             <span class="keywordflow">return</span> -1;
<a name="l00643"></a>00643         }
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="comment">/* read stats line */</span>
<a name="l00647"></a>00647     <span class="keywordflow">do</span> {
<a name="l00648"></a>00648         ret = read(fd, <span class="keywordtype">string</span>, USB_LINE_LEN-1);
<a name="l00649"></a>00649     } <span class="keywordflow">while</span> ((ret == -1) &amp;&amp; (errno == EINTR));
<a name="l00650"></a>00650     close(fd);
<a name="l00651"></a>00651 
<a name="l00652"></a>00652     <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l00653"></a>00653     {
<a name="l00654"></a>00654         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00655"></a>00655             <span class="stringliteral">&quot;Can&#39;t read stats from fd %d &quot;</span>, fd);
<a name="l00656"></a>00656         <span class="keywordflow">return</span> -1;
<a name="l00657"></a>00657     }
<a name="l00658"></a>00658     <span class="keywordtype">string</span>[ret] = 0;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="comment">/* extract info on dropped urbs */</span>
<a name="l00661"></a>00661     <span class="keywordflow">for</span> (consumed=0; consumed &lt; ret; ) {
<a name="l00662"></a>00662         <span class="comment">/* from the sscanf man page: </span>
<a name="l00663"></a>00663 <span class="comment">         * The C standard says: &quot;Execution of a %n directive does </span>
<a name="l00664"></a>00664 <span class="comment">         * not increment the assignment count returned at the completion</span>
<a name="l00665"></a>00665 <span class="comment">         * of  execution&quot; but the Corrigendum seems to contradict this.</span>
<a name="l00666"></a>00666 <span class="comment">         * Do not make any assumptions on the effect of %n conversions </span>
<a name="l00667"></a>00667 <span class="comment">         * on the return value and explicitly check for cnt assignmet*/</span>
<a name="l00668"></a>00668         <span class="keywordtype">int</span> ntok;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         cnt = -1;
<a name="l00671"></a>00671         ntok = sscanf(ptr, <span class="stringliteral">&quot;%s%n&quot;</span>, token, &amp;cnt);
<a name="l00672"></a>00672         <span class="keywordflow">if</span> ((ntok &lt; 1) || (cnt &lt; 0))
<a name="l00673"></a>00673             <span class="keywordflow">break</span>;
<a name="l00674"></a>00674         consumed += cnt;
<a name="l00675"></a>00675         ptr += cnt;
<a name="l00676"></a>00676         <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">&quot;nreaders&quot;</span>) == 0)
<a name="l00677"></a>00677             ret = sscanf(ptr, <span class="stringliteral">&quot;%d&quot;</span>, &amp;stats-&gt;ps_drop);
<a name="l00678"></a>00678         <span class="keywordflow">else</span> 
<a name="l00679"></a>00679             ret = sscanf(ptr, <span class="stringliteral">&quot;%d&quot;</span>, &amp;dummy);
<a name="l00680"></a>00680         <span class="keywordflow">if</span> (ntok != 1)
<a name="l00681"></a>00681             <span class="keywordflow">break</span>;
<a name="l00682"></a>00682         consumed += cnt;
<a name="l00683"></a>00683         ptr += cnt;
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     stats-&gt;ps_recv = handle-&gt;md.packets_read;
<a name="l00687"></a>00687     stats-&gt;ps_ifdrop = 0;
<a name="l00688"></a>00688     <span class="keywordflow">return</span> 0;
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00692"></a>00692 usb_setfilter_linux(<a class="code" href="structpcap.html">pcap_t</a> *p, <span class="keyword">struct</span> <a class="code" href="structbpf__program.html">bpf_program</a> *fp)
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694     <span class="keywordflow">return</span> 0;
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00698"></a>00698 usb_setdirection_linux(<a class="code" href="structpcap.html">pcap_t</a> *p, pcap_direction_t d)
<a name="l00699"></a>00699 {
<a name="l00700"></a>00700     p-&gt;direction = d;
<a name="l00701"></a>00701     <span class="keywordflow">return</span> 0;
<a name="l00702"></a>00702 }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00706"></a>00706 usb_stats_linux_bin(<a class="code" href="structpcap.html">pcap_t</a> *handle, <span class="keyword">struct</span> <a class="code" href="structpcap__stat.html">pcap_stat</a> *stats)
<a name="l00707"></a>00707 {
<a name="l00708"></a>00708     <span class="keywordtype">int</span> ret;
<a name="l00709"></a>00709     <span class="keyword">struct </span><a class="code" href="structmon__bin__stats.html">mon_bin_stats</a> st;
<a name="l00710"></a>00710     ret = ioctl(handle-&gt;fd, MON_IOCG_STATS, &amp;st);
<a name="l00711"></a>00711     <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l00712"></a>00712     {
<a name="l00713"></a>00713         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00714"></a>00714             <span class="stringliteral">&quot;Can&#39;t read stats from fd %d:%s &quot;</span>, handle-&gt;fd, strerror(errno));
<a name="l00715"></a>00715         <span class="keywordflow">return</span> -1;
<a name="l00716"></a>00716     }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     stats-&gt;ps_recv = handle-&gt;md.packets_read + st.queued;
<a name="l00719"></a>00719     stats-&gt;ps_drop = st.dropped;
<a name="l00720"></a>00720     stats-&gt;ps_ifdrop = 0;
<a name="l00721"></a>00721     <span class="keywordflow">return</span> 0;
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="comment">/*</span>
<a name="l00725"></a>00725 <span class="comment"> * see &lt;linux-kernel-source&gt;/Documentation/usb/usbmon.txt and </span>
<a name="l00726"></a>00726 <span class="comment"> * &lt;linux-kernel-source&gt;/drivers/usb/mon/mon_bin.c binary ABI</span>
<a name="l00727"></a>00727 <span class="comment"> */</span>
<a name="l00728"></a>00728 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00729"></a>00729 usb_read_linux_bin(<a class="code" href="structpcap.html">pcap_t</a> *handle, <span class="keywordtype">int</span> max_packets, pcap_handler callback, u_char *user)
<a name="l00730"></a>00730 {
<a name="l00731"></a>00731     <span class="keyword">struct </span><a class="code" href="structmon__bin__get.html">mon_bin_get</a> info;
<a name="l00732"></a>00732     <span class="keywordtype">int</span> ret;
<a name="l00733"></a>00733     <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> pkth;
<a name="l00734"></a>00734     <span class="keywordtype">int</span> clen = handle-&gt;snapshot - <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header.html">pcap_usb_header</a>);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="comment">/* the usb header is going to be part of &#39;packet&#39; data*/</span>
<a name="l00737"></a>00737     info.hdr = (<a class="code" href="struct__usb__header.html">pcap_usb_header</a>*) handle-&gt;buffer;
<a name="l00738"></a>00738     info.data = handle-&gt;buffer + <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header.html">pcap_usb_header</a>);
<a name="l00739"></a>00739     info.data_len = clen;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     <span class="comment">/* ignore interrupt system call errors */</span>
<a name="l00742"></a>00742     <span class="keywordflow">do</span> {
<a name="l00743"></a>00743         ret = ioctl(handle-&gt;fd, MON_IOCX_GET, &amp;info);
<a name="l00744"></a>00744         <span class="keywordflow">if</span> (handle-&gt;break_loop)
<a name="l00745"></a>00745         {
<a name="l00746"></a>00746             handle-&gt;break_loop = 0;
<a name="l00747"></a>00747             <span class="keywordflow">return</span> -2;
<a name="l00748"></a>00748         }
<a name="l00749"></a>00749     } <span class="keywordflow">while</span> ((ret == -1) &amp;&amp; (errno == EINTR));
<a name="l00750"></a>00750     <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l00751"></a>00751     {
<a name="l00752"></a>00752         <span class="keywordflow">if</span> (errno == EAGAIN)
<a name="l00753"></a>00753             <span class="keywordflow">return</span> 0;   <span class="comment">/* no data there */</span>
<a name="l00754"></a>00754 
<a name="l00755"></a>00755         snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00756"></a>00756             <span class="stringliteral">&quot;Can&#39;t read from fd %d: %s&quot;</span>, handle-&gt;fd, strerror(errno));
<a name="l00757"></a>00757         <span class="keywordflow">return</span> -1;
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760     <span class="comment">/* we can get less that than really captured from kernel, depending on</span>
<a name="l00761"></a>00761 <span class="comment">     * snaplen, so adjust header accordingly */</span>
<a name="l00762"></a>00762     <span class="keywordflow">if</span> (info.hdr-&gt;data_len &lt; clen)
<a name="l00763"></a>00763         clen = info.hdr-&gt;data_len;
<a name="l00764"></a>00764     info.hdr-&gt;data_len = clen;
<a name="l00765"></a>00765     pkth.caplen = clen + <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header.html">pcap_usb_header</a>);
<a name="l00766"></a>00766     pkth.len = info.hdr-&gt;data_len + <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header.html">pcap_usb_header</a>);
<a name="l00767"></a>00767     pkth.ts.tv_sec = info.hdr-&gt;ts_sec;
<a name="l00768"></a>00768     pkth.ts.tv_usec = info.hdr-&gt;ts_usec;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     handle-&gt;md.packets_read++;
<a name="l00771"></a>00771     callback(user, &amp;pkth, handle-&gt;buffer);
<a name="l00772"></a>00772     <span class="keywordflow">return</span> 1;
<a name="l00773"></a>00773 }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="comment">/*</span>
<a name="l00776"></a>00776 <span class="comment"> * see &lt;linux-kernel-source&gt;/Documentation/usb/usbmon.txt and </span>
<a name="l00777"></a>00777 <span class="comment"> * &lt;linux-kernel-source&gt;/drivers/usb/mon/mon_bin.c binary ABI</span>
<a name="l00778"></a>00778 <span class="comment"> */</span>
<a name="l00779"></a>00779 <span class="preprocessor">#define VEC_SIZE 32</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00781"></a>00781 usb_read_linux_mmap(<a class="code" href="structpcap.html">pcap_t</a> *handle, <span class="keywordtype">int</span> max_packets, pcap_handler callback, u_char *user)
<a name="l00782"></a>00782 {
<a name="l00783"></a>00783     <span class="keyword">struct </span><a class="code" href="structmon__bin__mfetch.html">mon_bin_mfetch</a> fetch;
<a name="l00784"></a>00784     int32_t vec[VEC_SIZE];
<a name="l00785"></a>00785     <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> pkth;
<a name="l00786"></a>00786     <a class="code" href="struct__usb__header.html">pcap_usb_header</a>* hdr;
<a name="l00787"></a>00787     <span class="keywordtype">int</span> nflush = 0;
<a name="l00788"></a>00788     <span class="keywordtype">int</span> packets = 0;
<a name="l00789"></a>00789     <span class="keywordtype">int</span> clen, max_clen;
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     max_clen = handle-&gt;snapshot - <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header.html">pcap_usb_header</a>);
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     <span class="keywordflow">for</span> (;;) {
<a name="l00794"></a>00794         <span class="keywordtype">int</span> i, ret;
<a name="l00795"></a>00795         <span class="keywordtype">int</span> limit = max_packets - packets;
<a name="l00796"></a>00796         <span class="keywordflow">if</span> (limit &lt;= 0)
<a name="l00797"></a>00797             limit = VEC_SIZE;
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (limit &gt; VEC_SIZE)
<a name="l00799"></a>00799             limit = VEC_SIZE;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         <span class="comment">/* try to fetch as many events as possible*/</span>
<a name="l00802"></a>00802         fetch.offvec = vec;
<a name="l00803"></a>00803         fetch.nfetch = limit;
<a name="l00804"></a>00804         fetch.nflush = nflush;
<a name="l00805"></a>00805         <span class="comment">/* ignore interrupt system call errors */</span>
<a name="l00806"></a>00806         <span class="keywordflow">do</span> {
<a name="l00807"></a>00807             ret = ioctl(handle-&gt;fd, MON_IOCX_MFETCH, &amp;fetch);
<a name="l00808"></a>00808             <span class="keywordflow">if</span> (handle-&gt;break_loop)
<a name="l00809"></a>00809             {
<a name="l00810"></a>00810                 handle-&gt;break_loop = 0;
<a name="l00811"></a>00811                 <span class="keywordflow">return</span> -2;
<a name="l00812"></a>00812             }
<a name="l00813"></a>00813         } <span class="keywordflow">while</span> ((ret == -1) &amp;&amp; (errno == EINTR));
<a name="l00814"></a>00814         <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l00815"></a>00815         {
<a name="l00816"></a>00816             <span class="keywordflow">if</span> (errno == EAGAIN)
<a name="l00817"></a>00817                 <span class="keywordflow">return</span> 0;   <span class="comment">/* no data there */</span>
<a name="l00818"></a>00818 
<a name="l00819"></a>00819             snprintf(handle-&gt;errbuf, PCAP_ERRBUF_SIZE,
<a name="l00820"></a>00820                 <span class="stringliteral">&quot;Can&#39;t mfetch fd %d: %s&quot;</span>, handle-&gt;fd, strerror(errno));
<a name="l00821"></a>00821             <span class="keywordflow">return</span> -1;
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         <span class="comment">/* keep track of processed events, we will flush them later */</span>
<a name="l00825"></a>00825         nflush = fetch.nfetch;
<a name="l00826"></a>00826         <span class="keywordflow">for</span> (i=0; i&lt;fetch.nfetch; ++i) {
<a name="l00827"></a>00827             <span class="comment">/* discard filler */</span>
<a name="l00828"></a>00828             hdr = (<a class="code" href="struct__usb__header.html">pcap_usb_header</a>*) &amp;handle-&gt;md.mmapbuf[vec[i]];
<a name="l00829"></a>00829             if (hdr-&gt;event_type == <span class="charliteral">&#39;@&#39;</span>) 
<a name="l00830"></a>00830                 <span class="keywordflow">continue</span>;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832             <span class="comment">/* we can get less that than really captured from kernel, depending on</span>
<a name="l00833"></a>00833 <span class="comment">            * snaplen, so adjust header accordingly */</span>
<a name="l00834"></a>00834             clen = max_clen;
<a name="l00835"></a>00835             <span class="keywordflow">if</span> (hdr-&gt;data_len &lt; clen)
<a name="l00836"></a>00836                 clen = hdr-&gt;data_len;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838             <span class="comment">/* get packet info from header*/</span>
<a name="l00839"></a>00839             pkth.caplen = clen + <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header__mmapped.html">pcap_usb_header_mmapped</a>);
<a name="l00840"></a>00840             pkth.len = hdr-&gt;data_len + <span class="keyword">sizeof</span>(<a class="code" href="struct__usb__header__mmapped.html">pcap_usb_header_mmapped</a>);
<a name="l00841"></a>00841             pkth.ts.tv_sec = hdr-&gt;ts_sec;
<a name="l00842"></a>00842             pkth.ts.tv_usec = hdr-&gt;ts_usec;
<a name="l00843"></a>00843 
<a name="l00844"></a>00844             handle-&gt;md.packets_read++;
<a name="l00845"></a>00845             callback(user, &amp;pkth, (u_char*) hdr);
<a name="l00846"></a>00846             packets++;
<a name="l00847"></a>00847         }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         <span class="comment">/* with max_packets &lt;= 0 we stop afer the first chunk*/</span>
<a name="l00850"></a>00850         <span class="keywordflow">if</span> ((max_packets &lt;= 0) || (packets == max_packets))
<a name="l00851"></a>00851             <span class="keywordflow">break</span>;
<a name="l00852"></a>00852     }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854     <span class="comment">/* flush pending events*/</span>
<a name="l00855"></a>00855     ioctl(handle-&gt;fd, MON_IOCH_MFLUSH, nflush);
<a name="l00856"></a>00856     <span class="keywordflow">return</span> packets;
<a name="l00857"></a>00857 }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00860"></a>00860 usb_cleanup_linux_mmap(<a class="code" href="structpcap.html">pcap_t</a>* handle)
<a name="l00861"></a>00861 {
<a name="l00862"></a>00862     <span class="comment">/* if we have a memory-mapped buffer, unmap it */</span>
<a name="l00863"></a>00863     <span class="keywordflow">if</span> (handle-&gt;md.mmapbuf != NULL) {
<a name="l00864"></a>00864         munmap(handle-&gt;md.mmapbuf, handle-&gt;md.mmapbuflen);
<a name="l00865"></a>00865         handle-&gt;md.mmapbuf = NULL;
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867     pcap_cleanup_live_common(handle);
<a name="l00868"></a>00868 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:31 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
