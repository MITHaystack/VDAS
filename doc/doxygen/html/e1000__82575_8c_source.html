<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/igb/igb-3.0.22/src/e1000_82575.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_3c2810a9602a6e1cace3517f89aee72b.html">igb</a>      </li>
      <li class="navelem"><a class="el" href="dir_7e6283e46a535da0a7c1aa2c5482db05.html">igb-3.0.22</a>      </li>
      <li class="navelem"><a class="el" href="dir_0c425da04c49dcf9213f9b26dcbb667f.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">e1000_82575.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Intel(R) Gigabit Ethernet Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">  Copyright(c) 2007-2010 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">  under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">  version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">  more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">  The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00024"></a>00024 <span class="comment">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">*******************************************************************************/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">/*</span>
<a name="l00029"></a>00029 <span class="comment"> * 82575EB Gigabit Network Connection</span>
<a name="l00030"></a>00030 <span class="comment"> * 82575EB Gigabit Backplane Connection</span>
<a name="l00031"></a>00031 <span class="comment"> * 82575GB Gigabit Network Connection</span>
<a name="l00032"></a>00032 <span class="comment"> * 82576 Gigabit Network Connection</span>
<a name="l00033"></a>00033 <span class="comment"> * 82576 Quad Port Gigabit Mezzanine Adapter</span>
<a name="l00034"></a>00034 <span class="comment"> */</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;e1000_api.h&quot;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">static</span> s32  e1000_init_phy_params_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00039"></a>00039 <span class="keyword">static</span> s32  e1000_init_mac_params_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00040"></a>00040 <span class="keyword">static</span> s32  e1000_acquire_phy_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00041"></a>00041 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_release_phy_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00042"></a>00042 <span class="keyword">static</span> s32  e1000_acquire_nvm_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00043"></a>00043 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_release_nvm_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00044"></a>00044 <span class="keyword">static</span> s32  e1000_check_for_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00045"></a>00045 <span class="keyword">static</span> s32  e1000_get_cfg_done_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00046"></a>00046 <span class="keyword">static</span> s32  e1000_get_link_up_info_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 *speed,
<a name="l00047"></a>00047                                          u16 *duplex);
<a name="l00048"></a>00048 <span class="keyword">static</span> s32  e1000_init_hw_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00049"></a>00049 <span class="keyword">static</span> s32  e1000_phy_hw_reset_sgmii_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00050"></a>00050 <span class="keyword">static</span> s32  e1000_read_phy_reg_sgmii_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset,
<a name="l00051"></a>00051                                            u16 *data);
<a name="l00052"></a>00052 <span class="keyword">static</span> s32  e1000_reset_hw_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00053"></a>00053 <span class="keyword">static</span> s32  e1000_reset_hw_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00054"></a>00054 <span class="keyword">static</span> s32  e1000_read_phy_reg_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00055"></a>00055                                     u32 offset, u16 *data);
<a name="l00056"></a>00056 <span class="keyword">static</span> s32  e1000_write_phy_reg_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00057"></a>00057                                      u32 offset, u16 data);
<a name="l00058"></a>00058 <span class="keyword">static</span> s32  e1000_set_d0_lplu_state_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00059"></a>00059                                           <span class="keywordtype">bool</span> active);
<a name="l00060"></a>00060 <span class="keyword">static</span> s32  e1000_set_d3_lplu_state_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00061"></a>00061                                           <span class="keywordtype">bool</span> active);
<a name="l00062"></a>00062 <span class="keyword">static</span> s32  e1000_set_d0_lplu_state_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00063"></a>00063                                           <span class="keywordtype">bool</span> active);
<a name="l00064"></a>00064 <span class="keyword">static</span> s32  e1000_setup_copper_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00065"></a>00065 <span class="keyword">static</span> s32  e1000_setup_serdes_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00066"></a>00066 <span class="keyword">static</span> s32  e1000_valid_led_default_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 *data);
<a name="l00067"></a>00067 <span class="keyword">static</span> s32  e1000_write_phy_reg_sgmii_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00068"></a>00068                                             u32 offset, u16 data);
<a name="l00069"></a>00069 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_clear_hw_cntrs_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00070"></a>00070 <span class="keyword">static</span> s32  e1000_acquire_swfw_sync_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 mask);
<a name="l00071"></a>00071 <span class="keyword">static</span> s32  e1000_get_pcs_speed_and_duplex_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00072"></a>00072                                                  u16 *speed, u16 *duplex);
<a name="l00073"></a>00073 <span class="keyword">static</span> s32  e1000_get_phy_id_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00074"></a>00074 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_release_swfw_sync_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 mask);
<a name="l00075"></a>00075 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_sgmii_active_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00076"></a>00076 <span class="keyword">static</span> s32  e1000_reset_init_script_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00077"></a>00077 <span class="keyword">static</span> s32  e1000_read_mac_addr_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00078"></a>00078 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_config_collision_dist_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00079"></a>00079 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_power_down_phy_copper_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00080"></a>00080 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_shutdown_serdes_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_power_up_serdes_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00082"></a>00082 <span class="keyword">static</span> s32 e1000_set_pcie_completion_timeout(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00083"></a>00083 <span class="keyword">static</span> s32 e1000_reset_mdicnfg_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00084"></a>00084 <span class="keyword">static</span> s32 e1000_validate_nvm_checksum_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00085"></a>00085 <span class="keyword">static</span> s32 e1000_update_nvm_checksum_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00086"></a>00086 <span class="keyword">static</span> s32 e1000_update_nvm_checksum_with_offset(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00087"></a>00087                         u16 offset);
<a name="l00088"></a>00088 <span class="keyword">static</span> s32 e1000_validate_nvm_checksum_with_offset(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l00089"></a>00089                         u16 offset);
<a name="l00090"></a>00090 <span class="keyword">static</span> s32 e1000_validate_nvm_checksum_i350(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00091"></a>00091 <span class="keyword">static</span> s32 e1000_update_nvm_checksum_i350(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="keyword">static</span> <span class="keyword">const</span> u16 e1000_82580_rxpbs_table[] =
<a name="l00094"></a>00094     { 36, 72, 144, 1, 2, 4, 8, 16,
<a name="l00095"></a>00095       35, 70, 140 };
<a name="l00096"></a>00096 <span class="preprocessor">#define E1000_82580_RXPBS_TABLE_SIZE \</span>
<a name="l00097"></a>00097 <span class="preprocessor">    (sizeof(e1000_82580_rxpbs_table)/sizeof(u16))</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>
<a name="l00099"></a>00099 
<a name="l00107"></a>00107 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_sgmii_uses_mdio_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109     u32 reg = 0;
<a name="l00110"></a>00110     <span class="keywordtype">bool</span> ext_mdio = <span class="keyword">false</span>;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     DEBUGFUNC(<span class="stringliteral">&quot;e1000_sgmii_uses_mdio_82575&quot;</span>);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00115"></a>00115     <span class="keywordflow">case</span> e1000_82575:
<a name="l00116"></a>00116     <span class="keywordflow">case</span> e1000_82576:
<a name="l00117"></a>00117         reg = E1000_READ_REG(hw, E1000_MDIC);
<a name="l00118"></a>00118         ext_mdio = !!(reg &amp; E1000_MDIC_DEST);
<a name="l00119"></a>00119         <span class="keywordflow">break</span>;
<a name="l00120"></a>00120     <span class="keywordflow">case</span> e1000_82580:
<a name="l00121"></a>00121     <span class="keywordflow">case</span> e1000_i350:
<a name="l00122"></a>00122         reg = E1000_READ_REG(hw, E1000_MDICNFG);
<a name="l00123"></a>00123         ext_mdio = !!(reg &amp; E1000_MDICNFG_EXT_MDIO);
<a name="l00124"></a>00124         <span class="keywordflow">break</span>;
<a name="l00125"></a>00125     <span class="keywordflow">default</span>:
<a name="l00126"></a>00126         <span class="keywordflow">break</span>;
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128     <span class="keywordflow">return</span> ext_mdio;
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00135"></a>00135 <span class="keyword">static</span> s32 e1000_init_phy_params_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00136"></a>00136 {
<a name="l00137"></a>00137     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;hw-&gt;phy;
<a name="l00138"></a>00138     s32 ret_val = E1000_SUCCESS;
<a name="l00139"></a>00139     u32 ctrl_ext;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_phy_params_82575&quot;</span>);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     <span class="keywordflow">if</span> (hw-&gt;phy.media_type != e1000_media_type_copper) {
<a name="l00144"></a>00144         phy-&gt;type = e1000_phy_none;
<a name="l00145"></a>00145         <span class="keywordflow">goto</span> out;
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148     phy-&gt;ops.power_up   = e1000_power_up_phy_copper;
<a name="l00149"></a>00149     phy-&gt;ops.power_down = e1000_power_down_phy_copper_82575;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151     phy-&gt;autoneg_mask           = AUTONEG_ADVERTISE_SPEED_DEFAULT;
<a name="l00152"></a>00152     phy-&gt;reset_delay_us         = 100;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     phy-&gt;ops.acquire            = e1000_acquire_phy_82575;
<a name="l00155"></a>00155     phy-&gt;ops.check_reset_block  = e1000_check_reset_block_generic;
<a name="l00156"></a>00156     phy-&gt;ops.commit             = e1000_phy_sw_reset_generic;
<a name="l00157"></a>00157     phy-&gt;ops.get_cfg_done       = e1000_get_cfg_done_82575;
<a name="l00158"></a>00158     phy-&gt;ops.release            = e1000_release_phy_82575;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     <span class="keywordflow">if</span> (e1000_sgmii_active_82575(hw)) {
<a name="l00163"></a>00163         phy-&gt;ops.reset      = e1000_phy_hw_reset_sgmii_82575;
<a name="l00164"></a>00164         ctrl_ext |= E1000_CTRL_I2C_ENA;
<a name="l00165"></a>00165     } <span class="keywordflow">else</span> {
<a name="l00166"></a>00166         phy-&gt;ops.reset      = e1000_phy_hw_reset_generic;
<a name="l00167"></a>00167         ctrl_ext &amp;= ~E1000_CTRL_I2C_ENA;
<a name="l00168"></a>00168     }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
<a name="l00171"></a>00171     e1000_reset_mdicnfg_82580(hw);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173     <span class="keywordflow">if</span> (e1000_sgmii_active_82575(hw) &amp;&amp; !e1000_sgmii_uses_mdio_82575(hw)) {
<a name="l00174"></a>00174         phy-&gt;ops.read_reg   = e1000_read_phy_reg_sgmii_82575;
<a name="l00175"></a>00175         phy-&gt;ops.write_reg  = e1000_write_phy_reg_sgmii_82575;
<a name="l00176"></a>00176     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;mac.type &gt;= e1000_82580) {
<a name="l00177"></a>00177         phy-&gt;ops.read_reg   = e1000_read_phy_reg_82580;
<a name="l00178"></a>00178         phy-&gt;ops.write_reg  = e1000_write_phy_reg_82580;
<a name="l00179"></a>00179     } <span class="keywordflow">else</span> {
<a name="l00180"></a>00180         phy-&gt;ops.read_reg   = e1000_read_phy_reg_igp;
<a name="l00181"></a>00181         phy-&gt;ops.write_reg  = e1000_write_phy_reg_igp;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     <span class="comment">/* Set phy-&gt;phy_addr and phy-&gt;id. */</span>
<a name="l00185"></a>00185     ret_val = e1000_get_phy_id_82575(hw);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="comment">/* Verify phy id and set remaining function pointers */</span>
<a name="l00188"></a>00188     <span class="keywordflow">switch</span> (phy-&gt;id) {
<a name="l00189"></a>00189     <span class="keywordflow">case</span> I347AT4_E_PHY_ID:
<a name="l00190"></a>00190     <span class="keywordflow">case</span> M88E1112_E_PHY_ID:
<a name="l00191"></a>00191     <span class="keywordflow">case</span> M88E1340M_E_PHY_ID:
<a name="l00192"></a>00192     <span class="keywordflow">case</span> M88E1111_I_PHY_ID:
<a name="l00193"></a>00193         phy-&gt;type                   = e1000_phy_m88;
<a name="l00194"></a>00194         phy-&gt;ops.check_polarity     = e1000_check_polarity_m88;
<a name="l00195"></a>00195         phy-&gt;ops.get_info           = e1000_get_phy_info_m88;
<a name="l00196"></a>00196         <span class="keywordflow">if</span> (phy-&gt;id == I347AT4_E_PHY_ID ||
<a name="l00197"></a>00197             phy-&gt;id == M88E1112_E_PHY_ID ||
<a name="l00198"></a>00198             phy-&gt;id == M88E1340M_E_PHY_ID)
<a name="l00199"></a>00199             phy-&gt;ops.get_cable_length = e1000_get_cable_length_m88_gen2;
<a name="l00200"></a>00200         <span class="keywordflow">else</span>
<a name="l00201"></a>00201             phy-&gt;ops.get_cable_length = e1000_get_cable_length_m88;
<a name="l00202"></a>00202         phy-&gt;ops.force_speed_duplex = e1000_phy_force_speed_duplex_m88;
<a name="l00203"></a>00203         <span class="keywordflow">break</span>;
<a name="l00204"></a>00204     <span class="keywordflow">case</span> IGP03E1000_E_PHY_ID:
<a name="l00205"></a>00205     <span class="keywordflow">case</span> IGP04E1000_E_PHY_ID:
<a name="l00206"></a>00206         phy-&gt;type                   = e1000_phy_igp_3;
<a name="l00207"></a>00207         phy-&gt;ops.check_polarity     = e1000_check_polarity_igp;
<a name="l00208"></a>00208         phy-&gt;ops.get_info           = e1000_get_phy_info_igp;
<a name="l00209"></a>00209         phy-&gt;ops.get_cable_length   = e1000_get_cable_length_igp_2;
<a name="l00210"></a>00210         phy-&gt;ops.force_speed_duplex = e1000_phy_force_speed_duplex_igp;
<a name="l00211"></a>00211         phy-&gt;ops.set_d0_lplu_state  = e1000_set_d0_lplu_state_82575;
<a name="l00212"></a>00212         phy-&gt;ops.set_d3_lplu_state  = e1000_set_d3_lplu_state_generic;
<a name="l00213"></a>00213         <span class="keywordflow">break</span>;
<a name="l00214"></a>00214     <span class="keywordflow">case</span> I82580_I_PHY_ID:
<a name="l00215"></a>00215     <span class="keywordflow">case</span> I350_I_PHY_ID:
<a name="l00216"></a>00216         phy-&gt;type                   = e1000_phy_82580;
<a name="l00217"></a>00217         phy-&gt;ops.check_polarity     = e1000_check_polarity_82577;
<a name="l00218"></a>00218         phy-&gt;ops.force_speed_duplex = e1000_phy_force_speed_duplex_82577;
<a name="l00219"></a>00219         phy-&gt;ops.get_cable_length   = e1000_get_cable_length_82577;
<a name="l00220"></a>00220         phy-&gt;ops.get_info           = e1000_get_phy_info_82577;
<a name="l00221"></a>00221         phy-&gt;ops.set_d0_lplu_state  = e1000_set_d0_lplu_state_82580;
<a name="l00222"></a>00222         phy-&gt;ops.set_d3_lplu_state  = e1000_set_d3_lplu_state_82580;
<a name="l00223"></a>00223         <span class="keywordflow">break</span>;
<a name="l00224"></a>00224     <span class="keywordflow">default</span>:
<a name="l00225"></a>00225         ret_val = -E1000_ERR_PHY;
<a name="l00226"></a>00226         <span class="keywordflow">goto</span> out;
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 out:
<a name="l00230"></a>00230     <span class="keywordflow">return</span> ret_val;
<a name="l00231"></a>00231 }
<a name="l00232"></a>00232 
<a name="l00237"></a>00237 s32 e1000_init_nvm_params_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00238"></a>00238 {
<a name="l00239"></a>00239     <span class="keyword">struct </span><a class="code" href="structe1000__nvm__info.html">e1000_nvm_info</a> *nvm = &amp;hw-&gt;nvm;
<a name="l00240"></a>00240     u32 eecd = E1000_READ_REG(hw, E1000_EECD);
<a name="l00241"></a>00241     u16 size;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_nvm_params_82575&quot;</span>);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     size = (u16)((eecd &amp; E1000_EECD_SIZE_EX_MASK) &gt;&gt;
<a name="l00246"></a>00246                  E1000_EECD_SIZE_EX_SHIFT);
<a name="l00247"></a>00247     <span class="comment">/*</span>
<a name="l00248"></a>00248 <span class="comment">     * Added to a constant, &quot;size&quot; becomes the left-shift value</span>
<a name="l00249"></a>00249 <span class="comment">     * for setting word_size.</span>
<a name="l00250"></a>00250 <span class="comment">     */</span>
<a name="l00251"></a>00251     size += NVM_WORD_SIZE_BASE_SHIFT;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     nvm-&gt;word_size = 1 &lt;&lt; size;
<a name="l00254"></a>00254     nvm-&gt;opcode_bits        = 8;
<a name="l00255"></a>00255     nvm-&gt;delay_usec         = 1;
<a name="l00256"></a>00256     <span class="keywordflow">switch</span> (nvm-&gt;override) {
<a name="l00257"></a>00257     <span class="keywordflow">case</span> e1000_nvm_override_spi_large:
<a name="l00258"></a>00258         nvm-&gt;page_size    = 32;
<a name="l00259"></a>00259         nvm-&gt;address_bits = 16;
<a name="l00260"></a>00260         <span class="keywordflow">break</span>;
<a name="l00261"></a>00261     <span class="keywordflow">case</span> e1000_nvm_override_spi_small:
<a name="l00262"></a>00262         nvm-&gt;page_size    = 8;
<a name="l00263"></a>00263         nvm-&gt;address_bits = 8;
<a name="l00264"></a>00264         <span class="keywordflow">break</span>;
<a name="l00265"></a>00265     <span class="keywordflow">default</span>:
<a name="l00266"></a>00266         nvm-&gt;page_size    = eecd &amp; E1000_EECD_ADDR_BITS ? 32 : 8;
<a name="l00267"></a>00267         nvm-&gt;address_bits = eecd &amp; E1000_EECD_ADDR_BITS ? 16 : 8;
<a name="l00268"></a>00268         <span class="keywordflow">break</span>;
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     nvm-&gt;type = e1000_nvm_eeprom_spi;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (nvm-&gt;word_size == (1 &lt;&lt; 15))
<a name="l00274"></a>00274         nvm-&gt;page_size = 128;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     <span class="comment">/* Function Pointers */</span>
<a name="l00277"></a>00277     nvm-&gt;ops.acquire    = e1000_acquire_nvm_82575;
<a name="l00278"></a>00278     nvm-&gt;ops.release    = e1000_release_nvm_82575;
<a name="l00279"></a>00279     if (nvm-&gt;word_size &lt; (1 &lt;&lt; 15))
<a name="l00280"></a>00280         nvm-&gt;ops.read    = e1000_read_nvm_eerd;
<a name="l00281"></a>00281     <span class="keywordflow">else</span>
<a name="l00282"></a>00282         nvm-&gt;ops.read    = e1000_read_nvm_spi;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     nvm-&gt;ops.write              = e1000_write_nvm_spi;
<a name="l00285"></a>00285     nvm-&gt;ops.validate           = e1000_validate_nvm_checksum_generic;
<a name="l00286"></a>00286     nvm-&gt;ops.update             = e1000_update_nvm_checksum_generic;
<a name="l00287"></a>00287     nvm-&gt;ops.valid_led_default  = e1000_valid_led_default_82575;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="comment">/* override genric family function pointers for specific descendants */</span>
<a name="l00290"></a>00290     switch (hw-&gt;mac.type) {
<a name="l00291"></a>00291     <span class="keywordflow">case</span> e1000_82580:
<a name="l00292"></a>00292         nvm-&gt;ops.validate = e1000_validate_nvm_checksum_82580;
<a name="l00293"></a>00293         nvm-&gt;ops.update = e1000_update_nvm_checksum_82580;
<a name="l00294"></a>00294         <span class="keywordflow">break</span>;
<a name="l00295"></a>00295     <span class="keywordflow">case</span> e1000_i350:
<a name="l00296"></a>00296         nvm-&gt;ops.validate = e1000_validate_nvm_checksum_i350;
<a name="l00297"></a>00297         nvm-&gt;ops.update = e1000_update_nvm_checksum_i350;
<a name="l00298"></a>00298         <span class="keywordflow">break</span>;
<a name="l00299"></a>00299     <span class="keywordflow">default</span>:
<a name="l00300"></a>00300         <span class="keywordflow">break</span>;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00310"></a>00310 <span class="keyword">static</span> s32 e1000_init_mac_params_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l00313"></a>00313     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82575.html">e1000_dev_spec_82575</a> *dev_spec = &amp;hw-&gt;dev_spec._82575;
<a name="l00314"></a>00314     u32 ctrl_ext = 0;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_mac_params_82575&quot;</span>);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     <span class="comment">/* Set media type */</span>
<a name="l00319"></a>00319         <span class="comment">/*</span>
<a name="l00320"></a>00320 <span class="comment">     * The 82575 uses bits 22:23 for link mode. The mode can be changed</span>
<a name="l00321"></a>00321 <span class="comment">         * based on the EEPROM. We cannot rely upon device ID. There</span>
<a name="l00322"></a>00322 <span class="comment">         * is no distinguishable difference between fiber and internal</span>
<a name="l00323"></a>00323 <span class="comment">         * SerDes mode on the 82575. There can be an external PHY attached</span>
<a name="l00324"></a>00324 <span class="comment">         * on the SGMII interface. For this, we&#39;ll set sgmii_active to true.</span>
<a name="l00325"></a>00325 <span class="comment">         */</span>
<a name="l00326"></a>00326     hw-&gt;phy.media_type = e1000_media_type_copper;
<a name="l00327"></a>00327     dev_spec-&gt;sgmii_active = <span class="keyword">false</span>;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l00330"></a>00330     <span class="keywordflow">switch</span> (ctrl_ext &amp; E1000_CTRL_EXT_LINK_MODE_MASK) {
<a name="l00331"></a>00331     <span class="keywordflow">case</span> E1000_CTRL_EXT_LINK_MODE_SGMII:
<a name="l00332"></a>00332         dev_spec-&gt;sgmii_active = <span class="keyword">true</span>;
<a name="l00333"></a>00333         <span class="keywordflow">break</span>;
<a name="l00334"></a>00334     <span class="keywordflow">case</span> E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:
<a name="l00335"></a>00335     <span class="keywordflow">case</span> E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES:
<a name="l00336"></a>00336         hw-&gt;phy.media_type = e1000_media_type_internal_serdes;
<a name="l00337"></a>00337         <span class="keywordflow">break</span>;
<a name="l00338"></a>00338     <span class="keywordflow">default</span>:
<a name="l00339"></a>00339         <span class="keywordflow">break</span>;
<a name="l00340"></a>00340     }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342     <span class="comment">/* Set mta register count */</span>
<a name="l00343"></a>00343     mac-&gt;mta_reg_count = 128;
<a name="l00344"></a>00344     <span class="comment">/* Set uta register count */</span>
<a name="l00345"></a>00345     mac-&gt;uta_reg_count = (hw-&gt;mac.type == e1000_82575) ? 0 : 128;
<a name="l00346"></a>00346     <span class="comment">/* Set rar entry count */</span>
<a name="l00347"></a>00347     mac-&gt;rar_entry_count = E1000_RAR_ENTRIES_82575;
<a name="l00348"></a>00348     <span class="keywordflow">if</span> (mac-&gt;type == e1000_82576)
<a name="l00349"></a>00349         mac-&gt;rar_entry_count = E1000_RAR_ENTRIES_82576;
<a name="l00350"></a>00350     <span class="keywordflow">if</span> (mac-&gt;type == e1000_82580)
<a name="l00351"></a>00351         mac-&gt;rar_entry_count = E1000_RAR_ENTRIES_82580;
<a name="l00352"></a>00352     <span class="keywordflow">if</span> (mac-&gt;type == e1000_i350) {
<a name="l00353"></a>00353         mac-&gt;rar_entry_count = E1000_RAR_ENTRIES_I350;
<a name="l00354"></a>00354         <span class="comment">/* Enable EEE default settings for i350 */</span>
<a name="l00355"></a>00355         dev_spec-&gt;eee_disable = <span class="keyword">false</span>;
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     <span class="comment">/* Set if part includes ASF firmware */</span>
<a name="l00359"></a>00359     mac-&gt;asf_firmware_present = <span class="keyword">true</span>;
<a name="l00360"></a>00360     <span class="comment">/* FWSM register */</span>
<a name="l00361"></a>00361     mac-&gt;has_fwsm = <span class="keyword">true</span>;
<a name="l00362"></a>00362     <span class="comment">/* ARC supported; valid only if manageability features are enabled. */</span>
<a name="l00363"></a>00363     mac-&gt;arc_subsystem_valid =
<a name="l00364"></a>00364             (E1000_READ_REG(hw, E1000_FWSM) &amp; E1000_FWSM_MODE_MASK)
<a name="l00365"></a>00365                     ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367     <span class="comment">/* Function pointers */</span>
<a name="l00368"></a>00368 
<a name="l00369"></a>00369     <span class="comment">/* bus type/speed/width */</span>
<a name="l00370"></a>00370     mac-&gt;ops.get_bus_info = e1000_get_bus_info_pcie_generic;
<a name="l00371"></a>00371     <span class="comment">/* reset */</span>
<a name="l00372"></a>00372     <span class="keywordflow">if</span> (mac-&gt;type &gt;= e1000_82580)
<a name="l00373"></a>00373         mac-&gt;ops.reset_hw = e1000_reset_hw_82580;
<a name="l00374"></a>00374     <span class="keywordflow">else</span>
<a name="l00375"></a>00375     mac-&gt;ops.reset_hw = e1000_reset_hw_82575;
<a name="l00376"></a>00376     <span class="comment">/* hw initialization */</span>
<a name="l00377"></a>00377     mac-&gt;ops.init_hw = e1000_init_hw_82575;
<a name="l00378"></a>00378     <span class="comment">/* link setup */</span>
<a name="l00379"></a>00379     mac-&gt;ops.setup_link = e1000_setup_link_generic;
<a name="l00380"></a>00380     <span class="comment">/* physical interface link setup */</span>
<a name="l00381"></a>00381     mac-&gt;ops.setup_physical_interface =
<a name="l00382"></a>00382             (hw-&gt;phy.media_type == e1000_media_type_copper)
<a name="l00383"></a>00383                     ? e1000_setup_copper_link_82575
<a name="l00384"></a>00384                     : e1000_setup_serdes_link_82575;
<a name="l00385"></a>00385     <span class="comment">/* physical interface shutdown */</span>
<a name="l00386"></a>00386     mac-&gt;ops.shutdown_serdes = e1000_shutdown_serdes_link_82575;
<a name="l00387"></a>00387     <span class="comment">/* physical interface power up */</span>
<a name="l00388"></a>00388     mac-&gt;ops.power_up_serdes = e1000_power_up_serdes_link_82575;
<a name="l00389"></a>00389     <span class="comment">/* check for link */</span>
<a name="l00390"></a>00390     mac-&gt;ops.check_for_link = e1000_check_for_link_82575;
<a name="l00391"></a>00391     <span class="comment">/* receive address register setting */</span>
<a name="l00392"></a>00392     mac-&gt;ops.rar_set = e1000_rar_set_generic;
<a name="l00393"></a>00393     <span class="comment">/* read mac address */</span>
<a name="l00394"></a>00394     mac-&gt;ops.read_mac_addr = e1000_read_mac_addr_82575;
<a name="l00395"></a>00395     <span class="comment">/* configure collision distance */</span>
<a name="l00396"></a>00396     mac-&gt;ops.config_collision_dist = e1000_config_collision_dist_82575;
<a name="l00397"></a>00397     <span class="comment">/* multicast address update */</span>
<a name="l00398"></a>00398     mac-&gt;ops.update_mc_addr_list = e1000_update_mc_addr_list_generic;
<a name="l00399"></a>00399     <span class="comment">/* writing VFTA */</span>
<a name="l00400"></a>00400     mac-&gt;ops.write_vfta = e1000_write_vfta_generic;
<a name="l00401"></a>00401     <span class="comment">/* clearing VFTA */</span>
<a name="l00402"></a>00402     mac-&gt;ops.clear_vfta = e1000_clear_vfta_generic;
<a name="l00403"></a>00403     <span class="comment">/* ID LED init */</span>
<a name="l00404"></a>00404     mac-&gt;ops.id_led_init = e1000_id_led_init_generic;
<a name="l00405"></a>00405     <span class="comment">/* blink LED */</span>
<a name="l00406"></a>00406     mac-&gt;ops.blink_led = e1000_blink_led_generic;
<a name="l00407"></a>00407     <span class="comment">/* setup LED */</span>
<a name="l00408"></a>00408     mac-&gt;ops.setup_led = e1000_setup_led_generic;
<a name="l00409"></a>00409     <span class="comment">/* cleanup LED */</span>
<a name="l00410"></a>00410     mac-&gt;ops.cleanup_led = e1000_cleanup_led_generic;
<a name="l00411"></a>00411     <span class="comment">/* turn on/off LED */</span>
<a name="l00412"></a>00412     mac-&gt;ops.led_on = e1000_led_on_generic;
<a name="l00413"></a>00413     mac-&gt;ops.led_off = e1000_led_off_generic;
<a name="l00414"></a>00414     <span class="comment">/* clear hardware counters */</span>
<a name="l00415"></a>00415     mac-&gt;ops.clear_hw_cntrs = e1000_clear_hw_cntrs_82575;
<a name="l00416"></a>00416     <span class="comment">/* link info */</span>
<a name="l00417"></a>00417     mac-&gt;ops.get_link_up_info = e1000_get_link_up_info_82575;
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     <span class="comment">/* set lan id for port to determine which phy lock to use */</span>
<a name="l00420"></a>00420     hw-&gt;mac.ops.set_lan_id(hw);
<a name="l00421"></a>00421 
<a name="l00422"></a>00422     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l00423"></a>00423 }
<a name="l00424"></a>00424 
<a name="l00431"></a>00431 <span class="keywordtype">void</span> e1000_init_function_pointers_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00432"></a>00432 {
<a name="l00433"></a>00433     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_function_pointers_82575&quot;</span>);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     hw-&gt;mac.ops.init_params = e1000_init_mac_params_82575;
<a name="l00436"></a>00436     hw-&gt;nvm.ops.init_params = e1000_init_nvm_params_82575;
<a name="l00437"></a>00437     hw-&gt;phy.ops.init_params = e1000_init_phy_params_82575;
<a name="l00438"></a>00438     hw-&gt;mbx.ops.init_params = e1000_init_mbx_params_pf;
<a name="l00439"></a>00439 }
<a name="l00440"></a>00440 
<a name="l00447"></a>00447 <span class="keyword">static</span> s32 e1000_acquire_phy_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00448"></a>00448 {
<a name="l00449"></a>00449     u16 mask = E1000_SWFW_PHY0_SM;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451     DEBUGFUNC(<span class="stringliteral">&quot;e1000_acquire_phy_82575&quot;</span>);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_1)
<a name="l00454"></a>00454         mask = E1000_SWFW_PHY1_SM;
<a name="l00455"></a>00455     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_2)
<a name="l00456"></a>00456         mask = E1000_SWFW_PHY2_SM;
<a name="l00457"></a>00457     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_3)
<a name="l00458"></a>00458         mask = E1000_SWFW_PHY3_SM;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <span class="keywordflow">return</span> e1000_acquire_swfw_sync_82575(hw, mask);
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00469"></a>00469 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_release_phy_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471     u16 mask = E1000_SWFW_PHY0_SM;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     DEBUGFUNC(<span class="stringliteral">&quot;e1000_release_phy_82575&quot;</span>);
<a name="l00474"></a>00474 
<a name="l00475"></a>00475     <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_1)
<a name="l00476"></a>00476         mask = E1000_SWFW_PHY1_SM;
<a name="l00477"></a>00477     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_2)
<a name="l00478"></a>00478         mask = E1000_SWFW_PHY2_SM;
<a name="l00479"></a>00479     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_3)
<a name="l00480"></a>00480         mask = E1000_SWFW_PHY3_SM;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     e1000_release_swfw_sync_82575(hw, mask);
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00494"></a>00494 <span class="keyword">static</span> s32 e1000_read_phy_reg_sgmii_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset,
<a name="l00495"></a>00495                                           u16 *data)
<a name="l00496"></a>00496 {
<a name="l00497"></a>00497     s32 ret_val = -E1000_ERR_PARAM;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499     DEBUGFUNC(<span class="stringliteral">&quot;e1000_read_phy_reg_sgmii_82575&quot;</span>);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501     <span class="keywordflow">if</span> (offset &gt; E1000_MAX_SGMII_PHY_REG_ADDR) {
<a name="l00502"></a>00502         DEBUGOUT1(<span class="stringliteral">&quot;PHY Address %u is out of range\n&quot;</span>, offset);
<a name="l00503"></a>00503         <span class="keywordflow">goto</span> out;
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     ret_val = hw-&gt;phy.ops.acquire(hw);
<a name="l00507"></a>00507     <span class="keywordflow">if</span> (ret_val)
<a name="l00508"></a>00508         <span class="keywordflow">goto</span> out;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510     ret_val = e1000_read_phy_reg_i2c(hw, offset, data);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512     hw-&gt;phy.ops.release(hw);
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 out:
<a name="l00515"></a>00515     <span class="keywordflow">return</span> ret_val;
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00527"></a>00527 <span class="keyword">static</span> s32 e1000_write_phy_reg_sgmii_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset,
<a name="l00528"></a>00528                                            u16 data)
<a name="l00529"></a>00529 {
<a name="l00530"></a>00530     s32 ret_val = -E1000_ERR_PARAM;
<a name="l00531"></a>00531 
<a name="l00532"></a>00532     DEBUGFUNC(<span class="stringliteral">&quot;e1000_write_phy_reg_sgmii_82575&quot;</span>);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="keywordflow">if</span> (offset &gt; E1000_MAX_SGMII_PHY_REG_ADDR) {
<a name="l00535"></a>00535         DEBUGOUT1(<span class="stringliteral">&quot;PHY Address %d is out of range\n&quot;</span>, offset);
<a name="l00536"></a>00536         <span class="keywordflow">goto</span> out;
<a name="l00537"></a>00537     }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539     ret_val = hw-&gt;phy.ops.acquire(hw);
<a name="l00540"></a>00540     <span class="keywordflow">if</span> (ret_val)
<a name="l00541"></a>00541         <span class="keywordflow">goto</span> out;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     ret_val = e1000_write_phy_reg_i2c(hw, offset, data);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     hw-&gt;phy.ops.release(hw);
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 out:
<a name="l00548"></a>00548     <span class="keywordflow">return</span> ret_val;
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00558"></a>00558 <span class="keyword">static</span> s32 e1000_get_phy_id_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00559"></a>00559 {
<a name="l00560"></a>00560     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;hw-&gt;phy;
<a name="l00561"></a>00561     s32  ret_val = E1000_SUCCESS;
<a name="l00562"></a>00562     u16 phy_id;
<a name="l00563"></a>00563     u32 ctrl_ext;
<a name="l00564"></a>00564     u32 mdic;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     DEBUGFUNC(<span class="stringliteral">&quot;e1000_get_phy_id_82575&quot;</span>);
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="comment">/*</span>
<a name="l00569"></a>00569 <span class="comment">     * For SGMII PHYs, we try the list of possible addresses until</span>
<a name="l00570"></a>00570 <span class="comment">     * we find one that works.  For non-SGMII PHYs</span>
<a name="l00571"></a>00571 <span class="comment">     * (e.g. integrated copper PHYs), an address of 1 should</span>
<a name="l00572"></a>00572 <span class="comment">     * work.  The result of this function should mean phy-&gt;phy_addr</span>
<a name="l00573"></a>00573 <span class="comment">     * and phy-&gt;id are set correctly.</span>
<a name="l00574"></a>00574 <span class="comment">     */</span>
<a name="l00575"></a>00575     <span class="keywordflow">if</span> (!e1000_sgmii_active_82575(hw)) {
<a name="l00576"></a>00576         phy-&gt;addr = 1;
<a name="l00577"></a>00577         ret_val = e1000_get_phy_id(hw);
<a name="l00578"></a>00578         <span class="keywordflow">goto</span> out;
<a name="l00579"></a>00579     }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581     <span class="keywordflow">if</span> (e1000_sgmii_uses_mdio_82575(hw)) {
<a name="l00582"></a>00582         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00583"></a>00583         <span class="keywordflow">case</span> e1000_82575:
<a name="l00584"></a>00584         <span class="keywordflow">case</span> e1000_82576:
<a name="l00585"></a>00585             mdic = E1000_READ_REG(hw, E1000_MDIC);
<a name="l00586"></a>00586             mdic &amp;= E1000_MDIC_PHY_MASK;
<a name="l00587"></a>00587             phy-&gt;addr = mdic &gt;&gt; E1000_MDIC_PHY_SHIFT;
<a name="l00588"></a>00588             <span class="keywordflow">break</span>;
<a name="l00589"></a>00589         <span class="keywordflow">case</span> e1000_82580:
<a name="l00590"></a>00590         <span class="keywordflow">case</span> e1000_i350:
<a name="l00591"></a>00591             mdic = E1000_READ_REG(hw, E1000_MDICNFG);
<a name="l00592"></a>00592             mdic &amp;= E1000_MDICNFG_PHY_MASK;
<a name="l00593"></a>00593             phy-&gt;addr = mdic &gt;&gt; E1000_MDICNFG_PHY_SHIFT;
<a name="l00594"></a>00594             <span class="keywordflow">break</span>;
<a name="l00595"></a>00595         <span class="keywordflow">default</span>:
<a name="l00596"></a>00596             ret_val = -E1000_ERR_PHY;
<a name="l00597"></a>00597             <span class="keywordflow">goto</span> out;
<a name="l00598"></a>00598             <span class="keywordflow">break</span>;
<a name="l00599"></a>00599         }
<a name="l00600"></a>00600         ret_val = e1000_get_phy_id(hw);
<a name="l00601"></a>00601         <span class="keywordflow">goto</span> out;
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="comment">/* Power on sgmii phy if it is disabled */</span>
<a name="l00605"></a>00605     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l00606"></a>00606     E1000_WRITE_REG(hw, E1000_CTRL_EXT,
<a name="l00607"></a>00607                     ctrl_ext &amp; ~E1000_CTRL_EXT_SDP3_DATA);
<a name="l00608"></a>00608     E1000_WRITE_FLUSH(hw);
<a name="l00609"></a>00609     msec_delay(300);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     <span class="comment">/*</span>
<a name="l00612"></a>00612 <span class="comment">     * The address field in the I2CCMD register is 3 bits and 0 is invalid.</span>
<a name="l00613"></a>00613 <span class="comment">     * Therefore, we need to test 1-7</span>
<a name="l00614"></a>00614 <span class="comment">     */</span>
<a name="l00615"></a>00615     <span class="keywordflow">for</span> (phy-&gt;addr = 1; phy-&gt;addr &lt; 8; phy-&gt;addr++) {
<a name="l00616"></a>00616         ret_val = e1000_read_phy_reg_sgmii_82575(hw, PHY_ID1, &amp;phy_id);
<a name="l00617"></a>00617         <span class="keywordflow">if</span> (ret_val == E1000_SUCCESS) {
<a name="l00618"></a>00618             DEBUGOUT2(<span class="stringliteral">&quot;Vendor ID 0x%08X read at address %u\n&quot;</span>,
<a name="l00619"></a>00619                       phy_id,
<a name="l00620"></a>00620                       phy-&gt;addr);
<a name="l00621"></a>00621             <span class="comment">/*</span>
<a name="l00622"></a>00622 <span class="comment">             * At the time of this writing, The M88 part is</span>
<a name="l00623"></a>00623 <span class="comment">             * the only supported SGMII PHY product.</span>
<a name="l00624"></a>00624 <span class="comment">             */</span>
<a name="l00625"></a>00625             <span class="keywordflow">if</span> (phy_id == M88_VENDOR)
<a name="l00626"></a>00626                 <span class="keywordflow">break</span>;
<a name="l00627"></a>00627         } <span class="keywordflow">else</span> {
<a name="l00628"></a>00628             DEBUGOUT1(<span class="stringliteral">&quot;PHY address %u was unreadable\n&quot;</span>,
<a name="l00629"></a>00629                       phy-&gt;addr);
<a name="l00630"></a>00630         }
<a name="l00631"></a>00631     }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633     <span class="comment">/* A valid PHY type couldn&#39;t be found. */</span>
<a name="l00634"></a>00634     <span class="keywordflow">if</span> (phy-&gt;addr == 8) {
<a name="l00635"></a>00635         phy-&gt;addr = 0;
<a name="l00636"></a>00636         ret_val = -E1000_ERR_PHY;
<a name="l00637"></a>00637     } <span class="keywordflow">else</span> {
<a name="l00638"></a>00638         ret_val = e1000_get_phy_id(hw);
<a name="l00639"></a>00639     }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     <span class="comment">/* restore previous sfp cage power state */</span>
<a name="l00642"></a>00642     E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 out:
<a name="l00645"></a>00645     <span class="keywordflow">return</span> ret_val;
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
<a name="l00654"></a>00654 <span class="keyword">static</span> s32 e1000_phy_hw_reset_sgmii_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00655"></a>00655 {
<a name="l00656"></a>00656     s32 ret_val = E1000_SUCCESS;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     DEBUGFUNC(<span class="stringliteral">&quot;e1000_phy_hw_reset_sgmii_82575&quot;</span>);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="comment">/*</span>
<a name="l00661"></a>00661 <span class="comment">     * This isn&#39;t a true &quot;hard&quot; reset, but is the only reset</span>
<a name="l00662"></a>00662 <span class="comment">     * available to us at this time.</span>
<a name="l00663"></a>00663 <span class="comment">     */</span>
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     DEBUGOUT(<span class="stringliteral">&quot;Soft resetting SGMII attached PHY...\n&quot;</span>);
<a name="l00666"></a>00666 
<a name="l00667"></a>00667     <span class="keywordflow">if</span> (!(hw-&gt;phy.ops.write_reg))
<a name="l00668"></a>00668         <span class="keywordflow">goto</span> out;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     <span class="comment">/*</span>
<a name="l00671"></a>00671 <span class="comment">     * SFP documentation requires the following to configure the SPF module</span>
<a name="l00672"></a>00672 <span class="comment">     * to work on SGMII.  No further documentation is given.</span>
<a name="l00673"></a>00673 <span class="comment">     */</span>
<a name="l00674"></a>00674     ret_val = hw-&gt;phy.ops.write_reg(hw, 0x1B, 0x8084);
<a name="l00675"></a>00675     <span class="keywordflow">if</span> (ret_val)
<a name="l00676"></a>00676         <span class="keywordflow">goto</span> out;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     ret_val = hw-&gt;phy.ops.commit(hw);
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 out:
<a name="l00681"></a>00681     <span class="keywordflow">return</span> ret_val;
<a name="l00682"></a>00682 }
<a name="l00683"></a>00683 
<a name="l00697"></a>00697 <span class="keyword">static</span> s32 e1000_set_d0_lplu_state_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> active)
<a name="l00698"></a>00698 {
<a name="l00699"></a>00699     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;hw-&gt;phy;
<a name="l00700"></a>00700     s32 ret_val = E1000_SUCCESS;
<a name="l00701"></a>00701     u16 data;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     DEBUGFUNC(<span class="stringliteral">&quot;e1000_set_d0_lplu_state_82575&quot;</span>);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <span class="keywordflow">if</span> (!(hw-&gt;phy.ops.read_reg))
<a name="l00706"></a>00706         <span class="keywordflow">goto</span> out;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     ret_val = phy-&gt;ops.read_reg(hw, IGP02E1000_PHY_POWER_MGMT, &amp;data);
<a name="l00709"></a>00709     <span class="keywordflow">if</span> (ret_val)
<a name="l00710"></a>00710         <span class="keywordflow">goto</span> out;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712     <span class="keywordflow">if</span> (active) {
<a name="l00713"></a>00713         data |= IGP02E1000_PM_D0_LPLU;
<a name="l00714"></a>00714         ret_val = phy-&gt;ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,
<a name="l00715"></a>00715                                      data);
<a name="l00716"></a>00716         <span class="keywordflow">if</span> (ret_val)
<a name="l00717"></a>00717             <span class="keywordflow">goto</span> out;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719         <span class="comment">/* When LPLU is enabled, we should disable SmartSpeed */</span>
<a name="l00720"></a>00720         ret_val = phy-&gt;ops.read_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
<a name="l00721"></a>00721                                     &amp;data);
<a name="l00722"></a>00722         data &amp;= ~IGP01E1000_PSCFR_SMART_SPEED;
<a name="l00723"></a>00723         ret_val = phy-&gt;ops.write_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
<a name="l00724"></a>00724                                      data);
<a name="l00725"></a>00725         <span class="keywordflow">if</span> (ret_val)
<a name="l00726"></a>00726             <span class="keywordflow">goto</span> out;
<a name="l00727"></a>00727     } <span class="keywordflow">else</span> {
<a name="l00728"></a>00728         data &amp;= ~IGP02E1000_PM_D0_LPLU;
<a name="l00729"></a>00729         ret_val = phy-&gt;ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,
<a name="l00730"></a>00730                                      data);
<a name="l00731"></a>00731         <span class="comment">/*</span>
<a name="l00732"></a>00732 <span class="comment">         * LPLU and SmartSpeed are mutually exclusive.  LPLU is used</span>
<a name="l00733"></a>00733 <span class="comment">         * during Dx states where the power conservation is most</span>
<a name="l00734"></a>00734 <span class="comment">         * important.  During driver activity we should enable</span>
<a name="l00735"></a>00735 <span class="comment">         * SmartSpeed, so performance is maintained.</span>
<a name="l00736"></a>00736 <span class="comment">         */</span>
<a name="l00737"></a>00737         <span class="keywordflow">if</span> (phy-&gt;smart_speed == e1000_smart_speed_on) {
<a name="l00738"></a>00738             ret_val = phy-&gt;ops.read_reg(hw,
<a name="l00739"></a>00739                                         IGP01E1000_PHY_PORT_CONFIG,
<a name="l00740"></a>00740                                         &amp;data);
<a name="l00741"></a>00741             <span class="keywordflow">if</span> (ret_val)
<a name="l00742"></a>00742                 <span class="keywordflow">goto</span> out;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744             data |= IGP01E1000_PSCFR_SMART_SPEED;
<a name="l00745"></a>00745             ret_val = phy-&gt;ops.write_reg(hw,
<a name="l00746"></a>00746                                          IGP01E1000_PHY_PORT_CONFIG,
<a name="l00747"></a>00747                                          data);
<a name="l00748"></a>00748             <span class="keywordflow">if</span> (ret_val)
<a name="l00749"></a>00749                 <span class="keywordflow">goto</span> out;
<a name="l00750"></a>00750         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phy-&gt;smart_speed == e1000_smart_speed_off) {
<a name="l00751"></a>00751             ret_val = phy-&gt;ops.read_reg(hw,
<a name="l00752"></a>00752                                         IGP01E1000_PHY_PORT_CONFIG,
<a name="l00753"></a>00753                                         &amp;data);
<a name="l00754"></a>00754             <span class="keywordflow">if</span> (ret_val)
<a name="l00755"></a>00755                 <span class="keywordflow">goto</span> out;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757             data &amp;= ~IGP01E1000_PSCFR_SMART_SPEED;
<a name="l00758"></a>00758             ret_val = phy-&gt;ops.write_reg(hw,
<a name="l00759"></a>00759                                          IGP01E1000_PHY_PORT_CONFIG,
<a name="l00760"></a>00760                                          data);
<a name="l00761"></a>00761             <span class="keywordflow">if</span> (ret_val)
<a name="l00762"></a>00762                 <span class="keywordflow">goto</span> out;
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 out:
<a name="l00767"></a>00767     <span class="keywordflow">return</span> ret_val;
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00783"></a>00783 <span class="keyword">static</span> s32 e1000_set_d0_lplu_state_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> active)
<a name="l00784"></a>00784 {
<a name="l00785"></a>00785     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;hw-&gt;phy;
<a name="l00786"></a>00786     s32 ret_val = E1000_SUCCESS;
<a name="l00787"></a>00787     u16 data;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789     DEBUGFUNC(<span class="stringliteral">&quot;e1000_set_d0_lplu_state_82580&quot;</span>);
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     data = E1000_READ_REG(hw, E1000_82580_PHY_POWER_MGMT);
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     <span class="keywordflow">if</span> (active) {
<a name="l00794"></a>00794         data |= E1000_82580_PM_D0_LPLU;
<a name="l00795"></a>00795 
<a name="l00796"></a>00796         <span class="comment">/* When LPLU is enabled, we should disable SmartSpeed */</span>
<a name="l00797"></a>00797         data &amp;= ~E1000_82580_PM_SPD;
<a name="l00798"></a>00798     } <span class="keywordflow">else</span> {
<a name="l00799"></a>00799         data &amp;= ~E1000_82580_PM_D0_LPLU;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         <span class="comment">/*</span>
<a name="l00802"></a>00802 <span class="comment">         * LPLU and SmartSpeed are mutually exclusive.  LPLU is used</span>
<a name="l00803"></a>00803 <span class="comment">         * during Dx states where the power conservation is most</span>
<a name="l00804"></a>00804 <span class="comment">         * important.  During driver activity we should enable</span>
<a name="l00805"></a>00805 <span class="comment">         * SmartSpeed, so performance is maintained.</span>
<a name="l00806"></a>00806 <span class="comment">         */</span>
<a name="l00807"></a>00807         <span class="keywordflow">if</span> (phy-&gt;smart_speed == e1000_smart_speed_on) {
<a name="l00808"></a>00808             data |= E1000_82580_PM_SPD;
<a name="l00809"></a>00809         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phy-&gt;smart_speed == e1000_smart_speed_off) {
<a name="l00810"></a>00810             data &amp;= ~E1000_82580_PM_SPD;
<a name="l00811"></a>00811         }
<a name="l00812"></a>00812     }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814     E1000_WRITE_REG(hw, E1000_82580_PHY_POWER_MGMT, data);
<a name="l00815"></a>00815     <span class="keywordflow">return</span> ret_val;
<a name="l00816"></a>00816 }
<a name="l00817"></a>00817 
<a name="l00832"></a>00832 s32 e1000_set_d3_lplu_state_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> active)
<a name="l00833"></a>00833 {
<a name="l00834"></a>00834     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;hw-&gt;phy;
<a name="l00835"></a>00835     s32 ret_val = E1000_SUCCESS;
<a name="l00836"></a>00836     u16 data;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838     DEBUGFUNC(<span class="stringliteral">&quot;e1000_set_d3_lplu_state_82580&quot;</span>);
<a name="l00839"></a>00839 
<a name="l00840"></a>00840     data = E1000_READ_REG(hw, E1000_82580_PHY_POWER_MGMT);
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     <span class="keywordflow">if</span> (!active) {
<a name="l00843"></a>00843         data &amp;= ~E1000_82580_PM_D3_LPLU;
<a name="l00844"></a>00844         <span class="comment">/*</span>
<a name="l00845"></a>00845 <span class="comment">         * LPLU and SmartSpeed are mutually exclusive.  LPLU is used</span>
<a name="l00846"></a>00846 <span class="comment">         * during Dx states where the power conservation is most</span>
<a name="l00847"></a>00847 <span class="comment">         * important.  During driver activity we should enable</span>
<a name="l00848"></a>00848 <span class="comment">         * SmartSpeed, so performance is maintained.</span>
<a name="l00849"></a>00849 <span class="comment">         */</span>
<a name="l00850"></a>00850         <span class="keywordflow">if</span> (phy-&gt;smart_speed == e1000_smart_speed_on) {
<a name="l00851"></a>00851             data |= E1000_82580_PM_SPD;
<a name="l00852"></a>00852         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phy-&gt;smart_speed == e1000_smart_speed_off) {
<a name="l00853"></a>00853             data &amp;= ~E1000_82580_PM_SPD;
<a name="l00854"></a>00854         }
<a name="l00855"></a>00855     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((phy-&gt;autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||
<a name="l00856"></a>00856                (phy-&gt;autoneg_advertised == E1000_ALL_NOT_GIG) ||
<a name="l00857"></a>00857                (phy-&gt;autoneg_advertised == E1000_ALL_10_SPEED)) {
<a name="l00858"></a>00858         data |= E1000_82580_PM_D3_LPLU;
<a name="l00859"></a>00859         <span class="comment">/* When LPLU is enabled, we should disable SmartSpeed */</span>
<a name="l00860"></a>00860         data &amp;= ~E1000_82580_PM_SPD;
<a name="l00861"></a>00861     }
<a name="l00862"></a>00862 
<a name="l00863"></a>00863     E1000_WRITE_REG(hw, E1000_82580_PHY_POWER_MGMT, data);
<a name="l00864"></a>00864     <span class="keywordflow">return</span> ret_val;
<a name="l00865"></a>00865 }
<a name="l00866"></a>00866 
<a name="l00876"></a>00876 <span class="keyword">static</span> s32 e1000_acquire_nvm_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00877"></a>00877 {
<a name="l00878"></a>00878     s32 ret_val;
<a name="l00879"></a>00879 
<a name="l00880"></a>00880     DEBUGFUNC(<span class="stringliteral">&quot;e1000_acquire_nvm_82575&quot;</span>);
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     ret_val = e1000_acquire_swfw_sync_82575(hw, E1000_SWFW_EEP_SM);
<a name="l00883"></a>00883     <span class="keywordflow">if</span> (ret_val)
<a name="l00884"></a>00884         <span class="keywordflow">goto</span> out;
<a name="l00885"></a>00885 
<a name="l00886"></a>00886     <span class="comment">/*</span>
<a name="l00887"></a>00887 <span class="comment">     * Check if there is some access</span>
<a name="l00888"></a>00888 <span class="comment">     * error this access may hook on</span>
<a name="l00889"></a>00889 <span class="comment">     */</span>
<a name="l00890"></a>00890     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_i350) {
<a name="l00891"></a>00891         u32 eecd = E1000_READ_REG(hw, E1000_EECD);
<a name="l00892"></a>00892         <span class="keywordflow">if</span> (eecd &amp; (E1000_EECD_BLOCKED | E1000_EECD_ABORT |
<a name="l00893"></a>00893             E1000_EECD_TIMEOUT)) {
<a name="l00894"></a>00894             <span class="comment">/* Clear all access error flags */</span>
<a name="l00895"></a>00895             E1000_WRITE_REG(hw, E1000_EECD, eecd |
<a name="l00896"></a>00896                     E1000_EECD_ERROR_CLR);
<a name="l00897"></a>00897             DEBUGOUT(<span class="stringliteral">&quot;Nvm bit banging access error&quot;</span>
<a name="l00898"></a>00898                 <span class="stringliteral">&quot; detected and cleared.\n&quot;</span>);
<a name="l00899"></a>00899         }
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82580) {
<a name="l00902"></a>00902         u32 eecd = E1000_READ_REG(hw, E1000_EECD);
<a name="l00903"></a>00903         <span class="keywordflow">if</span> (eecd &amp; E1000_EECD_BLOCKED) {
<a name="l00904"></a>00904             <span class="comment">/* Clear access error flag */</span>
<a name="l00905"></a>00905             E1000_WRITE_REG(hw, E1000_EECD, eecd |
<a name="l00906"></a>00906                     E1000_EECD_BLOCKED);
<a name="l00907"></a>00907             DEBUGOUT(<span class="stringliteral">&quot;Nvm bit banging access&quot;</span>
<a name="l00908"></a>00908                 <span class="stringliteral">&quot; error detected and cleared.\n&quot;</span>);
<a name="l00909"></a>00909         }
<a name="l00910"></a>00910     }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912     ret_val = e1000_acquire_nvm_generic(hw);
<a name="l00913"></a>00913     <span class="keywordflow">if</span> (ret_val)
<a name="l00914"></a>00914         e1000_release_swfw_sync_82575(hw, E1000_SWFW_EEP_SM);
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 out:
<a name="l00917"></a>00917     <span class="keywordflow">return</span> ret_val;
<a name="l00918"></a>00918 }
<a name="l00919"></a>00919 
<a name="l00927"></a>00927 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_release_nvm_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l00928"></a>00928 {
<a name="l00929"></a>00929     DEBUGFUNC(<span class="stringliteral">&quot;e1000_release_nvm_82575&quot;</span>);
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     e1000_release_swfw_sync_82575(hw, E1000_SWFW_EEP_SM);
<a name="l00932"></a>00932 }
<a name="l00933"></a>00933 
<a name="l00942"></a>00942 <span class="keyword">static</span> s32 e1000_acquire_swfw_sync_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 mask)
<a name="l00943"></a>00943 {
<a name="l00944"></a>00944     u32 swfw_sync;
<a name="l00945"></a>00945     u32 swmask = mask;
<a name="l00946"></a>00946     u32 fwmask = mask &lt;&lt; 16;
<a name="l00947"></a>00947     s32 ret_val = E1000_SUCCESS;
<a name="l00948"></a>00948     s32 i = 0, timeout = 200; <span class="comment">/* FIXME: find real value to use here */</span>
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     DEBUGFUNC(<span class="stringliteral">&quot;e1000_acquire_swfw_sync_82575&quot;</span>);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952     <span class="keywordflow">while</span> (i &lt; timeout) {
<a name="l00953"></a>00953         <span class="keywordflow">if</span> (e1000_get_hw_semaphore_generic(hw)) {
<a name="l00954"></a>00954             ret_val = -E1000_ERR_SWFW_SYNC;
<a name="l00955"></a>00955             <span class="keywordflow">goto</span> out;
<a name="l00956"></a>00956         }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958         swfw_sync = E1000_READ_REG(hw, E1000_SW_FW_SYNC);
<a name="l00959"></a>00959         <span class="keywordflow">if</span> (!(swfw_sync &amp; (fwmask | swmask)))
<a name="l00960"></a>00960             <span class="keywordflow">break</span>;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962         <span class="comment">/*</span>
<a name="l00963"></a>00963 <span class="comment">         * Firmware currently using resource (fwmask)</span>
<a name="l00964"></a>00964 <span class="comment">         * or other software thread using resource (swmask)</span>
<a name="l00965"></a>00965 <span class="comment">         */</span>
<a name="l00966"></a>00966         e1000_put_hw_semaphore_generic(hw);
<a name="l00967"></a>00967         msec_delay_irq(5);
<a name="l00968"></a>00968         i++;
<a name="l00969"></a>00969     }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971     <span class="keywordflow">if</span> (i == timeout) {
<a name="l00972"></a>00972         DEBUGOUT(<span class="stringliteral">&quot;Driver can&#39;t access resource, SW_FW_SYNC timeout.\n&quot;</span>);
<a name="l00973"></a>00973         ret_val = -E1000_ERR_SWFW_SYNC;
<a name="l00974"></a>00974         <span class="keywordflow">goto</span> out;
<a name="l00975"></a>00975     }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977     swfw_sync |= swmask;
<a name="l00978"></a>00978     E1000_WRITE_REG(hw, E1000_SW_FW_SYNC, swfw_sync);
<a name="l00979"></a>00979 
<a name="l00980"></a>00980     e1000_put_hw_semaphore_generic(hw);
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 out:
<a name="l00983"></a>00983     <span class="keywordflow">return</span> ret_val;
<a name="l00984"></a>00984 }
<a name="l00985"></a>00985 
<a name="l00994"></a>00994 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_release_swfw_sync_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 mask)
<a name="l00995"></a>00995 {
<a name="l00996"></a>00996     u32 swfw_sync;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998     DEBUGFUNC(<span class="stringliteral">&quot;e1000_release_swfw_sync_82575&quot;</span>);
<a name="l00999"></a>00999 
<a name="l01000"></a>01000     <span class="keywordflow">while</span> (e1000_get_hw_semaphore_generic(hw) != E1000_SUCCESS);
<a name="l01001"></a>01001     <span class="comment">/* Empty */</span>
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     swfw_sync = E1000_READ_REG(hw, E1000_SW_FW_SYNC);
<a name="l01004"></a>01004     swfw_sync &amp;= ~mask;
<a name="l01005"></a>01005     E1000_WRITE_REG(hw, E1000_SW_FW_SYNC, swfw_sync);
<a name="l01006"></a>01006 
<a name="l01007"></a>01007     e1000_put_hw_semaphore_generic(hw);
<a name="l01008"></a>01008 }
<a name="l01009"></a>01009 
<a name="l01020"></a>01020 <span class="keyword">static</span> s32 e1000_get_cfg_done_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01021"></a>01021 {
<a name="l01022"></a>01022     s32 timeout = PHY_CFG_TIMEOUT;
<a name="l01023"></a>01023     s32 ret_val = E1000_SUCCESS;
<a name="l01024"></a>01024     u32 mask = E1000_NVM_CFG_DONE_PORT_0;
<a name="l01025"></a>01025 
<a name="l01026"></a>01026     DEBUGFUNC(<span class="stringliteral">&quot;e1000_get_cfg_done_82575&quot;</span>);
<a name="l01027"></a>01027 
<a name="l01028"></a>01028     <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_1)
<a name="l01029"></a>01029         mask = E1000_NVM_CFG_DONE_PORT_1;
<a name="l01030"></a>01030     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_2)
<a name="l01031"></a>01031         mask = E1000_NVM_CFG_DONE_PORT_2;
<a name="l01032"></a>01032     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hw-&gt;bus.func == E1000_FUNC_3)
<a name="l01033"></a>01033         mask = E1000_NVM_CFG_DONE_PORT_3;
<a name="l01034"></a>01034     <span class="keywordflow">while</span> (timeout) {
<a name="l01035"></a>01035         <span class="keywordflow">if</span> (E1000_READ_REG(hw, E1000_EEMNGCTL) &amp; mask)
<a name="l01036"></a>01036             <span class="keywordflow">break</span>;
<a name="l01037"></a>01037         msec_delay(1);
<a name="l01038"></a>01038         timeout--;
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040     <span class="keywordflow">if</span> (!timeout)
<a name="l01041"></a>01041         DEBUGOUT(<span class="stringliteral">&quot;MNG configuration cycle has not completed.\n&quot;</span>);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043     <span class="comment">/* If EEPROM is not marked present, init the PHY manually */</span>
<a name="l01044"></a>01044     <span class="keywordflow">if</span> (((E1000_READ_REG(hw, E1000_EECD) &amp; E1000_EECD_PRES) == 0) &amp;&amp;
<a name="l01045"></a>01045         (hw-&gt;phy.type == e1000_phy_igp_3))
<a name="l01046"></a>01046         e1000_phy_init_script_igp3(hw);
<a name="l01047"></a>01047 
<a name="l01048"></a>01048     <span class="keywordflow">return</span> ret_val;
<a name="l01049"></a>01049 }
<a name="l01050"></a>01050 
<a name="l01061"></a>01061 <span class="keyword">static</span> s32 e1000_get_link_up_info_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 *speed,
<a name="l01062"></a>01062                                         u16 *duplex)
<a name="l01063"></a>01063 {
<a name="l01064"></a>01064     s32 ret_val;
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     DEBUGFUNC(<span class="stringliteral">&quot;e1000_get_link_up_info_82575&quot;</span>);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068     <span class="keywordflow">if</span> (hw-&gt;phy.media_type != e1000_media_type_copper)
<a name="l01069"></a>01069         ret_val = e1000_get_pcs_speed_and_duplex_82575(hw, speed,
<a name="l01070"></a>01070                                                        duplex);
<a name="l01071"></a>01071     <span class="keywordflow">else</span>
<a name="l01072"></a>01072         ret_val = e1000_get_speed_and_duplex_copper_generic(hw, speed,
<a name="l01073"></a>01073                                                             duplex);
<a name="l01074"></a>01074 
<a name="l01075"></a>01075     <span class="keywordflow">return</span> ret_val;
<a name="l01076"></a>01076 }
<a name="l01077"></a>01077 
<a name="l01085"></a>01085 <span class="keyword">static</span> s32 e1000_check_for_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01086"></a>01086 {
<a name="l01087"></a>01087     s32 ret_val;
<a name="l01088"></a>01088     u16 speed, duplex;
<a name="l01089"></a>01089 
<a name="l01090"></a>01090     DEBUGFUNC(<span class="stringliteral">&quot;e1000_check_for_link_82575&quot;</span>);
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     <span class="keywordflow">if</span> (hw-&gt;phy.media_type != e1000_media_type_copper) {
<a name="l01093"></a>01093         ret_val = e1000_get_pcs_speed_and_duplex_82575(hw, &amp;speed,
<a name="l01094"></a>01094                                                        &amp;duplex);
<a name="l01095"></a>01095         <span class="comment">/*</span>
<a name="l01096"></a>01096 <span class="comment">         * Use this flag to determine if link needs to be checked or</span>
<a name="l01097"></a>01097 <span class="comment">         * not.  If we have link clear the flag so that we do not</span>
<a name="l01098"></a>01098 <span class="comment">         * continue to check for link.</span>
<a name="l01099"></a>01099 <span class="comment">         */</span>
<a name="l01100"></a>01100         hw-&gt;mac.get_link_status = !hw-&gt;mac.serdes_has_link;
<a name="l01101"></a>01101     } <span class="keywordflow">else</span> {
<a name="l01102"></a>01102         ret_val = e1000_check_for_copper_link_generic(hw);
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105     <span class="keywordflow">return</span> ret_val;
<a name="l01106"></a>01106 }
<a name="l01107"></a>01107 
<a name="l01112"></a>01112 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_power_up_serdes_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01113"></a>01113 {
<a name="l01114"></a>01114     u32 reg;
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     DEBUGFUNC(<span class="stringliteral">&quot;e1000_power_up_serdes_link_82575&quot;</span>);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type != e1000_media_type_internal_serdes) &amp;&amp;
<a name="l01119"></a>01119         !e1000_sgmii_active_82575(hw))
<a name="l01120"></a>01120         <span class="keywordflow">return</span>;
<a name="l01121"></a>01121 
<a name="l01122"></a>01122     <span class="comment">/* Enable PCS to turn on link */</span>
<a name="l01123"></a>01123     reg = E1000_READ_REG(hw, E1000_PCS_CFG0);
<a name="l01124"></a>01124     reg |= E1000_PCS_CFG_PCS_EN;
<a name="l01125"></a>01125     E1000_WRITE_REG(hw, E1000_PCS_CFG0, reg);
<a name="l01126"></a>01126 
<a name="l01127"></a>01127     <span class="comment">/* Power up the laser */</span>
<a name="l01128"></a>01128     reg = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l01129"></a>01129     reg &amp;= ~E1000_CTRL_EXT_SDP3_DATA;
<a name="l01130"></a>01130     E1000_WRITE_REG(hw, E1000_CTRL_EXT, reg);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132     <span class="comment">/* flush the write to verify completion */</span>
<a name="l01133"></a>01133     E1000_WRITE_FLUSH(hw);
<a name="l01134"></a>01134     msec_delay(1);
<a name="l01135"></a>01135 }
<a name="l01136"></a>01136 
<a name="l01146"></a>01146 <span class="keyword">static</span> s32 e1000_get_pcs_speed_and_duplex_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw,
<a name="l01147"></a>01147                                                 u16 *speed, u16 *duplex)
<a name="l01148"></a>01148 {
<a name="l01149"></a>01149     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l01150"></a>01150     u32 pcs;
<a name="l01151"></a>01151 
<a name="l01152"></a>01152     DEBUGFUNC(<span class="stringliteral">&quot;e1000_get_pcs_speed_and_duplex_82575&quot;</span>);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154     <span class="comment">/* Set up defaults for the return values of this function */</span>
<a name="l01155"></a>01155     mac-&gt;serdes_has_link = <span class="keyword">false</span>;
<a name="l01156"></a>01156     *speed = 0;
<a name="l01157"></a>01157     *duplex = 0;
<a name="l01158"></a>01158 
<a name="l01159"></a>01159     <span class="comment">/*</span>
<a name="l01160"></a>01160 <span class="comment">     * Read the PCS Status register for link state. For non-copper mode,</span>
<a name="l01161"></a>01161 <span class="comment">     * the status register is not accurate. The PCS status register is</span>
<a name="l01162"></a>01162 <span class="comment">     * used instead.</span>
<a name="l01163"></a>01163 <span class="comment">     */</span>
<a name="l01164"></a>01164     pcs = E1000_READ_REG(hw, E1000_PCS_LSTAT);
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     <span class="comment">/*</span>
<a name="l01167"></a>01167 <span class="comment">     * The link up bit determines when link is up on autoneg. The sync ok</span>
<a name="l01168"></a>01168 <span class="comment">     * gets set once both sides sync up and agree upon link. Stable link</span>
<a name="l01169"></a>01169 <span class="comment">     * can be determined by checking for both link up and link sync ok</span>
<a name="l01170"></a>01170 <span class="comment">     */</span>
<a name="l01171"></a>01171     <span class="keywordflow">if</span> ((pcs &amp; E1000_PCS_LSTS_LINK_OK) &amp;&amp; (pcs &amp; E1000_PCS_LSTS_SYNK_OK)) {
<a name="l01172"></a>01172         mac-&gt;serdes_has_link = <span class="keyword">true</span>;
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         <span class="comment">/* Detect and store PCS speed */</span>
<a name="l01175"></a>01175         <span class="keywordflow">if</span> (pcs &amp; E1000_PCS_LSTS_SPEED_1000) {
<a name="l01176"></a>01176             *speed = SPEED_1000;
<a name="l01177"></a>01177         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcs &amp; E1000_PCS_LSTS_SPEED_100) {
<a name="l01178"></a>01178             *speed = SPEED_100;
<a name="l01179"></a>01179         } <span class="keywordflow">else</span> {
<a name="l01180"></a>01180             *speed = SPEED_10;
<a name="l01181"></a>01181         }
<a name="l01182"></a>01182 
<a name="l01183"></a>01183         <span class="comment">/* Detect and store PCS duplex */</span>
<a name="l01184"></a>01184         <span class="keywordflow">if</span> (pcs &amp; E1000_PCS_LSTS_DUPLEX_FULL) {
<a name="l01185"></a>01185             *duplex = FULL_DUPLEX;
<a name="l01186"></a>01186         } <span class="keywordflow">else</span> {
<a name="l01187"></a>01187             *duplex = HALF_DUPLEX;
<a name="l01188"></a>01188         }
<a name="l01189"></a>01189     }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l01192"></a>01192 }
<a name="l01193"></a>01193 
<a name="l01201"></a>01201 <span class="keywordtype">void</span> e1000_shutdown_serdes_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01202"></a>01202 {
<a name="l01203"></a>01203     u32 reg;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205     DEBUGFUNC(<span class="stringliteral">&quot;e1000_shutdown_serdes_link_82575&quot;</span>);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type != e1000_media_type_internal_serdes) &amp;&amp;
<a name="l01208"></a>01208         !e1000_sgmii_active_82575(hw))
<a name="l01209"></a>01209         <span class="keywordflow">return</span>;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211     <span class="keywordflow">if</span> (!e1000_enable_mng_pass_thru(hw)) {
<a name="l01212"></a>01212         <span class="comment">/* Disable PCS to turn off link */</span>
<a name="l01213"></a>01213         reg = E1000_READ_REG(hw, E1000_PCS_CFG0);
<a name="l01214"></a>01214         reg &amp;= ~E1000_PCS_CFG_PCS_EN;
<a name="l01215"></a>01215         E1000_WRITE_REG(hw, E1000_PCS_CFG0, reg);
<a name="l01216"></a>01216 
<a name="l01217"></a>01217         <span class="comment">/* shutdown the laser */</span>
<a name="l01218"></a>01218         reg = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l01219"></a>01219         reg |= E1000_CTRL_EXT_SDP3_DATA;
<a name="l01220"></a>01220         E1000_WRITE_REG(hw, E1000_CTRL_EXT, reg);
<a name="l01221"></a>01221 
<a name="l01222"></a>01222         <span class="comment">/* flush the write to verify completion */</span>
<a name="l01223"></a>01223         E1000_WRITE_FLUSH(hw);
<a name="l01224"></a>01224         msec_delay(1);
<a name="l01225"></a>01225     }
<a name="l01226"></a>01226 
<a name="l01227"></a>01227     <span class="keywordflow">return</span>;
<a name="l01228"></a>01228 }
<a name="l01229"></a>01229 
<a name="l01236"></a>01236 <span class="keyword">static</span> s32 e1000_reset_hw_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238     u32 ctrl;
<a name="l01239"></a>01239     s32 ret_val;
<a name="l01240"></a>01240 
<a name="l01241"></a>01241     DEBUGFUNC(<span class="stringliteral">&quot;e1000_reset_hw_82575&quot;</span>);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243     <span class="comment">/*</span>
<a name="l01244"></a>01244 <span class="comment">     * Prevent the PCI-E bus from sticking if there is no TLP connection</span>
<a name="l01245"></a>01245 <span class="comment">     * on the last TLP read/write transaction when MAC is reset.</span>
<a name="l01246"></a>01246 <span class="comment">     */</span>
<a name="l01247"></a>01247     ret_val = e1000_disable_pcie_master_generic(hw);
<a name="l01248"></a>01248     <span class="keywordflow">if</span> (ret_val) {
<a name="l01249"></a>01249         DEBUGOUT(<span class="stringliteral">&quot;PCI-E Master disable polling has failed.\n&quot;</span>);
<a name="l01250"></a>01250     }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252     <span class="comment">/* set the completion timeout for interface */</span>
<a name="l01253"></a>01253     ret_val = e1000_set_pcie_completion_timeout(hw);
<a name="l01254"></a>01254     <span class="keywordflow">if</span> (ret_val) {
<a name="l01255"></a>01255         DEBUGOUT(<span class="stringliteral">&quot;PCI-E Set completion timeout has failed.\n&quot;</span>);
<a name="l01256"></a>01256     }
<a name="l01257"></a>01257 
<a name="l01258"></a>01258     DEBUGOUT(<span class="stringliteral">&quot;Masking off all interrupts\n&quot;</span>);
<a name="l01259"></a>01259     E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);
<a name="l01260"></a>01260 
<a name="l01261"></a>01261     E1000_WRITE_REG(hw, E1000_RCTL, 0);
<a name="l01262"></a>01262     E1000_WRITE_REG(hw, E1000_TCTL, E1000_TCTL_PSP);
<a name="l01263"></a>01263     E1000_WRITE_FLUSH(hw);
<a name="l01264"></a>01264 
<a name="l01265"></a>01265     msec_delay(10);
<a name="l01266"></a>01266 
<a name="l01267"></a>01267     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269     DEBUGOUT(<span class="stringliteral">&quot;Issuing a global reset to MAC\n&quot;</span>);
<a name="l01270"></a>01270     E1000_WRITE_REG(hw, E1000_CTRL, ctrl | E1000_CTRL_RST);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272     ret_val = e1000_get_auto_rd_done_generic(hw);
<a name="l01273"></a>01273     <span class="keywordflow">if</span> (ret_val) {
<a name="l01274"></a>01274         <span class="comment">/*</span>
<a name="l01275"></a>01275 <span class="comment">         * When auto config read does not complete, do not</span>
<a name="l01276"></a>01276 <span class="comment">         * return with an error. This can happen in situations</span>
<a name="l01277"></a>01277 <span class="comment">         * where there is no eeprom and prevents getting link.</span>
<a name="l01278"></a>01278 <span class="comment">         */</span>
<a name="l01279"></a>01279         DEBUGOUT(<span class="stringliteral">&quot;Auto Read Done did not complete\n&quot;</span>);
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     <span class="comment">/* If EEPROM is not present, run manual init scripts */</span>
<a name="l01283"></a>01283     <span class="keywordflow">if</span> ((E1000_READ_REG(hw, E1000_EECD) &amp; E1000_EECD_PRES) == 0)
<a name="l01284"></a>01284         e1000_reset_init_script_82575(hw);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="comment">/* Clear any pending interrupt events. */</span>
<a name="l01287"></a>01287     E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);
<a name="l01288"></a>01288     E1000_READ_REG(hw, E1000_ICR);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290     <span class="comment">/* Install any alternate MAC address into RAR0 */</span>
<a name="l01291"></a>01291     ret_val = e1000_check_alt_mac_addr_generic(hw);
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     <span class="keywordflow">return</span> ret_val;
<a name="l01294"></a>01294 }
<a name="l01295"></a>01295 
<a name="l01302"></a>01302 <span class="keyword">static</span> s32 e1000_init_hw_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01303"></a>01303 {
<a name="l01304"></a>01304     <span class="keyword">struct </span><a class="code" href="structe1000__mac__info.html">e1000_mac_info</a> *mac = &amp;hw-&gt;mac;
<a name="l01305"></a>01305     s32 ret_val;
<a name="l01306"></a>01306     u16 i, rar_count = mac-&gt;rar_entry_count;
<a name="l01307"></a>01307 
<a name="l01308"></a>01308     DEBUGFUNC(<span class="stringliteral">&quot;e1000_init_hw_82575&quot;</span>);
<a name="l01309"></a>01309 
<a name="l01310"></a>01310     <span class="comment">/* Initialize identification LED */</span>
<a name="l01311"></a>01311     ret_val = mac-&gt;ops.id_led_init(hw);
<a name="l01312"></a>01312     <span class="keywordflow">if</span> (ret_val) {
<a name="l01313"></a>01313         DEBUGOUT(<span class="stringliteral">&quot;Error initializing identification LED\n&quot;</span>);
<a name="l01314"></a>01314         <span class="comment">/* This is not fatal and we should not stop init due to this */</span>
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="comment">/* Disabling VLAN filtering */</span>
<a name="l01318"></a>01318     DEBUGOUT(<span class="stringliteral">&quot;Initializing the IEEE VLAN\n&quot;</span>);
<a name="l01319"></a>01319     mac-&gt;ops.clear_vfta(hw);
<a name="l01320"></a>01320 
<a name="l01321"></a>01321     <span class="comment">/* Setup the receive address */</span>
<a name="l01322"></a>01322     e1000_init_rx_addrs_generic(hw, rar_count);
<a name="l01323"></a>01323 
<a name="l01324"></a>01324     <span class="comment">/* Zero out the Multicast HASH table */</span>
<a name="l01325"></a>01325     DEBUGOUT(<span class="stringliteral">&quot;Zeroing the MTA\n&quot;</span>);
<a name="l01326"></a>01326     <span class="keywordflow">for</span> (i = 0; i &lt; mac-&gt;mta_reg_count; i++)
<a name="l01327"></a>01327         E1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);
<a name="l01328"></a>01328 
<a name="l01329"></a>01329     <span class="comment">/* Zero out the Unicast HASH table */</span>
<a name="l01330"></a>01330     DEBUGOUT(<span class="stringliteral">&quot;Zeroing the UTA\n&quot;</span>);
<a name="l01331"></a>01331     <span class="keywordflow">for</span> (i = 0; i &lt; mac-&gt;uta_reg_count; i++)
<a name="l01332"></a>01332         E1000_WRITE_REG_ARRAY(hw, E1000_UTA, i, 0);
<a name="l01333"></a>01333 
<a name="l01334"></a>01334     <span class="comment">/* Setup link and flow control */</span>
<a name="l01335"></a>01335     ret_val = mac-&gt;ops.setup_link(hw);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     <span class="comment">/*</span>
<a name="l01338"></a>01338 <span class="comment">     * Clear all of the statistics registers (clear on read).  It is</span>
<a name="l01339"></a>01339 <span class="comment">     * important that we do this after we have tried to establish link</span>
<a name="l01340"></a>01340 <span class="comment">     * because the symbol error count will increment wildly if there</span>
<a name="l01341"></a>01341 <span class="comment">     * is no link.</span>
<a name="l01342"></a>01342 <span class="comment">     */</span>
<a name="l01343"></a>01343     e1000_clear_hw_cntrs_82575(hw);
<a name="l01344"></a>01344 
<a name="l01345"></a>01345     <span class="keywordflow">return</span> ret_val;
<a name="l01346"></a>01346 }
<a name="l01347"></a>01347 
<a name="l01356"></a>01356 <span class="keyword">static</span> s32 e1000_setup_copper_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01357"></a>01357 {
<a name="l01358"></a>01358     u32 ctrl;
<a name="l01359"></a>01359     s32  ret_val;
<a name="l01360"></a>01360 
<a name="l01361"></a>01361     DEBUGFUNC(<span class="stringliteral">&quot;e1000_setup_copper_link_82575&quot;</span>);
<a name="l01362"></a>01362 
<a name="l01363"></a>01363     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01364"></a>01364     ctrl |= E1000_CTRL_SLU;
<a name="l01365"></a>01365     ctrl &amp;= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
<a name="l01366"></a>01366     E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l01367"></a>01367 
<a name="l01368"></a>01368     ret_val = e1000_setup_serdes_link_82575(hw);
<a name="l01369"></a>01369     <span class="keywordflow">if</span> (ret_val)
<a name="l01370"></a>01370         <span class="keywordflow">goto</span> out;
<a name="l01371"></a>01371 
<a name="l01372"></a>01372     <span class="keywordflow">if</span> (e1000_sgmii_active_82575(hw) &amp;&amp; !hw-&gt;phy.reset_disable) {
<a name="l01373"></a>01373         <span class="comment">/* allow time for SFP cage time to power up phy */</span>
<a name="l01374"></a>01374         msec_delay(300);
<a name="l01375"></a>01375 
<a name="l01376"></a>01376         ret_val = hw-&gt;phy.ops.reset(hw);
<a name="l01377"></a>01377         <span class="keywordflow">if</span> (ret_val) {
<a name="l01378"></a>01378             DEBUGOUT(<span class="stringliteral">&quot;Error resetting the PHY.\n&quot;</span>);
<a name="l01379"></a>01379             <span class="keywordflow">goto</span> out;
<a name="l01380"></a>01380         }
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382     <span class="keywordflow">switch</span> (hw-&gt;phy.type) {
<a name="l01383"></a>01383     <span class="keywordflow">case</span> e1000_phy_m88:
<a name="l01384"></a>01384         <span class="keywordflow">if</span> (hw-&gt;phy.id == I347AT4_E_PHY_ID ||
<a name="l01385"></a>01385             hw-&gt;phy.id == M88E1112_E_PHY_ID ||
<a name="l01386"></a>01386             hw-&gt;phy.id == M88E1340M_E_PHY_ID)
<a name="l01387"></a>01387             ret_val = e1000_copper_link_setup_m88_gen2(hw);
<a name="l01388"></a>01388         <span class="keywordflow">else</span>
<a name="l01389"></a>01389             ret_val = e1000_copper_link_setup_m88(hw);
<a name="l01390"></a>01390         <span class="keywordflow">break</span>;
<a name="l01391"></a>01391     <span class="keywordflow">case</span> e1000_phy_igp_3:
<a name="l01392"></a>01392         ret_val = e1000_copper_link_setup_igp(hw);
<a name="l01393"></a>01393         <span class="keywordflow">break</span>;
<a name="l01394"></a>01394     <span class="keywordflow">case</span> e1000_phy_82580:
<a name="l01395"></a>01395         ret_val = e1000_copper_link_setup_82577(hw);
<a name="l01396"></a>01396         <span class="keywordflow">break</span>;
<a name="l01397"></a>01397     <span class="keywordflow">default</span>:
<a name="l01398"></a>01398         ret_val = -E1000_ERR_PHY;
<a name="l01399"></a>01399         <span class="keywordflow">break</span>;
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402     <span class="keywordflow">if</span> (ret_val)
<a name="l01403"></a>01403         <span class="keywordflow">goto</span> out;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405     ret_val = e1000_setup_copper_link_generic(hw);
<a name="l01406"></a>01406 out:
<a name="l01407"></a>01407     <span class="keywordflow">return</span> ret_val;
<a name="l01408"></a>01408 }
<a name="l01409"></a>01409 
<a name="l01419"></a>01419 <span class="keyword">static</span> s32 e1000_setup_serdes_link_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01420"></a>01420 {
<a name="l01421"></a>01421     u32 ctrl_ext, ctrl_reg, reg;
<a name="l01422"></a>01422     <span class="keywordtype">bool</span> pcs_autoneg;
<a name="l01423"></a>01423 
<a name="l01424"></a>01424     DEBUGFUNC(<span class="stringliteral">&quot;e1000_setup_serdes_link_82575&quot;</span>);
<a name="l01425"></a>01425 
<a name="l01426"></a>01426     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type != e1000_media_type_internal_serdes) &amp;&amp;
<a name="l01427"></a>01427         !e1000_sgmii_active_82575(hw))
<a name="l01428"></a>01428         <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l01429"></a>01429 
<a name="l01430"></a>01430     <span class="comment">/*</span>
<a name="l01431"></a>01431 <span class="comment">     * On the 82575, SerDes loopback mode persists until it is</span>
<a name="l01432"></a>01432 <span class="comment">     * explicitly turned off or a power cycle is performed.  A read to</span>
<a name="l01433"></a>01433 <span class="comment">     * the register does not indicate its status.  Therefore, we ensure</span>
<a name="l01434"></a>01434 <span class="comment">     * loopback mode is disabled during initialization.</span>
<a name="l01435"></a>01435 <span class="comment">     */</span>
<a name="l01436"></a>01436     E1000_WRITE_REG(hw, E1000_SCTL, E1000_SCTL_DISABLE_SERDES_LOOPBACK);
<a name="l01437"></a>01437 
<a name="l01438"></a>01438     <span class="comment">/* power on the sfp cage if present */</span>
<a name="l01439"></a>01439     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l01440"></a>01440     ctrl_ext &amp;= ~E1000_CTRL_EXT_SDP3_DATA;
<a name="l01441"></a>01441     E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
<a name="l01442"></a>01442 
<a name="l01443"></a>01443     ctrl_reg = E1000_READ_REG(hw, E1000_CTRL);
<a name="l01444"></a>01444     ctrl_reg |= E1000_CTRL_SLU;
<a name="l01445"></a>01445 
<a name="l01446"></a>01446     <span class="comment">/* set both sw defined pins on 82575/82576*/</span>
<a name="l01447"></a>01447     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82575 || hw-&gt;mac.type == e1000_82576)
<a name="l01448"></a>01448         ctrl_reg |= E1000_CTRL_SWDPIN0 | E1000_CTRL_SWDPIN1;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450     reg = E1000_READ_REG(hw, E1000_PCS_LCTL);
<a name="l01451"></a>01451 
<a name="l01452"></a>01452     <span class="comment">/* default pcs_autoneg to the same setting as mac autoneg */</span>
<a name="l01453"></a>01453     pcs_autoneg = hw-&gt;mac.autoneg;
<a name="l01454"></a>01454 
<a name="l01455"></a>01455     <span class="keywordflow">switch</span> (ctrl_ext &amp; E1000_CTRL_EXT_LINK_MODE_MASK) {
<a name="l01456"></a>01456     <span class="keywordflow">case</span> E1000_CTRL_EXT_LINK_MODE_SGMII:
<a name="l01457"></a>01457         <span class="comment">/* sgmii mode lets the phy handle forcing speed/duplex */</span>
<a name="l01458"></a>01458         pcs_autoneg = <span class="keyword">true</span>;
<a name="l01459"></a>01459         <span class="comment">/* autoneg time out should be disabled for SGMII mode */</span>
<a name="l01460"></a>01460         reg &amp;= ~(E1000_PCS_LCTL_AN_TIMEOUT);
<a name="l01461"></a>01461         <span class="keywordflow">break</span>;
<a name="l01462"></a>01462     <span class="keywordflow">case</span> E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:
<a name="l01463"></a>01463         <span class="comment">/* disable PCS autoneg and support parallel detect only */</span>
<a name="l01464"></a>01464         pcs_autoneg = <span class="keyword">false</span>;
<a name="l01465"></a>01465         <span class="comment">/* fall through to default case */</span>
<a name="l01466"></a>01466     <span class="keywordflow">default</span>:
<a name="l01467"></a>01467         <span class="comment">/*</span>
<a name="l01468"></a>01468 <span class="comment">         * non-SGMII modes only supports a speed of 1000/Full for the</span>
<a name="l01469"></a>01469 <span class="comment">         * link so it is best to just force the MAC and let the pcs</span>
<a name="l01470"></a>01470 <span class="comment">         * link either autoneg or be forced to 1000/Full</span>
<a name="l01471"></a>01471 <span class="comment">         */</span>
<a name="l01472"></a>01472         ctrl_reg |= E1000_CTRL_SPD_1000 | E1000_CTRL_FRCSPD |
<a name="l01473"></a>01473                     E1000_CTRL_FD | E1000_CTRL_FRCDPX;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475         <span class="comment">/* set speed of 1000/Full if speed/duplex is forced */</span>
<a name="l01476"></a>01476         reg |= E1000_PCS_LCTL_FSV_1000 | E1000_PCS_LCTL_FDV_FULL;
<a name="l01477"></a>01477         <span class="keywordflow">break</span>;
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480     E1000_WRITE_REG(hw, E1000_CTRL, ctrl_reg);
<a name="l01481"></a>01481 
<a name="l01482"></a>01482     <span class="comment">/*</span>
<a name="l01483"></a>01483 <span class="comment">     * New SerDes mode allows for forcing speed or autonegotiating speed</span>
<a name="l01484"></a>01484 <span class="comment">     * at 1gb. Autoneg should be default set by most drivers. This is the</span>
<a name="l01485"></a>01485 <span class="comment">     * mode that will be compatible with older link partners and switches.</span>
<a name="l01486"></a>01486 <span class="comment">     * However, both are supported by the hardware and some drivers/tools.</span>
<a name="l01487"></a>01487 <span class="comment">     */</span>
<a name="l01488"></a>01488     reg &amp;= ~(E1000_PCS_LCTL_AN_ENABLE | E1000_PCS_LCTL_FLV_LINK_UP |
<a name="l01489"></a>01489              E1000_PCS_LCTL_FSD | E1000_PCS_LCTL_FORCE_LINK);
<a name="l01490"></a>01490 
<a name="l01491"></a>01491     <span class="comment">/*</span>
<a name="l01492"></a>01492 <span class="comment">     * We force flow control to prevent the CTRL register values from being</span>
<a name="l01493"></a>01493 <span class="comment">     * overwritten by the autonegotiated flow control values</span>
<a name="l01494"></a>01494 <span class="comment">     */</span>
<a name="l01495"></a>01495     reg |= E1000_PCS_LCTL_FORCE_FCTRL;
<a name="l01496"></a>01496 
<a name="l01497"></a>01497     <span class="keywordflow">if</span> (pcs_autoneg) {
<a name="l01498"></a>01498         <span class="comment">/* Set PCS register for autoneg */</span>
<a name="l01499"></a>01499         reg |= E1000_PCS_LCTL_AN_ENABLE | <span class="comment">/* Enable Autoneg */</span>
<a name="l01500"></a>01500                E1000_PCS_LCTL_AN_RESTART; <span class="comment">/* Restart autoneg */</span>
<a name="l01501"></a>01501         DEBUGOUT1(<span class="stringliteral">&quot;Configuring Autoneg:PCS_LCTL=0x%08X\n&quot;</span>, reg);
<a name="l01502"></a>01502     } <span class="keywordflow">else</span> {
<a name="l01503"></a>01503         <span class="comment">/* Set PCS register for forced link */</span>
<a name="l01504"></a>01504         reg |= E1000_PCS_LCTL_FSD;        <span class="comment">/* Force Speed */</span>
<a name="l01505"></a>01505         DEBUGOUT1(<span class="stringliteral">&quot;Configuring Forced Link:PCS_LCTL=0x%08X\n&quot;</span>, reg);
<a name="l01506"></a>01506     }
<a name="l01507"></a>01507 
<a name="l01508"></a>01508     E1000_WRITE_REG(hw, E1000_PCS_LCTL, reg);
<a name="l01509"></a>01509 
<a name="l01510"></a>01510     <span class="keywordflow">if</span> (!e1000_sgmii_active_82575(hw))
<a name="l01511"></a>01511         e1000_force_mac_fc_generic(hw);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l01514"></a>01514 }
<a name="l01515"></a>01515 
<a name="l01524"></a>01524 <span class="keyword">static</span> s32 e1000_valid_led_default_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 *data)
<a name="l01525"></a>01525 {
<a name="l01526"></a>01526     s32 ret_val;
<a name="l01527"></a>01527 
<a name="l01528"></a>01528     DEBUGFUNC(<span class="stringliteral">&quot;e1000_valid_led_default_82575&quot;</span>);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530     ret_val = hw-&gt;nvm.ops.read(hw, NVM_ID_LED_SETTINGS, 1, data);
<a name="l01531"></a>01531     <span class="keywordflow">if</span> (ret_val) {
<a name="l01532"></a>01532         DEBUGOUT(<span class="stringliteral">&quot;NVM Read Error\n&quot;</span>);
<a name="l01533"></a>01533         <span class="keywordflow">goto</span> out;
<a name="l01534"></a>01534     }
<a name="l01535"></a>01535 
<a name="l01536"></a>01536     <span class="keywordflow">if</span> (*data == ID_LED_RESERVED_0000 || *data == ID_LED_RESERVED_FFFF) {
<a name="l01537"></a>01537         <span class="keywordflow">switch</span>(hw-&gt;phy.media_type) {
<a name="l01538"></a>01538         <span class="keywordflow">case</span> e1000_media_type_internal_serdes:
<a name="l01539"></a>01539             *data = ID_LED_DEFAULT_82575_SERDES;
<a name="l01540"></a>01540             <span class="keywordflow">break</span>;
<a name="l01541"></a>01541         <span class="keywordflow">case</span> e1000_media_type_copper:
<a name="l01542"></a>01542         <span class="keywordflow">default</span>:
<a name="l01543"></a>01543             *data = ID_LED_DEFAULT;
<a name="l01544"></a>01544             <span class="keywordflow">break</span>;
<a name="l01545"></a>01545         }
<a name="l01546"></a>01546     }
<a name="l01547"></a>01547 out:
<a name="l01548"></a>01548     <span class="keywordflow">return</span> ret_val;
<a name="l01549"></a>01549 }
<a name="l01550"></a>01550 
<a name="l01559"></a>01559 <span class="keyword">static</span> <span class="keywordtype">bool</span> e1000_sgmii_active_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01560"></a>01560 {
<a name="l01561"></a>01561     <span class="keyword">struct </span><a class="code" href="structe1000__dev__spec__82575.html">e1000_dev_spec_82575</a> *dev_spec = &amp;hw-&gt;dev_spec._82575;
<a name="l01562"></a>01562     <span class="keywordflow">return</span> dev_spec-&gt;sgmii_active;
<a name="l01563"></a>01563 }
<a name="l01564"></a>01564 
<a name="l01572"></a>01572 <span class="keyword">static</span> s32 e1000_reset_init_script_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a>* hw)
<a name="l01573"></a>01573 {
<a name="l01574"></a>01574     DEBUGFUNC(<span class="stringliteral">&quot;e1000_reset_init_script_82575&quot;</span>);
<a name="l01575"></a>01575 
<a name="l01576"></a>01576     <span class="keywordflow">if</span> (hw-&gt;mac.type == e1000_82575) {
<a name="l01577"></a>01577         DEBUGOUT(<span class="stringliteral">&quot;Running reset init script for 82575\n&quot;</span>);
<a name="l01578"></a>01578         <span class="comment">/* SerDes configuration via SERDESCTRL */</span>
<a name="l01579"></a>01579         e1000_write_8bit_ctrl_reg_generic(hw, E1000_SCTL, 0x00, 0x0C);
<a name="l01580"></a>01580         e1000_write_8bit_ctrl_reg_generic(hw, E1000_SCTL, 0x01, 0x78);
<a name="l01581"></a>01581         e1000_write_8bit_ctrl_reg_generic(hw, E1000_SCTL, 0x1B, 0x23);
<a name="l01582"></a>01582         e1000_write_8bit_ctrl_reg_generic(hw, E1000_SCTL, 0x23, 0x15);
<a name="l01583"></a>01583 
<a name="l01584"></a>01584         <span class="comment">/* CCM configuration via CCMCTL register */</span>
<a name="l01585"></a>01585         e1000_write_8bit_ctrl_reg_generic(hw, E1000_CCMCTL, 0x14, 0x00);
<a name="l01586"></a>01586         e1000_write_8bit_ctrl_reg_generic(hw, E1000_CCMCTL, 0x10, 0x00);
<a name="l01587"></a>01587 
<a name="l01588"></a>01588         <span class="comment">/* PCIe lanes configuration */</span>
<a name="l01589"></a>01589         e1000_write_8bit_ctrl_reg_generic(hw, E1000_GIOCTL, 0x00, 0xEC);
<a name="l01590"></a>01590         e1000_write_8bit_ctrl_reg_generic(hw, E1000_GIOCTL, 0x61, 0xDF);
<a name="l01591"></a>01591         e1000_write_8bit_ctrl_reg_generic(hw, E1000_GIOCTL, 0x34, 0x05);
<a name="l01592"></a>01592         e1000_write_8bit_ctrl_reg_generic(hw, E1000_GIOCTL, 0x2F, 0x81);
<a name="l01593"></a>01593 
<a name="l01594"></a>01594         <span class="comment">/* PCIe PLL Configuration */</span>
<a name="l01595"></a>01595         e1000_write_8bit_ctrl_reg_generic(hw, E1000_SCCTL, 0x02, 0x47);
<a name="l01596"></a>01596         e1000_write_8bit_ctrl_reg_generic(hw, E1000_SCCTL, 0x14, 0x00);
<a name="l01597"></a>01597         e1000_write_8bit_ctrl_reg_generic(hw, E1000_SCCTL, 0x10, 0x00);
<a name="l01598"></a>01598     }
<a name="l01599"></a>01599 
<a name="l01600"></a>01600     <span class="keywordflow">return</span> E1000_SUCCESS;
<a name="l01601"></a>01601 }
<a name="l01602"></a>01602 
<a name="l01607"></a>01607 <span class="keyword">static</span> s32 e1000_read_mac_addr_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01608"></a>01608 {
<a name="l01609"></a>01609     s32 ret_val = E1000_SUCCESS;
<a name="l01610"></a>01610 
<a name="l01611"></a>01611     DEBUGFUNC(<span class="stringliteral">&quot;e1000_read_mac_addr_82575&quot;</span>);
<a name="l01612"></a>01612 
<a name="l01613"></a>01613     <span class="comment">/*</span>
<a name="l01614"></a>01614 <span class="comment">     * If there&#39;s an alternate MAC address place it in RAR0</span>
<a name="l01615"></a>01615 <span class="comment">     * so that it will override the Si installed default perm</span>
<a name="l01616"></a>01616 <span class="comment">     * address.</span>
<a name="l01617"></a>01617 <span class="comment">     */</span>
<a name="l01618"></a>01618     ret_val = e1000_check_alt_mac_addr_generic(hw);
<a name="l01619"></a>01619     <span class="keywordflow">if</span> (ret_val)
<a name="l01620"></a>01620         <span class="keywordflow">goto</span> out;
<a name="l01621"></a>01621 
<a name="l01622"></a>01622     ret_val = e1000_read_mac_addr_generic(hw);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 out:
<a name="l01625"></a>01625     <span class="keywordflow">return</span> ret_val;
<a name="l01626"></a>01626 }
<a name="l01627"></a>01627 
<a name="l01635"></a>01635 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_config_collision_dist_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01636"></a>01636 {
<a name="l01637"></a>01637     u32 tctl_ext;
<a name="l01638"></a>01638 
<a name="l01639"></a>01639     DEBUGFUNC(<span class="stringliteral">&quot;e1000_config_collision_dist_82575&quot;</span>);
<a name="l01640"></a>01640 
<a name="l01641"></a>01641     tctl_ext = E1000_READ_REG(hw, E1000_TCTL_EXT);
<a name="l01642"></a>01642 
<a name="l01643"></a>01643     tctl_ext &amp;= ~E1000_TCTL_EXT_COLD;
<a name="l01644"></a>01644     tctl_ext |= E1000_COLLISION_DISTANCE &lt;&lt; E1000_TCTL_EXT_COLD_SHIFT;
<a name="l01645"></a>01645 
<a name="l01646"></a>01646     E1000_WRITE_REG(hw, E1000_TCTL_EXT, tctl_ext);
<a name="l01647"></a>01647     E1000_WRITE_FLUSH(hw);
<a name="l01648"></a>01648 }
<a name="l01649"></a>01649 
<a name="l01657"></a>01657 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_power_down_phy_copper_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01658"></a>01658 {
<a name="l01659"></a>01659     <span class="keyword">struct </span><a class="code" href="structe1000__phy__info.html">e1000_phy_info</a> *phy = &amp;hw-&gt;phy;
<a name="l01660"></a>01660 
<a name="l01661"></a>01661     <span class="keywordflow">if</span> (!(phy-&gt;ops.check_reset_block))
<a name="l01662"></a>01662         <span class="keywordflow">return</span>;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664     <span class="comment">/* If the management interface is not enabled, then power down */</span>
<a name="l01665"></a>01665     <span class="keywordflow">if</span> (!(e1000_enable_mng_pass_thru(hw) || phy-&gt;ops.check_reset_block(hw)))
<a name="l01666"></a>01666         e1000_power_down_phy_copper(hw);
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     <span class="keywordflow">return</span>;
<a name="l01669"></a>01669 }
<a name="l01670"></a>01670 
<a name="l01677"></a>01677 <span class="keyword">static</span> <span class="keywordtype">void</span> e1000_clear_hw_cntrs_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01678"></a>01678 {
<a name="l01679"></a>01679     DEBUGFUNC(<span class="stringliteral">&quot;e1000_clear_hw_cntrs_82575&quot;</span>);
<a name="l01680"></a>01680 
<a name="l01681"></a>01681     e1000_clear_hw_cntrs_base_generic(hw);
<a name="l01682"></a>01682 
<a name="l01683"></a>01683     E1000_READ_REG(hw, E1000_PRC64);
<a name="l01684"></a>01684     E1000_READ_REG(hw, E1000_PRC127);
<a name="l01685"></a>01685     E1000_READ_REG(hw, E1000_PRC255);
<a name="l01686"></a>01686     E1000_READ_REG(hw, E1000_PRC511);
<a name="l01687"></a>01687     E1000_READ_REG(hw, E1000_PRC1023);
<a name="l01688"></a>01688     E1000_READ_REG(hw, E1000_PRC1522);
<a name="l01689"></a>01689     E1000_READ_REG(hw, E1000_PTC64);
<a name="l01690"></a>01690     E1000_READ_REG(hw, E1000_PTC127);
<a name="l01691"></a>01691     E1000_READ_REG(hw, E1000_PTC255);
<a name="l01692"></a>01692     E1000_READ_REG(hw, E1000_PTC511);
<a name="l01693"></a>01693     E1000_READ_REG(hw, E1000_PTC1023);
<a name="l01694"></a>01694     E1000_READ_REG(hw, E1000_PTC1522);
<a name="l01695"></a>01695 
<a name="l01696"></a>01696     E1000_READ_REG(hw, E1000_ALGNERRC);
<a name="l01697"></a>01697     E1000_READ_REG(hw, E1000_RXERRC);
<a name="l01698"></a>01698     E1000_READ_REG(hw, E1000_TNCRS);
<a name="l01699"></a>01699     E1000_READ_REG(hw, E1000_CEXTERR);
<a name="l01700"></a>01700     E1000_READ_REG(hw, E1000_TSCTC);
<a name="l01701"></a>01701     E1000_READ_REG(hw, E1000_TSCTFC);
<a name="l01702"></a>01702 
<a name="l01703"></a>01703     E1000_READ_REG(hw, E1000_MGTPRC);
<a name="l01704"></a>01704     E1000_READ_REG(hw, E1000_MGTPDC);
<a name="l01705"></a>01705     E1000_READ_REG(hw, E1000_MGTPTC);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707     E1000_READ_REG(hw, E1000_IAC);
<a name="l01708"></a>01708     E1000_READ_REG(hw, E1000_ICRXOC);
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     E1000_READ_REG(hw, E1000_ICRXPTC);
<a name="l01711"></a>01711     E1000_READ_REG(hw, E1000_ICRXATC);
<a name="l01712"></a>01712     E1000_READ_REG(hw, E1000_ICTXPTC);
<a name="l01713"></a>01713     E1000_READ_REG(hw, E1000_ICTXATC);
<a name="l01714"></a>01714     E1000_READ_REG(hw, E1000_ICTXQEC);
<a name="l01715"></a>01715     E1000_READ_REG(hw, E1000_ICTXQMTC);
<a name="l01716"></a>01716     E1000_READ_REG(hw, E1000_ICRXDMTC);
<a name="l01717"></a>01717 
<a name="l01718"></a>01718     E1000_READ_REG(hw, E1000_CBTMPC);
<a name="l01719"></a>01719     E1000_READ_REG(hw, E1000_HTDPMC);
<a name="l01720"></a>01720     E1000_READ_REG(hw, E1000_CBRMPC);
<a name="l01721"></a>01721     E1000_READ_REG(hw, E1000_RPTHC);
<a name="l01722"></a>01722     E1000_READ_REG(hw, E1000_HGPTC);
<a name="l01723"></a>01723     E1000_READ_REG(hw, E1000_HTCBDPC);
<a name="l01724"></a>01724     E1000_READ_REG(hw, E1000_HGORCL);
<a name="l01725"></a>01725     E1000_READ_REG(hw, E1000_HGORCH);
<a name="l01726"></a>01726     E1000_READ_REG(hw, E1000_HGOTCL);
<a name="l01727"></a>01727     E1000_READ_REG(hw, E1000_HGOTCH);
<a name="l01728"></a>01728     E1000_READ_REG(hw, E1000_LENERRS);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730     <span class="comment">/* This register should not be read in copper configurations */</span>
<a name="l01731"></a>01731     <span class="keywordflow">if</span> ((hw-&gt;phy.media_type == e1000_media_type_internal_serdes) ||
<a name="l01732"></a>01732         e1000_sgmii_active_82575(hw))
<a name="l01733"></a>01733         E1000_READ_REG(hw, E1000_SCVPC);
<a name="l01734"></a>01734 }
<a name="l01735"></a>01735 
<a name="l01745"></a>01745 <span class="keywordtype">void</span> e1000_rx_fifo_flush_82575(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01746"></a>01746 {
<a name="l01747"></a>01747     u32 rctl, rlpml, rxdctl[4], rfctl, temp_rctl, rx_enabled;
<a name="l01748"></a>01748     <span class="keywordtype">int</span> i, ms_wait;
<a name="l01749"></a>01749 
<a name="l01750"></a>01750     DEBUGFUNC(<span class="stringliteral">&quot;e1000_rx_fifo_workaround_82575&quot;</span>);
<a name="l01751"></a>01751     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82575 ||
<a name="l01752"></a>01752         !(E1000_READ_REG(hw, E1000_MANC) &amp; E1000_MANC_RCV_TCO_EN))
<a name="l01753"></a>01753         <span class="keywordflow">return</span>;
<a name="l01754"></a>01754 
<a name="l01755"></a>01755     <span class="comment">/* Disable all Rx queues */</span>
<a name="l01756"></a>01756     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l01757"></a>01757         rxdctl[i] = E1000_READ_REG(hw, E1000_RXDCTL(i));
<a name="l01758"></a>01758         E1000_WRITE_REG(hw, E1000_RXDCTL(i),
<a name="l01759"></a>01759                         rxdctl[i] &amp; ~E1000_RXDCTL_QUEUE_ENABLE);
<a name="l01760"></a>01760     }
<a name="l01761"></a>01761     <span class="comment">/* Poll all queues to verify they have shut down */</span>
<a name="l01762"></a>01762     <span class="keywordflow">for</span> (ms_wait = 0; ms_wait &lt; 10; ms_wait++) {
<a name="l01763"></a>01763         msec_delay(1);
<a name="l01764"></a>01764         rx_enabled = 0;
<a name="l01765"></a>01765         <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
<a name="l01766"></a>01766             rx_enabled |= E1000_READ_REG(hw, E1000_RXDCTL(i));
<a name="l01767"></a>01767         <span class="keywordflow">if</span> (!(rx_enabled &amp; E1000_RXDCTL_QUEUE_ENABLE))
<a name="l01768"></a>01768             <span class="keywordflow">break</span>;
<a name="l01769"></a>01769     }
<a name="l01770"></a>01770 
<a name="l01771"></a>01771     <span class="keywordflow">if</span> (ms_wait == 10)
<a name="l01772"></a>01772         DEBUGOUT(<span class="stringliteral">&quot;Queue disable timed out after 10ms\n&quot;</span>);
<a name="l01773"></a>01773 
<a name="l01774"></a>01774     <span class="comment">/* Clear RLPML, RCTL.SBP, RFCTL.LEF, and set RCTL.LPE so that all</span>
<a name="l01775"></a>01775 <span class="comment">     * incoming packets are rejected.  Set enable and wait 2ms so that</span>
<a name="l01776"></a>01776 <span class="comment">     * any packet that was coming in as RCTL.EN was set is flushed</span>
<a name="l01777"></a>01777 <span class="comment">     */</span>
<a name="l01778"></a>01778     rfctl = E1000_READ_REG(hw, E1000_RFCTL);
<a name="l01779"></a>01779     E1000_WRITE_REG(hw, E1000_RFCTL, rfctl &amp; ~E1000_RFCTL_LEF);
<a name="l01780"></a>01780 
<a name="l01781"></a>01781     rlpml = E1000_READ_REG(hw, E1000_RLPML);
<a name="l01782"></a>01782     E1000_WRITE_REG(hw, E1000_RLPML, 0);
<a name="l01783"></a>01783 
<a name="l01784"></a>01784     rctl = E1000_READ_REG(hw, E1000_RCTL);
<a name="l01785"></a>01785     temp_rctl = rctl &amp; ~(E1000_RCTL_EN | E1000_RCTL_SBP);
<a name="l01786"></a>01786     temp_rctl |= E1000_RCTL_LPE;
<a name="l01787"></a>01787 
<a name="l01788"></a>01788     E1000_WRITE_REG(hw, E1000_RCTL, temp_rctl);
<a name="l01789"></a>01789     E1000_WRITE_REG(hw, E1000_RCTL, temp_rctl | E1000_RCTL_EN);
<a name="l01790"></a>01790     E1000_WRITE_FLUSH(hw);
<a name="l01791"></a>01791     msec_delay(2);
<a name="l01792"></a>01792 
<a name="l01793"></a>01793     <span class="comment">/* Enable Rx queues that were previously enabled and restore our</span>
<a name="l01794"></a>01794 <span class="comment">     * previous state</span>
<a name="l01795"></a>01795 <span class="comment">     */</span>
<a name="l01796"></a>01796     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
<a name="l01797"></a>01797         E1000_WRITE_REG(hw, E1000_RXDCTL(i), rxdctl[i]);
<a name="l01798"></a>01798     E1000_WRITE_REG(hw, E1000_RCTL, rctl);
<a name="l01799"></a>01799     E1000_WRITE_FLUSH(hw);
<a name="l01800"></a>01800 
<a name="l01801"></a>01801     E1000_WRITE_REG(hw, E1000_RLPML, rlpml);
<a name="l01802"></a>01802     E1000_WRITE_REG(hw, E1000_RFCTL, rfctl);
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     <span class="comment">/* Flush receive errors generated by workaround */</span>
<a name="l01805"></a>01805     E1000_READ_REG(hw, E1000_ROC);
<a name="l01806"></a>01806     E1000_READ_REG(hw, E1000_RNBC);
<a name="l01807"></a>01807     E1000_READ_REG(hw, E1000_MPC);
<a name="l01808"></a>01808 }
<a name="l01809"></a>01809 
<a name="l01820"></a>01820 <span class="keyword">static</span> s32 e1000_set_pcie_completion_timeout(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l01821"></a>01821 {
<a name="l01822"></a>01822     u32 gcr = E1000_READ_REG(hw, E1000_GCR);
<a name="l01823"></a>01823     s32 ret_val = E1000_SUCCESS;
<a name="l01824"></a>01824     u16 pcie_devctl2;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826     <span class="comment">/* only take action if timeout value is defaulted to 0 */</span>
<a name="l01827"></a>01827     <span class="keywordflow">if</span> (gcr &amp; E1000_GCR_CMPL_TMOUT_MASK)
<a name="l01828"></a>01828         <span class="keywordflow">goto</span> out;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830     <span class="comment">/*</span>
<a name="l01831"></a>01831 <span class="comment">     * if capababilities version is type 1 we can write the</span>
<a name="l01832"></a>01832 <span class="comment">     * timeout of 10ms to 200ms through the GCR register</span>
<a name="l01833"></a>01833 <span class="comment">     */</span>
<a name="l01834"></a>01834     <span class="keywordflow">if</span> (!(gcr &amp; E1000_GCR_CAP_VER2)) {
<a name="l01835"></a>01835         gcr |= E1000_GCR_CMPL_TMOUT_10ms;
<a name="l01836"></a>01836         <span class="keywordflow">goto</span> out;
<a name="l01837"></a>01837     }
<a name="l01838"></a>01838 
<a name="l01839"></a>01839     <span class="comment">/*</span>
<a name="l01840"></a>01840 <span class="comment">     * for version 2 capabilities we need to write the config space</span>
<a name="l01841"></a>01841 <span class="comment">     * directly in order to set the completion timeout value for</span>
<a name="l01842"></a>01842 <span class="comment">     * 16ms to 55ms</span>
<a name="l01843"></a>01843 <span class="comment">     */</span>
<a name="l01844"></a>01844     ret_val = e1000_read_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,
<a name="l01845"></a>01845                                       &amp;pcie_devctl2);
<a name="l01846"></a>01846     <span class="keywordflow">if</span> (ret_val)
<a name="l01847"></a>01847         <span class="keywordflow">goto</span> out;
<a name="l01848"></a>01848 
<a name="l01849"></a>01849     pcie_devctl2 |= PCIE_DEVICE_CONTROL2_16ms;
<a name="l01850"></a>01850 
<a name="l01851"></a>01851     ret_val = e1000_write_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,
<a name="l01852"></a>01852                                        &amp;pcie_devctl2);
<a name="l01853"></a>01853 out:
<a name="l01854"></a>01854     <span class="comment">/* disable completion timeout resend */</span>
<a name="l01855"></a>01855     gcr &amp;= ~E1000_GCR_CMPL_TMOUT_RESEND;
<a name="l01856"></a>01856 
<a name="l01857"></a>01857     E1000_WRITE_REG(hw, E1000_GCR, gcr);
<a name="l01858"></a>01858     <span class="keywordflow">return</span> ret_val;
<a name="l01859"></a>01859 }
<a name="l01860"></a>01860 
<a name="l01869"></a>01869 <span class="keywordtype">void</span> e1000_vmdq_set_anti_spoofing_pf(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> enable, <span class="keywordtype">int</span> pf)
<a name="l01870"></a>01870 {
<a name="l01871"></a>01871     u32 dtxswc;
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l01874"></a>01874     <span class="keywordflow">case</span> e1000_82576:
<a name="l01875"></a>01875         dtxswc = E1000_READ_REG(hw, E1000_DTXSWC);
<a name="l01876"></a>01876         <span class="keywordflow">if</span> (enable) {
<a name="l01877"></a>01877             dtxswc |= (E1000_DTXSWC_MAC_SPOOF_MASK |
<a name="l01878"></a>01878                    E1000_DTXSWC_VLAN_SPOOF_MASK);
<a name="l01879"></a>01879             <span class="comment">/* The PF can spoof - it has to in order to</span>
<a name="l01880"></a>01880 <span class="comment">             * support emulation mode NICs */</span>
<a name="l01881"></a>01881             dtxswc ^= (1 &lt;&lt; pf | 1 &lt;&lt; (pf + MAX_NUM_VFS));
<a name="l01882"></a>01882         } <span class="keywordflow">else</span> {
<a name="l01883"></a>01883             dtxswc &amp;= ~(E1000_DTXSWC_MAC_SPOOF_MASK |
<a name="l01884"></a>01884                     E1000_DTXSWC_VLAN_SPOOF_MASK);
<a name="l01885"></a>01885         }
<a name="l01886"></a>01886         E1000_WRITE_REG(hw, E1000_DTXSWC, dtxswc);
<a name="l01887"></a>01887         <span class="keywordflow">break</span>;
<a name="l01888"></a>01888     <span class="keywordflow">case</span> e1000_i350:
<a name="l01889"></a>01889         dtxswc = E1000_READ_REG(hw, E1000_TXSWC);
<a name="l01890"></a>01890         <span class="keywordflow">if</span> (enable) {
<a name="l01891"></a>01891             dtxswc |= (E1000_DTXSWC_MAC_SPOOF_MASK |
<a name="l01892"></a>01892                    E1000_DTXSWC_VLAN_SPOOF_MASK);
<a name="l01893"></a>01893             <span class="comment">/* The PF can spoof - it has to in order to</span>
<a name="l01894"></a>01894 <span class="comment">             * support emulation mode NICs</span>
<a name="l01895"></a>01895 <span class="comment">             */</span>
<a name="l01896"></a>01896             dtxswc ^= (1 &lt;&lt; pf | 1 &lt;&lt; (pf + MAX_NUM_VFS));
<a name="l01897"></a>01897         } <span class="keywordflow">else</span> {
<a name="l01898"></a>01898             dtxswc &amp;= ~(E1000_DTXSWC_MAC_SPOOF_MASK |
<a name="l01899"></a>01899                     E1000_DTXSWC_VLAN_SPOOF_MASK);
<a name="l01900"></a>01900         }
<a name="l01901"></a>01901         E1000_WRITE_REG(hw, E1000_TXSWC, dtxswc);
<a name="l01902"></a>01902     <span class="keywordflow">default</span>:
<a name="l01903"></a>01903         <span class="keywordflow">break</span>;
<a name="l01904"></a>01904     }
<a name="l01905"></a>01905 }
<a name="l01906"></a>01906 
<a name="l01914"></a>01914 <span class="keywordtype">void</span> e1000_vmdq_set_loopback_pf(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> enable)
<a name="l01915"></a>01915 {
<a name="l01916"></a>01916     u32 dtxswc;
<a name="l01917"></a>01917 
<a name="l01918"></a>01918     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l01919"></a>01919     <span class="keywordflow">case</span> e1000_82576:
<a name="l01920"></a>01920         dtxswc = E1000_READ_REG(hw, E1000_DTXSWC);
<a name="l01921"></a>01921         <span class="keywordflow">if</span> (enable)
<a name="l01922"></a>01922             dtxswc |= E1000_DTXSWC_VMDQ_LOOPBACK_EN;
<a name="l01923"></a>01923         <span class="keywordflow">else</span>
<a name="l01924"></a>01924             dtxswc &amp;= ~E1000_DTXSWC_VMDQ_LOOPBACK_EN;
<a name="l01925"></a>01925         E1000_WRITE_REG(hw, E1000_DTXSWC, dtxswc);
<a name="l01926"></a>01926         <span class="keywordflow">break</span>;
<a name="l01927"></a>01927     <span class="keywordflow">case</span> e1000_i350:
<a name="l01928"></a>01928         dtxswc = E1000_READ_REG(hw, E1000_TXSWC);
<a name="l01929"></a>01929         <span class="keywordflow">if</span> (enable)
<a name="l01930"></a>01930             dtxswc |= E1000_DTXSWC_VMDQ_LOOPBACK_EN;
<a name="l01931"></a>01931         <span class="keywordflow">else</span>
<a name="l01932"></a>01932             dtxswc &amp;= ~E1000_DTXSWC_VMDQ_LOOPBACK_EN;
<a name="l01933"></a>01933         E1000_WRITE_REG(hw, E1000_TXSWC, dtxswc);
<a name="l01934"></a>01934         <span class="keywordflow">break</span>;
<a name="l01935"></a>01935     <span class="keywordflow">default</span>:
<a name="l01936"></a>01936         <span class="comment">/* Currently no other hardware supports loopback */</span>
<a name="l01937"></a>01937         <span class="keywordflow">break</span>;
<a name="l01938"></a>01938     }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940 
<a name="l01941"></a>01941 }
<a name="l01942"></a>01942 
<a name="l01950"></a>01950 <span class="keywordtype">void</span> e1000_vmdq_set_replication_pf(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, <span class="keywordtype">bool</span> enable)
<a name="l01951"></a>01951 {
<a name="l01952"></a>01952     u32 vt_ctl = E1000_READ_REG(hw, E1000_VT_CTL);
<a name="l01953"></a>01953 
<a name="l01954"></a>01954     <span class="keywordflow">if</span> (enable)
<a name="l01955"></a>01955         vt_ctl |= E1000_VT_CTL_VM_REPL_EN;
<a name="l01956"></a>01956     <span class="keywordflow">else</span>
<a name="l01957"></a>01957         vt_ctl &amp;= ~E1000_VT_CTL_VM_REPL_EN;
<a name="l01958"></a>01958 
<a name="l01959"></a>01959     E1000_WRITE_REG(hw, E1000_VT_CTL, vt_ctl);
<a name="l01960"></a>01960 }
<a name="l01961"></a>01961 
<a name="l01971"></a>01971 <span class="keyword">static</span> s32 e1000_read_phy_reg_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset, u16 *data)
<a name="l01972"></a>01972 {
<a name="l01973"></a>01973     s32 ret_val;
<a name="l01974"></a>01974 
<a name="l01975"></a>01975     DEBUGFUNC(<span class="stringliteral">&quot;e1000_read_phy_reg_82580&quot;</span>);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977     ret_val = hw-&gt;phy.ops.acquire(hw);
<a name="l01978"></a>01978     <span class="keywordflow">if</span> (ret_val)
<a name="l01979"></a>01979         <span class="keywordflow">goto</span> out;
<a name="l01980"></a>01980 
<a name="l01981"></a>01981     ret_val = e1000_read_phy_reg_mdic(hw, offset, data);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983     hw-&gt;phy.ops.release(hw);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985 out:
<a name="l01986"></a>01986     <span class="keywordflow">return</span> ret_val;
<a name="l01987"></a>01987 }
<a name="l01988"></a>01988 
<a name="l01997"></a>01997 <span class="keyword">static</span> s32 e1000_write_phy_reg_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u32 offset, u16 data)
<a name="l01998"></a>01998 {
<a name="l01999"></a>01999     s32 ret_val;
<a name="l02000"></a>02000 
<a name="l02001"></a>02001     DEBUGFUNC(<span class="stringliteral">&quot;e1000_write_phy_reg_82580&quot;</span>);
<a name="l02002"></a>02002 
<a name="l02003"></a>02003     ret_val = hw-&gt;phy.ops.acquire(hw);
<a name="l02004"></a>02004     <span class="keywordflow">if</span> (ret_val)
<a name="l02005"></a>02005         <span class="keywordflow">goto</span> out;
<a name="l02006"></a>02006 
<a name="l02007"></a>02007     ret_val = e1000_write_phy_reg_mdic(hw, offset, data);
<a name="l02008"></a>02008 
<a name="l02009"></a>02009     hw-&gt;phy.ops.release(hw);
<a name="l02010"></a>02010 
<a name="l02011"></a>02011 out:
<a name="l02012"></a>02012     <span class="keywordflow">return</span> ret_val;
<a name="l02013"></a>02013 }
<a name="l02014"></a>02014 
<a name="l02023"></a>02023 <span class="keyword">static</span> s32 e1000_reset_mdicnfg_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l02024"></a>02024 {
<a name="l02025"></a>02025     s32 ret_val = E1000_SUCCESS;
<a name="l02026"></a>02026     u32 mdicnfg;
<a name="l02027"></a>02027     u16 nvm_data = 0;
<a name="l02028"></a>02028 
<a name="l02029"></a>02029     DEBUGFUNC(<span class="stringliteral">&quot;e1000_reset_mdicnfg_82580&quot;</span>);
<a name="l02030"></a>02030 
<a name="l02031"></a>02031     <span class="keywordflow">if</span> (hw-&gt;mac.type != e1000_82580)
<a name="l02032"></a>02032         <span class="keywordflow">goto</span> out;
<a name="l02033"></a>02033     <span class="keywordflow">if</span> (!e1000_sgmii_active_82575(hw))
<a name="l02034"></a>02034         <span class="keywordflow">goto</span> out;
<a name="l02035"></a>02035 
<a name="l02036"></a>02036     ret_val = hw-&gt;nvm.ops.read(hw, NVM_INIT_CONTROL3_PORT_A +
<a name="l02037"></a>02037                                NVM_82580_LAN_FUNC_OFFSET(hw-&gt;bus.func), 1,
<a name="l02038"></a>02038                                &amp;nvm_data);
<a name="l02039"></a>02039     <span class="keywordflow">if</span> (ret_val) {
<a name="l02040"></a>02040         DEBUGOUT(<span class="stringliteral">&quot;NVM Read Error\n&quot;</span>);
<a name="l02041"></a>02041         <span class="keywordflow">goto</span> out;
<a name="l02042"></a>02042     }
<a name="l02043"></a>02043 
<a name="l02044"></a>02044     mdicnfg = E1000_READ_REG(hw, E1000_MDICNFG);
<a name="l02045"></a>02045     <span class="keywordflow">if</span> (nvm_data &amp; NVM_WORD24_EXT_MDIO)
<a name="l02046"></a>02046         mdicnfg |= E1000_MDICNFG_EXT_MDIO;
<a name="l02047"></a>02047     <span class="keywordflow">if</span> (nvm_data &amp; NVM_WORD24_COM_MDIO)
<a name="l02048"></a>02048         mdicnfg |= E1000_MDICNFG_COM_MDIO;
<a name="l02049"></a>02049     E1000_WRITE_REG(hw, E1000_MDICNFG, mdicnfg);
<a name="l02050"></a>02050 out:
<a name="l02051"></a>02051     <span class="keywordflow">return</span> ret_val;
<a name="l02052"></a>02052 }
<a name="l02053"></a>02053 
<a name="l02061"></a>02061 <span class="keyword">static</span> s32 e1000_reset_hw_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l02062"></a>02062 {
<a name="l02063"></a>02063     s32 ret_val = E1000_SUCCESS;
<a name="l02064"></a>02064     <span class="comment">/* BH SW mailbox bit in SW_FW_SYNC */</span>
<a name="l02065"></a>02065     u16 swmbsw_mask = E1000_SW_SYNCH_MB;
<a name="l02066"></a>02066     u32 ctrl;
<a name="l02067"></a>02067     <span class="keywordtype">bool</span> global_device_reset = hw-&gt;dev_spec._82575.global_device_reset;
<a name="l02068"></a>02068 
<a name="l02069"></a>02069     DEBUGFUNC(<span class="stringliteral">&quot;e1000_reset_hw_82580&quot;</span>);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071     hw-&gt;dev_spec._82575.global_device_reset = <span class="keyword">false</span>;
<a name="l02072"></a>02072 
<a name="l02073"></a>02073     <span class="comment">/* Get current control state. */</span>
<a name="l02074"></a>02074     ctrl = E1000_READ_REG(hw, E1000_CTRL);
<a name="l02075"></a>02075 
<a name="l02076"></a>02076     <span class="comment">/*</span>
<a name="l02077"></a>02077 <span class="comment">     * Prevent the PCI-E bus from sticking if there is no TLP connection</span>
<a name="l02078"></a>02078 <span class="comment">     * on the last TLP read/write transaction when MAC is reset.</span>
<a name="l02079"></a>02079 <span class="comment">     */</span>
<a name="l02080"></a>02080     ret_val = e1000_disable_pcie_master_generic(hw);
<a name="l02081"></a>02081     <span class="keywordflow">if</span> (ret_val)
<a name="l02082"></a>02082         DEBUGOUT(<span class="stringliteral">&quot;PCI-E Master disable polling has failed.\n&quot;</span>);
<a name="l02083"></a>02083 
<a name="l02084"></a>02084     DEBUGOUT(<span class="stringliteral">&quot;Masking off all interrupts\n&quot;</span>);
<a name="l02085"></a>02085     E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);
<a name="l02086"></a>02086     E1000_WRITE_REG(hw, E1000_RCTL, 0);
<a name="l02087"></a>02087     E1000_WRITE_REG(hw, E1000_TCTL, E1000_TCTL_PSP);
<a name="l02088"></a>02088     E1000_WRITE_FLUSH(hw);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090     msec_delay(10);
<a name="l02091"></a>02091 
<a name="l02092"></a>02092     <span class="comment">/* Determine whether or not a global dev reset is requested */</span>
<a name="l02093"></a>02093     <span class="keywordflow">if</span> (global_device_reset &amp;&amp;
<a name="l02094"></a>02094         e1000_acquire_swfw_sync_82575(hw, swmbsw_mask))
<a name="l02095"></a>02095             global_device_reset = <span class="keyword">false</span>;
<a name="l02096"></a>02096 
<a name="l02097"></a>02097     <span class="keywordflow">if</span> (global_device_reset &amp;&amp;
<a name="l02098"></a>02098         !(E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STAT_DEV_RST_SET))
<a name="l02099"></a>02099         ctrl |= E1000_CTRL_DEV_RST;
<a name="l02100"></a>02100     <span class="keywordflow">else</span>
<a name="l02101"></a>02101         ctrl |= E1000_CTRL_RST;
<a name="l02102"></a>02102 
<a name="l02103"></a>02103     E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
<a name="l02104"></a>02104 
<a name="l02105"></a>02105     <span class="comment">/* Add delay to insure DEV_RST has time to complete */</span>
<a name="l02106"></a>02106     <span class="keywordflow">if</span> (global_device_reset)
<a name="l02107"></a>02107         msec_delay(5);
<a name="l02108"></a>02108 
<a name="l02109"></a>02109     ret_val = e1000_get_auto_rd_done_generic(hw);
<a name="l02110"></a>02110     <span class="keywordflow">if</span> (ret_val) {
<a name="l02111"></a>02111         <span class="comment">/*</span>
<a name="l02112"></a>02112 <span class="comment">         * When auto config read does not complete, do not</span>
<a name="l02113"></a>02113 <span class="comment">         * return with an error. This can happen in situations</span>
<a name="l02114"></a>02114 <span class="comment">         * where there is no eeprom and prevents getting link.</span>
<a name="l02115"></a>02115 <span class="comment">         */</span>
<a name="l02116"></a>02116         DEBUGOUT(<span class="stringliteral">&quot;Auto Read Done did not complete\n&quot;</span>);
<a name="l02117"></a>02117     }
<a name="l02118"></a>02118 
<a name="l02119"></a>02119     <span class="comment">/* If EEPROM is not present, run manual init scripts */</span>
<a name="l02120"></a>02120     <span class="keywordflow">if</span> ((E1000_READ_REG(hw, E1000_EECD) &amp; E1000_EECD_PRES) == 0)
<a name="l02121"></a>02121         e1000_reset_init_script_82575(hw);
<a name="l02122"></a>02122 
<a name="l02123"></a>02123     <span class="comment">/* clear global device reset status bit */</span>
<a name="l02124"></a>02124     E1000_WRITE_REG(hw, E1000_STATUS, E1000_STAT_DEV_RST_SET);
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <span class="comment">/* Clear any pending interrupt events. */</span>
<a name="l02127"></a>02127     E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);
<a name="l02128"></a>02128     E1000_READ_REG(hw, E1000_ICR);
<a name="l02129"></a>02129 
<a name="l02130"></a>02130     ret_val = e1000_reset_mdicnfg_82580(hw);
<a name="l02131"></a>02131     <span class="keywordflow">if</span> (ret_val)
<a name="l02132"></a>02132         DEBUGOUT(<span class="stringliteral">&quot;Could not reset MDICNFG based on EEPROM\n&quot;</span>);
<a name="l02133"></a>02133 
<a name="l02134"></a>02134     <span class="comment">/* Install any alternate MAC address into RAR0 */</span>
<a name="l02135"></a>02135     ret_val = e1000_check_alt_mac_addr_generic(hw);
<a name="l02136"></a>02136 
<a name="l02137"></a>02137     <span class="comment">/* Release semaphore */</span>
<a name="l02138"></a>02138     <span class="keywordflow">if</span> (global_device_reset)
<a name="l02139"></a>02139         e1000_release_swfw_sync_82575(hw, swmbsw_mask);
<a name="l02140"></a>02140 
<a name="l02141"></a>02141     <span class="keywordflow">return</span> ret_val;
<a name="l02142"></a>02142 }
<a name="l02143"></a>02143 
<a name="l02154"></a>02154 u16 e1000_rxpbs_adjust_82580(u32 data)
<a name="l02155"></a>02155 {
<a name="l02156"></a>02156     u16 ret_val = 0;
<a name="l02157"></a>02157 
<a name="l02158"></a>02158     <span class="keywordflow">if</span> (data &lt; E1000_82580_RXPBS_TABLE_SIZE)
<a name="l02159"></a>02159         ret_val = e1000_82580_rxpbs_table[data];
<a name="l02160"></a>02160 
<a name="l02161"></a>02161     <span class="keywordflow">return</span> ret_val;
<a name="l02162"></a>02162 }
<a name="l02163"></a>02163 
<a name="l02173"></a>02173 s32 e1000_validate_nvm_checksum_with_offset(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 offset)
<a name="l02174"></a>02174 {
<a name="l02175"></a>02175     s32 ret_val = E1000_SUCCESS;
<a name="l02176"></a>02176     u16 checksum = 0;
<a name="l02177"></a>02177     u16 i, nvm_data;
<a name="l02178"></a>02178 
<a name="l02179"></a>02179     DEBUGFUNC(<span class="stringliteral">&quot;e1000_validate_nvm_checksum_with_offset&quot;</span>);
<a name="l02180"></a>02180 
<a name="l02181"></a>02181     <span class="keywordflow">for</span> (i = offset; i &lt; ((NVM_CHECKSUM_REG + offset) + 1); i++) {
<a name="l02182"></a>02182         ret_val = hw-&gt;nvm.ops.read(hw, i, 1, &amp;nvm_data);
<a name="l02183"></a>02183         <span class="keywordflow">if</span> (ret_val) {
<a name="l02184"></a>02184             DEBUGOUT(<span class="stringliteral">&quot;NVM Read Error\n&quot;</span>);
<a name="l02185"></a>02185             <span class="keywordflow">goto</span> out;
<a name="l02186"></a>02186         }
<a name="l02187"></a>02187         checksum += nvm_data;
<a name="l02188"></a>02188     }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190     <span class="keywordflow">if</span> (checksum != (u16) NVM_SUM) {
<a name="l02191"></a>02191         DEBUGOUT(<span class="stringliteral">&quot;NVM Checksum Invalid\n&quot;</span>);
<a name="l02192"></a>02192         ret_val = -E1000_ERR_NVM;
<a name="l02193"></a>02193         <span class="keywordflow">goto</span> out;
<a name="l02194"></a>02194     }
<a name="l02195"></a>02195 
<a name="l02196"></a>02196 out:
<a name="l02197"></a>02197     <span class="keywordflow">return</span> ret_val;
<a name="l02198"></a>02198 }
<a name="l02199"></a>02199 
<a name="l02210"></a>02210 s32 e1000_update_nvm_checksum_with_offset(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw, u16 offset)
<a name="l02211"></a>02211 {
<a name="l02212"></a>02212     s32 ret_val;
<a name="l02213"></a>02213     u16 checksum = 0;
<a name="l02214"></a>02214     u16 i, nvm_data;
<a name="l02215"></a>02215 
<a name="l02216"></a>02216     DEBUGFUNC(<span class="stringliteral">&quot;e1000_update_nvm_checksum_with_offset&quot;</span>);
<a name="l02217"></a>02217 
<a name="l02218"></a>02218     <span class="keywordflow">for</span> (i = offset; i &lt; (NVM_CHECKSUM_REG + offset); i++) {
<a name="l02219"></a>02219         ret_val = hw-&gt;nvm.ops.read(hw, i, 1, &amp;nvm_data);
<a name="l02220"></a>02220         <span class="keywordflow">if</span> (ret_val) {
<a name="l02221"></a>02221             DEBUGOUT(<span class="stringliteral">&quot;NVM Read Error while updating checksum.\n&quot;</span>);
<a name="l02222"></a>02222             <span class="keywordflow">goto</span> out;
<a name="l02223"></a>02223         }
<a name="l02224"></a>02224         checksum += nvm_data;
<a name="l02225"></a>02225     }
<a name="l02226"></a>02226     checksum = (u16) NVM_SUM - checksum;
<a name="l02227"></a>02227     ret_val = hw-&gt;nvm.ops.write(hw, (NVM_CHECKSUM_REG + offset), 1,
<a name="l02228"></a>02228                 &amp;checksum);
<a name="l02229"></a>02229     <span class="keywordflow">if</span> (ret_val)
<a name="l02230"></a>02230         DEBUGOUT(<span class="stringliteral">&quot;NVM Write Error while updating checksum.\n&quot;</span>);
<a name="l02231"></a>02231 
<a name="l02232"></a>02232 out:
<a name="l02233"></a>02233     <span class="keywordflow">return</span> ret_val;
<a name="l02234"></a>02234 }
<a name="l02235"></a>02235 
<a name="l02244"></a>02244 <span class="keyword">static</span> s32 e1000_validate_nvm_checksum_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l02245"></a>02245 {
<a name="l02246"></a>02246     s32 ret_val = E1000_SUCCESS;
<a name="l02247"></a>02247     u16 eeprom_regions_count = 1;
<a name="l02248"></a>02248     u16 j, nvm_data;
<a name="l02249"></a>02249     u16 nvm_offset;
<a name="l02250"></a>02250 
<a name="l02251"></a>02251     DEBUGFUNC(<span class="stringliteral">&quot;e1000_validate_nvm_checksum_82580&quot;</span>);
<a name="l02252"></a>02252 
<a name="l02253"></a>02253     ret_val = hw-&gt;nvm.ops.read(hw, NVM_COMPATIBILITY_REG_3, 1, &amp;nvm_data);
<a name="l02254"></a>02254     <span class="keywordflow">if</span> (ret_val) {
<a name="l02255"></a>02255         DEBUGOUT(<span class="stringliteral">&quot;NVM Read Error\n&quot;</span>);
<a name="l02256"></a>02256         <span class="keywordflow">goto</span> out;
<a name="l02257"></a>02257     }
<a name="l02258"></a>02258 
<a name="l02259"></a>02259     <span class="keywordflow">if</span> (nvm_data &amp; NVM_COMPATIBILITY_BIT_MASK) {
<a name="l02260"></a>02260         <span class="comment">/* if chekcsums compatibility bit is set validate checksums</span>
<a name="l02261"></a>02261 <span class="comment">         * for all 4 ports. */</span>
<a name="l02262"></a>02262         eeprom_regions_count = 4;
<a name="l02263"></a>02263     }
<a name="l02264"></a>02264 
<a name="l02265"></a>02265     <span class="keywordflow">for</span> (j = 0; j &lt; eeprom_regions_count; j++) {
<a name="l02266"></a>02266         nvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);
<a name="l02267"></a>02267         ret_val = e1000_validate_nvm_checksum_with_offset(hw,
<a name="l02268"></a>02268                                 nvm_offset);
<a name="l02269"></a>02269         <span class="keywordflow">if</span> (ret_val != E1000_SUCCESS)
<a name="l02270"></a>02270             <span class="keywordflow">goto</span> out;
<a name="l02271"></a>02271     }
<a name="l02272"></a>02272 
<a name="l02273"></a>02273 out:
<a name="l02274"></a>02274     <span class="keywordflow">return</span> ret_val;
<a name="l02275"></a>02275 }
<a name="l02276"></a>02276 
<a name="l02285"></a>02285 <span class="keyword">static</span> s32 e1000_update_nvm_checksum_82580(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l02286"></a>02286 {
<a name="l02287"></a>02287     s32 ret_val;
<a name="l02288"></a>02288     u16 j, nvm_data;
<a name="l02289"></a>02289     u16 nvm_offset;
<a name="l02290"></a>02290 
<a name="l02291"></a>02291     DEBUGFUNC(<span class="stringliteral">&quot;e1000_update_nvm_checksum_82580&quot;</span>);
<a name="l02292"></a>02292 
<a name="l02293"></a>02293     ret_val = hw-&gt;nvm.ops.read(hw, NVM_COMPATIBILITY_REG_3, 1, &amp;nvm_data);
<a name="l02294"></a>02294     <span class="keywordflow">if</span> (ret_val) {
<a name="l02295"></a>02295         DEBUGOUT(<span class="stringliteral">&quot;NVM Read Error while updating checksum&quot;</span>
<a name="l02296"></a>02296             <span class="stringliteral">&quot; compatibility bit.\n&quot;</span>);
<a name="l02297"></a>02297         <span class="keywordflow">goto</span> out;
<a name="l02298"></a>02298     }
<a name="l02299"></a>02299 
<a name="l02300"></a>02300     <span class="keywordflow">if</span> ((nvm_data &amp; NVM_COMPATIBILITY_BIT_MASK) == 0) {
<a name="l02301"></a>02301         <span class="comment">/* set compatibility bit to validate checksums appropriately */</span>
<a name="l02302"></a>02302         nvm_data = nvm_data | NVM_COMPATIBILITY_BIT_MASK;
<a name="l02303"></a>02303         ret_val = hw-&gt;nvm.ops.write(hw, NVM_COMPATIBILITY_REG_3, 1,
<a name="l02304"></a>02304                     &amp;nvm_data);
<a name="l02305"></a>02305         <span class="keywordflow">if</span> (ret_val) {
<a name="l02306"></a>02306             DEBUGOUT(<span class="stringliteral">&quot;NVM Write Error while updating checksum&quot;</span>
<a name="l02307"></a>02307                 <span class="stringliteral">&quot; compatibility bit.\n&quot;</span>);
<a name="l02308"></a>02308             <span class="keywordflow">goto</span> out;
<a name="l02309"></a>02309         }
<a name="l02310"></a>02310     }
<a name="l02311"></a>02311 
<a name="l02312"></a>02312     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l02313"></a>02313         nvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);
<a name="l02314"></a>02314         ret_val = e1000_update_nvm_checksum_with_offset(hw, nvm_offset);
<a name="l02315"></a>02315         <span class="keywordflow">if</span> (ret_val) {
<a name="l02316"></a>02316             <span class="keywordflow">goto</span> out;
<a name="l02317"></a>02317         }
<a name="l02318"></a>02318     }
<a name="l02319"></a>02319 
<a name="l02320"></a>02320 out:
<a name="l02321"></a>02321     <span class="keywordflow">return</span> ret_val;
<a name="l02322"></a>02322 }
<a name="l02323"></a>02323 
<a name="l02332"></a>02332 <span class="keyword">static</span> s32 e1000_validate_nvm_checksum_i350(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l02333"></a>02333 {
<a name="l02334"></a>02334     s32 ret_val = E1000_SUCCESS;
<a name="l02335"></a>02335     u16 j;
<a name="l02336"></a>02336     u16 nvm_offset;
<a name="l02337"></a>02337 
<a name="l02338"></a>02338     DEBUGFUNC(<span class="stringliteral">&quot;e1000_validate_nvm_checksum_i350&quot;</span>);
<a name="l02339"></a>02339 
<a name="l02340"></a>02340     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l02341"></a>02341         nvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);
<a name="l02342"></a>02342         ret_val = e1000_validate_nvm_checksum_with_offset(hw,
<a name="l02343"></a>02343                                 nvm_offset);
<a name="l02344"></a>02344         <span class="keywordflow">if</span> (ret_val != E1000_SUCCESS)
<a name="l02345"></a>02345             <span class="keywordflow">goto</span> out;
<a name="l02346"></a>02346     }
<a name="l02347"></a>02347 
<a name="l02348"></a>02348 out:
<a name="l02349"></a>02349     <span class="keywordflow">return</span> ret_val;
<a name="l02350"></a>02350 }
<a name="l02351"></a>02351 
<a name="l02360"></a>02360 <span class="keyword">static</span> s32 e1000_update_nvm_checksum_i350(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l02361"></a>02361 {
<a name="l02362"></a>02362     s32 ret_val = E1000_SUCCESS;
<a name="l02363"></a>02363     u16 j;
<a name="l02364"></a>02364     u16 nvm_offset;
<a name="l02365"></a>02365 
<a name="l02366"></a>02366     DEBUGFUNC(<span class="stringliteral">&quot;e1000_update_nvm_checksum_i350&quot;</span>);
<a name="l02367"></a>02367 
<a name="l02368"></a>02368     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l02369"></a>02369         nvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);
<a name="l02370"></a>02370         ret_val = e1000_update_nvm_checksum_with_offset(hw, nvm_offset);
<a name="l02371"></a>02371         <span class="keywordflow">if</span> (ret_val != E1000_SUCCESS)
<a name="l02372"></a>02372             <span class="keywordflow">goto</span> out;
<a name="l02373"></a>02373     }
<a name="l02374"></a>02374 
<a name="l02375"></a>02375 out:
<a name="l02376"></a>02376     <span class="keywordflow">return</span> ret_val;
<a name="l02377"></a>02377 }
<a name="l02378"></a>02378 
<a name="l02386"></a>02386 s32 e1000_set_eee_i350(<span class="keyword">struct</span> <a class="code" href="structe1000__hw.html">e1000_hw</a> *hw)
<a name="l02387"></a>02387 {
<a name="l02388"></a>02388     s32 ret_val = E1000_SUCCESS;
<a name="l02389"></a>02389     u32 ipcnfg, eeer, ctrl_ext;
<a name="l02390"></a>02390 
<a name="l02391"></a>02391     DEBUGFUNC(<span class="stringliteral">&quot;e1000_set_eee_i350&quot;</span>);
<a name="l02392"></a>02392 
<a name="l02393"></a>02393     ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
<a name="l02394"></a>02394     <span class="keywordflow">if</span> ((hw-&gt;mac.type != e1000_i350) ||
<a name="l02395"></a>02395         (ctrl_ext &amp; E1000_CTRL_EXT_LINK_MODE_MASK))
<a name="l02396"></a>02396         <span class="keywordflow">goto</span> out;
<a name="l02397"></a>02397     ipcnfg = E1000_READ_REG(hw, E1000_IPCNFG);
<a name="l02398"></a>02398     eeer = E1000_READ_REG(hw, E1000_EEER);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400     <span class="comment">/* enable or disable per user setting */</span>
<a name="l02401"></a>02401     <span class="keywordflow">if</span> (!(hw-&gt;dev_spec._82575.eee_disable)) {
<a name="l02402"></a>02402         ipcnfg |= (E1000_IPCNFG_EEE_1G_AN |
<a name="l02403"></a>02403                    E1000_IPCNFG_EEE_100M_AN);
<a name="l02404"></a>02404         eeer |= (E1000_EEER_TX_LPI_EN |
<a name="l02405"></a>02405                  E1000_EEER_RX_LPI_EN |
<a name="l02406"></a>02406                  E1000_EEER_LPI_FC);
<a name="l02407"></a>02407 
<a name="l02408"></a>02408     } <span class="keywordflow">else</span> {
<a name="l02409"></a>02409         ipcnfg &amp;= ~(E1000_IPCNFG_EEE_1G_AN |
<a name="l02410"></a>02410                     E1000_IPCNFG_EEE_100M_AN);
<a name="l02411"></a>02411         eeer &amp;= ~(E1000_EEER_TX_LPI_EN |
<a name="l02412"></a>02412                   E1000_EEER_RX_LPI_EN |
<a name="l02413"></a>02413                   E1000_EEER_LPI_FC);
<a name="l02414"></a>02414     }
<a name="l02415"></a>02415     E1000_WRITE_REG(hw, E1000_IPCNFG, ipcnfg);
<a name="l02416"></a>02416     E1000_WRITE_REG(hw, E1000_EEER, eeer);
<a name="l02417"></a>02417             E1000_READ_REG(hw, E1000_IPCNFG);
<a name="l02418"></a>02418             E1000_READ_REG(hw, E1000_EEER);
<a name="l02419"></a>02419 out:
<a name="l02420"></a>02420 
<a name="l02421"></a>02421     <span class="keywordflow">return</span> ret_val;
<a name="l02422"></a>02422 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:26 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
