<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: NetReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">NetReader Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="NetReader" --><!-- doxytag: inherits="Threaded" -->
<p><code>#include &lt;<a class="el" href="net__reader_8h_source.html">net_reader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetReader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_net_reader.png" usemap="#NetReader_map" alt=""/>
  <map id="NetReader_map" name="NetReader_map">
<area href="class_threaded.html" alt="Threaded" shape="rect" coords="0,0,72,24"/>
</map>
 </div></div>

<p><a href="class_net_reader-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#adadbce06c16a6350aba08f468a7b0d83">NetReader</a> (const int id, const std::string interface, const int snaplen, const int payload_length, const int buffer_size, const bool promiscuous, <a class="el" href="class_file_writer.html">FileWriter</a> *const fw, <a class="el" href="class_stats_writer.html">StatsWriter</a> *const sw, const double command_interval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87d8aa64164c1f55ad34dc3c1b362559"></a><!-- doxytag: member="NetReader::~NetReader" ref="a87d8aa64164c1f55ad34dc3c1b362559" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a87d8aa64164c1f55ad34dc3c1b362559">~NetReader</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3d94d0ddcddacb2985046934fa1006e"></a><!-- doxytag: member="NetReader::start" ref="aa3d94d0ddcddacb2985046934fa1006e" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#aa3d94d0ddcddacb2985046934fa1006e">start</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the main processing loop <a class="el" href="class_net_reader.html#af770f94a75655fc02489c9cb1f778181" title="Main processing loop.">run()</a> in its own thread of execution. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eb2447a323f7068b3838418bf746854"></a><!-- doxytag: member="NetReader::join" ref="a4eb2447a323f7068b3838418bf746854" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a4eb2447a323f7068b3838418bf746854">join</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the main processing loop/thread to exit. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a8ba627314d064cb636f192974e4daed6">cmd_stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a47c2209376226353e4c5d80c4f35713f">cmd_read_from_network</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>IDLE</b>, 
<b>READ_FROM_NETWORK</b>, 
<b>STOP</b>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af770f94a75655fc02489c9cb1f778181"></a><!-- doxytag: member="NetReader::run" ref="af770f94a75655fc02489c9cb1f778181" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#af770f94a75655fc02489c9cb1f778181">run</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main processing loop. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a6b81e13eba7624570bfd0ed90874069c">handle_stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13ec87275d0da80672ca1b6db0d8db01"></a><!-- doxytag: member="NetReader::handle_idle" ref="a13ec87275d0da80672ca1b6db0d8db01" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a13ec87275d0da80672ca1b6db0d8db01">handle_idle</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Command handler. Handles the IDLE state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#adff36260184f5d1207e298574a41becb">handle_read_from_network</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#adcf200863f3126eaaa825d66de3b2ae6">_interface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a315fd6f68c1e8aa65bfb1125e4a07568"></a><!-- doxytag: member="NetReader::_snaplen" ref="a315fd6f68c1e8aa65bfb1125e4a07568" args="" -->
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a315fd6f68c1e8aa65bfb1125e4a07568">_snaplen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The total amount of bytes to capture from the packet (e.g. 9000). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#aeee03720b22f775cdbee80a50c39453a">_payload_length</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a2ae2988890c04fd26f274d039fb868d8">_buffer_size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff7f135e9b67c9c0b91b65532c7178ac"></a><!-- doxytag: member="NetReader::_promiscuous" ref="aff7f135e9b67c9c0b91b65532c7178ac" args="" -->
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#aff7f135e9b67c9c0b91b65532c7178ac">_promiscuous</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not to open the network interface in promiscuous mode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_file_writer.html">FileWriter</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">_fw</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_stats_writer.html">StatsWriter</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#a73d95d4fdb1065e26e2e8eed2b64d534">_sw</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_f_r.html">PFR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#acf0a225f9ec8f89f3b3b1e9ff761d916">_ring</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_reader.html#afc35b98235d4d5479f755765d6bb1c97">_net_buf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a225465439801fc011e7a9d080f02ad"></a><!-- doxytag: member="NetReader::_state" ref="a7a225465439801fc011e7a9d080f02ad" args="" -->
enum NetReader:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>_state</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Manages high speed capture of data from network interface using PF_RING. Data are read in from an assigned interface using the PF_RING API. The data are read in to specially allocated and sized buffers, that have been optimized for disk throughput. Once a buffer is full, it is passed on to a <a class="el" href="class_file_writer.html">FileWriter</a> to be written to disk. </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00049">49</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ab7f953c3d9d89435f05ba1674fd868c9"></a><!-- doxytag: member="NetReader::@320" ref="ab7f953c3d9d89435f05ba1674fd868c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>State variable. This variable is changed in response to cmd_X() commands applied to this object. The variable is used in the <a class="el" href="class_net_reader.html#af770f94a75655fc02489c9cb1f778181" title="Main processing loop.">run()</a> method to determine what state the object is currently in, so that the appropriate handle_X() method can be called. </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00154">154</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>
<div class="fragment"><pre class="fragment">{ IDLE, READ_FROM_NETWORK, STOP } _state;
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adadbce06c16a6350aba08f468a7b0d83"></a><!-- doxytag: member="NetReader::NetReader" ref="adadbce06c16a6350aba08f468a7b0d83" args="(const int id, const std::string interface, const int snaplen, const int payload_length, const int buffer_size, const bool promiscuous, FileWriter *const fw, StatsWriter *const sw, const double command_interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetReader::NetReader </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>snaplen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>payload_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>promiscuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_file_writer.html">FileWriter</a> *const&#160;</td>
          <td class="paramname"><em>fw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_stats_writer.html">StatsWriter</a> *const&#160;</td>
          <td class="paramname"><em>sw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>command_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>A unique identifies for this object. Used in logging. </td></tr>
    <tr><td class="paramname">interface</td><td>The name of the network interface from which data will be captured. </td></tr>
    <tr><td class="paramname">snaplen</td><td>The total amount of data to be captured (data packet headers from layer2 and up are included in the count). </td></tr>
    <tr><td class="paramname">payload_length</td><td>The total length of the UDP payload. This is the amount of data that needs to be extracted from each packet and then stored to disk. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The size of the optimal buffers that are used to transfer data from network interface to disk. Typically, these are a multiple of the system page size, and aligned to page size boundaries (e..g, page size of 256B, buffer size of 1048576B). </td></tr>
    <tr><td class="paramname">promiscuous</td><td>Wheter or not to put the network interface into promiscuous mode. </td></tr>
    <tr><td class="paramname">fw</td><td>A pointer to a <a class="el" href="class_file_writer.html">FileWriter</a> object. </td></tr>
    <tr><td class="paramname">sw</td><td>A pointer to a <a class="el" href="class_stats_writer.html">StatsWriter</a> object. </td></tr>
    <tr><td class="paramname">command_interval</td><td>The main executin thread in <a class="el" href="class_net_reader.html#af770f94a75655fc02489c9cb1f778181" title="Main processing loop.">run()</a> will attempt to check for new commands every command_interval seconds. The actual interval between checks may be larger than this if the execution thread spends longer than command_interval processing individual tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Robustify this. </dd></dl>

<p>Definition at line <a class="el" href="net__reader_8cc_source.html#l00043">43</a> of file <a class="el" href="net__reader_8cc_source.html">net_reader.cc</a>.</p>
<div class="fragment"><pre class="fragment">                                           :
  <a class="code" href="class_threaded.html#a6236a842ddac09f974c58e17680d41c0">Threaded</a>(<span class="keywordtype">id</span>, command_interval),
  <a class="code" href="class_net_reader.html#adcf200863f3126eaaa825d66de3b2ae6">_interface</a>(interface),
  <a class="code" href="class_net_reader.html#a315fd6f68c1e8aa65bfb1125e4a07568" title="The total amount of bytes to capture from the packet (e.g. 9000).">_snaplen</a>(snaplen),
  <a class="code" href="class_net_reader.html#aeee03720b22f775cdbee80a50c39453a">_payload_length</a>(payload_length),
  <a class="code" href="class_net_reader.html#a2ae2988890c04fd26f274d039fb868d8">_buffer_size</a>(buffer_size),
  <a class="code" href="class_net_reader.html#aff7f135e9b67c9c0b91b65532c7178ac" title="Whether or not to open the network interface in promiscuous mode.">_promiscuous</a>(promiscuous),
  <a class="code" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">_fw</a>(fw),
  <a class="code" href="class_net_reader.html#a73d95d4fdb1065e26e2e8eed2b64d534">_sw</a>(sw),
  <a class="code" href="class_net_reader.html#acf0a225f9ec8f89f3b3b1e9ff761d916">_ring</a>(0),
  <a class="code" href="class_net_reader.html#afc35b98235d4d5479f755765d6bb1c97">_net_buf</a>(0),
  _state(IDLE) {
  <a class="code" href="class_net_reader.html#acf0a225f9ec8f89f3b3b1e9ff761d916">_ring</a> = <span class="keyword">new</span> <a class="code" href="class_p_f_r.html">PFR</a>(interface.c_str(), snaplen, <a class="code" href="class_net_reader.html#aff7f135e9b67c9c0b91b65532c7178ac" title="Whether or not to open the network interface in promiscuous mode.">_promiscuous</a>);
  <a class="code" href="class_net_reader.html#afc35b98235d4d5479f755765d6bb1c97">_net_buf</a> = <span class="keyword">new</span> boost::uint8_t[snaplen];
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a47c2209376226353e4c5d80c4f35713f"></a><!-- doxytag: member="NetReader::cmd_read_from_network" ref="a47c2209376226353e4c5d80c4f35713f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetReader::cmd_read_from_network </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>External API command. Insert a READ_FROM_NETWORK command into the object's command queue for processing. </p>

<p>Definition at line <a class="el" href="net__reader_8cc_source.html#l00130">130</a> of file <a class="el" href="net__reader_8cc_source.html">net_reader.cc</a>.</p>
<div class="fragment"><pre class="fragment">                                      {
  LOG4CXX_INFO(logger, <span class="stringliteral">&quot;Received READ_FROM_NETWORK...&quot;</span>);
  _state = READ_FROM_NETWORK;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8ba627314d064cb636f192974e4daed6"></a><!-- doxytag: member="NetReader::cmd_stop" ref="a8ba627314d064cb636f192974e4daed6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetReader::cmd_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>External API command. Insert a STOP command into the object's command queue for processing. </p>

<p>Implements <a class="el" href="class_threaded.html#a52a40998cd6f4b995ceaba12899b4212">Threaded</a>.</p>

<p>Definition at line <a class="el" href="net__reader_8cc_source.html#l00125">125</a> of file <a class="el" href="net__reader_8cc_source.html">net_reader.cc</a>.</p>
<div class="fragment"><pre class="fragment">                         {
  LOG4CXX_INFO(logger, <span class="stringliteral">&quot;Received STOP&quot;</span>);
  _state = STOP;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adff36260184f5d1207e298574a41becb"></a><!-- doxytag: member="NetReader::handle_read_from_network" ref="adff36260184f5d1207e298574a41becb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetReader::handle_read_from_network </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Command handler. Handles the READ_FROM_NETWORK state/command. On receiving this command, the <a class="el" href="class_net_reader.html">NetReader</a> object will start to read data from the network interface and pass filled buffers to the <a class="el" href="class_file_writer.html">FileWriter</a> object. </p>

<p>Definition at line <a class="el" href="net__reader_8cc_source.html#l00174">174</a> of file <a class="el" href="net__reader_8cc_source.html">net_reader.cc</a>.</p>
<div class="fragment"><pre class="fragment">                                         {
  <span class="keyword">struct </span><a class="code" href="structpfring__pkthdr.html">pfring_pkthdr</a> hdr;
  <span class="keywordtype">int</span> payload_length;
  boost::uint8_t* payload_ptr;
  
  <span class="keywordtype">int</span> bytes_read = 0;
  <span class="keyword">static</span> <span class="keywordtype">int</span> remainder_len = 0;
  <span class="keyword">static</span> boost::uint8_t remainder_buf[9000];
  <span class="keyword">static</span> <span class="keywordtype">bool</span> first_write = <span class="keyword">true</span>;
  <span class="keyword">static</span> boost::uint8_t net_buf[9000];
  <span class="keyword">static</span> <a class="code" href="struct_pcap_packet_header.html">PcapPacketHeader</a> pph;

<span class="preprocessor">#define DYNAMIC_BUFFER</span>
<span class="preprocessor"></span><span class="preprocessor">#ifdef DYNAMIC_BUFFER</span>
<span class="preprocessor"></span>  <span class="keywordtype">int</span> bytes_left = <a class="code" href="class_net_reader.html#a2ae2988890c04fd26f274d039fb868d8">_buffer_size</a>;
  boost::uint8_t* file_buf = <a class="code" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">_fw</a>-&gt;malloc_buffer();
  <span class="keywordflow">if</span> (!file_buf) {
    LOG4CXX_ERROR(logger, <span class="stringliteral">&quot;File buffer&#39;s full: timedout&quot;</span>);
    <span class="keywordflow">return</span>;
  }
  assert(file_buf);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> BUFFER_SIZE = 1048576;
  <span class="keywordtype">int</span> bytes_left = BUFFER_SIZE;
  <span class="keyword">static</span> boost::uint8_t file_buf[BUFFER_SIZE];
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  boost::uint64_t dropped_packets = 0;
  boost::uint64_t num_packets = 0;
  boost::uint64_t num_bytes = 0;

  <span class="keywordflow">if</span> (first_write) {
    memcpy(remainder_buf, PCAP_HEADER, PCAP_HEADER_LENGTH);
    remainder_len = PCAP_HEADER_LENGTH;
    first_write = <span class="keyword">false</span>;
  }

  <span class="comment">// Copy partial packet.</span>
  <span class="keywordflow">if</span> (remainder_len &gt; 0) {
    memcpy(file_buf, remainder_buf, remainder_len);
    bytes_read += remainder_len;
    bytes_left -= remainder_len;
    remainder_len = 0;
  }

  <span class="comment">// Fill the new file_buf;</span>
  <span class="keywordflow">while</span> (bytes_left &gt; 0) {
    <span class="keywordflow">if</span> (<a class="code" href="class_net_reader.html#acf0a225f9ec8f89f3b3b1e9ff761d916">_ring</a>-&gt;get_next_packet(&amp;hdr, &amp;net_buf[PCAP_PACKET_HEADER_LENGTH],
                   <a class="code" href="class_net_reader.html#a315fd6f68c1e8aa65bfb1125e4a07568" title="The total amount of bytes to capture from the packet (e.g. 9000).">_snaplen</a>) &gt; 0) {
      <span class="comment">// Successful read.</span>

      <span class="comment">// Extract offsets etc. from pfring structures.</span>
      <span class="keyword">struct </span><a class="code" href="structpfring__extended__pkthdr.html">pfring_extended_pkthdr</a>&amp; pep(hdr.extended_hdr);
      <span class="keyword">struct </span><a class="code" href="structpkt__parsing__info.html">pkt_parsing_info</a>&amp; ppi(pep.parsed_pkt);
      <span class="keyword">struct </span><a class="code" href="structpkt__offset.html">pkt_offset</a> po(ppi.offset);
      <span class="keyword">const</span> boost::uint16_t eth_offset(po.eth_offset);
      <span class="keyword">const</span> boost::uint16_t l3_offset(po.l3_offset);
      <span class="keyword">const</span> boost::uint16_t l4_offset(po.l4_offset);
      <span class="keyword">const</span> boost::uint16_t payload_offset(po.payload_offset);

      <span class="comment">// Get payload information.</span>
      <span class="comment">// FIXME payload_ptr = &amp;_net_buf[payload_offset];</span>
      payload_ptr = net_buf;
      <span class="comment">// FIXME payload_length = hdr.caplen - payload_offset;</span>
      payload_length = hdr.len + PCAP_PACKET_HEADER_LENGTH;

      pph.ts_sec = hdr.ts.tv_sec;
      pph.ts_usec = hdr.ts.tv_usec;
      pph.incl_len = hdr.len;
      pph.orig_len = hdr.len;
      memcpy(net_buf, &amp;pph, PCAP_PACKET_HEADER_LENGTH);

      <span class="comment">// Check for validity of capture.</span>
      <span class="keywordflow">if</span> (hdr.caplen != <a class="code" href="class_net_reader.html#a315fd6f68c1e8aa65bfb1125e4a07568" title="The total amount of bytes to capture from the packet (e.g. 9000).">_snaplen</a>) {
      <span class="comment">// || hdr.caplen != hdr.len</span>
      <span class="comment">// || payload_length != _payload_length) {</span>
    LOG4CXX_DEBUG(logger, <span class="stringliteral">&quot;Short capture(caplen/snaplen&quot;</span>
              <span class="stringliteral">&quot;len/payload_length/PAYLOAD_LENGTH) -&gt; (&quot;</span>
              &lt;&lt; hdr.caplen &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; <a class="code" href="class_net_reader.html#a315fd6f68c1e8aa65bfb1125e4a07568" title="The total amount of bytes to capture from the packet (e.g. 9000).">_snaplen</a> &lt;&lt; <span class="stringliteral">&quot;/&quot;</span>
              &lt;&lt; hdr.len &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; payload_length &lt;&lt; <span class="stringliteral">&quot;/&quot;</span>
              &lt;&lt; <a class="code" href="class_net_reader.html#aeee03720b22f775cdbee80a50c39453a">_payload_length</a> &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>);
    <span class="keywordflow">continue</span>;
      }

      <span class="comment">// Update stats.</span>
      num_packets++;
      num_bytes += hdr.len;
    } <span class="keywordflow">else</span> {
      LOG4CXX_ERROR(logger, <span class="stringliteral">&quot;Error while calling get_next_packet(): &quot;</span>
            &lt;&lt; strerror(errno));
      <span class="keywordflow">continue</span>;
    }

    <span class="comment">// Accumulate or flush data.</span>
    <span class="keywordflow">if</span> (bytes_left &lt; payload_length) {
      <span class="comment">// Copy fragment into buffer.</span>
      memcpy(&amp;file_buf[bytes_read], payload_ptr, bytes_left);
      bytes_read += bytes_left;
      
      <span class="comment">// Copy remainder into remainder_buf.</span>
      remainder_len = payload_length - bytes_left;
      memcpy(remainder_buf, payload_ptr + bytes_left, remainder_len);

<span class="preprocessor">#define BUFFERED_WRITE      </span>
<span class="preprocessor"></span><span class="preprocessor">#ifdef BUFFERED_WRITE</span>
<span class="preprocessor"></span>      <span class="keywordflow">if</span> (!<a class="code" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">_fw</a>-&gt;<a class="code" href="class_file_writer.html#aed0ee15de36255a2883b5f15c710848c">write</a>(file_buf))
    ++dropped_packets;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>      <a class="code" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">_fw</a>-&gt;write_unbuffered(file_buf, BUFFER_SIZE);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>      <span class="comment">// Update stats.</span>
      <a class="code" href="class_net_reader.html#a73d95d4fdb1065e26e2e8eed2b64d534">_sw</a>-&gt;<a class="code" href="class_stats_writer.html#a7b73b711a050b4bd17fe7489db8231d4">update</a>(num_packets, num_bytes, dropped_packets, 0);
      bytes_left = 0;
      <span class="keywordflow">break</span>;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_left == payload_length) {
      <span class="comment">// Copy captured payload to file buffer.</span>
      memcpy(&amp;file_buf[bytes_read], payload_ptr, payload_length);
      bytes_read += payload_length;
      bytes_left -= payload_length;
<span class="preprocessor">#ifdef BUFFERED_WRITE</span>
<span class="preprocessor"></span>      <span class="keywordflow">if</span> (!<a class="code" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">_fw</a>-&gt;<a class="code" href="class_file_writer.html#aed0ee15de36255a2883b5f15c710848c">write</a>(file_buf))
    ++dropped_packets;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>      <a class="code" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">_fw</a>-&gt;write_unbuffered(file_buf, BUFFER_SIZE);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
      <span class="comment">// Copy captured payload to file buffer.</span>
      memcpy(&amp;file_buf[bytes_read], payload_ptr, payload_length);
      bytes_read += payload_length;
      bytes_left -= payload_length;
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6b81e13eba7624570bfd0ed90874069c"></a><!-- doxytag: member="NetReader::handle_stop" ref="a6b81e13eba7624570bfd0ed90874069c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetReader::handle_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Command handler. Handles the STOP command/state. On receiving this command, the <a class="el" href="class_file_writer.html">FileWriter</a> object will stop processing and exit the <a class="el" href="class_net_reader.html#af770f94a75655fc02489c9cb1f778181" title="Main processing loop.">run()</a> method at the next opportunity. </p>

<p>Implements <a class="el" href="class_threaded.html#a421b31c46443970af90b8fa1df8ea141">Threaded</a>.</p>

<p>Definition at line <a class="el" href="net__reader_8cc_source.html#l00135">135</a> of file <a class="el" href="net__reader_8cc_source.html">net_reader.cc</a>.</p>
<div class="fragment"><pre class="fragment">                            {
  <a class="code" href="class_threaded.html#a96b6bd60b0eb14d91ea26b1eac61064c">_running</a> = <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2ae2988890c04fd26f274d039fb868d8"></a><!-- doxytag: member="NetReader::_buffer_size" ref="a2ae2988890c04fd26f274d039fb868d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="class_net_reader.html#a2ae2988890c04fd26f274d039fb868d8">NetReader::_buffer_size</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The size of the buffer being filled. These buffers are optimized for disk throughput and have custom memory allocation and alignment mechanisms. Typically, these buffers are orders of magnitude larger than a packet (e.g. 1 MB v. 9KB). </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00127">127</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c447196aabbe2920be2bad71765ec31"></a><!-- doxytag: member="NetReader::_fw" ref="a5c447196aabbe2920be2bad71765ec31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_file_writer.html">FileWriter</a>* const <a class="el" href="class_net_reader.html#a5c447196aabbe2920be2bad71765ec31">NetReader::_fw</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pointer to the <a class="el" href="class_file_writer.html">FileWriter</a> object that will write the data to disk. Once a buffer is filled, it is passed in to the <a class="el" href="class_file_writer.html">FileWriter</a> object where it is queued awaiting transfer to disk. </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00135">135</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>

</div>
</div>
<a class="anchor" id="adcf200863f3126eaaa825d66de3b2ae6"></a><!-- doxytag: member="NetReader::_interface" ref="adcf200863f3126eaaa825d66de3b2ae6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="class_net_reader.html#adcf200863f3126eaaa825d66de3b2ae6">NetReader::_interface</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The name of the network interface from which to capture data (e.g., eth2). </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00114">114</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc35b98235d4d5479f755765d6bb1c97"></a><!-- doxytag: member="NetReader::_net_buf" ref="afc35b98235d4d5479f755765d6bb1c97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::uint8_t* <a class="el" href="class_net_reader.html#afc35b98235d4d5479f755765d6bb1c97">NetReader::_net_buf</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pointer to the temporary buffer used to store data recently captured from the network interface. </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00148">148</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeee03720b22f775cdbee80a50c39453a"></a><!-- doxytag: member="NetReader::_payload_length" ref="aeee03720b22f775cdbee80a50c39453a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="class_net_reader.html#aeee03720b22f775cdbee80a50c39453a">NetReader::_payload_length</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The length of the payload (i.e. the amount of data to extract and write to disk). </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00121">121</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf0a225f9ec8f89f3b3b1e9ff761d916"></a><!-- doxytag: member="NetReader::_ring" ref="acf0a225f9ec8f89f3b3b1e9ff761d916" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_f_r.html">PFR</a>* <a class="el" href="class_net_reader.html#acf0a225f9ec8f89f3b3b1e9ff761d916">NetReader::_ring</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pointer to the PF_RING data structure that tracks the PF_RING state and data structures. </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00144">144</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>

</div>
</div>
<a class="anchor" id="a73d95d4fdb1065e26e2e8eed2b64d534"></a><!-- doxytag: member="NetReader::_sw" ref="a73d95d4fdb1065e26e2e8eed2b64d534" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_stats_writer.html">StatsWriter</a>* const <a class="el" href="class_net_reader.html#a73d95d4fdb1065e26e2e8eed2b64d534">NetReader::_sw</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pointer to a <a class="el" href="class_stats_writer.html">StatsWriter</a> object that will keep track of throughput statistics for this object. The <a class="el" href="class_stats_writer.html">StatsWriter</a> will also write these statistics to CSV file on disk. </p>

<p>Definition at line <a class="el" href="net__reader_8h_source.html#l00140">140</a> of file <a class="el" href="net__reader_8h_source.html">net_reader.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/net2disk/<a class="el" href="net__reader_8h_source.html">net_reader.h</a></li>
<li>src/net2disk/<a class="el" href="net__reader_8cc_source.html">net_reader.cc</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:36 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
