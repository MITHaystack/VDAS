<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mark6: src/extern/PF_RING-4.7.0/drivers/intel/ixgbe/ixgbe-3.1.15-FlowDirector-NoTNAPI/src/ixgbe_main.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mark6</div>
   <div id="projectbrief">Mark6 VLBI data acquisition software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_249616ead0532db7c581c28062f7a49e.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_99a38eff05bc1388efa7bcbb456e2008.html">extern</a>      </li>
      <li class="navelem"><a class="el" href="dir_53c688ba8854e22dd560901b085b7a24.html">PF_RING-4.7.0</a>      </li>
      <li class="navelem"><a class="el" href="dir_08abce4056e40422ca54188a7ad15713.html">drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_0aa32237f90cad5b43b1dfe5d6b3443b.html">intel</a>      </li>
      <li class="navelem"><a class="el" href="dir_aa6459e1e92664bab04094557f6624be.html">ixgbe</a>      </li>
      <li class="navelem"><a class="el" href="dir_841ccacdd8dc0779375a2d0bee41ab9a.html">ixgbe-3.1.15-FlowDirector-NoTNAPI</a>      </li>
      <li class="navelem"><a class="el" href="dir_48709381b9d94a6f6b2ce25044cf89fa.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ixgbe_main.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  Intel 10 Gigabit PCI Express Linux driver</span>
<a name="l00004"></a>00004 <span class="comment">  Copyright(c) 1999 - 2010 Intel Corporation.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
<a name="l00007"></a>00007 <span class="comment">  under the terms and conditions of the GNU General Public License,</span>
<a name="l00008"></a>00008 <span class="comment">  version 2, as published by the Free Software Foundation.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<a name="l00011"></a>00011 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00012"></a>00012 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<a name="l00013"></a>00013 <span class="comment">  more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">  You should have received a copy of the GNU General Public License along with</span>
<a name="l00016"></a>00016 <span class="comment">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">  The full GNU General Public License is included in this distribution in</span>
<a name="l00020"></a>00020 <span class="comment">  the file called &quot;COPYING&quot;.</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">  Contact Information:</span>
<a name="l00023"></a>00023 <span class="comment">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<a name="l00024"></a>00024 <span class="comment">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">*******************************************************************************/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">/******************************************************************************</span>
<a name="l00030"></a>00030 <span class="comment"> Copyright (c)2006 - 2007 Myricom, Inc. for some LRO specific code</span>
<a name="l00031"></a>00031 <span class="comment">******************************************************************************/</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;linux/pci.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;linux/netdevice.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;linux/vmalloc.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;linux/string.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;linux/in.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;linux/ip.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;linux/tcp.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;linux/sctp.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;linux/pkt_sched.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;linux/ipv6.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/checksum.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;net/ip6_checksum.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIOCETHTOOL</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/ethtool.h&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#endif</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;ixgbe.h&quot;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="preprocessor">#ifndef HAVE_PF_RING</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#define HAVE_PF_RING</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#if(LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30))</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define CPACKET_TIMESTAMPS</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="preprocessor">#ifdef CPACKET_TIMESTAMPS</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/timecompare.h&gt;</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keywordtype">int</span> cpacket_ts_enable = 0;
<a name="l00068"></a>00068 module_param(cpacket_ts_enable, uint, 0644);
<a name="l00069"></a>00069 MODULE_PARM_DESC(cpacket_ts_enable, <span class="stringliteral">&quot;Enable cpacket.com timestamp detection: 0=Disabled (default), 1=Enabled&quot;</span>);
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="structcpacket__ts.html">00071</a> <span class="keyword">struct </span><a class="code" href="structcpacket__ts.html">cpacket_ts</a> {
<a name="l00072"></a>00072   u_int32_t original_crc, epoch, ns, ignore;
<a name="l00073"></a>00073 };
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="preprocessor">#endif </span><span class="comment">/* CPACKET_TIMESTAMPS */</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#include &quot;../../../../../kernel/linux/pf_ring.h&quot;</span>
<a name="l00079"></a>00079 <span class="preprocessor">#endif</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="preprocessor">#include &quot;ixgbe_sriov.h&quot;</span>
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="keywordtype">char</span> ixgbe_driver_name[] = <span class="stringliteral">&quot;ixgbe&quot;</span>;
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> ixgbe_driver_string[] =
<a name="l00086"></a>00086                   <span class="stringliteral">&quot;Intel(R) 10 Gigabit PCI Express Network Driver&quot;</span>;
<a name="l00087"></a>00087 <span class="preprocessor">#define DRV_HW_PERF</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span>
<a name="l00089"></a>00089 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#define DRIVERNAPI</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#define DRIVERNAPI &quot;-NAPI&quot;</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095 <span class="preprocessor">#define FPGA</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a>00097 <span class="preprocessor">#define DRV_VERSION &quot;3.1.15&quot; DRIVERNAPI DRV_HW_PERF FPGA</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="keyword">const</span> <span class="keywordtype">char</span> ixgbe_driver_version[] = DRV_VERSION;
<a name="l00099"></a>00099 <span class="keyword">static</span> <span class="keywordtype">char</span> ixgbe_copyright[] = <span class="stringliteral">&quot;Copyright (c) 1999-2010 Intel Corporation.&quot;</span>;
<a name="l00100"></a>00100 <span class="comment">/* ixgbe_pci_tbl - PCI Device ID Table</span>
<a name="l00101"></a>00101 <span class="comment"> *</span>
<a name="l00102"></a>00102 <span class="comment"> * Wildcard entries (PCI_ANY_ID) should come last</span>
<a name="l00103"></a>00103 <span class="comment"> * Last entry must be all 0s</span>
<a name="l00104"></a>00104 <span class="comment"> *</span>
<a name="l00105"></a>00105 <span class="comment"> * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,</span>
<a name="l00106"></a>00106 <span class="comment"> *   Class, Class Mask, private data (not used) }</span>
<a name="l00107"></a>00107 <span class="comment"> */</span>
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keyword">struct </span>pci_device_id ixgbe_pci_tbl[] = {
<a name="l00109"></a>00109     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598)},
<a name="l00110"></a>00110     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_BX)},
<a name="l00111"></a>00111     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AF_DUAL_PORT)},
<a name="l00112"></a>00112     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AF_SINGLE_PORT)},
<a name="l00113"></a>00113     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AT)},
<a name="l00114"></a>00114     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598AT2)},
<a name="l00115"></a>00115     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598EB_CX4)},
<a name="l00116"></a>00116     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_CX4_DUAL_PORT)},
<a name="l00117"></a>00117     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_DA_DUAL_PORT)},
<a name="l00118"></a>00118     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM)},
<a name="l00119"></a>00119     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598EB_XF_LR)},
<a name="l00120"></a>00120     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82598EB_SFP_LOM)},
<a name="l00121"></a>00121     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_KX4)},
<a name="l00122"></a>00122     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_XAUI_LOM)},
<a name="l00123"></a>00123     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_KR)},
<a name="l00124"></a>00124     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_SFP)},
<a name="l00125"></a>00125     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_SFP_EM)},
<a name="l00126"></a>00126     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_KX4_MEZZ)},
<a name="l00127"></a>00127     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_T3_LOM)},
<a name="l00128"></a>00128     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_CX4)},
<a name="l00129"></a>00129     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_BACKPLANE_FCOE)},
<a name="l00130"></a>00130     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_SFP_FCOE)},
<a name="l00131"></a>00131     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_82599_COMBO_BACKPLANE)},
<a name="l00132"></a>00132     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_X540)},
<a name="l00133"></a>00133     {PCI_DEVICE(PCI_VENDOR_ID_INTEL, IXGBE_DEV_ID_X540T)},
<a name="l00134"></a>00134     <span class="comment">/* required last entry */</span>
<a name="l00135"></a>00135     {0, }
<a name="l00136"></a>00136 };
<a name="l00137"></a>00137 MODULE_DEVICE_TABLE(pci, ixgbe_pci_tbl);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_notify_dca(<span class="keyword">struct</span> notifier_block *, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l00141"></a>00141                 <span class="keywordtype">void</span> *p);
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keyword">struct </span>notifier_block dca_notifier = {
<a name="l00143"></a>00143     .notifier_call = ixgbe_notify_dca,
<a name="l00144"></a>00144     .next          = NULL,
<a name="l00145"></a>00145     .priority      = 0
<a name="l00146"></a>00146 };
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="preprocessor">#endif</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>MODULE_AUTHOR(<span class="stringliteral">&quot;Intel Corporation, &lt;linux.nics@intel.com&gt;&quot;</span>);
<a name="l00150"></a>00150 MODULE_DESCRIPTION(<span class="stringliteral">&quot;Intel(R) 10 Gigabit PCI Express Network Driver&quot;</span>);
<a name="l00151"></a>00151 MODULE_LICENSE(<span class="stringliteral">&quot;GPL&quot;</span>);
<a name="l00152"></a>00152 MODULE_VERSION(DRV_VERSION);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="preprocessor">#define DEFAULT_DEBUG_LEVEL_SHIFT 3</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span>
<a name="l00156"></a>00156 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_disable_sriov(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00159"></a>00159     u32 gcr;
<a name="l00160"></a>00160     u32 gpie;
<a name="l00161"></a>00161     u32 vmdctl;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span>    <span class="comment">/* disable iov and allow time for transactions to clear */</span>
<a name="l00165"></a>00165     pci_disable_sriov(adapter-&gt;pdev);
<a name="l00166"></a>00166 <span class="preprocessor">#endif</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>
<a name="l00168"></a>00168     <span class="comment">/* turn off device IOV mode */</span>
<a name="l00169"></a>00169     gcr = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);
<a name="l00170"></a>00170     gcr &amp;= ~(IXGBE_GCR_EXT_SRIOV);
<a name="l00171"></a>00171     IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr);
<a name="l00172"></a>00172     gpie = IXGBE_READ_REG(hw, IXGBE_GPIE);
<a name="l00173"></a>00173     gpie &amp;= ~IXGBE_GPIE_VTMODE_MASK;
<a name="l00174"></a>00174     IXGBE_WRITE_REG(hw, IXGBE_GPIE, gpie);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     <span class="comment">/* set default pool back to 0 */</span>
<a name="l00177"></a>00177     vmdctl = IXGBE_READ_REG(hw, IXGBE_VT_CTL);
<a name="l00178"></a>00178     vmdctl &amp;= ~IXGBE_VT_CTL_POOL_MASK;
<a name="l00179"></a>00179     IXGBE_WRITE_REG(hw, IXGBE_VT_CTL, vmdctl);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     <span class="comment">/* take a breather then clean up driver data */</span>
<a name="l00182"></a>00182     msleep(100);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     kfree(adapter-&gt;vfinfo);
<a name="l00185"></a>00185     adapter-&gt;vfinfo = NULL;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     adapter-&gt;num_vfs = 0;
<a name="l00188"></a>00188     adapter-&gt;flags &amp;= ~IXGBE_FLAG_SRIOV_ENABLED;
<a name="l00189"></a>00189 }
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_event_schedule(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) &amp;&amp;
<a name="l00194"></a>00194         !test_and_set_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state))
<a name="l00195"></a>00195         schedule_work(&amp;adapter-&gt;service_task);
<a name="l00196"></a>00196 }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_event_complete(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00199"></a>00199 {
<a name="l00200"></a>00200     BUG_ON(!test_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state));
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     <span class="comment">/* flush memory to make sure state is correct before next watchog */</span>
<a name="l00203"></a>00203     smp_mb__before_clear_bit();
<a name="l00204"></a>00204     clear_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state);
<a name="l00205"></a>00205 }
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_release_hw_control(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209     u32 ctrl_ext;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <span class="comment">/* Let firmware take over control of h/w */</span>
<a name="l00212"></a>00212     ctrl_ext = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT);
<a name="l00213"></a>00213     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT,
<a name="l00214"></a>00214             ctrl_ext &amp; ~IXGBE_CTRL_EXT_DRV_LOAD);
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_get_hw_control(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00218"></a>00218 {
<a name="l00219"></a>00219     u32 ctrl_ext;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     <span class="comment">/* Let firmware know the driver has taken over */</span>
<a name="l00222"></a>00222     ctrl_ext = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT);
<a name="l00223"></a>00223     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_CTRL_EXT,
<a name="l00224"></a>00224             ctrl_ext | IXGBE_CTRL_EXT_DRV_LOAD);
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment">/*</span>
<a name="l00228"></a>00228 <span class="comment"> * ixgbe_set_ivar - set the IVAR registers, mapping interrupt causes to vectors</span>
<a name="l00229"></a>00229 <span class="comment"> * @adapter: pointer to adapter struct</span>
<a name="l00230"></a>00230 <span class="comment"> * @direction: 0 for Rx, 1 for Tx, -1 for other causes</span>
<a name="l00231"></a>00231 <span class="comment"> * @queue: queue to map the corresponding interrupt to</span>
<a name="l00232"></a>00232 <span class="comment"> * @msix_vector: the vector to map to the corresponding queue</span>
<a name="l00233"></a>00233 <span class="comment"> *</span>
<a name="l00234"></a>00234 <span class="comment"> */</span>
<a name="l00235"></a>00235 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_ivar(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, s8 direction,
<a name="l00236"></a>00236                u8 queue, u8 msix_vector)
<a name="l00237"></a>00237 {
<a name="l00238"></a>00238     u32 ivar, index;
<a name="l00239"></a>00239     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00240"></a>00240     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00241"></a>00241     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00242"></a>00242         msix_vector |= IXGBE_IVAR_ALLOC_VAL;
<a name="l00243"></a>00243         <span class="keywordflow">if</span> (direction == -1)
<a name="l00244"></a>00244             direction = 0;
<a name="l00245"></a>00245         index = (((direction * 64) + queue) &gt;&gt; 2) &amp; 0x1F;
<a name="l00246"></a>00246         ivar = IXGBE_READ_REG(hw, IXGBE_IVAR(index));
<a name="l00247"></a>00247         ivar &amp;= ~(0xFF &lt;&lt; (8 * (queue &amp; 0x3)));
<a name="l00248"></a>00248         ivar |= (msix_vector &lt;&lt; (8 * (queue &amp; 0x3)));
<a name="l00249"></a>00249         IXGBE_WRITE_REG(hw, IXGBE_IVAR(index), ivar);
<a name="l00250"></a>00250         <span class="keywordflow">break</span>;
<a name="l00251"></a>00251     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00252"></a>00252     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00253"></a>00253         <span class="keywordflow">if</span> (direction == -1) {
<a name="l00254"></a>00254             <span class="comment">/* other causes */</span>
<a name="l00255"></a>00255             msix_vector |= IXGBE_IVAR_ALLOC_VAL;
<a name="l00256"></a>00256             index = ((queue &amp; 1) * 8);
<a name="l00257"></a>00257             ivar = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_IVAR_MISC);
<a name="l00258"></a>00258             ivar &amp;= ~(0xFF &lt;&lt; index);
<a name="l00259"></a>00259             ivar |= (msix_vector &lt;&lt; index);
<a name="l00260"></a>00260             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IVAR_MISC, ivar);
<a name="l00261"></a>00261             <span class="keywordflow">break</span>;
<a name="l00262"></a>00262         } <span class="keywordflow">else</span> {
<a name="l00263"></a>00263             <span class="comment">/* tx or rx causes */</span>
<a name="l00264"></a>00264             msix_vector |= IXGBE_IVAR_ALLOC_VAL;
<a name="l00265"></a>00265             index = ((16 * (queue &amp; 1)) + (8 * direction));
<a name="l00266"></a>00266             ivar = IXGBE_READ_REG(hw, IXGBE_IVAR(queue &gt;&gt; 1));
<a name="l00267"></a>00267             ivar &amp;= ~(0xFF &lt;&lt; index);
<a name="l00268"></a>00268             ivar |= (msix_vector &lt;&lt; index);
<a name="l00269"></a>00269             IXGBE_WRITE_REG(hw, IXGBE_IVAR(queue &gt;&gt; 1), ivar);
<a name="l00270"></a>00270             <span class="keywordflow">break</span>;
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272     <span class="keywordflow">default</span>:
<a name="l00273"></a>00273         <span class="keywordflow">break</span>;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_irq_rearm_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l00278"></a>00278                       u64 qmask)
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280     u32 mask;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l00283"></a>00283     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00284"></a>00284         mask = (IXGBE_EIMS_RTX_QUEUE &amp; qmask);
<a name="l00285"></a>00285         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS, mask);
<a name="l00286"></a>00286         <span class="keywordflow">break</span>;
<a name="l00287"></a>00287     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00288"></a>00288     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00289"></a>00289         mask = (qmask &amp; 0xFFFFFFFF);
<a name="l00290"></a>00290         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS_EX(0), mask);
<a name="l00291"></a>00291         mask = (qmask &gt;&gt; 32);
<a name="l00292"></a>00292         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EICS_EX(1), mask);
<a name="l00293"></a>00293         <span class="keywordflow">break</span>;
<a name="l00294"></a>00294     <span class="keywordflow">default</span>:
<a name="l00295"></a>00295         <span class="keywordflow">break</span>;
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_unmap_tx_resource(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring,
<a name="l00300"></a>00300                        <span class="keyword">struct</span> <a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer)
<a name="l00301"></a>00301 {
<a name="l00302"></a>00302     <span class="keywordflow">if</span> (tx_buffer-&gt;dma) {
<a name="l00303"></a>00303         <span class="keywordflow">if</span> (tx_buffer-&gt;tx_flags &amp; IXGBE_TX_FLAGS_MAPPED_AS_PAGE)
<a name="l00304"></a>00304             dma_unmap_page(ring-&gt;dev,
<a name="l00305"></a>00305                            tx_buffer-&gt;dma,
<a name="l00306"></a>00306                            tx_buffer-&gt;length,
<a name="l00307"></a>00307                            DMA_TO_DEVICE);
<a name="l00308"></a>00308         <span class="keywordflow">else</span>
<a name="l00309"></a>00309             dma_unmap_single(ring-&gt;dev,
<a name="l00310"></a>00310                              tx_buffer-&gt;dma,
<a name="l00311"></a>00311                              tx_buffer-&gt;length,
<a name="l00312"></a>00312                              DMA_TO_DEVICE);
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314     tx_buffer-&gt;dma = 0;
<a name="l00315"></a>00315     tx_buffer-&gt;time_stamp = 0;
<a name="l00316"></a>00316 }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="keywordtype">void</span> ixgbe_unmap_and_free_tx_resource(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l00319"></a>00319                       <span class="keyword">struct</span> <a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info)
<a name="l00320"></a>00320 {
<a name="l00321"></a>00321     ixgbe_unmap_tx_resource(tx_ring, tx_buffer_info);
<a name="l00322"></a>00322     <span class="keywordflow">if</span> (tx_buffer_info-&gt;skb)
<a name="l00323"></a>00323         dev_kfree_skb_any(tx_buffer_info-&gt;skb);
<a name="l00324"></a>00324     tx_buffer_info-&gt;skb = NULL;
<a name="l00325"></a>00325     <span class="comment">/* tx_buffer_info must be completely set up in the transmit path */</span>
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00338"></a>00338 u8 ixgbe_dcb_txq_to_tc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u8 reg_idx)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340     <span class="keywordtype">int</span> tc = -1;
<a name="l00341"></a>00341     <span class="keywordtype">int</span> dcb_i = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     <span class="comment">/* if DCB is not enabled the queues have no TC */</span>
<a name="l00344"></a>00344     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l00345"></a>00345         <span class="keywordflow">return</span> tc;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     <span class="comment">/* check valid range */</span>
<a name="l00348"></a>00348     <span class="keywordflow">if</span> (reg_idx &gt;= adapter-&gt;hw.mac.max_tx_queues)
<a name="l00349"></a>00349         <span class="keywordflow">return</span> tc;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l00352"></a>00352     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00353"></a>00353         tc = reg_idx &gt;&gt; 2;
<a name="l00354"></a>00354         <span class="keywordflow">break</span>;
<a name="l00355"></a>00355     <span class="keywordflow">default</span>:
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (dcb_i != 4 &amp;&amp; dcb_i != 8)
<a name="l00357"></a>00357             <span class="keywordflow">break</span>;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359         <span class="comment">/* if VMDq is enabled the lowest order bits determine TC */</span>
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_SRIOV_ENABLED |
<a name="l00361"></a>00361                       IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l00362"></a>00362             tc = reg_idx &amp; (dcb_i - 1);
<a name="l00363"></a>00363             <span class="keywordflow">break</span>;
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="comment">/*</span>
<a name="l00367"></a>00367 <span class="comment">         * Convert the reg_idx into the correct TC. This bitmask</span>
<a name="l00368"></a>00368 <span class="comment">         * targets the last full 32 ring traffic class and assigns</span>
<a name="l00369"></a>00369 <span class="comment">         * it a value of 1. From there the rest of the rings are</span>
<a name="l00370"></a>00370 <span class="comment">         * based on shifting the mask further up to include the</span>
<a name="l00371"></a>00371 <span class="comment">         * reg_idx / 16 and then reg_idx / 8. It assumes dcB_i</span>
<a name="l00372"></a>00372 <span class="comment">         * will only ever be 8 or 4 and that reg_idx will never</span>
<a name="l00373"></a>00373 <span class="comment">         * be greater then 128. The code without the power of 2</span>
<a name="l00374"></a>00374 <span class="comment">         * optimizations would be:</span>
<a name="l00375"></a>00375 <span class="comment">         * (((reg_idx % 32) + 32) * dcb_i) &gt;&gt; (9 - reg_idx / 32)</span>
<a name="l00376"></a>00376 <span class="comment">         */</span>
<a name="l00377"></a>00377         tc = ((reg_idx &amp; 0X1F) + 0x20) * dcb_i;
<a name="l00378"></a>00378         tc &gt;&gt;= 9 - (reg_idx &gt;&gt; 5);
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="keywordflow">return</span> tc;
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_xoff_received(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00387"></a>00387     <span class="keyword">struct </span><a class="code" href="structixgbe__hw__stats.html">ixgbe_hw_stats</a> *hwstats = &amp;adapter-&gt;stats;
<a name="l00388"></a>00388     u32 data = 0;
<a name="l00389"></a>00389     u32 xoff[8] = {0};
<a name="l00390"></a>00390     <span class="keywordtype">int</span> i;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392     <span class="keywordflow">if</span> ((hw-&gt;fc.current_mode == ixgbe_fc_full) ||
<a name="l00393"></a>00393         (hw-&gt;fc.current_mode == ixgbe_fc_rx_pause)) {
<a name="l00394"></a>00394         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00395"></a>00395         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00396"></a>00396             data = IXGBE_READ_REG(hw, IXGBE_LXOFFRXC);
<a name="l00397"></a>00397             <span class="keywordflow">break</span>;
<a name="l00398"></a>00398         <span class="keywordflow">default</span>:
<a name="l00399"></a>00399             data = IXGBE_READ_REG(hw, IXGBE_LXOFFRXCNT);
<a name="l00400"></a>00400         }
<a name="l00401"></a>00401         hwstats-&gt;lxoffrxc += data;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         <span class="comment">/* refill credits (no tx hang) if we received xoff */</span>
<a name="l00404"></a>00404         <span class="keywordflow">if</span> (!data)
<a name="l00405"></a>00405             <span class="keywordflow">return</span>;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l00408"></a>00408             clear_bit(__IXGBE_HANG_CHECK_ARMED,
<a name="l00409"></a>00409                   &amp;adapter-&gt;tx_ring[i]-&gt;state);
<a name="l00410"></a>00410         <span class="keywordflow">return</span>;
<a name="l00411"></a>00411     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(adapter-&gt;dcb_cfg.pfc_mode_enable)) {
<a name="l00412"></a>00412            <span class="keywordflow">return</span>;
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415     <span class="comment">/* update stats for each tc, only valid with PFC enabled */</span>
<a name="l00416"></a>00416     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TX_PACKET_BUFFERS; i++) {
<a name="l00417"></a>00417         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00418"></a>00418         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00419"></a>00419             xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));
<a name="l00420"></a>00420             <span class="keywordflow">break</span>;
<a name="l00421"></a>00421         <span class="keywordflow">default</span>:
<a name="l00422"></a>00422             xoff[i] = IXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(i));
<a name="l00423"></a>00423         }
<a name="l00424"></a>00424         hwstats-&gt;pxoffrxc[i] += xoff[i];
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426     
<a name="l00427"></a>00427     <span class="comment">/* disarm tx queues that have received xoff frames */</span>
<a name="l00428"></a>00428     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l00429"></a>00429         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l00430"></a>00430         u8 tc = ixgbe_dcb_txq_to_tc(adapter, tx_ring-&gt;reg_idx);
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         <span class="keywordflow">if</span> (xoff[tc])
<a name="l00433"></a>00433             clear_bit(__IXGBE_HANG_CHECK_ARMED, &amp;tx_ring-&gt;state);
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="keyword">static</span> u64 ixgbe_get_tx_completed(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l00438"></a>00438 {
<a name="l00439"></a>00439     <span class="keywordflow">return</span> ring-&gt;tx_stats.completed;
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="keyword">static</span> u64 ixgbe_get_tx_pending(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(ring-&gt;netdev);
<a name="l00445"></a>00445     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447     u32 head = IXGBE_READ_REG(hw, IXGBE_TDH(ring-&gt;reg_idx));
<a name="l00448"></a>00448     u32 tail = IXGBE_READ_REG(hw, IXGBE_TDT(ring-&gt;reg_idx));
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <span class="keywordflow">if</span> (head != tail)
<a name="l00451"></a>00451         <span class="keywordflow">return</span> (head &lt; tail) ? tail - head : (tail + ring-&gt;count - head);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="keywordflow">return</span> 0;
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_check_tx_hang(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l00457"></a>00457 {
<a name="l00458"></a>00458     u32 tx_done = ixgbe_get_tx_completed(tx_ring);
<a name="l00459"></a>00459     u32 tx_done_old = tx_ring-&gt;tx_stats.tx_done_old;
<a name="l00460"></a>00460     u32 tx_pending = ixgbe_get_tx_pending(tx_ring);
<a name="l00461"></a>00461     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     clear_check_for_tx_hang(tx_ring);
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     <span class="comment">/*</span>
<a name="l00466"></a>00466 <span class="comment">     * Check for a hung queue, but be thorough. This verifies</span>
<a name="l00467"></a>00467 <span class="comment">     * that a transmit has been completed since the previous</span>
<a name="l00468"></a>00468 <span class="comment">     * check AND there is at least one packet pending. The</span>
<a name="l00469"></a>00469 <span class="comment">     * ARMED bit is set to indicate a potential hang. The</span>
<a name="l00470"></a>00470 <span class="comment">     * bit is cleared if a pause frame is received to remove</span>
<a name="l00471"></a>00471 <span class="comment">     * false hang detection due to PFC or 802.3x frames. By</span>
<a name="l00472"></a>00472 <span class="comment">     * requiring this to fail twice we avoid races with</span>
<a name="l00473"></a>00473 <span class="comment">     * PFC clearing the ARMED bit and conditions where we</span>
<a name="l00474"></a>00474 <span class="comment">     * run the check_tx_hang logic with a transmit completion</span>
<a name="l00475"></a>00475 <span class="comment">     * pending but without time to complete it yet. </span>
<a name="l00476"></a>00476 <span class="comment">     */</span>
<a name="l00477"></a>00477     <span class="keywordflow">if</span> ((tx_done_old == tx_done) &amp;&amp; tx_pending) {
<a name="l00478"></a>00478         <span class="comment">/* make sure it is true for two checks in a row */</span>
<a name="l00479"></a>00479         ret = test_and_set_bit(__IXGBE_HANG_CHECK_ARMED,
<a name="l00480"></a>00480                        &amp;tx_ring-&gt;state);
<a name="l00481"></a>00481     } <span class="keywordflow">else</span> {
<a name="l00482"></a>00482         <span class="comment">/* update completed stats and continue */</span>
<a name="l00483"></a>00483         tx_ring-&gt;tx_stats.tx_done_old = tx_done;
<a name="l00484"></a>00484         <span class="comment">/* reset the countdown */</span>
<a name="l00485"></a>00485         clear_bit(__IXGBE_HANG_CHECK_ARMED, &amp;tx_ring-&gt;state);
<a name="l00486"></a>00486     }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488     <span class="keywordflow">return</span> ret;
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00495"></a>00495 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_tx_timeout(<span class="keyword">struct</span> net_device *netdev)
<a name="l00496"></a>00496 {
<a name="l00497"></a>00497     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499     <span class="comment">/* Do the reset outside of interrupt context */</span>
<a name="l00500"></a>00500     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l00501"></a>00501         adapter-&gt;flags2 |= IXGBE_FLAG2_RESET_REQUESTED;
<a name="l00502"></a>00502         ixgbe_service_event_schedule(adapter);
<a name="l00503"></a>00503     }
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 
<a name="l00512"></a>00512 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_clean_tx_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l00513"></a>00513                   <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, 
<a name="l00514"></a>00514                   <span class="keywordtype">int</span> budget)
<a name="l00515"></a>00515 {
<a name="l00516"></a>00516     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l00517"></a>00517     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer;
<a name="l00518"></a>00518     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a> *tx_desc;
<a name="l00519"></a>00519     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_bytes = 0, total_packets = 0;
<a name="l00520"></a>00520     u16 i = tx_ring-&gt;next_to_clean;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522     tx_buffer = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l00523"></a>00523     tx_desc = IXGBE_TX_DESC_ADV(tx_ring, i);
<a name="l00524"></a>00524 
<a name="l00525"></a>00525     <span class="keywordflow">for</span> (; budget; budget--) {
<a name="l00526"></a>00526         <span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a> *eop_desc = tx_buffer-&gt;next_to_watch;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528         <span class="keywordflow">if</span> (!eop_desc)
<a name="l00529"></a>00529             eop_desc = tx_desc;
<a name="l00530"></a>00530 
<a name="l00531"></a>00531         <span class="keywordflow">if</span> (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(IXGBE_TXD_STAT_DD)))
<a name="l00532"></a>00532             <span class="keywordflow">break</span>;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         rmb();
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         tx_buffer-&gt;time_stamp = 0;
<a name="l00537"></a>00537         tx_buffer-&gt;next_to_watch = NULL;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="keywordflow">while</span> (eop_desc) {
<a name="l00540"></a>00540             ixgbe_unmap_tx_resource(tx_ring, tx_buffer);
<a name="l00541"></a>00541             tx_desc-&gt;wb.status = 0;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543             <span class="keywordflow">if</span> (likely(tx_desc == eop_desc)) {
<a name="l00544"></a>00544                 dev_kfree_skb_any(tx_buffer-&gt;skb);
<a name="l00545"></a>00545                 total_bytes += tx_buffer-&gt;bytecount;
<a name="l00546"></a>00546                 total_packets += tx_buffer-&gt;gso_segs;
<a name="l00547"></a>00547                 tx_buffer-&gt;skb = NULL;
<a name="l00548"></a>00548                 eop_desc = NULL;
<a name="l00549"></a>00549             }
<a name="l00550"></a>00550  
<a name="l00551"></a>00551             tx_buffer++;
<a name="l00552"></a>00552             tx_desc++;
<a name="l00553"></a>00553             i++;
<a name="l00554"></a>00554             <span class="keywordflow">if</span> (i == tx_ring-&gt;count) {
<a name="l00555"></a>00555                 i = 0;
<a name="l00556"></a>00556                 tx_buffer = tx_ring-&gt;tx_buffer_info;
<a name="l00557"></a>00557                 tx_desc = IXGBE_TX_DESC_ADV(tx_ring, 0);
<a name="l00558"></a>00558             }
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         tx_ring-&gt;tx_stats.completed++;
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     tx_ring-&gt;next_to_clean = i;
<a name="l00565"></a>00565     tx_ring-&gt;stats.bytes += total_bytes;
<a name="l00566"></a>00566     tx_ring-&gt;stats.packets += total_packets;
<a name="l00567"></a>00567     q_vector-&gt;total_tx_bytes += total_bytes;
<a name="l00568"></a>00568     q_vector-&gt;total_tx_packets += total_packets;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     <span class="keywordflow">if</span> (check_for_tx_hang(tx_ring) &amp;&amp; ixgbe_check_tx_hang(tx_ring)) {
<a name="l00571"></a>00571         <span class="comment">/* schedule immediate reset if we believe we hung */</span>
<a name="l00572"></a>00572         <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00573"></a>00573         u32 head = IXGBE_READ_REG(hw, IXGBE_TDH(tx_ring-&gt;reg_idx));
<a name="l00574"></a>00574         u32 tail = IXGBE_READ_REG(hw, IXGBE_TDT(tx_ring-&gt;reg_idx));
<a name="l00575"></a>00575         DPRINTK(DRV, ERR, <span class="stringliteral">&quot;Detected Tx Unit Hang\n&quot;</span>
<a name="l00576"></a>00576             <span class="stringliteral">&quot;  Tx Queue             &lt;%d&gt;\n&quot;</span>
<a name="l00577"></a>00577             <span class="stringliteral">&quot;  TDH, TDT             &lt;%x&gt;, &lt;%x&gt;\n&quot;</span>
<a name="l00578"></a>00578             <span class="stringliteral">&quot;  next_to_use          &lt;%x&gt;\n&quot;</span>
<a name="l00579"></a>00579             <span class="stringliteral">&quot;  next_to_clean        &lt;%x&gt;\n&quot;</span>,
<a name="l00580"></a>00580             tx_ring-&gt;queue_index, head, tail,
<a name="l00581"></a>00581             tx_ring-&gt;next_to_use, i);
<a name="l00582"></a>00582         DPRINTK(DRV, ERR, <span class="stringliteral">&quot;tx_buffer_info[next_to_clean]\n&quot;</span>
<a name="l00583"></a>00583             <span class="stringliteral">&quot;  time_stamp           &lt;%lx&gt;\n&quot;</span>
<a name="l00584"></a>00584             <span class="stringliteral">&quot;  jiffies              &lt;%lx&gt;\n&quot;</span>,
<a name="l00585"></a>00585             tx_ring-&gt;tx_buffer_info[i].time_stamp, jiffies);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587         netif_stop_subqueue(tx_ring-&gt;netdev, tx_ring-&gt;queue_index);
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         DPRINTK(PROBE, INFO,
<a name="l00590"></a>00590                 <span class="stringliteral">&quot;tx hang %d detected on queue %d, resetting adapter\n&quot;</span>,
<a name="l00591"></a>00591                 adapter-&gt;tx_timeout_count + 1, tx_ring-&gt;queue_index);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         ixgbe_tx_timeout(tx_ring-&gt;netdev);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         <span class="comment">/* the adapter is about to reset, no point in enabling stuff */</span>
<a name="l00596"></a>00596         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00597"></a>00597     }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <span class="preprocessor">#define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (unlikely(total_packets &amp;&amp; netif_carrier_ok(tx_ring-&gt;netdev) &amp;&amp;
<a name="l00601"></a>00601              (IXGBE_DESC_UNUSED(tx_ring) &gt;= TX_WAKE_THRESHOLD))) {
<a name="l00602"></a>00602         <span class="comment">/* Make sure that anybody stopping the queue after this</span>
<a name="l00603"></a>00603 <span class="comment">         * sees the new next_to_clean.</span>
<a name="l00604"></a>00604 <span class="comment">         */</span>
<a name="l00605"></a>00605         smp_mb();
<a name="l00606"></a>00606 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l00607"></a>00607 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (__netif_subqueue_stopped(tx_ring-&gt;netdev, tx_ring-&gt;queue_index)
<a name="l00608"></a>00608             &amp;&amp; !test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l00609"></a>00609             netif_wake_subqueue(tx_ring-&gt;netdev, tx_ring-&gt;queue_index);
<a name="l00610"></a>00610             ++tx_ring-&gt;tx_stats.restart_queue;
<a name="l00611"></a>00611         }
<a name="l00612"></a>00612 <span class="preprocessor">#else</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (netif_queue_stopped(tx_ring-&gt;netdev) &amp;&amp;
<a name="l00614"></a>00614             !test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l00615"></a>00615             netif_wake_queue(tx_ring-&gt;netdev);
<a name="l00616"></a>00616             ++tx_ring-&gt;tx_stats.restart_queue;
<a name="l00617"></a>00617         }
<a name="l00618"></a>00618 <span class="preprocessor">#endif</span>
<a name="l00619"></a>00619 <span class="preprocessor"></span>    }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     <span class="keywordflow">return</span> budget;
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_rx_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l00625"></a>00625                 <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l00626"></a>00626                 <span class="keywordtype">int</span> cpu)
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00629"></a>00629     u32 rxctrl;
<a name="l00630"></a>00630     u8 reg_idx = rx_ring-&gt;reg_idx;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     rxctrl = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(reg_idx));
<a name="l00633"></a>00633     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00634"></a>00634     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00635"></a>00635         rxctrl &amp;= ~IXGBE_DCA_RXCTRL_CPUID_MASK;
<a name="l00636"></a>00636         rxctrl |= dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu);
<a name="l00637"></a>00637         <span class="keywordflow">break</span>;
<a name="l00638"></a>00638     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00639"></a>00639     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00640"></a>00640         rxctrl &amp;= ~IXGBE_DCA_RXCTRL_CPUID_MASK_82599;
<a name="l00641"></a>00641         rxctrl |= (dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu) &lt;&lt;
<a name="l00642"></a>00642                IXGBE_DCA_RXCTRL_CPUID_SHIFT_82599);
<a name="l00643"></a>00643         <span class="keywordflow">break</span>;
<a name="l00644"></a>00644     <span class="keywordflow">default</span>:
<a name="l00645"></a>00645         <span class="keywordflow">break</span>;
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647     rxctrl |= IXGBE_DCA_RXCTRL_DESC_DCA_EN;
<a name="l00648"></a>00648     rxctrl |= IXGBE_DCA_RXCTRL_HEAD_DCA_EN;
<a name="l00649"></a>00649     <span class="comment">/* just do the header data when in Packet Split mode */</span>
<a name="l00650"></a>00650     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED_DATA) ||
<a name="l00651"></a>00651         ring_is_ps_enabled(rx_ring))
<a name="l00652"></a>00652         rxctrl &amp;= ~IXGBE_DCA_RXCTRL_DATA_DCA_EN;
<a name="l00653"></a>00653     <span class="keywordflow">else</span>
<a name="l00654"></a>00654         rxctrl |= IXGBE_DCA_RXCTRL_DATA_DCA_EN;
<a name="l00655"></a>00655 
<a name="l00656"></a>00656     rxctrl &amp;= ~(IXGBE_DCA_RXCTRL_DESC_RRO_EN);
<a name="l00657"></a>00657     rxctrl &amp;= ~(IXGBE_DCA_RXCTRL_DESC_WRO_EN |
<a name="l00658"></a>00658             IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
<a name="l00659"></a>00659     IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(reg_idx), rxctrl);
<a name="l00660"></a>00660 }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_tx_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l00663"></a>00663                 <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l00664"></a>00664                 <span class="keywordtype">int</span> cpu)
<a name="l00665"></a>00665 {
<a name="l00666"></a>00666     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l00667"></a>00667     u32 txctrl;
<a name="l00668"></a>00668     u8 reg_idx = tx_ring-&gt;reg_idx;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l00671"></a>00671     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l00672"></a>00672         txctrl = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(reg_idx));
<a name="l00673"></a>00673         txctrl &amp;= ~IXGBE_DCA_TXCTRL_CPUID_MASK;
<a name="l00674"></a>00674         txctrl |= dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu);
<a name="l00675"></a>00675         txctrl |= IXGBE_DCA_TXCTRL_DESC_DCA_EN;
<a name="l00676"></a>00676         txctrl &amp;= ~IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
<a name="l00677"></a>00677         IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL(reg_idx), txctrl);
<a name="l00678"></a>00678         <span class="keywordflow">break</span>;
<a name="l00679"></a>00679     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l00680"></a>00680     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l00681"></a>00681         txctrl = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(reg_idx));
<a name="l00682"></a>00682         txctrl &amp;= ~IXGBE_DCA_TXCTRL_CPUID_MASK_82599;
<a name="l00683"></a>00683         txctrl |= (dca3_get_tag(&amp;adapter-&gt;pdev-&gt;dev, cpu) &lt;&lt;
<a name="l00684"></a>00684                IXGBE_DCA_TXCTRL_CPUID_SHIFT_82599);
<a name="l00685"></a>00685         txctrl |= IXGBE_DCA_TXCTRL_DESC_DCA_EN;
<a name="l00686"></a>00686         txctrl &amp;= ~IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
<a name="l00687"></a>00687         IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(reg_idx), txctrl);
<a name="l00688"></a>00688         <span class="keywordflow">break</span>;
<a name="l00689"></a>00689     <span class="keywordflow">default</span>:
<a name="l00690"></a>00690         <span class="keywordflow">break</span>;
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_update_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l00697"></a>00697     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring;
<a name="l00698"></a>00698     <span class="keywordtype">int</span> cpu = get_cpu();
<a name="l00699"></a>00699 
<a name="l00700"></a>00700     <span class="keywordflow">if</span> (q_vector-&gt;cpu == cpu)
<a name="l00701"></a>00701         <span class="keywordflow">goto</span> out_no_update;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     <span class="keywordflow">for</span> (ring = q_vector-&gt;tx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l00704"></a>00704         ixgbe_update_tx_dca(adapter, ring, cpu);
<a name="l00705"></a>00705 
<a name="l00706"></a>00706     <span class="keywordflow">for</span> (ring = q_vector-&gt;rx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l00707"></a>00707         ixgbe_update_rx_dca(adapter, ring, cpu);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709     q_vector-&gt;cpu = cpu;
<a name="l00710"></a>00710 out_no_update:
<a name="l00711"></a>00711     put_cpu();
<a name="l00712"></a>00712 }
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_dca(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l00715"></a>00715 {
<a name="l00716"></a>00716     <span class="keywordtype">int</span> num_q_vectors;
<a name="l00717"></a>00717     <span class="keywordtype">int</span> i;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED))
<a name="l00720"></a>00720         <span class="keywordflow">return</span>;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     <span class="comment">/* always use CB2 mode, difference is masked in the CB driver */</span>
<a name="l00723"></a>00723     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DCA_CTRL, 2);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l00726"></a>00726         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l00727"></a>00727     <span class="keywordflow">else</span>
<a name="l00728"></a>00728         num_q_vectors = 1;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730     <span class="keywordflow">for</span> (i = 0; i &lt; num_q_vectors; i++) {
<a name="l00731"></a>00731         adapter-&gt;q_vector[i]-&gt;cpu = -1;
<a name="l00732"></a>00732         ixgbe_update_dca(adapter-&gt;q_vector[i]);
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734 }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> __ixgbe_notify_dca(<span class="keyword">struct</span> <a class="code" href="structdevice.html">device</a> *dev, <span class="keywordtype">void</span> *data)
<a name="l00738"></a>00738 {
<a name="l00739"></a>00739     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = dev_get_drvdata(dev);
<a name="l00740"></a>00740     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keyword">event</span> = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)data;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED))
<a name="l00743"></a>00743         <span class="keywordflow">return</span> 0;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     <span class="keywordflow">switch</span> (event) {
<a name="l00746"></a>00746     <span class="keywordflow">case</span> DCA_PROVIDER_ADD:
<a name="l00747"></a>00747         <span class="comment">/* if we&#39;re already enabled, don&#39;t do it again */</span>
<a name="l00748"></a>00748         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
<a name="l00749"></a>00749             <span class="keywordflow">break</span>;
<a name="l00750"></a>00750         <span class="keywordflow">if</span> (dca_add_requester(dev) == 0) {
<a name="l00751"></a>00751             adapter-&gt;flags |= IXGBE_FLAG_DCA_ENABLED;
<a name="l00752"></a>00752             ixgbe_setup_dca(adapter);
<a name="l00753"></a>00753             <span class="keywordflow">break</span>;
<a name="l00754"></a>00754         }
<a name="l00755"></a>00755         <span class="comment">/* Fall Through since DCA is disabled. */</span>
<a name="l00756"></a>00756     <span class="keywordflow">case</span> DCA_PROVIDER_REMOVE:
<a name="l00757"></a>00757         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED) {
<a name="l00758"></a>00758             dca_remove_requester(dev);
<a name="l00759"></a>00759             adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCA_ENABLED;
<a name="l00760"></a>00760             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DCA_CTRL, 1);
<a name="l00761"></a>00761         }
<a name="l00762"></a>00762         <span class="keywordflow">break</span>;
<a name="l00763"></a>00763     }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765     <span class="keywordflow">return</span> 0;
<a name="l00766"></a>00766 }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_DCA or CONFIG_DCA_MODULE */</span>
<a name="l00769"></a>00769 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_release_rx_desc(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring, u32 val)
<a name="l00770"></a>00770 {
<a name="l00771"></a>00771     rx_ring-&gt;next_to_use = val;
<a name="l00772"></a>00772     <span class="comment">/*</span>
<a name="l00773"></a>00773 <span class="comment">     * Force memory writes to complete before letting h/w</span>
<a name="l00774"></a>00774 <span class="comment">     * know there are new descriptors to fetch.  (Only</span>
<a name="l00775"></a>00775 <span class="comment">     * applicable for weak-ordered memory model archs,</span>
<a name="l00776"></a>00776 <span class="comment">     * such as IA-64).</span>
<a name="l00777"></a>00777 <span class="comment">     */</span>
<a name="l00778"></a>00778     wmb();
<a name="l00779"></a>00779     writel(val, rx_ring-&gt;tail);
<a name="l00780"></a>00780 }
<a name="l00781"></a>00781 
<a name="l00787"></a>00787 <span class="keywordtype">void</span> ixgbe_alloc_rx_buffers(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring, u16 cleaned_count)
<a name="l00788"></a>00788 {
<a name="l00789"></a>00789     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc;
<a name="l00790"></a>00790     <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *bi;
<a name="l00791"></a>00791     <span class="keyword">struct </span>sk_buff *skb;
<a name="l00792"></a>00792     u16 i = rx_ring-&gt;next_to_use;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794     <span class="comment">/* do nothing if no valid netdev defined */</span>
<a name="l00795"></a>00795     <span class="keywordflow">if</span> (!rx_ring-&gt;netdev)
<a name="l00796"></a>00796         <span class="keywordflow">return</span>;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798     <span class="keywordflow">while</span> (cleaned_count--) {
<a name="l00799"></a>00799         rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
<a name="l00800"></a>00800         bi = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l00801"></a>00801         skb = bi-&gt;skb;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="keywordflow">if</span> (!skb) {
<a name="l00804"></a>00804             skb = netdev_alloc_skb_ip_align(rx_ring-&gt;netdev,
<a name="l00805"></a>00805                                             rx_ring-&gt;rx_buf_len);
<a name="l00806"></a>00806             <span class="keywordflow">if</span> (!skb) {
<a name="l00807"></a>00807                 rx_ring-&gt;rx_stats.alloc_rx_buff_failed++;
<a name="l00808"></a>00808                 <span class="keywordflow">goto</span> no_buffers;
<a name="l00809"></a>00809             }
<a name="l00810"></a>00810             <span class="comment">/* initialize queue mapping */</span>
<a name="l00811"></a>00811             skb_record_rx_queue(skb, rx_ring-&gt;queue_index);
<a name="l00812"></a>00812             bi-&gt;skb = skb;
<a name="l00813"></a>00813         }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815         <span class="keywordflow">if</span> (!bi-&gt;dma) {
<a name="l00816"></a>00816             bi-&gt;dma = dma_map_single(rx_ring-&gt;dev,
<a name="l00817"></a>00817                          skb-&gt;data,
<a name="l00818"></a>00818                          rx_ring-&gt;rx_buf_len,
<a name="l00819"></a>00819                          DMA_FROM_DEVICE);
<a name="l00820"></a>00820             <span class="keywordflow">if</span> (dma_mapping_error(rx_ring-&gt;dev, bi-&gt;dma)) {
<a name="l00821"></a>00821                 rx_ring-&gt;rx_stats.alloc_rx_buff_failed++;
<a name="l00822"></a>00822                 bi-&gt;dma = 0;
<a name="l00823"></a>00823                 <span class="keywordflow">goto</span> no_buffers;
<a name="l00824"></a>00824             }
<a name="l00825"></a>00825         }
<a name="l00826"></a>00826 
<a name="l00827"></a>00827         <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring)) {
<a name="l00828"></a>00828             <span class="keywordflow">if</span> (!bi-&gt;page) {
<a name="l00829"></a>00829                 bi-&gt;page = netdev_alloc_page(rx_ring-&gt;netdev);
<a name="l00830"></a>00830                 <span class="keywordflow">if</span> (!bi-&gt;page) {
<a name="l00831"></a>00831                     rx_ring-&gt;rx_stats.alloc_rx_page_failed++;
<a name="l00832"></a>00832                     <span class="keywordflow">goto</span> no_buffers;
<a name="l00833"></a>00833                 }
<a name="l00834"></a>00834             }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836             <span class="keywordflow">if</span> (!bi-&gt;page_dma) {
<a name="l00837"></a>00837                 <span class="comment">/* use a half page if we&#39;re re-using */</span>
<a name="l00838"></a>00838                 bi-&gt;page_offset ^= PAGE_SIZE / 2;
<a name="l00839"></a>00839                 bi-&gt;page_dma = dma_map_page(rx_ring-&gt;dev,
<a name="l00840"></a>00840                                 bi-&gt;page,
<a name="l00841"></a>00841                                 bi-&gt;page_offset,
<a name="l00842"></a>00842                                 PAGE_SIZE / 2,
<a name="l00843"></a>00843                                 DMA_FROM_DEVICE);
<a name="l00844"></a>00844                 <span class="keywordflow">if</span> (dma_mapping_error(rx_ring-&gt;dev,
<a name="l00845"></a>00845                               bi-&gt;page_dma)) {
<a name="l00846"></a>00846                     rx_ring-&gt;rx_stats.alloc_rx_page_failed++;
<a name="l00847"></a>00847                     bi-&gt;page_dma = 0;
<a name="l00848"></a>00848                     <span class="keywordflow">goto</span> no_buffers;
<a name="l00849"></a>00849                 }
<a name="l00850"></a>00850             }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852             <span class="comment">/* Refresh the desc even if buffer_addrs didn&#39;t change</span>
<a name="l00853"></a>00853 <span class="comment">             * because each write-back erases this info. */</span>
<a name="l00854"></a>00854             rx_desc-&gt;read.pkt_addr = cpu_to_le64(bi-&gt;page_dma);
<a name="l00855"></a>00855             rx_desc-&gt;read.hdr_addr = cpu_to_le64(bi-&gt;dma);
<a name="l00856"></a>00856         } <span class="keywordflow">else</span> {
<a name="l00857"></a>00857             rx_desc-&gt;read.pkt_addr = cpu_to_le64(bi-&gt;dma);
<a name="l00858"></a>00858             rx_desc-&gt;read.hdr_addr = 0;
<a name="l00859"></a>00859         }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861         i++;
<a name="l00862"></a>00862         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l00863"></a>00863             i = 0;
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865 
<a name="l00866"></a>00866 no_buffers:
<a name="l00867"></a>00867     <span class="keywordflow">if</span> (rx_ring-&gt;next_to_use != i)
<a name="l00868"></a>00868         ixgbe_release_rx_desc(rx_ring, i);
<a name="l00869"></a>00869 }
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 <span class="keyword">static</span> <span class="keyword">inline</span> u16 ixgbe_get_hlen(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l00872"></a>00872                  <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc)
<a name="l00873"></a>00873 {
<a name="l00874"></a>00874     __le16 hdr_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.hdr_info;
<a name="l00875"></a>00875     u16 hlen = le16_to_cpu(hdr_info) &amp; IXGBE_RXDADV_HDRBUFLEN_MASK;
<a name="l00876"></a>00876 
<a name="l00877"></a>00877     <span class="comment">/* if we are not packet split we just need to return upper length */</span>
<a name="l00878"></a>00878     <span class="keywordflow">if</span> (!ring_is_ps_enabled(rx_ring))
<a name="l00879"></a>00879         <span class="keywordflow">return</span> le16_to_cpu(rx_desc-&gt;wb.upper.length);
<a name="l00880"></a>00880 
<a name="l00881"></a>00881     <span class="comment">/*</span>
<a name="l00882"></a>00882 <span class="comment">     * HW will not DMA in data larger than the given buffer, even if it</span>
<a name="l00883"></a>00883 <span class="comment">     * parses the (NFS, of course) header to be larger.  In that case, it</span>
<a name="l00884"></a>00884 <span class="comment">     * fills the header buffer and spills the rest into the page.</span>
<a name="l00885"></a>00885 <span class="comment">     */</span>
<a name="l00886"></a>00886     <span class="keywordflow">if</span> (hlen &gt; (IXGBE_RX_HDR_SIZE &lt;&lt; IXGBE_RXDADV_HDRBUFLEN_SHIFT))
<a name="l00887"></a>00887         hlen = IXGBE_RX_HDR_SIZE;
<a name="l00888"></a>00888     <span class="keywordflow">else</span>
<a name="l00889"></a>00889         hlen &gt;&gt;= IXGBE_RXDADV_HDRBUFLEN_SHIFT;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     <span class="keywordflow">return</span> hlen;
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 
<a name="l00902"></a>00902 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>sk_buff *ixgbe_merge_active_tail(<span class="keyword">struct</span> sk_buff *tail)
<a name="l00903"></a>00903 {
<a name="l00904"></a>00904     <span class="keyword">struct </span>sk_buff *head = IXGBE_RSC_CB(tail)-&gt;head;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     <span class="keywordflow">if</span> (!head)
<a name="l00907"></a>00907         <span class="keywordflow">return</span> tail;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     IXGBE_RSC_CB(tail)-&gt;head = NULL;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911     <span class="keywordflow">if</span> (head-&gt;prev)
<a name="l00912"></a>00912         head-&gt;prev-&gt;next = tail;
<a name="l00913"></a>00913     <span class="keywordflow">else</span>
<a name="l00914"></a>00914         skb_shinfo(head)-&gt;frag_list = tail;
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     head-&gt;len += tail-&gt;len;
<a name="l00917"></a>00917     head-&gt;data_len += tail-&gt;len;
<a name="l00918"></a>00918     head-&gt;truesize += tail-&gt;len;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     head-&gt;prev = tail;
<a name="l00921"></a>00921     IXGBE_RSC_CB(head)-&gt;append_cnt++;
<a name="l00922"></a>00922 
<a name="l00923"></a>00923     <span class="keywordflow">return</span> head;
<a name="l00924"></a>00924 }
<a name="l00925"></a>00925 
<a name="l00933"></a>00933 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_close_active_frag_list(<span class="keyword">struct</span> sk_buff *head)
<a name="l00934"></a>00934 {
<a name="l00935"></a>00935     <span class="keywordflow">if</span> (head-&gt;prev) {
<a name="l00936"></a>00936         head-&gt;prev = NULL;
<a name="l00937"></a>00937         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00940"></a>00940 }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l00943"></a>00943 <span class="preprocessor"></span>
<a name="l00950"></a>00950 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_rx_is_fcoe(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l00951"></a>00951                     <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc)
<a name="l00952"></a>00952 {
<a name="l00953"></a>00953     __le16 pkt_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.pkt_info;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     <span class="keywordflow">return</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) &amp;&amp;
<a name="l00956"></a>00956            (pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_ETQF_MASK)) &amp;&amp;
<a name="l00957"></a>00957            ((pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_ETQF_MASK)) ==
<a name="l00958"></a>00958         (cpu_to_le16(IXGBE_ETQF_FILTER_FCOE &lt;&lt;
<a name="l00959"></a>00959                  IXGBE_RXDADV_PKTTYPE_ETQF_SHIFT)));
<a name="l00960"></a>00960 }
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l00963"></a>00963 
<a name="l00969"></a>00969 <span class="keyword">static</span>
<a name="l00970"></a>00970 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span><span class="keywordtype">int</span>
<a name="l00972"></a>00972 <span class="preprocessor">#else</span>
<a name="l00973"></a>00973 <span class="preprocessor"></span><span class="keywordtype">void</span> 
<a name="l00974"></a>00974 <span class="preprocessor">#endif</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>ixgbe_receive_skb(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l00976"></a>00976           <span class="keyword">struct</span> sk_buff *skb, u16 <a class="code" href="structvlan__tag.html">vlan_tag</a>)
<a name="l00977"></a>00977 {
<a name="l00978"></a>00978     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l00979"></a>00979     <span class="keywordtype">int</span> ret = NET_RX_SUCCESS;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981 <span class="preprocessor">#ifdef CPACKET_TIMESTAMPS</span>
<a name="l00982"></a>00982 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(cpacket_ts_enable) {
<a name="l00983"></a>00983       <span class="keyword">struct </span><a class="code" href="structcpacket__ts.html">cpacket_ts</a> ts;
<a name="l00984"></a>00984       <span class="comment">/* </span>
<a name="l00985"></a>00985 <span class="comment">         4 bytes CRC</span>
<a name="l00986"></a>00986 <span class="comment">         4 bytes Epoch</span>
<a name="l00987"></a>00987 <span class="comment">         4 bytes ns</span>
<a name="l00988"></a>00988 <span class="comment">         4 bytes [ignore]</span>
<a name="l00989"></a>00989 <span class="comment">      */</span>
<a name="l00990"></a>00990       
<a name="l00991"></a>00991       skb-&gt;len -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structcpacket__ts.html">cpacket_ts</a>); <span class="comment">/* Shorten packet */</span>
<a name="l00992"></a>00992       memcpy(&amp;ts, &amp;skb-&gt;data[skb-&gt;len], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcpacket__ts.html">cpacket_ts</a>));
<a name="l00993"></a>00993       
<a name="l00994"></a>00994       <span class="keywordflow">if</span>(ts.epoch &gt; 0) {
<a name="l00995"></a>00995         <span class="keyword">struct </span>skb_shared_hwtstamps *skb_hwts = skb_hwtstamps(skb);
<a name="l00996"></a>00996         
<a name="l00997"></a>00997         ts.epoch = ntohl(ts.epoch), ts.ns = ntohl(ts.ns);      
<a name="l00998"></a>00998         skb_hwts-&gt;hwtstamp = ktime_set((<span class="keyword">const</span> <span class="keywordtype">long</span>)ts.epoch, (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)ts.ns);
<a name="l00999"></a>00999         skb_hwts-&gt;syststamp.tv64 = 0;
<a name="l01000"></a>01000         skb-&gt;tstamp.tv64 = skb_hwts-&gt;hwtstamp.tv64; <span class="comment">/* Set precise TS in packet */</span>
<a name="l01001"></a>01001 
<a name="l01002"></a>01002         <span class="comment">/* printk(KERN_INFO &quot;[CPACKET] %u.%u\n&quot;, ts.epoch, ts.ns); */</span>
<a name="l01003"></a>01003       }
<a name="l01004"></a>01004     }
<a name="l01005"></a>01005 <span class="preprocessor">#endif</span>
<a name="l01006"></a>01006 <span class="preprocessor"></span>
<a name="l01007"></a>01007 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l01008"></a>01008 <span class="preprocessor"></span>    {
<a name="l01009"></a>01009       <span class="keywordtype">int</span> debug = 0;
<a name="l01010"></a>01010       <span class="keyword">struct </span>pfring_hooks *hook = (<span class="keyword">struct </span>pfring_hooks*)skb-&gt;dev-&gt;pfring_ptr;
<a name="l01011"></a>01011       
<a name="l01012"></a>01012       <span class="keywordflow">if</span>(hook &amp;&amp; (hook-&gt;magic == PF_RING)) {
<a name="l01013"></a>01013         <span class="comment">/* Wow: PF_RING is alive &amp; kickin&#39; ! */</span>
<a name="l01014"></a>01014         <span class="keywordtype">int</span> rc;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016         <span class="keywordflow">if</span>(debug) 
<a name="l01017"></a>01017           printk(KERN_INFO <span class="stringliteral">&quot;[PF_RING] alive [%s][len=%d]\n&quot;</span>, skb-&gt;dev-&gt;name, skb-&gt;len);
<a name="l01018"></a>01018 
<a name="l01019"></a>01019         <span class="keywordflow">if</span>(*hook-&gt;transparent_mode != standard_linux_path) {
<a name="l01020"></a>01020           rc = hook-&gt;ring_handler(skb, 1, 1, skb_get_rx_queue(skb), adapter-&gt;num_rx_queues);
<a name="l01021"></a>01021           
<a name="l01022"></a>01022           <span class="keywordflow">if</span>(rc &gt; 0 <span class="comment">/* Packet handled by PF_RING */</span>) {
<a name="l01023"></a>01023         <span class="keywordflow">if</span>(*hook-&gt;transparent_mode == driver2pf_ring_non_transparent) {
<a name="l01024"></a>01024           <span class="comment">/* PF_RING has already freed the memory */</span>
<a name="l01025"></a>01025           <span class="keywordflow">return</span>(rc);
<a name="l01026"></a>01026         }
<a name="l01027"></a>01027           }
<a name="l01028"></a>01028         } <span class="keywordflow">else</span> {
<a name="l01029"></a>01029           <span class="keywordflow">if</span>(debug) printk(KERN_INFO <span class="stringliteral">&quot;[PF_RING] not present on %s\n&quot;</span>, skb-&gt;dev-&gt;name);
<a name="l01030"></a>01030         }
<a name="l01031"></a>01031       }
<a name="l01032"></a>01032     }
<a name="l01033"></a>01033 <span class="preprocessor">#endif</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span>
<a name="l01035"></a>01035 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l01036"></a>01036 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_IN_NETPOLL)) {
<a name="l01037"></a>01037 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (vlan_tag &amp; VLAN_VID_MASK) {
<a name="l01039"></a>01039                 <span class="keywordflow">if</span> (adapter-&gt;vlgrp)
<a name="l01040"></a>01040                     vlan_gro_receive(&amp;q_vector-&gt;napi,
<a name="l01041"></a>01041                              adapter-&gt;vlgrp,
<a name="l01042"></a>01042                                      vlan_tag, skb);
<a name="l01043"></a>01043                 <span class="keywordflow">else</span>
<a name="l01044"></a>01044                     dev_kfree_skb_any(skb);
<a name="l01045"></a>01045             } <span class="keywordflow">else</span> {
<a name="l01046"></a>01046                 napi_gro_receive(&amp;q_vector-&gt;napi, skb);
<a name="l01047"></a>01047             }
<a name="l01048"></a>01048 <span class="preprocessor">#else</span>
<a name="l01049"></a>01049 <span class="preprocessor"></span>            napi_gro_receive(&amp;q_vector-&gt;napi, skb);
<a name="l01050"></a>01050 <span class="preprocessor">#endif</span>
<a name="l01051"></a>01051 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l01052"></a>01052 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l01053"></a>01053 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l01054"></a>01054 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (vlan_tag &amp; VLAN_VID_MASK) {
<a name="l01055"></a>01055                 <span class="keywordflow">if</span> (adapter-&gt;vlgrp)
<a name="l01056"></a>01056                     ret = vlan_hwaccel_rx(skb,
<a name="l01057"></a>01057                                           adapter-&gt;vlgrp,
<a name="l01058"></a>01058                                           vlan_tag);
<a name="l01059"></a>01059                 <span class="keywordflow">else</span>
<a name="l01060"></a>01060                     dev_kfree_skb_any(skb);
<a name="l01061"></a>01061             } <span class="keywordflow">else</span> {
<a name="l01062"></a>01062                 ret = netif_rx(skb);
<a name="l01063"></a>01063             }
<a name="l01064"></a>01064 <span class="preprocessor">#else</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>            ret = netif_rx(skb);
<a name="l01066"></a>01066 <span class="preprocessor">#endif</span>
<a name="l01067"></a>01067 <span class="preprocessor"></span><span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l01068"></a>01068 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (ret == NET_RX_DROP)
<a name="l01069"></a>01069                 adapter-&gt;rx_dropped_backlog++;
<a name="l01070"></a>01070 <span class="preprocessor">#endif</span>
<a name="l01071"></a>01071 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l01072"></a>01072 <span class="preprocessor"></span>        }
<a name="l01073"></a>01073 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span> <span class="keywordflow">return</span>(0);
<a name="l01077"></a>01077 <span class="preprocessor">#endif</span>
<a name="l01078"></a>01078 <span class="preprocessor"></span>}
<a name="l01079"></a>01079 
<a name="l01087"></a>01087 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_rx_checksum(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l01088"></a>01088                                      <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc,
<a name="l01089"></a>01089                                      <span class="keyword">struct</span> sk_buff *skb,
<a name="l01090"></a>01090                      u32 status_err)
<a name="l01091"></a>01091 {
<a name="l01092"></a>01092     skb-&gt;ip_summed = CHECKSUM_NONE;
<a name="l01093"></a>01093 
<a name="l01094"></a>01094     <span class="comment">/* Rx csum disabled */</span>
<a name="l01095"></a>01095     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_RX_CSUM_ENABLED))
<a name="l01096"></a>01096         <span class="keywordflow">return</span>;
<a name="l01097"></a>01097 
<a name="l01098"></a>01098     <span class="comment">/* if IP and error */</span>
<a name="l01099"></a>01099     <span class="keywordflow">if</span> ((status_err &amp; IXGBE_RXD_STAT_IPCS) &amp;&amp;
<a name="l01100"></a>01100         (status_err &amp; IXGBE_RXDADV_ERR_IPE)) {
<a name="l01101"></a>01101         adapter-&gt;hw_csum_rx_error++;
<a name="l01102"></a>01102         <span class="keywordflow">return</span>;
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105     <span class="keywordflow">if</span> (!(status_err &amp; IXGBE_RXD_STAT_L4CS))
<a name="l01106"></a>01106         <span class="keywordflow">return</span>;
<a name="l01107"></a>01107 
<a name="l01108"></a>01108     <span class="keywordflow">if</span> (status_err &amp; IXGBE_RXDADV_ERR_TCPE) {
<a name="l01109"></a>01109         __le16 pkt_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.pkt_info;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111         <span class="comment">/*</span>
<a name="l01112"></a>01112 <span class="comment">         * 82599 errata, UDP frames with a 0 checksum can be marked as</span>
<a name="l01113"></a>01113 <span class="comment">         * checksum errors.</span>
<a name="l01114"></a>01114 <span class="comment">         */</span>
<a name="l01115"></a>01115         <span class="keywordflow">if</span> ((pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_UDP)) &amp;&amp;
<a name="l01116"></a>01116             (adapter-&gt;hw.mac.type == ixgbe_mac_82599EB))
<a name="l01117"></a>01117             <span class="keywordflow">return</span>;
<a name="l01118"></a>01118 
<a name="l01119"></a>01119         adapter-&gt;hw_csum_rx_error++;
<a name="l01120"></a>01120         <span class="keywordflow">return</span>;
<a name="l01121"></a>01121     }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123     <span class="comment">/* It must be a TCP or UDP packet with a valid checksum */</span>
<a name="l01124"></a>01124     skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l01128"></a>01128 <span class="preprocessor"></span>
<a name="l01135"></a>01135 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_can_lro(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01136"></a>01136                  <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc,
<a name="l01137"></a>01137                  <span class="keyword">struct</span> sk_buff *skb)
<a name="l01138"></a>01138 {
<a name="l01139"></a>01139     __le16 pkt_info = rx_desc-&gt;wb.lower.lo_dword.hs_rss.pkt_info;
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     <span class="keywordflow">return</span> (ring_is_lro_enabled(rx_ring) &amp;&amp;
<a name="l01142"></a>01142         (skb-&gt;protocol == __constant_htons(ETH_P_IP)) &amp;&amp;
<a name="l01143"></a>01143         !(rx_ring-&gt;netdev-&gt;flags &amp; IFF_PROMISC) &amp;&amp;
<a name="l01144"></a>01144         (pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_IPV4)) &amp;&amp;
<a name="l01145"></a>01145         (pkt_info &amp; cpu_to_le16(IXGBE_RXDADV_PKTTYPE_TCP)));
<a name="l01146"></a>01146 }
<a name="l01147"></a>01147 
<a name="l01154"></a>01154 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_flush(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01155"></a>01155                                  <span class="keyword">struct</span> <a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod)
<a name="l01156"></a>01156 {
<a name="l01157"></a>01157     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist = q_vector-&gt;lrolist;
<a name="l01158"></a>01158     <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph;
<a name="l01159"></a>01159     <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *th;
<a name="l01160"></a>01160     <span class="keyword">struct </span>sk_buff *skb;
<a name="l01161"></a>01161     __be32 *ts_ptr;
<a name="l01162"></a>01162 
<a name="l01163"></a>01163     hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01164"></a>01164     lrolist-&gt;active_cnt--;
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     skb = lrod-&gt;skb;
<a name="l01167"></a>01167     lrod-&gt;skb = NULL;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169     <span class="keywordflow">if</span> (lrod-&gt;append_cnt) {
<a name="l01170"></a>01170         <span class="comment">/* merge last skb in chain and adjust pointers */</span>
<a name="l01171"></a>01171         skb = ixgbe_merge_active_tail(skb);
<a name="l01172"></a>01172         ixgbe_close_active_frag_list(skb);
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         <span class="comment">/* incorporate ip header and re-calculate checksum */</span>
<a name="l01175"></a>01175         iph = (<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *)skb-&gt;data;
<a name="l01176"></a>01176         iph-&gt;tot_len = htons(skb-&gt;len);
<a name="l01177"></a>01177         iph-&gt;check = 0;
<a name="l01178"></a>01178         iph-&gt;check = ip_fast_csum((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)iph, iph-&gt;ihl);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         <span class="comment">/* incorporate the push flag into the tcp header */</span>
<a name="l01181"></a>01181         th = (<span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *) ((<span class="keywordtype">char</span> *)skb-&gt;data + <span class="keyword">sizeof</span>(*iph));
<a name="l01182"></a>01182         th-&gt;psh = lrod-&gt;psh;
<a name="l01183"></a>01183         th-&gt;check = 0;
<a name="l01184"></a>01184 
<a name="l01185"></a>01185         <span class="comment">/* incorporate latest timestamp into the tcp header */</span>
<a name="l01186"></a>01186         <span class="keywordflow">if</span> (lrod-&gt;opt_bytes) {
<a name="l01187"></a>01187             ts_ptr = (__be32 *)(th + 1);
<a name="l01188"></a>01188             ts_ptr[1] = htonl(lrod-&gt;tsval);
<a name="l01189"></a>01189             ts_ptr[2] = lrod-&gt;tsecr;
<a name="l01190"></a>01190         }
<a name="l01191"></a>01191     }
<a name="l01192"></a>01192 
<a name="l01193"></a>01193 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l01194"></a>01194 <span class="preprocessor"></span>    skb_shinfo(skb)-&gt;gso_size = lrod-&gt;mss;
<a name="l01195"></a>01195 <span class="preprocessor">#endif</span>
<a name="l01196"></a>01196 <span class="preprocessor"></span>    ixgbe_receive_skb(q_vector, skb, lrod-&gt;vlan_tag);
<a name="l01197"></a>01197     lrolist-&gt;stats.flushed++;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199     hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;free);
<a name="l01200"></a>01200 }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_flush_all(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l01203"></a>01203 {
<a name="l01204"></a>01204     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01205"></a>01205     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l01206"></a>01206     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist = q_vector-&gt;lrolist;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;active, lro_node)
<a name="l01209"></a>01209         ixgbe_lro_flush(q_vector, lrod);
<a name="l01210"></a>01210 }
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 <span class="comment">/*</span>
<a name="l01213"></a>01213 <span class="comment"> * ixgbe_lro_header_ok - Main LRO function.</span>
<a name="l01214"></a>01214 <span class="comment"> **/</span>
<a name="l01215"></a>01215 static u16 ixgbe_lro_header_ok(struct sk_buff *new_skb, struct <a class="code" href="structiphdr.html">iphdr</a> *iph,
<a name="l01216"></a>01216                                struct <a class="code" href="structtcphdr.html">tcphdr</a> *th)
<a name="l01217"></a>01217 {
<a name="l01218"></a>01218     <span class="keywordtype">int</span> opt_bytes, tcp_data_len;
<a name="l01219"></a>01219     __be32 *ts_ptr = NULL;
<a name="l01220"></a>01220 
<a name="l01221"></a>01221     <span class="comment">/* If we see CE codepoint in IP header, packet is not mergeable */</span>
<a name="l01222"></a>01222     <span class="keywordflow">if</span> (INET_ECN_is_ce(ipv4_get_dsfield(iph)))
<a name="l01223"></a>01223         <span class="keywordflow">return</span> -1;
<a name="l01224"></a>01224 
<a name="l01225"></a>01225     <span class="comment">/* ensure there are no options */</span>
<a name="l01226"></a>01226     <span class="keywordflow">if</span> ((iph-&gt;ihl &lt;&lt; 2) != <span class="keyword">sizeof</span>(*iph))
<a name="l01227"></a>01227         <span class="keywordflow">return</span> -1;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="comment">/* verify protocol is TCP */</span>
<a name="l01230"></a>01230     <span class="keywordflow">if</span> (iph-&gt;protocol != IPPROTO_TCP)
<a name="l01231"></a>01231         <span class="keywordflow">return</span> -1;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233     <span class="comment">/* .. and the packet is not fragmented */</span>
<a name="l01234"></a>01234     <span class="keywordflow">if</span> (iph-&gt;frag_off &amp; __constant_htons(IP_MF|IP_OFFSET))
<a name="l01235"></a>01235         <span class="keywordflow">return</span> -1;
<a name="l01236"></a>01236 
<a name="l01237"></a>01237     <span class="comment">/* ensure no bits set besides ack or psh */</span>
<a name="l01238"></a>01238     <span class="keywordflow">if</span> (th-&gt;fin || th-&gt;syn || th-&gt;rst ||
<a name="l01239"></a>01239         th-&gt;urg || th-&gt;ece || th-&gt;cwr || !th-&gt;ack)
<a name="l01240"></a>01240         <span class="keywordflow">return</span> -1;
<a name="l01241"></a>01241 
<a name="l01242"></a>01242     <span class="comment">/* ensure that the checksum is valid */</span>
<a name="l01243"></a>01243     <span class="keywordflow">if</span> (new_skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)
<a name="l01244"></a>01244         <span class="keywordflow">return</span> -1;
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     <span class="comment">/*</span>
<a name="l01247"></a>01247 <span class="comment">     * check for timestamps. Since the only option we handle are timestamps,</span>
<a name="l01248"></a>01248 <span class="comment">     * we only have to handle the simple case of aligned timestamps</span>
<a name="l01249"></a>01249 <span class="comment">     */</span>
<a name="l01250"></a>01250 
<a name="l01251"></a>01251     opt_bytes = (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*th);
<a name="l01252"></a>01252     <span class="keywordflow">if</span> (opt_bytes != 0) {
<a name="l01253"></a>01253         ts_ptr = (__be32 *)(th + 1);
<a name="l01254"></a>01254         <span class="keywordflow">if</span> ((opt_bytes != TCPOLEN_TSTAMP_ALIGNED) ||
<a name="l01255"></a>01255             (*ts_ptr != htonl((TCPOPT_NOP &lt;&lt; 24) |
<a name="l01256"></a>01256             (TCPOPT_NOP &lt;&lt; 16) | (TCPOPT_TIMESTAMP &lt;&lt; 8) |
<a name="l01257"></a>01257             TCPOLEN_TIMESTAMP))) {
<a name="l01258"></a>01258             <span class="keywordflow">return</span> -1;
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     tcp_data_len = ntohs(iph-&gt;tot_len) - (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*iph);
<a name="l01263"></a>01263 
<a name="l01264"></a>01264     <span class="keywordflow">return</span> tcp_data_len;
<a name="l01265"></a>01265 }
<a name="l01266"></a>01266 
<a name="l01277"></a>01277 <span class="keyword">static</span> <span class="keyword">struct </span>sk_buff *ixgbe_lro_queue(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01278"></a>01278                                        <span class="keyword">struct</span> sk_buff *new_skb,
<a name="l01279"></a>01279                        u16 tag)
<a name="l01280"></a>01280 {
<a name="l01281"></a>01281     <span class="keyword">struct </span>sk_buff *lro_skb;
<a name="l01282"></a>01282     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01283"></a>01283     <span class="keyword">struct </span>hlist_node *node;
<a name="l01284"></a>01284     <span class="keyword">struct </span>skb_shared_info *new_skb_info = skb_shinfo(new_skb);
<a name="l01285"></a>01285     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist = q_vector-&gt;lrolist;
<a name="l01286"></a>01286     <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = (<span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *)new_skb-&gt;data;
<a name="l01287"></a>01287     <span class="keyword">struct</span> <a class="code" href="structtcphdr.html">tcphdr</a> *th = (<span class="keyword">struct</span> <a class="code" href="structtcphdr.html">tcphdr</a> *)(iph + 1);
<a name="l01288"></a>01288     <span class="keywordtype">int</span> tcp_data_len = ixgbe_lro_header_ok(new_skb, iph, th);
<a name="l01289"></a>01289     u16  opt_bytes = (th-&gt;doff &lt;&lt; 2) - <span class="keyword">sizeof</span>(*th);
<a name="l01290"></a>01290     __be32 *ts_ptr = (opt_bytes ? (__be32 *)(th + 1) : NULL);
<a name="l01291"></a>01291     u32 seq = ntohl(th-&gt;seq);
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     <span class="comment">/*</span>
<a name="l01294"></a>01294 <span class="comment">     * we have a packet that might be eligible for LRO,</span>
<a name="l01295"></a>01295 <span class="comment">     * so see if it matches anything we might expect</span>
<a name="l01296"></a>01296 <span class="comment">     */</span>
<a name="l01297"></a>01297     hlist_for_each_entry(lrod, node, &amp;lrolist-&gt;active, lro_node) {
<a name="l01298"></a>01298         <span class="keywordflow">if</span> (lrod-&gt;source_port != th-&gt;source ||
<a name="l01299"></a>01299             lrod-&gt;dest_port != th-&gt;dest ||
<a name="l01300"></a>01300             lrod-&gt;source_ip != iph-&gt;saddr ||
<a name="l01301"></a>01301             lrod-&gt;dest_ip != iph-&gt;daddr ||
<a name="l01302"></a>01302             lrod-&gt;vlan_tag != tag)
<a name="l01303"></a>01303             <span class="keywordflow">continue</span>;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305         <span class="comment">/*</span>
<a name="l01306"></a>01306 <span class="comment">         * malformed header, no tcp data, resultant packet would</span>
<a name="l01307"></a>01307 <span class="comment">         * be too large, ack sequence numbers do not match, window</span>
<a name="l01308"></a>01308 <span class="comment">         * size has changed, or new skb is larger than our current mss.</span>
<a name="l01309"></a>01309 <span class="comment">         * If any of the above we should flush the lro descriptor and</span>
<a name="l01310"></a>01310 <span class="comment">         * start over if possible</span>
<a name="l01311"></a>01311 <span class="comment">         */</span>
<a name="l01312"></a>01312         <span class="keywordflow">if</span> (tcp_data_len &lt;= 0 || (tcp_data_len + lrod-&gt;len) &gt; 65521 ||
<a name="l01313"></a>01313             lrod-&gt;ack_seq != th-&gt;ack_seq ||
<a name="l01314"></a>01314             lrod-&gt;window != th-&gt;window ||
<a name="l01315"></a>01315             lrod-&gt;mss &lt; tcp_data_len) {
<a name="l01316"></a>01316             ixgbe_lro_flush(q_vector, lrod);
<a name="l01317"></a>01317             <span class="keywordflow">break</span>;
<a name="l01318"></a>01318         }
<a name="l01319"></a>01319 
<a name="l01320"></a>01320         <span class="comment">/* out of order packet */</span>
<a name="l01321"></a>01321         <span class="keywordflow">if</span> (seq != lrod-&gt;next_seq) {
<a name="l01322"></a>01322             ixgbe_lro_flush(q_vector, lrod);
<a name="l01323"></a>01323             tcp_data_len = -1;
<a name="l01324"></a>01324             <span class="keywordflow">break</span>;
<a name="l01325"></a>01325         }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327         <span class="comment">/* packet without timestamp, or timestamp suddenly added to flow */</span>
<a name="l01328"></a>01328         <span class="keywordflow">if</span> (lrod-&gt;opt_bytes != opt_bytes) {
<a name="l01329"></a>01329             ixgbe_lro_flush(q_vector, lrod);
<a name="l01330"></a>01330             <span class="keywordflow">break</span>;
<a name="l01331"></a>01331         }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333         <span class="keywordflow">if</span> (opt_bytes) {
<a name="l01334"></a>01334             u32 tsval = ntohl(*(ts_ptr + 1));
<a name="l01335"></a>01335             <span class="comment">/* make sure timestamp values are increasing */</span>
<a name="l01336"></a>01336             <span class="keywordflow">if</span> (opt_bytes != lrod-&gt;opt_bytes ||
<a name="l01337"></a>01337                 lrod-&gt;tsval &gt; tsval || *(ts_ptr + 2) == 0) {
<a name="l01338"></a>01338                 ixgbe_lro_flush(q_vector, lrod);
<a name="l01339"></a>01339                 tcp_data_len = -1;
<a name="l01340"></a>01340                 <span class="keywordflow">break</span>;
<a name="l01341"></a>01341             }
<a name="l01342"></a>01342 
<a name="l01343"></a>01343             lrod-&gt;tsval = tsval;
<a name="l01344"></a>01344             lrod-&gt;tsecr = *(ts_ptr + 2);
<a name="l01345"></a>01345         }
<a name="l01346"></a>01346 
<a name="l01347"></a>01347         <span class="comment">/* remove any padding from the end of the skb */</span>
<a name="l01348"></a>01348         __pskb_trim(new_skb, ntohs(iph-&gt;tot_len));
<a name="l01349"></a>01349         <span class="comment">/* Remove IP and TCP header*/</span>
<a name="l01350"></a>01350         skb_pull(new_skb, ntohs(iph-&gt;tot_len) - tcp_data_len);
<a name="l01351"></a>01351 
<a name="l01352"></a>01352         lrod-&gt;next_seq += tcp_data_len;
<a name="l01353"></a>01353         lrod-&gt;len += tcp_data_len;
<a name="l01354"></a>01354         lrod-&gt;psh |= th-&gt;psh;
<a name="l01355"></a>01355         lrod-&gt;append_cnt++;
<a name="l01356"></a>01356         lrolist-&gt;stats.coal++;
<a name="l01357"></a>01357         lro_skb = lrod-&gt;skb;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359         <span class="comment">/* if header is empty pull pages into current skb */</span>
<a name="l01360"></a>01360         <span class="keywordflow">if</span> (!skb_headlen(new_skb) &amp;&amp;
<a name="l01361"></a>01361             ((skb_shinfo(lro_skb)-&gt;nr_frags +
<a name="l01362"></a>01362               skb_shinfo(new_skb)-&gt;nr_frags) &lt;= MAX_SKB_FRAGS )) {
<a name="l01363"></a>01363             <span class="keyword">struct </span>skb_shared_info *lro_skb_info = skb_shinfo(lro_skb);
<a name="l01364"></a>01364 
<a name="l01365"></a>01365             <span class="comment">/* copy frags into the last skb */</span>
<a name="l01366"></a>01366             memcpy(lro_skb_info-&gt;frags + lro_skb_info-&gt;nr_frags,
<a name="l01367"></a>01367                    new_skb_info-&gt;frags,
<a name="l01368"></a>01368                    new_skb_info-&gt;nr_frags * <span class="keyword">sizeof</span>(skb_frag_t));
<a name="l01369"></a>01369 
<a name="l01370"></a>01370             lro_skb_info-&gt;nr_frags += new_skb_info-&gt;nr_frags;
<a name="l01371"></a>01371             lro_skb-&gt;len += tcp_data_len;
<a name="l01372"></a>01372             lro_skb-&gt;data_len += tcp_data_len;
<a name="l01373"></a>01373             lro_skb-&gt;truesize += tcp_data_len;
<a name="l01374"></a>01374 
<a name="l01375"></a>01375             new_skb_info-&gt;nr_frags = 0;
<a name="l01376"></a>01376             new_skb-&gt;truesize -= tcp_data_len;
<a name="l01377"></a>01377             new_skb-&gt;len = new_skb-&gt;data_len = 0;
<a name="l01378"></a>01378             new_skb-&gt;data = skb_mac_header(new_skb);
<a name="l01379"></a>01379             __pskb_trim(new_skb, 0);
<a name="l01380"></a>01380             new_skb-&gt;protocol = 0;
<a name="l01381"></a>01381             lrolist-&gt;stats.recycled++;
<a name="l01382"></a>01382         } <span class="keywordflow">else</span> {
<a name="l01383"></a>01383             lro_skb = ixgbe_merge_active_tail(lro_skb);
<a name="l01384"></a>01384             IXGBE_RSC_CB(new_skb)-&gt;head = lro_skb;
<a name="l01385"></a>01385             lrod-&gt;skb = new_skb;
<a name="l01386"></a>01386             new_skb = NULL;
<a name="l01387"></a>01387         }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389         <span class="keywordflow">if</span> (lrod-&gt;psh || (tcp_data_len &lt; lrod-&gt;mss))
<a name="l01390"></a>01390             ixgbe_lro_flush(q_vector, lrod);
<a name="l01391"></a>01391 
<a name="l01392"></a>01392         <span class="keywordflow">return</span> new_skb;
<a name="l01393"></a>01393     }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395     <span class="comment">/* start a new packet */</span>
<a name="l01396"></a>01396     <span class="keywordflow">if</span> (tcp_data_len &gt; 0 &amp;&amp; !hlist_empty(&amp;lrolist-&gt;free) &amp;&amp; !th-&gt;psh) {
<a name="l01397"></a>01397         lrod = hlist_entry(lrolist-&gt;free.first, <span class="keyword">struct</span> <a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a>,
<a name="l01398"></a>01398                            lro_node);
<a name="l01399"></a>01399 
<a name="l01400"></a>01400         lrod-&gt;skb = new_skb;
<a name="l01401"></a>01401         lrod-&gt;source_ip = iph-&gt;saddr;
<a name="l01402"></a>01402         lrod-&gt;dest_ip = iph-&gt;daddr;
<a name="l01403"></a>01403         lrod-&gt;source_port = th-&gt;source;
<a name="l01404"></a>01404         lrod-&gt;dest_port = th-&gt;dest;
<a name="l01405"></a>01405         lrod-&gt;vlan_tag = tag;
<a name="l01406"></a>01406         lrod-&gt;len = new_skb-&gt;len;
<a name="l01407"></a>01407         lrod-&gt;next_seq = seq + tcp_data_len;
<a name="l01408"></a>01408         lrod-&gt;ack_seq = th-&gt;ack_seq;
<a name="l01409"></a>01409         lrod-&gt;window = th-&gt;window;
<a name="l01410"></a>01410         lrod-&gt;mss = tcp_data_len;
<a name="l01411"></a>01411         lrod-&gt;opt_bytes = opt_bytes;
<a name="l01412"></a>01412         lrod-&gt;psh = 0;
<a name="l01413"></a>01413         lrod-&gt;append_cnt = 0;
<a name="l01414"></a>01414 
<a name="l01415"></a>01415         <span class="comment">/* record timestamp if it is present */</span>
<a name="l01416"></a>01416         <span class="keywordflow">if</span> (opt_bytes) {
<a name="l01417"></a>01417             lrod-&gt;tsval = ntohl(*(ts_ptr + 1));
<a name="l01418"></a>01418             lrod-&gt;tsecr = *(ts_ptr + 2);
<a name="l01419"></a>01419         }
<a name="l01420"></a>01420         <span class="comment">/* remove first packet from freelist.. */</span>
<a name="l01421"></a>01421         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01422"></a>01422         <span class="comment">/* .. and insert at the front of the active list */</span>
<a name="l01423"></a>01423         hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;active);
<a name="l01424"></a>01424         lrolist-&gt;active_cnt++;
<a name="l01425"></a>01425         lrolist-&gt;stats.coal++;
<a name="l01426"></a>01426         <span class="keywordflow">return</span> NULL;
<a name="l01427"></a>01427     }
<a name="l01428"></a>01428 
<a name="l01429"></a>01429     <span class="comment">/* packet not handled by any of the above, pass it to the stack */</span>
<a name="l01430"></a>01430     ixgbe_receive_skb(q_vector, new_skb, tag);
<a name="l01431"></a>01431     <span class="keywordflow">return</span> NULL;
<a name="l01432"></a>01432 }
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_ring_exit(<span class="keyword">struct</span> <a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist)
<a name="l01435"></a>01435 {
<a name="l01436"></a>01436     <span class="keyword">struct </span>hlist_node *node, *node2;
<a name="l01437"></a>01437     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01438"></a>01438 
<a name="l01439"></a>01439     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;active,
<a name="l01440"></a>01440                               lro_node) {
<a name="l01441"></a>01441         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01442"></a>01442         kfree(lrod);
<a name="l01443"></a>01443     }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     hlist_for_each_entry_safe(lrod, node, node2, &amp;lrolist-&gt;free,
<a name="l01446"></a>01446                               lro_node) {
<a name="l01447"></a>01447         hlist_del(&amp;lrod-&gt;lro_node);
<a name="l01448"></a>01448         kfree(lrod);
<a name="l01449"></a>01449     }
<a name="l01450"></a>01450 }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_lro_ring_init(<span class="keyword">struct</span> <a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a> *lrolist)
<a name="l01453"></a>01453 {
<a name="l01454"></a>01454     <span class="keywordtype">int</span> j, bytes;
<a name="l01455"></a>01455     <span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a> *lrod;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457     bytes = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__lro__desc.html">ixgbe_lro_desc</a>);
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     INIT_HLIST_HEAD(&amp;lrolist-&gt;free);
<a name="l01460"></a>01460     INIT_HLIST_HEAD(&amp;lrolist-&gt;active);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462     <span class="keywordflow">for</span> (j = 0; j &lt; IXGBE_LRO_MAX; j++) {
<a name="l01463"></a>01463         lrod = kzalloc(bytes, GFP_KERNEL);
<a name="l01464"></a>01464         <span class="keywordflow">if</span> (lrod != NULL) {
<a name="l01465"></a>01465             INIT_HLIST_NODE(&amp;lrod-&gt;lro_node);
<a name="l01466"></a>01466             hlist_add_head(&amp;lrod-&gt;lro_node, &amp;lrolist-&gt;free);
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468     }
<a name="l01469"></a>01469 }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l01472"></a>01472 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_get_rsc_state(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01473"></a>01473                        <span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc)
<a name="l01474"></a>01474 {
<a name="l01475"></a>01475     <span class="keywordflow">return</span> ring_is_rsc_enabled(rx_ring) &amp;&amp;
<a name="l01476"></a>01476            (rx_desc-&gt;wb.lower.lo_dword.data &amp;
<a name="l01477"></a>01477         cpu_to_le32(IXGBE_RXDADV_RSCCNT_MASK));
<a name="l01478"></a>01478 }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_rx_status_indication(u32 staterr,
<a name="l01481"></a>01481                                        <span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01482"></a>01482 {
<a name="l01483"></a>01483     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01484"></a>01484     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01485"></a>01485     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01486"></a>01486         <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_FLM)
<a name="l01487"></a>01487             adapter-&gt;flm++;
<a name="l01488"></a>01488 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l01489"></a>01489 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_DYNINT)
<a name="l01490"></a>01490             adapter-&gt;lli_int++;
<a name="l01491"></a>01491 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LLI */</span>
<a name="l01492"></a>01492         <span class="keywordflow">break</span>;
<a name="l01493"></a>01493     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01494"></a>01494 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l01495"></a>01495 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_DYNINT)
<a name="l01496"></a>01496             adapter-&gt;lli_int++;
<a name="l01497"></a>01497 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LLI */</span>
<a name="l01498"></a>01498         <span class="keywordflow">break</span>;
<a name="l01499"></a>01499     <span class="keywordflow">default</span>:
<a name="l01500"></a>01500         <span class="keywordflow">break</span>;
<a name="l01501"></a>01501     }
<a name="l01502"></a>01502 }
<a name="l01503"></a>01503 
<a name="l01504"></a>01504 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l01505"></a>01505 <span class="preprocessor"></span>
<a name="l01518"></a>01518 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_cleanup_loopback_headers(<span class="keyword">struct</span> sk_buff *skb)
<a name="l01519"></a>01519 {
<a name="l01520"></a>01520     <span class="keywordtype">int</span> pull_len = (skb-&gt;len &lt; 60) ? skb-&gt;len : ETH_HLEN;
<a name="l01521"></a>01521     <span class="keywordtype">int</span> pad_len = 60 - min_t(<span class="keywordtype">int</span>, skb-&gt;len, 60);
<a name="l01522"></a>01522 
<a name="l01523"></a>01523     <span class="comment">/* pull at least Ethernet header length into data */</span>
<a name="l01524"></a>01524     <span class="keywordflow">if</span> (!pskb_may_pull(skb, pull_len)) {
<a name="l01525"></a>01525         dev_kfree_skb_any(skb);
<a name="l01526"></a>01526         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01527"></a>01527     }
<a name="l01528"></a>01528 
<a name="l01529"></a>01529     <span class="comment">/* if skb_pad returns an error the skb was freed */</span>
<a name="l01530"></a>01530     <span class="keywordflow">if</span> (pad_len) {
<a name="l01531"></a>01531         <span class="keywordflow">if</span> (skb_pad(skb, pad_len))
<a name="l01532"></a>01532             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01533"></a>01533         skb_put(skb, pad_len);
<a name="l01534"></a>01534     }
<a name="l01535"></a>01535 
<a name="l01536"></a>01536     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01537"></a>01537 }
<a name="l01538"></a>01538 
<a name="l01539"></a>01539 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PCI_IOV */</span>
<a name="l01540"></a>01540 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_clean_rx_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01541"></a>01541                   <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring,
<a name="l01542"></a>01542                   <span class="keywordtype">int</span> budget)
<a name="l01543"></a>01543 {
<a name="l01544"></a>01544     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l01545"></a>01545     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *rx_desc;
<a name="l01546"></a>01546     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_rx_bytes = 0, total_rx_packets = 0;
<a name="l01547"></a>01547     <span class="keyword">const</span> <span class="keywordtype">int</span> current_node = numa_node_id();
<a name="l01548"></a>01548 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l01549"></a>01549 <span class="preprocessor"></span>    <span class="keywordtype">int</span> ddp_bytes = 0;
<a name="l01550"></a>01550 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l01551"></a>01551     u32 staterr;
<a name="l01552"></a>01552     u16 i = rx_ring-&gt;next_to_clean;
<a name="l01553"></a>01553     u16 cleaned_count = IXGBE_DESC_UNUSED(rx_ring);
<a name="l01554"></a>01554 
<a name="l01555"></a>01555     rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
<a name="l01556"></a>01556     staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558     <span class="keywordflow">while</span> (staterr &amp; IXGBE_RXD_STAT_DD) {
<a name="l01559"></a>01559         <span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a> *next_rxd;
<a name="l01560"></a>01560         <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *rx_buffer_info;
<a name="l01561"></a>01561         <span class="keyword">struct </span>sk_buff *skb;
<a name="l01562"></a>01562         u16 vlan_tag;
<a name="l01563"></a>01563         <span class="keywordtype">bool</span> pkt_is_rsc;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565         rx_buffer_info = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l01566"></a>01566         skb = rx_buffer_info-&gt;skb;
<a name="l01567"></a>01567         prefetch(skb-&gt;data);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569         rx_desc-&gt;wb.upper.status_error = 0;
<a name="l01570"></a>01570         rx_buffer_info-&gt;skb = NULL;
<a name="l01571"></a>01571 
<a name="l01572"></a>01572         <span class="comment">/*</span>
<a name="l01573"></a>01573 <span class="comment">         * This memory barrier is needed to keep us from reading</span>
<a name="l01574"></a>01574 <span class="comment">         * any other fields out of the rx_desc until we know the</span>
<a name="l01575"></a>01575 <span class="comment">         * RXD_STAT_DD bit is set</span>
<a name="l01576"></a>01576 <span class="comment">         */</span>
<a name="l01577"></a>01577         rmb();
<a name="l01578"></a>01578 
<a name="l01579"></a>01579         pkt_is_rsc = ixgbe_get_rsc_state(rx_ring, rx_desc);
<a name="l01580"></a>01580 
<a name="l01581"></a>01581         <span class="comment">/* if this is a skb from previous receive dma will be 0 */</span>
<a name="l01582"></a>01582         <span class="keywordflow">if</span> (rx_buffer_info-&gt;dma) {
<a name="l01583"></a>01583             skb_put(skb, ixgbe_get_hlen(rx_ring, rx_desc));
<a name="l01584"></a>01584             <span class="comment">/*</span>
<a name="l01585"></a>01585 <span class="comment">             * When HWRSC is enabled, delay unmapping of the first</span>
<a name="l01586"></a>01586 <span class="comment">             * packet. It carries the header information, HW may</span>
<a name="l01587"></a>01587 <span class="comment">             * still access the header after the writeback.  Only</span>
<a name="l01588"></a>01588 <span class="comment">             * unmap it when EOP is reached</span>
<a name="l01589"></a>01589 <span class="comment">             */</span>
<a name="l01590"></a>01590             <span class="keywordflow">if</span> (!(staterr &amp; IXGBE_RXD_STAT_EOP) &amp;&amp; pkt_is_rsc &amp;&amp;
<a name="l01591"></a>01591                 !IXGBE_RSC_CB(skb)-&gt;head) {
<a name="l01592"></a>01592                 IXGBE_RSC_CB(skb)-&gt;delay_unmap = <span class="keyword">true</span>;
<a name="l01593"></a>01593                 IXGBE_RSC_CB(skb)-&gt;dma = rx_buffer_info-&gt;dma;
<a name="l01594"></a>01594             } <span class="keywordflow">else</span> {
<a name="l01595"></a>01595                 skb = ixgbe_merge_active_tail(skb);
<a name="l01596"></a>01596                 dma_unmap_single(rx_ring-&gt;dev,
<a name="l01597"></a>01597                          rx_buffer_info-&gt;dma,
<a name="l01598"></a>01598                          rx_ring-&gt;rx_buf_len,
<a name="l01599"></a>01599                          DMA_FROM_DEVICE);
<a name="l01600"></a>01600             }
<a name="l01601"></a>01601             rx_buffer_info-&gt;dma = 0;
<a name="l01602"></a>01602         }
<a name="l01603"></a>01603 
<a name="l01604"></a>01604         <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring) &amp;&amp; rx_desc-&gt;wb.upper.length) {
<a name="l01605"></a>01605             u16 upper_len = le16_to_cpu(rx_desc-&gt;wb.upper.length);
<a name="l01606"></a>01606 
<a name="l01607"></a>01607             skb_fill_page_desc(skb, skb_shinfo(skb)-&gt;nr_frags,
<a name="l01608"></a>01608                        rx_buffer_info-&gt;page,
<a name="l01609"></a>01609                        rx_buffer_info-&gt;page_offset,
<a name="l01610"></a>01610                        upper_len);
<a name="l01611"></a>01611 
<a name="l01612"></a>01612             skb-&gt;len += upper_len;
<a name="l01613"></a>01613             skb-&gt;data_len += upper_len;
<a name="l01614"></a>01614             skb-&gt;truesize += upper_len;
<a name="l01615"></a>01615 
<a name="l01616"></a>01616             <span class="keywordflow">if</span> ((page_count(rx_buffer_info-&gt;page) == 1) &amp;&amp;
<a name="l01617"></a>01617                 (page_to_nid(rx_buffer_info-&gt;page) == current_node))
<a name="l01618"></a>01618                 get_page(rx_buffer_info-&gt;page);
<a name="l01619"></a>01619             <span class="keywordflow">else</span>
<a name="l01620"></a>01620                 rx_buffer_info-&gt;page = NULL;
<a name="l01621"></a>01621 
<a name="l01622"></a>01622             dma_unmap_page(rx_ring-&gt;dev,
<a name="l01623"></a>01623                        rx_buffer_info-&gt;page_dma,
<a name="l01624"></a>01624                            PAGE_SIZE / 2,
<a name="l01625"></a>01625                            DMA_FROM_DEVICE);
<a name="l01626"></a>01626             rx_buffer_info-&gt;page_dma = 0;
<a name="l01627"></a>01627         }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629         i++;
<a name="l01630"></a>01630         <span class="keywordflow">if</span> (i == rx_ring-&gt;count)
<a name="l01631"></a>01631             i = 0;
<a name="l01632"></a>01632 
<a name="l01633"></a>01633         next_rxd = IXGBE_RX_DESC_ADV(rx_ring, i);
<a name="l01634"></a>01634         prefetch(next_rxd);
<a name="l01635"></a>01635 
<a name="l01636"></a>01636         <span class="keywordflow">if</span> (unlikely(!(staterr &amp; IXGBE_RXD_STAT_EOP))) {
<a name="l01637"></a>01637             <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *next_buffer;
<a name="l01638"></a>01638 
<a name="l01639"></a>01639             <span class="keywordflow">if</span> (pkt_is_rsc) {
<a name="l01640"></a>01640                 u32 nextp = staterr &amp; IXGBE_RXDADV_NEXTP_MASK;
<a name="l01641"></a>01641                 nextp &gt;&gt;= IXGBE_RXDADV_NEXTP_SHIFT;
<a name="l01642"></a>01642                 next_buffer = &amp;rx_ring-&gt;rx_buffer_info[nextp];
<a name="l01643"></a>01643             } <span class="keywordflow">else</span> {
<a name="l01644"></a>01644                 next_buffer = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l01645"></a>01645             }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647             <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring)) {
<a name="l01648"></a>01648                 rx_buffer_info-&gt;skb = next_buffer-&gt;skb;
<a name="l01649"></a>01649                 rx_buffer_info-&gt;dma = next_buffer-&gt;dma;
<a name="l01650"></a>01650                 next_buffer-&gt;skb = skb;
<a name="l01651"></a>01651                 next_buffer-&gt;dma = 0;
<a name="l01652"></a>01652             } <span class="keywordflow">else</span> {
<a name="l01653"></a>01653                 IXGBE_RSC_CB(next_buffer-&gt;skb)-&gt;head = skb;
<a name="l01654"></a>01654             }
<a name="l01655"></a>01655             rx_ring-&gt;rx_stats.non_eop_descs++;
<a name="l01656"></a>01656             <span class="keywordflow">goto</span> next_desc;
<a name="l01657"></a>01657         }
<a name="l01658"></a>01658 
<a name="l01659"></a>01659         <span class="keywordflow">if</span> (ixgbe_close_active_frag_list(skb) &amp;&amp; !pkt_is_rsc) {
<a name="l01660"></a>01660             <span class="comment">/* if we got here without RSC the packet is invalid */</span>
<a name="l01661"></a>01661             dev_kfree_skb_any(skb);
<a name="l01662"></a>01662             <span class="keywordflow">goto</span> next_desc;
<a name="l01663"></a>01663         }
<a name="l01664"></a>01664 
<a name="l01665"></a>01665         <span class="keywordflow">if</span> (pkt_is_rsc) {
<a name="l01666"></a>01666             <span class="keywordflow">if</span> (IXGBE_RSC_CB(skb)-&gt;delay_unmap) {
<a name="l01667"></a>01667                 dma_unmap_single(rx_ring-&gt;dev,
<a name="l01668"></a>01668                                  IXGBE_RSC_CB(skb)-&gt;dma,
<a name="l01669"></a>01669                          rx_ring-&gt;rx_buf_len,
<a name="l01670"></a>01670                                  DMA_FROM_DEVICE);
<a name="l01671"></a>01671                 IXGBE_RSC_CB(skb)-&gt;dma = 0;
<a name="l01672"></a>01672                 IXGBE_RSC_CB(skb)-&gt;delay_unmap = <span class="keyword">false</span>;
<a name="l01673"></a>01673             }
<a name="l01674"></a>01674 
<a name="l01675"></a>01675             <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring))
<a name="l01676"></a>01676                 rx_ring-&gt;rx_stats.rsc_count +=
<a name="l01677"></a>01677                     skb_shinfo(skb)-&gt;nr_frags;
<a name="l01678"></a>01678             <span class="keywordflow">else</span>
<a name="l01679"></a>01679                 rx_ring-&gt;rx_stats.rsc_count +=
<a name="l01680"></a>01680                     IXGBE_RSC_CB(skb)-&gt;append_cnt + 1;
<a name="l01681"></a>01681             rx_ring-&gt;rx_stats.rsc_flush++;
<a name="l01682"></a>01682 
<a name="l01683"></a>01683             IXGBE_RSC_CB(skb)-&gt;append_cnt = 0;
<a name="l01684"></a>01684         }
<a name="l01685"></a>01685 
<a name="l01686"></a>01686         <span class="comment">/* ERR_MASK will only have valid bits if EOP set */</span>
<a name="l01687"></a>01687         <span class="keywordflow">if</span> (unlikely(staterr &amp; IXGBE_RXDADV_ERR_FRAME_ERR_MASK)) {
<a name="l01688"></a>01688             dev_kfree_skb_any(skb);
<a name="l01689"></a>01689             <span class="keywordflow">goto</span> next_desc;
<a name="l01690"></a>01690         }
<a name="l01691"></a>01691 
<a name="l01692"></a>01692 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l01693"></a>01693 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (staterr &amp; IXGBE_RXD_STAT_LB) {
<a name="l01694"></a>01694             <span class="keywordflow">if</span> (ixgbe_cleanup_loopback_headers(skb))
<a name="l01695"></a>01695                 <span class="keywordflow">goto</span> next_desc;
<a name="l01696"></a>01696         }
<a name="l01697"></a>01697 
<a name="l01698"></a>01698 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PCI_IOV */</span>
<a name="l01699"></a>01699         ixgbe_rx_status_indication(staterr, adapter);
<a name="l01700"></a>01700         ixgbe_rx_checksum(adapter, rx_desc, skb, staterr);
<a name="l01701"></a>01701 
<a name="l01702"></a>01702 <span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l01703"></a>01703 <span class="preprocessor"></span>        skb_record_rx_queue(skb, rx_ring-&gt;queue_index);
<a name="l01704"></a>01704 <span class="preprocessor">#endif</span>
<a name="l01705"></a>01705 <span class="preprocessor"></span>
<a name="l01706"></a>01706         <span class="comment">/* probably a little skewed due to removing CRC */</span>
<a name="l01707"></a>01707         total_rx_bytes += skb-&gt;len;
<a name="l01708"></a>01708         total_rx_packets++;
<a name="l01709"></a>01709 
<a name="l01710"></a>01710         skb-&gt;protocol = eth_type_trans(skb, rx_ring-&gt;netdev);
<a name="l01711"></a>01711         vlan_tag = ((staterr &amp; IXGBE_RXD_STAT_VP) ?
<a name="l01712"></a>01712                     le16_to_cpu(rx_desc-&gt;wb.upper.vlan) : 0);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l01715"></a>01715 <span class="preprocessor"></span>        <span class="comment">/* if ddp, not passing to ULD unless for FCP_RSP or error */</span>
<a name="l01716"></a>01716         <span class="keywordflow">if</span> (ixgbe_rx_is_fcoe(adapter, rx_desc)) {
<a name="l01717"></a>01717             ddp_bytes = ixgbe_fcoe_ddp(adapter, rx_desc, skb,
<a name="l01718"></a>01718                            staterr);
<a name="l01719"></a>01719             <span class="keywordflow">if</span> (!ddp_bytes) {
<a name="l01720"></a>01720                 dev_kfree_skb_any(skb);
<a name="l01721"></a>01721                 rx_ring-&gt;netdev-&gt;last_rx = jiffies;
<a name="l01722"></a>01722                 <span class="keywordflow">goto</span> next_desc;
<a name="l01723"></a>01723             }
<a name="l01724"></a>01724         }
<a name="l01725"></a>01725 
<a name="l01726"></a>01726 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l01727"></a>01727 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l01728"></a>01728 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ixgbe_can_lro(rx_ring, rx_desc, skb))
<a name="l01729"></a>01729             rx_buffer_info-&gt;skb = ixgbe_lro_queue(q_vector, skb, vlan_tag);
<a name="l01730"></a>01730         <span class="keywordflow">else</span>
<a name="l01731"></a>01731 <span class="preprocessor">#endif</span>
<a name="l01732"></a>01732 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_PF_RING</span>
<a name="l01733"></a>01733 <span class="preprocessor"></span>          {
<a name="l01734"></a>01734             <span class="keywordflow">if</span>(ixgbe_receive_skb(q_vector, skb, vlan_tag) == 2) {
<a name="l01735"></a>01735               <span class="comment">/* Force adapter to stop polling as we have no room for packets */</span>
<a name="l01736"></a>01736               <span class="comment">/* printk(&quot;[PF_RING] Too many packets!\n&quot;); */</span>
<a name="l01737"></a>01737               budget = 1;
<a name="l01738"></a>01738              }
<a name="l01739"></a>01739           }
<a name="l01740"></a>01740 <span class="preprocessor">#else</span>
<a name="l01741"></a>01741 <span class="preprocessor"></span>            ixgbe_receive_skb(q_vector, skb, vlan_tag);
<a name="l01742"></a>01742 <span class="preprocessor">#endif</span>
<a name="l01743"></a>01743 <span class="preprocessor"></span>
<a name="l01744"></a>01744         rx_ring-&gt;netdev-&gt;last_rx = jiffies;
<a name="l01745"></a>01745         budget--;
<a name="l01746"></a>01746 next_desc:
<a name="l01747"></a>01747         <span class="keywordflow">if</span> (!budget)
<a name="l01748"></a>01748             <span class="keywordflow">break</span>;
<a name="l01749"></a>01749 
<a name="l01750"></a>01750         cleaned_count++;
<a name="l01751"></a>01751         <span class="comment">/* return some buffers to hardware, one at a time is too slow */</span>
<a name="l01752"></a>01752         <span class="keywordflow">if</span> (cleaned_count &gt;= IXGBE_RX_BUFFER_WRITE) {
<a name="l01753"></a>01753             ixgbe_alloc_rx_buffers(rx_ring, cleaned_count);
<a name="l01754"></a>01754             cleaned_count = 0;
<a name="l01755"></a>01755         }
<a name="l01756"></a>01756 
<a name="l01757"></a>01757         <span class="comment">/* use prefetched values */</span>
<a name="l01758"></a>01758         rx_desc = next_rxd;
<a name="l01759"></a>01759         staterr = le32_to_cpu(rx_desc-&gt;wb.upper.status_error);
<a name="l01760"></a>01760     }
<a name="l01761"></a>01761 
<a name="l01762"></a>01762 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l01763"></a>01763 <span class="preprocessor"></span>    <span class="comment">/* include DDPed FCoE data */</span>
<a name="l01764"></a>01764     <span class="keywordflow">if</span> (ddp_bytes &gt; 0) {
<a name="l01765"></a>01765         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mss;
<a name="l01766"></a>01766 
<a name="l01767"></a>01767         mss = rx_ring-&gt;netdev-&gt;mtu - <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fcoe_hdr) -
<a name="l01768"></a>01768             sizeof(struct fc_frame_header) -
<a name="l01769"></a>01769             sizeof(struct fcoe_crc_eof);
<a name="l01770"></a>01770         <span class="keywordflow">if</span> (mss &gt; 512)
<a name="l01771"></a>01771             mss &amp;= ~511;
<a name="l01772"></a>01772         total_rx_bytes += ddp_bytes;
<a name="l01773"></a>01773         total_rx_packets += DIV_ROUND_UP(ddp_bytes, mss);
<a name="l01774"></a>01774     }
<a name="l01775"></a>01775 
<a name="l01776"></a>01776 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l01777"></a>01777     rx_ring-&gt;next_to_clean = i;
<a name="l01778"></a>01778     rx_ring-&gt;stats.packets += total_rx_packets;
<a name="l01779"></a>01779     rx_ring-&gt;stats.bytes += total_rx_bytes;
<a name="l01780"></a>01780     q_vector-&gt;total_rx_packets += total_rx_packets;
<a name="l01781"></a>01781     q_vector-&gt;total_rx_bytes += total_rx_bytes;
<a name="l01782"></a>01782 
<a name="l01783"></a>01783     <span class="keywordflow">if</span> (cleaned_count)
<a name="l01784"></a>01784         ixgbe_alloc_rx_buffers(rx_ring, cleaned_count);
<a name="l01785"></a>01785 
<a name="l01786"></a>01786 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l01787"></a>01787 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ring_is_lro_enabled(rx_ring))
<a name="l01788"></a>01788         ixgbe_lro_flush_all(q_vector);
<a name="l01789"></a>01789 
<a name="l01790"></a>01790 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LRO */</span>
<a name="l01791"></a>01791     <span class="keywordflow">return</span> budget;
<a name="l01792"></a>01792 }
<a name="l01793"></a>01793 
<a name="l01801"></a>01801 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_msix(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l01802"></a>01802 {
<a name="l01803"></a>01803     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l01804"></a>01804     <span class="keywordtype">int</span> q_vectors, v_idx;
<a name="l01805"></a>01805     u32 mask;
<a name="l01806"></a>01806 
<a name="l01807"></a>01807     q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l01808"></a>01808 
<a name="l01809"></a>01809     <span class="comment">/*</span>
<a name="l01810"></a>01810 <span class="comment">     * Populate the IVAR table and set the ITR values to the</span>
<a name="l01811"></a>01811 <span class="comment">     * corresponding register.</span>
<a name="l01812"></a>01812 <span class="comment">     */</span>
<a name="l01813"></a>01813     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; q_vectors; v_idx++) {
<a name="l01814"></a>01814         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring;
<a name="l01815"></a>01815         q_vector = adapter-&gt;q_vector[v_idx];
<a name="l01816"></a>01816 
<a name="l01817"></a>01817         <span class="keywordflow">for</span> (ring = q_vector-&gt;rx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l01818"></a>01818             ixgbe_set_ivar(adapter, 0, ring-&gt;reg_idx, v_idx);
<a name="l01819"></a>01819 
<a name="l01820"></a>01820         <span class="keywordflow">for</span> (ring = q_vector-&gt;tx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l01821"></a>01821             ixgbe_set_ivar(adapter, 1, ring-&gt;reg_idx, v_idx);
<a name="l01822"></a>01822 
<a name="l01823"></a>01823         <span class="keywordflow">if</span> (q_vector-&gt;tx_ring &amp;&amp; !q_vector-&gt;rx_ring)
<a name="l01824"></a>01824             <span class="comment">/* tx only vector */</span>
<a name="l01825"></a>01825             q_vector-&gt;eitr = adapter-&gt;tx_eitr_param;
<a name="l01826"></a>01826         <span class="keywordflow">else</span>
<a name="l01827"></a>01827             <span class="comment">/* rx or rx/tx vector */</span>
<a name="l01828"></a>01828             q_vector-&gt;eitr = adapter-&gt;rx_eitr_param;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830         ixgbe_write_eitr(q_vector);
<a name="l01831"></a>01831     }
<a name="l01832"></a>01832 
<a name="l01833"></a>01833     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01834"></a>01834     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01835"></a>01835         ixgbe_set_ivar(adapter, -1, IXGBE_IVAR_OTHER_CAUSES_INDEX,
<a name="l01836"></a>01836                    v_idx);
<a name="l01837"></a>01837         <span class="keywordflow">break</span>;
<a name="l01838"></a>01838     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01839"></a>01839         ixgbe_set_ivar(adapter, -1, 1, v_idx);
<a name="l01840"></a>01840         <span class="keywordflow">break</span>;
<a name="l01841"></a>01841 
<a name="l01842"></a>01842     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01843"></a>01843         ixgbe_set_ivar(adapter, -1, 1, v_idx);
<a name="l01844"></a>01844         <span class="keywordflow">break</span>;
<a name="l01845"></a>01845     <span class="keywordflow">default</span>:
<a name="l01846"></a>01846         <span class="keywordflow">break</span>;
<a name="l01847"></a>01847     }
<a name="l01848"></a>01848     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EITR(v_idx), 1950);
<a name="l01849"></a>01849 
<a name="l01850"></a>01850     <span class="comment">/* set up to autoclear timer, and the vectors */</span>
<a name="l01851"></a>01851     mask = IXGBE_EIMS_ENABLE_MASK;
<a name="l01852"></a>01852     mask &amp;= ~(IXGBE_EIMS_OTHER |
<a name="l01853"></a>01853           IXGBE_EIMS_MAILBOX |
<a name="l01854"></a>01854           IXGBE_EIMS_LSC);
<a name="l01855"></a>01855 
<a name="l01856"></a>01856     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIAC, mask);
<a name="l01857"></a>01857 }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859 <span class="keyword">enum</span> latency_range {
<a name="l01860"></a>01860     lowest_latency = 0,
<a name="l01861"></a>01861     low_latency = 1,
<a name="l01862"></a>01862     bulk_latency = 2,
<a name="l01863"></a>01863     latency_invalid = 255
<a name="l01864"></a>01864 };
<a name="l01865"></a>01865 
<a name="l01884"></a>01884 <span class="keyword">static</span> u8 ixgbe_update_itr(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector,
<a name="l01885"></a>01885                u8 itr_setting, <span class="keywordtype">int</span> packets, <span class="keywordtype">int</span> bytes)
<a name="l01886"></a>01886 {
<a name="l01887"></a>01887     u32 timepassed_us;
<a name="l01888"></a>01888     u64 bytes_perint;
<a name="l01889"></a>01889 
<a name="l01890"></a>01890     <span class="keywordflow">if</span> (packets == 0)
<a name="l01891"></a>01891         <span class="keywordflow">goto</span> update_itr_done;
<a name="l01892"></a>01892 
<a name="l01893"></a>01893 
<a name="l01894"></a>01894     <span class="comment">/* simple throttlerate management</span>
<a name="l01895"></a>01895 <span class="comment">     *   0-10MB/s   lowest (100000 ints/s)</span>
<a name="l01896"></a>01896 <span class="comment">     *  10-20MB/s   low    (20000 ints/s)</span>
<a name="l01897"></a>01897 <span class="comment">     *  20-1249MB/s bulk   (8000 ints/s)</span>
<a name="l01898"></a>01898 <span class="comment">     */</span>
<a name="l01899"></a>01899     <span class="comment">/* what was last interrupt timeslice? */</span>
<a name="l01900"></a>01900     timepassed_us = 1000000/q_vector-&gt;eitr;
<a name="l01901"></a>01901     bytes_perint = bytes / timepassed_us; <span class="comment">/* bytes/usec */</span>
<a name="l01902"></a>01902 
<a name="l01903"></a>01903     <span class="keywordflow">switch</span> (itr_setting) {
<a name="l01904"></a>01904     <span class="keywordflow">case</span> lowest_latency:
<a name="l01905"></a>01905         <span class="keywordflow">if</span> (bytes_perint &gt; 10) {
<a name="l01906"></a>01906             itr_setting = low_latency;
<a name="l01907"></a>01907         }
<a name="l01908"></a>01908         <span class="keywordflow">break</span>;
<a name="l01909"></a>01909     <span class="keywordflow">case</span> low_latency:
<a name="l01910"></a>01910         <span class="keywordflow">if</span> (bytes_perint &lt;= 10) {
<a name="l01911"></a>01911             itr_setting = lowest_latency;
<a name="l01912"></a>01912         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_perint &gt; 20) {
<a name="l01913"></a>01913             itr_setting = bulk_latency;
<a name="l01914"></a>01914         }
<a name="l01915"></a>01915         <span class="keywordflow">break</span>;
<a name="l01916"></a>01916     <span class="keywordflow">case</span> bulk_latency:
<a name="l01917"></a>01917         <span class="keywordflow">if</span> (bytes_perint &lt;= 20) {
<a name="l01918"></a>01918             itr_setting = low_latency;
<a name="l01919"></a>01919         }
<a name="l01920"></a>01920         <span class="keywordflow">break</span>;
<a name="l01921"></a>01921     }
<a name="l01922"></a>01922 
<a name="l01923"></a>01923 update_itr_done:
<a name="l01924"></a>01924     <span class="keywordflow">return</span> itr_setting;
<a name="l01925"></a>01925 }
<a name="l01926"></a>01926 
<a name="l01935"></a>01935 <span class="keywordtype">void</span> ixgbe_write_eitr(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l01936"></a>01936 {
<a name="l01937"></a>01937     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l01938"></a>01938     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l01939"></a>01939     <span class="keywordtype">int</span> v_idx = q_vector-&gt;v_idx;
<a name="l01940"></a>01940     u32 itr_reg = EITR_INTS_PER_SEC_TO_REG(q_vector-&gt;eitr);
<a name="l01941"></a>01941 
<a name="l01942"></a>01942     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l01943"></a>01943     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l01944"></a>01944         <span class="comment">/* must write high and low 16 bits to reset counter */</span>
<a name="l01945"></a>01945         itr_reg |= (itr_reg &lt;&lt; 16);
<a name="l01946"></a>01946         <span class="keywordflow">break</span>;
<a name="l01947"></a>01947     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l01948"></a>01948     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l01949"></a>01949         <span class="comment">/*</span>
<a name="l01950"></a>01950 <span class="comment">         * 82599 can support a value of zero, so allow it for</span>
<a name="l01951"></a>01951 <span class="comment">         * max interrupt rate, but there is an errata where it can</span>
<a name="l01952"></a>01952 <span class="comment">         * not be zero with RSC</span>
<a name="l01953"></a>01953 <span class="comment">         */</span>
<a name="l01954"></a>01954         <span class="keywordflow">if</span> (itr_reg == 8 &amp;&amp;
<a name="l01955"></a>01955             !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED))
<a name="l01956"></a>01956             itr_reg = 0;
<a name="l01957"></a>01957 
<a name="l01958"></a>01958         <span class="comment">/*</span>
<a name="l01959"></a>01959 <span class="comment">         * set the WDIS bit to not clear the timer bits and cause an</span>
<a name="l01960"></a>01960 <span class="comment">         * immediate assertion of the interrupt</span>
<a name="l01961"></a>01961 <span class="comment">         */</span>
<a name="l01962"></a>01962         itr_reg |= IXGBE_EITR_CNT_WDIS;
<a name="l01963"></a>01963         <span class="keywordflow">break</span>;
<a name="l01964"></a>01964     <span class="keywordflow">default</span>:
<a name="l01965"></a>01965         <span class="keywordflow">break</span>;
<a name="l01966"></a>01966     }
<a name="l01967"></a>01967     IXGBE_WRITE_REG(hw, IXGBE_EITR(v_idx), itr_reg);
<a name="l01968"></a>01968 }
<a name="l01969"></a>01969 
<a name="l01970"></a>01970 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_itr(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector)
<a name="l01971"></a>01971 {
<a name="l01972"></a>01972     u32 new_itr = q_vector-&gt;eitr;
<a name="l01973"></a>01973     u8 current_itr;
<a name="l01974"></a>01974 
<a name="l01975"></a>01975     q_vector-&gt;tx_itr = ixgbe_update_itr(q_vector,
<a name="l01976"></a>01976                         q_vector-&gt;tx_itr,
<a name="l01977"></a>01977                         q_vector-&gt;total_tx_packets,
<a name="l01978"></a>01978                         q_vector-&gt;total_tx_bytes);
<a name="l01979"></a>01979     q_vector-&gt;rx_itr = ixgbe_update_itr(q_vector,
<a name="l01980"></a>01980                         q_vector-&gt;rx_itr,
<a name="l01981"></a>01981                         q_vector-&gt;total_rx_packets,
<a name="l01982"></a>01982                         q_vector-&gt;total_rx_bytes);
<a name="l01983"></a>01983 
<a name="l01984"></a>01984     <span class="comment">/* clear work counters since we have the values we need */</span>
<a name="l01985"></a>01985     q_vector-&gt;total_tx_bytes = 0;
<a name="l01986"></a>01986     q_vector-&gt;total_tx_packets = 0;
<a name="l01987"></a>01987     q_vector-&gt;total_rx_bytes = 0;
<a name="l01988"></a>01988     q_vector-&gt;total_rx_packets = 0;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990     current_itr = max(q_vector-&gt;rx_itr, q_vector-&gt;tx_itr);
<a name="l01991"></a>01991 
<a name="l01992"></a>01992     <span class="keywordflow">switch</span> (current_itr) {
<a name="l01993"></a>01993     <span class="comment">/* counts and packets in update_itr are dependent on these numbers */</span>
<a name="l01994"></a>01994     <span class="keywordflow">case</span> lowest_latency:
<a name="l01995"></a>01995         new_itr = 100000;
<a name="l01996"></a>01996         <span class="keywordflow">break</span>;
<a name="l01997"></a>01997     <span class="keywordflow">case</span> low_latency:
<a name="l01998"></a>01998         new_itr = 20000; <span class="comment">/* aka hwitr = ~200 */</span>
<a name="l01999"></a>01999         <span class="keywordflow">break</span>;
<a name="l02000"></a>02000     <span class="keywordflow">case</span> bulk_latency:
<a name="l02001"></a>02001         new_itr = 8000;
<a name="l02002"></a>02002         <span class="keywordflow">break</span>;
<a name="l02003"></a>02003     <span class="keywordflow">default</span>:
<a name="l02004"></a>02004         <span class="keywordflow">break</span>;
<a name="l02005"></a>02005     }
<a name="l02006"></a>02006 
<a name="l02007"></a>02007     <span class="keywordflow">if</span> (new_itr != q_vector-&gt;eitr) {
<a name="l02008"></a>02008         <span class="comment">/* do an exponential smoothing */</span>
<a name="l02009"></a>02009         new_itr = ((q_vector-&gt;eitr * 9) + new_itr)/10;
<a name="l02010"></a>02010 
<a name="l02011"></a>02011         <span class="comment">/* save the algorithm value here */</span>
<a name="l02012"></a>02012         q_vector-&gt;eitr = new_itr;
<a name="l02013"></a>02013 
<a name="l02014"></a>02014         ixgbe_write_eitr(q_vector);
<a name="l02015"></a>02015     }
<a name="l02016"></a>02016 }
<a name="l02017"></a>02017 
<a name="l02022"></a>02022 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_overtemp_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02023"></a>02023 {
<a name="l02024"></a>02024     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02025"></a>02025     u32 eicr = adapter-&gt;interrupt_event;
<a name="l02026"></a>02026 
<a name="l02027"></a>02027     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02028"></a>02028         <span class="keywordflow">return</span>;
<a name="l02029"></a>02029 
<a name="l02030"></a>02030     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &amp;&amp;
<a name="l02031"></a>02031         !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_EVENT))
<a name="l02032"></a>02032         <span class="keywordflow">return</span>;
<a name="l02033"></a>02033 
<a name="l02034"></a>02034     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_TEMP_SENSOR_EVENT;
<a name="l02035"></a>02035 
<a name="l02036"></a>02036     <span class="keywordflow">switch</span> (hw-&gt;device_id) {
<a name="l02037"></a>02037     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_T3_LOM:
<a name="l02038"></a>02038         <span class="comment">/*</span>
<a name="l02039"></a>02039 <span class="comment">         * Since the warning interrupt is for both ports</span>
<a name="l02040"></a>02040 <span class="comment">         * we don&#39;t have to check if:</span>
<a name="l02041"></a>02041 <span class="comment">         *  - This interrupt wasn&#39;t for our port.</span>
<a name="l02042"></a>02042 <span class="comment">         *  - We may have missed the interrupt so always have to</span>
<a name="l02043"></a>02043 <span class="comment">         *    check if we  got a LSC</span>
<a name="l02044"></a>02044 <span class="comment">         */</span>
<a name="l02045"></a>02045         <span class="keywordflow">if</span> (!(eicr &amp; IXGBE_EICR_GPI_SDP0) &amp;&amp;
<a name="l02046"></a>02046             !(eicr &amp; IXGBE_EICR_LSC))
<a name="l02047"></a>02047             <span class="keywordflow">return</span>;
<a name="l02048"></a>02048 
<a name="l02049"></a>02049         <span class="keywordflow">if</span> (!(eicr &amp; IXGBE_EICR_LSC) &amp;&amp; hw-&gt;mac.ops.check_link) {
<a name="l02050"></a>02050             u32 autoneg;
<a name="l02051"></a>02051             <span class="keywordtype">bool</span> link_up = <span class="keyword">false</span>;
<a name="l02052"></a>02052 
<a name="l02053"></a>02053             hw-&gt;mac.ops.check_link(hw, &amp;autoneg, &amp;link_up, <span class="keyword">false</span>);
<a name="l02054"></a>02054 
<a name="l02055"></a>02055             <span class="keywordflow">if</span> (link_up)
<a name="l02056"></a>02056                 <span class="keywordflow">return</span>;
<a name="l02057"></a>02057         }
<a name="l02058"></a>02058 
<a name="l02059"></a>02059         <span class="comment">/* Check if this is not due to overtemp */</span>
<a name="l02060"></a>02060         <span class="keywordflow">if</span> (hw-&gt;phy.ops.check_overtemp(hw) != IXGBE_ERR_OVERTEMP)
<a name="l02061"></a>02061             <span class="keywordflow">return</span>;
<a name="l02062"></a>02062 
<a name="l02063"></a>02063         <span class="keywordflow">break</span>;
<a name="l02064"></a>02064     <span class="keywordflow">default</span>:
<a name="l02065"></a>02065         <span class="keywordflow">if</span> (!(eicr &amp; IXGBE_EICR_GPI_SDP0))
<a name="l02066"></a>02066             <span class="keywordflow">return</span>;
<a name="l02067"></a>02067         <span class="keywordflow">break</span>;
<a name="l02068"></a>02068     }
<a name="l02069"></a>02069     DPRINTK(PROBE, CRIT, <span class="stringliteral">&quot;Network adapter has been stopped because it has &quot;</span>
<a name="l02070"></a>02070             <span class="stringliteral">&quot;over heated. Restart the computer. If the problem persists, &quot;</span>
<a name="l02071"></a>02071             <span class="stringliteral">&quot;power off the system and replace the adapter\n&quot;</span>);
<a name="l02072"></a>02072 
<a name="l02073"></a>02073     adapter-&gt;interrupt_event = 0;
<a name="l02074"></a>02074 }
<a name="l02075"></a>02075 
<a name="l02076"></a>02076 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_fan_failure(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u32 eicr)
<a name="l02077"></a>02077 {
<a name="l02078"></a>02078     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02079"></a>02079 
<a name="l02080"></a>02080     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE) &amp;&amp;
<a name="l02081"></a>02081         (eicr &amp; IXGBE_EICR_GPI_SDP1)) {
<a name="l02082"></a>02082         DPRINTK(PROBE, CRIT, <span class="stringliteral">&quot;Fan has stopped, replace the adapter\n&quot;</span>);
<a name="l02083"></a>02083         <span class="comment">/* write to clear the interrupt */</span>
<a name="l02084"></a>02084         IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1);
<a name="l02085"></a>02085     }
<a name="l02086"></a>02086 }
<a name="l02087"></a>02087 
<a name="l02088"></a>02088 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_sfp_event(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u32 eicr)
<a name="l02089"></a>02089 {
<a name="l02090"></a>02090     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02091"></a>02091 
<a name="l02092"></a>02092     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_GPI_SDP2) {
<a name="l02093"></a>02093         <span class="comment">/* Clear the interrupt */</span>
<a name="l02094"></a>02094         IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP2);
<a name="l02095"></a>02095         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02096"></a>02096             adapter-&gt;flags2 |= IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l02097"></a>02097             ixgbe_service_event_schedule(adapter);
<a name="l02098"></a>02098         }
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_GPI_SDP1) {
<a name="l02102"></a>02102         <span class="comment">/* Clear the interrupt */</span>
<a name="l02103"></a>02103         IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1);
<a name="l02104"></a>02104         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02105"></a>02105             adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l02106"></a>02106             ixgbe_service_event_schedule(adapter);
<a name="l02107"></a>02107         }
<a name="l02108"></a>02108     }
<a name="l02109"></a>02109 }
<a name="l02110"></a>02110 
<a name="l02111"></a>02111 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_lsc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02112"></a>02112 {
<a name="l02113"></a>02113     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02114"></a>02114 
<a name="l02115"></a>02115     adapter-&gt;lsc_int++;
<a name="l02116"></a>02116     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l02117"></a>02117     adapter-&gt;link_check_timeout = jiffies;
<a name="l02118"></a>02118     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02119"></a>02119         IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_EIMC_LSC);
<a name="l02120"></a>02120         IXGBE_WRITE_FLUSH(hw);
<a name="l02121"></a>02121         ixgbe_service_event_schedule(adapter);
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123 }
<a name="l02124"></a>02124 
<a name="l02125"></a>02125 <span class="keyword">static</span> irqreturn_t ixgbe_msix_lsc(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02126"></a>02126 {
<a name="l02127"></a>02127     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l02128"></a>02128     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02129"></a>02129     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02130"></a>02130     u32 eicr;
<a name="l02131"></a>02131 
<a name="l02132"></a>02132     <span class="comment">/*</span>
<a name="l02133"></a>02133 <span class="comment">     * Workaround for Silicon errata #26 on 82598.  Use clear-by-write</span>
<a name="l02134"></a>02134 <span class="comment">     * instead of clear-by-read.  Reading with EICS will return the</span>
<a name="l02135"></a>02135 <span class="comment">     * interrupt causes without clearing, which later be done</span>
<a name="l02136"></a>02136 <span class="comment">     * with the write to EICR.</span>
<a name="l02137"></a>02137 <span class="comment">     */</span>
<a name="l02138"></a>02138     eicr = IXGBE_READ_REG(hw, IXGBE_EICS);
<a name="l02139"></a>02139     IXGBE_WRITE_REG(hw, IXGBE_EICR, eicr);
<a name="l02140"></a>02140 
<a name="l02141"></a>02141     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_LSC)
<a name="l02142"></a>02142         ixgbe_check_lsc(adapter);
<a name="l02143"></a>02143 
<a name="l02144"></a>02144     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_MAILBOX)
<a name="l02145"></a>02145         ixgbe_msg_task(adapter);
<a name="l02146"></a>02146 
<a name="l02147"></a>02147     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02148"></a>02148     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02149"></a>02149     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02150"></a>02150         <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_ECC) {
<a name="l02151"></a>02151             DPRINTK(LINK, INFO, <span class="stringliteral">&quot;Received unrecoverable ECC Err, &quot;</span>
<a name="l02152"></a>02152                                 <span class="stringliteral">&quot;please reboot\n&quot;</span>);
<a name="l02153"></a>02153             IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_ECC);
<a name="l02154"></a>02154         }
<a name="l02155"></a>02155 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l02156"></a>02156 <span class="preprocessor"></span>        <span class="comment">/* Handle Flow Director Full threshold interrupt */</span>
<a name="l02157"></a>02157         <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_FLOW_DIR) {
<a name="l02158"></a>02158             <span class="keywordtype">int</span> reinit_count = 0;
<a name="l02159"></a>02159             <span class="keywordtype">int</span> i;
<a name="l02160"></a>02160             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l02161"></a>02161                 <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;tx_ring[i];
<a name="l02162"></a>02162                 <span class="keywordflow">if</span> (test_and_clear_bit(__IXGBE_TX_FDIR_INIT_DONE,
<a name="l02163"></a>02163                                &amp;ring-&gt;state))
<a name="l02164"></a>02164                     reinit_count++;
<a name="l02165"></a>02165             }
<a name="l02166"></a>02166             <span class="keywordflow">if</span> (reinit_count) {
<a name="l02167"></a>02167                 <span class="comment">/* no more flow director interrupts until after init */</span>
<a name="l02168"></a>02168                 IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_EIMC_FLOW_DIR);
<a name="l02169"></a>02169                 eicr &amp;= ~IXGBE_EICR_FLOW_DIR;
<a name="l02170"></a>02170                 adapter-&gt;flags2 |= IXGBE_FLAG2_FDIR_REQUIRES_REINIT;
<a name="l02171"></a>02171                 ixgbe_service_event_schedule(adapter);
<a name="l02172"></a>02172             }
<a name="l02173"></a>02173         }
<a name="l02174"></a>02174 <span class="preprocessor">#endif</span>
<a name="l02175"></a>02175 <span class="preprocessor"></span>        ixgbe_check_sfp_event(adapter, eicr);
<a name="l02176"></a>02176         <span class="keywordflow">if</span> ((adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &amp;&amp;
<a name="l02177"></a>02177             ((eicr &amp; IXGBE_EICR_GPI_SDP0) || (eicr &amp; IXGBE_EICR_LSC))) {
<a name="l02178"></a>02178             <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02179"></a>02179                 adapter-&gt;interrupt_event = eicr;
<a name="l02180"></a>02180                 adapter-&gt;flags2 |= IXGBE_FLAG2_TEMP_SENSOR_EVENT;
<a name="l02181"></a>02181                 ixgbe_service_event_schedule(adapter);
<a name="l02182"></a>02182             }
<a name="l02183"></a>02183         }
<a name="l02184"></a>02184         <span class="keywordflow">break</span>;
<a name="l02185"></a>02185     <span class="keywordflow">default</span>:
<a name="l02186"></a>02186         <span class="keywordflow">break</span>;
<a name="l02187"></a>02187     }
<a name="l02188"></a>02188 
<a name="l02189"></a>02189     ixgbe_check_fan_failure(adapter, eicr);
<a name="l02190"></a>02190 
<a name="l02191"></a>02191     <span class="comment">/* re-enable the original interrupt state, no lsc, no queues */</span>
<a name="l02192"></a>02192     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02193"></a>02193         IXGBE_WRITE_REG(hw, IXGBE_EIMS, eicr &amp;
<a name="l02194"></a>02194                         ~(IXGBE_EIMS_LSC | IXGBE_EIMS_RTX_QUEUE));
<a name="l02195"></a>02195 
<a name="l02196"></a>02196     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02197"></a>02197 }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 <span class="keywordtype">void</span> ixgbe_irq_enable_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 qmask)
<a name="l02200"></a>02200 {
<a name="l02201"></a>02201     u32 mask;
<a name="l02202"></a>02202     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02203"></a>02203 
<a name="l02204"></a>02204     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02205"></a>02205     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l02206"></a>02206         mask = (IXGBE_EIMS_RTX_QUEUE &amp; qmask);
<a name="l02207"></a>02207         IXGBE_WRITE_REG(hw, IXGBE_EIMS, mask);
<a name="l02208"></a>02208         <span class="keywordflow">break</span>;
<a name="l02209"></a>02209     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02210"></a>02210     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02211"></a>02211         mask = (qmask &amp; 0xFFFFFFFF);
<a name="l02212"></a>02212         <span class="keywordflow">if</span> (mask)
<a name="l02213"></a>02213             IXGBE_WRITE_REG(hw, IXGBE_EIMS_EX(0), mask);
<a name="l02214"></a>02214         mask = (qmask &gt;&gt; 32);
<a name="l02215"></a>02215         <span class="keywordflow">if</span> (mask)
<a name="l02216"></a>02216             IXGBE_WRITE_REG(hw, IXGBE_EIMS_EX(1), mask);
<a name="l02217"></a>02217         <span class="keywordflow">break</span>;
<a name="l02218"></a>02218     <span class="keywordflow">default</span>:
<a name="l02219"></a>02219         <span class="keywordflow">break</span>;
<a name="l02220"></a>02220     }
<a name="l02221"></a>02221     <span class="comment">/* skip the flush */</span>
<a name="l02222"></a>02222 }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224 <span class="keywordtype">void</span> ixgbe_irq_disable_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, u64 qmask)
<a name="l02225"></a>02225 {
<a name="l02226"></a>02226     u32 mask;
<a name="l02227"></a>02227     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02228"></a>02228 
<a name="l02229"></a>02229     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02230"></a>02230     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l02231"></a>02231         mask = (IXGBE_EIMS_RTX_QUEUE &amp; qmask);
<a name="l02232"></a>02232         IXGBE_WRITE_REG(hw, IXGBE_EIMC, mask);
<a name="l02233"></a>02233         <span class="keywordflow">break</span>;
<a name="l02234"></a>02234     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02235"></a>02235     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02236"></a>02236         mask = (qmask &amp; 0xFFFFFFFF);
<a name="l02237"></a>02237         <span class="keywordflow">if</span> (mask)
<a name="l02238"></a>02238             IXGBE_WRITE_REG(hw, IXGBE_EIMC_EX(0), mask);
<a name="l02239"></a>02239         mask = (qmask &gt;&gt; 32);
<a name="l02240"></a>02240         <span class="keywordflow">if</span> (mask)
<a name="l02241"></a>02241             IXGBE_WRITE_REG(hw, IXGBE_EIMC_EX(1), mask);
<a name="l02242"></a>02242         <span class="keywordflow">break</span>;
<a name="l02243"></a>02243     <span class="keywordflow">default</span>:
<a name="l02244"></a>02244         <span class="keywordflow">break</span>;
<a name="l02245"></a>02245     }
<a name="l02246"></a>02246     <span class="comment">/* skip the flush */</span>
<a name="l02247"></a>02247 }
<a name="l02248"></a>02248 
<a name="l02249"></a>02249 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l02250"></a>02250 <span class="preprocessor"></span><span class="keyword">static</span> irqreturn_t ixgbe_msix_clean_rings(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02251"></a>02251 {
<a name="l02252"></a>02252     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = data;
<a name="l02253"></a>02253     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>  *adapter = q_vector-&gt;adapter;
<a name="l02254"></a>02254     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a>  *ring;
<a name="l02255"></a>02255     <span class="keywordtype">bool</span> clean_complete = <span class="keyword">true</span>;
<a name="l02256"></a>02256 
<a name="l02257"></a>02257     <span class="keywordflow">if</span> (!q_vector-&gt;tx_ring &amp;&amp; !q_vector-&gt;rx_ring)
<a name="l02258"></a>02258         <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02259"></a>02259 
<a name="l02260"></a>02260     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
<a name="l02261"></a>02261         ixgbe_update_dca(q_vector);
<a name="l02262"></a>02262 
<a name="l02263"></a>02263     <span class="keywordflow">for</span> (ring = q_vector-&gt;tx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l02264"></a>02264         clean_complete &amp;= !!ixgbe_clean_tx_irq(q_vector, ring,
<a name="l02265"></a>02265                                q_vector-&gt;tx_work_limit);
<a name="l02266"></a>02266 
<a name="l02267"></a>02267     <span class="keywordflow">for</span> (ring = q_vector-&gt;rx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l02268"></a>02268         clean_complete &amp;= !!ixgbe_clean_rx_irq(q_vector, ring,
<a name="l02269"></a>02269                                q_vector-&gt;rx_work_limit);
<a name="l02270"></a>02270 
<a name="l02271"></a>02271     <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting &amp; 1)
<a name="l02272"></a>02272         ixgbe_set_itr(q_vector);
<a name="l02273"></a>02273 
<a name="l02274"></a>02274     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02275"></a>02275         u64 eics = ((u64)1 &lt;&lt; q_vector-&gt;v_idx);
<a name="l02276"></a>02276         ixgbe_irq_enable_queues(adapter, eics);
<a name="l02277"></a>02277         <span class="keywordflow">if</span> (!clean_complete)
<a name="l02278"></a>02278             ixgbe_irq_rearm_queues(adapter, eics);
<a name="l02279"></a>02279     }
<a name="l02280"></a>02280 
<a name="l02281"></a>02281     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02282"></a>02282 }
<a name="l02283"></a>02283 <span class="preprocessor">#else </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02284"></a>02284 <span class="keyword">static</span> irqreturn_t ixgbe_msix_clean_rings(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02285"></a>02285 {
<a name="l02286"></a>02286     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = data;
<a name="l02287"></a>02287 
<a name="l02288"></a>02288     <span class="keywordflow">if</span> (!q_vector-&gt;tx_ring &amp;&amp; !q_vector-&gt;rx_ring)
<a name="l02289"></a>02289         <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02290"></a>02290 
<a name="l02291"></a>02291     <span class="comment">/* EIAM disabled interrupts (on this vector) for us */</span>
<a name="l02292"></a>02292     napi_schedule(&amp;q_vector-&gt;napi);
<a name="l02293"></a>02293 
<a name="l02294"></a>02294     <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02295"></a>02295 }
<a name="l02296"></a>02296 
<a name="l02304"></a>02304 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_poll(<span class="keyword">struct</span> napi_struct *napi, <span class="keywordtype">int</span> budget)
<a name="l02305"></a>02305 {
<a name="l02306"></a>02306     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector =
<a name="l02307"></a>02307                    container_of(napi, <span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a>, napi);
<a name="l02308"></a>02308     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = q_vector-&gt;adapter;
<a name="l02309"></a>02309     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring;
<a name="l02310"></a>02310     <span class="keywordtype">int</span> per_ring_budget;
<a name="l02311"></a>02311     <span class="keywordtype">int</span> total_work = 0;
<a name="l02312"></a>02312     <span class="keywordtype">bool</span> clean_complete = <span class="keyword">true</span>;
<a name="l02313"></a>02313 
<a name="l02314"></a>02314     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)
<a name="l02315"></a>02315         ixgbe_update_dca(q_vector);
<a name="l02316"></a>02316 
<a name="l02317"></a>02317     <span class="keywordflow">for</span> (ring = q_vector-&gt;tx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l02318"></a>02318         clean_complete &amp;= !!ixgbe_clean_tx_irq(q_vector, ring, budget);
<a name="l02319"></a>02319 
<a name="l02320"></a>02320     <span class="comment">/* attempt to distribute budget to each queue fairly, but don&#39;t allow</span>
<a name="l02321"></a>02321 <span class="comment">     * the budget to go below 1 because we&#39;ll exit polling */</span>
<a name="l02322"></a>02322     <span class="keywordflow">if</span> (q_vector-&gt;rxr_count &gt; 1)
<a name="l02323"></a>02323         per_ring_budget = max(budget/q_vector-&gt;rxr_count, 1);
<a name="l02324"></a>02324     <span class="keywordflow">else</span>
<a name="l02325"></a>02325         per_ring_budget = budget;
<a name="l02326"></a>02326 
<a name="l02327"></a>02327     <span class="keywordflow">for</span> (ring = q_vector-&gt;rx_ring; ring != NULL; ring = ring-&gt;next)
<a name="l02328"></a>02328         clean_complete &amp;= !!ixgbe_clean_rx_irq(q_vector, ring,
<a name="l02329"></a>02329                                per_ring_budget);
<a name="l02330"></a>02330 
<a name="l02331"></a>02331     <span class="keywordflow">if</span> (!clean_complete)
<a name="l02332"></a>02332         total_work = budget;
<a name="l02333"></a>02333 
<a name="l02334"></a>02334 <span class="preprocessor">#ifndef HAVE_NETDEV_NAPI_LIST</span>
<a name="l02335"></a>02335 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!netif_running(adapter-&gt;netdev))
<a name="l02336"></a>02336         total_work = 0;
<a name="l02337"></a>02337 
<a name="l02338"></a>02338 <span class="preprocessor">#endif</span>
<a name="l02339"></a>02339 <span class="preprocessor"></span>    <span class="comment">/* If all Rx work done, exit the polling mode */</span>
<a name="l02340"></a>02340     <span class="keywordflow">if</span> (total_work &lt; budget) {
<a name="l02341"></a>02341         napi_complete(napi);
<a name="l02342"></a>02342         <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting &amp; 1)
<a name="l02343"></a>02343             ixgbe_set_itr(q_vector);
<a name="l02344"></a>02344         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02345"></a>02345             ixgbe_irq_enable_queues(adapter,
<a name="l02346"></a>02346                         ((u64)1 &lt;&lt; q_vector-&gt;v_idx));
<a name="l02347"></a>02347     }
<a name="l02348"></a>02348 
<a name="l02349"></a>02349     <span class="keywordflow">return</span> total_work;
<a name="l02350"></a>02350 }
<a name="l02351"></a>02351 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l02352"></a>02352 
<a name="l02353"></a>02353 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> map_vector_to_rxq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *a, <span class="keywordtype">int</span> v_idx,
<a name="l02354"></a>02354                      <span class="keywordtype">int</span> r_idx)
<a name="l02355"></a>02355 {
<a name="l02356"></a>02356     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = a-&gt;q_vector[v_idx];
<a name="l02357"></a>02357     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = a-&gt;rx_ring[r_idx];
<a name="l02358"></a>02358 
<a name="l02359"></a>02359     rx_ring-&gt;next = q_vector-&gt;rx_ring;
<a name="l02360"></a>02360     q_vector-&gt;rx_ring = rx_ring;
<a name="l02361"></a>02361     rx_ring-&gt;q_vector = q_vector;
<a name="l02362"></a>02362     q_vector-&gt;rxr_count++;
<a name="l02363"></a>02363 }
<a name="l02364"></a>02364 
<a name="l02365"></a>02365 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> map_vector_to_txq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *a, <span class="keywordtype">int</span> v_idx,
<a name="l02366"></a>02366                      <span class="keywordtype">int</span> t_idx)
<a name="l02367"></a>02367 {
<a name="l02368"></a>02368     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = a-&gt;q_vector[v_idx];
<a name="l02369"></a>02369     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = a-&gt;tx_ring[t_idx];
<a name="l02370"></a>02370 
<a name="l02371"></a>02371     tx_ring-&gt;next = q_vector-&gt;tx_ring;
<a name="l02372"></a>02372     q_vector-&gt;tx_ring = tx_ring;
<a name="l02373"></a>02373     tx_ring-&gt;q_vector = q_vector;
<a name="l02374"></a>02374     q_vector-&gt;txr_count++;
<a name="l02375"></a>02375 }
<a name="l02376"></a>02376 
<a name="l02387"></a>02387 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_map_rings_to_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02388"></a>02388 {
<a name="l02389"></a>02389     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02390"></a>02390     <span class="keywordtype">int</span> rxr_remaining = adapter-&gt;num_rx_queues, rxr_idx = 0;
<a name="l02391"></a>02391     <span class="keywordtype">int</span> txr_remaining = adapter-&gt;num_tx_queues, txr_idx = 0;
<a name="l02392"></a>02392     <span class="keywordtype">int</span> v_start = 0;
<a name="l02393"></a>02393 
<a name="l02394"></a>02394     <span class="comment">/* only one q_vector if MSI-X is disabled. */</span>
<a name="l02395"></a>02395     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l02396"></a>02396         q_vectors = 1;
<a name="l02397"></a>02397 
<a name="l02398"></a>02398     <span class="comment">/*</span>
<a name="l02399"></a>02399 <span class="comment">     * If we don&#39;t have enough vectors for a 1-to-1 mapping, we&#39;ll have to</span>
<a name="l02400"></a>02400 <span class="comment">     * group them so there are multiple queues per vector.</span>
<a name="l02401"></a>02401 <span class="comment">     *</span>
<a name="l02402"></a>02402 <span class="comment">     * Re-adjusting *qpv takes care of the remainder.</span>
<a name="l02403"></a>02403 <span class="comment">     */</span>
<a name="l02404"></a>02404     <span class="keywordflow">for</span> (; v_start &lt; q_vectors &amp;&amp; rxr_remaining; v_start++) {
<a name="l02405"></a>02405         <span class="keywordtype">int</span> rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_start);
<a name="l02406"></a>02406         <span class="keywordflow">for</span> (; rqpv; rqpv--, rxr_idx++, rxr_remaining--)
<a name="l02407"></a>02407             map_vector_to_rxq(adapter, v_start, rxr_idx);
<a name="l02408"></a>02408     }
<a name="l02409"></a>02409 
<a name="l02410"></a>02410     <span class="comment">/*</span>
<a name="l02411"></a>02411 <span class="comment">     * If there are not enough q_vectors for each ring to have it&#39;s own</span>
<a name="l02412"></a>02412 <span class="comment">     * vector then we must pair up Rx/Tx on a each vector</span>
<a name="l02413"></a>02413 <span class="comment">     */</span>
<a name="l02414"></a>02414     <span class="keywordflow">if</span> ((v_start + txr_remaining) &gt; q_vectors)
<a name="l02415"></a>02415         v_start = 0;
<a name="l02416"></a>02416 
<a name="l02417"></a>02417     <span class="keywordflow">for</span> (; v_start &lt; q_vectors &amp;&amp; txr_remaining; v_start++) {
<a name="l02418"></a>02418         <span class="keywordtype">int</span> tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_start);
<a name="l02419"></a>02419         <span class="keywordflow">for</span> (; tqpv; tqpv--, txr_idx++, txr_remaining--)
<a name="l02420"></a>02420             map_vector_to_txq(adapter, v_start, txr_idx);
<a name="l02421"></a>02421     }
<a name="l02422"></a>02422 }
<a name="l02423"></a>02423 
<a name="l02431"></a>02431 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_request_msix_irqs(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02432"></a>02432 {
<a name="l02433"></a>02433     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02434"></a>02434     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02435"></a>02435     <span class="keywordtype">int</span> vector, err;
<a name="l02436"></a>02436     <span class="keywordtype">int</span> ri = 0, ti = 0;
<a name="l02437"></a>02437 
<a name="l02438"></a>02438     <span class="keywordflow">for</span> (vector = 0; vector &lt; q_vectors; vector++) {
<a name="l02439"></a>02439         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[vector];
<a name="l02440"></a>02440 
<a name="l02441"></a>02441         <span class="keywordflow">if</span> (q_vector-&gt;tx_ring &amp;&amp; q_vector-&gt;rx_ring) {
<a name="l02442"></a>02442             sprintf(q_vector-&gt;name, <span class="stringliteral">&quot;%s-%s-%d&quot;</span>,
<a name="l02443"></a>02443                     netdev-&gt;name, <span class="stringliteral">&quot;TxRx&quot;</span>, ri++);
<a name="l02444"></a>02444             ti++;
<a name="l02445"></a>02445         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (q_vector-&gt;rx_ring) {
<a name="l02446"></a>02446             sprintf(q_vector-&gt;name, <span class="stringliteral">&quot;%s-%s-%d&quot;</span>,
<a name="l02447"></a>02447                     netdev-&gt;name, <span class="stringliteral">&quot;rx&quot;</span>, ri++);
<a name="l02448"></a>02448         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (q_vector-&gt;tx_ring) {
<a name="l02449"></a>02449             sprintf(q_vector-&gt;name, <span class="stringliteral">&quot;%s-%s-%d&quot;</span>,
<a name="l02450"></a>02450                     netdev-&gt;name, <span class="stringliteral">&quot;tx&quot;</span>, ti++);
<a name="l02451"></a>02451         } <span class="keywordflow">else</span> {
<a name="l02452"></a>02452             <span class="comment">/* skip this unused q_vector */</span>
<a name="l02453"></a>02453             <span class="keywordflow">continue</span>;
<a name="l02454"></a>02454         }
<a name="l02455"></a>02455         err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02456"></a>02456                   &amp;ixgbe_msix_clean_rings, 0, q_vector-&gt;name,
<a name="l02457"></a>02457                   q_vector);
<a name="l02458"></a>02458         <span class="keywordflow">if</span> (err) {
<a name="l02459"></a>02459             DPRINTK(PROBE, ERR,
<a name="l02460"></a>02460                     <span class="stringliteral">&quot;request_irq failed for MSIX interrupt &quot;</span>
<a name="l02461"></a>02461                     <span class="stringliteral">&quot;Error: %d\n&quot;</span>, err);
<a name="l02462"></a>02462             <span class="keywordflow">goto</span> free_queue_irqs;
<a name="l02463"></a>02463         }
<a name="l02464"></a>02464 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l02465"></a>02465 <span class="preprocessor"></span>        <span class="comment">/* If Flow Director is enabled, set interrupt affinity */</span>
<a name="l02466"></a>02466         <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) ||
<a name="l02467"></a>02467             (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)) {
<a name="l02468"></a>02468             <span class="comment">/* assign the mask for this irq */</span>
<a name="l02469"></a>02469             irq_set_affinity_hint(adapter-&gt;msix_entries[vector].vector,
<a name="l02470"></a>02470                                   q_vector-&gt;affinity_mask);
<a name="l02471"></a>02471         }
<a name="l02472"></a>02472 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_IRQ_AFFINITY_HINT */</span>
<a name="l02473"></a>02473     }
<a name="l02474"></a>02474 
<a name="l02475"></a>02475     sprintf(adapter-&gt;lsc_int_name, <span class="stringliteral">&quot;%s:lsc&quot;</span>, netdev-&gt;name);
<a name="l02476"></a>02476     err = request_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02477"></a>02477               &amp;ixgbe_msix_lsc, 0, adapter-&gt;lsc_int_name, netdev);
<a name="l02478"></a>02478     <span class="keywordflow">if</span> (err) {
<a name="l02479"></a>02479         DPRINTK(PROBE, ERR,
<a name="l02480"></a>02480                 <span class="stringliteral">&quot;request_irq for msix_lsc failed: %d\n&quot;</span>, err);
<a name="l02481"></a>02481         <span class="keywordflow">goto</span> free_queue_irqs;
<a name="l02482"></a>02482     }
<a name="l02483"></a>02483 
<a name="l02484"></a>02484     <span class="keywordflow">return</span> 0;
<a name="l02485"></a>02485 
<a name="l02486"></a>02486 free_queue_irqs:
<a name="l02487"></a>02487     <span class="keywordflow">while</span> (vector) {
<a name="l02488"></a>02488         vector--;
<a name="l02489"></a>02489 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l02490"></a>02490 <span class="preprocessor"></span>        irq_set_affinity_hint(adapter-&gt;msix_entries[vector].vector,
<a name="l02491"></a>02491                       NULL);
<a name="l02492"></a>02492 <span class="preprocessor">#endif</span>
<a name="l02493"></a>02493 <span class="preprocessor"></span>        free_irq(adapter-&gt;msix_entries[vector].vector,
<a name="l02494"></a>02494              adapter-&gt;q_vector[vector]);
<a name="l02495"></a>02495     }
<a name="l02496"></a>02496     adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSIX_ENABLED;
<a name="l02497"></a>02497     pci_disable_msix(adapter-&gt;pdev);
<a name="l02498"></a>02498     kfree(adapter-&gt;msix_entries);
<a name="l02499"></a>02499     adapter-&gt;msix_entries = NULL;
<a name="l02500"></a>02500     <span class="keywordflow">return</span> err;
<a name="l02501"></a>02501 }
<a name="l02502"></a>02502 
<a name="l02507"></a>02507 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_irq_enable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter, <span class="keywordtype">bool</span> queues, <span class="keywordtype">bool</span> flush)
<a name="l02508"></a>02508 {
<a name="l02509"></a>02509     u64 qmask = ~0;
<a name="l02510"></a>02510     u32 mask = (IXGBE_EIMS_ENABLE_MASK &amp; ~IXGBE_EIMS_RTX_QUEUE);
<a name="l02511"></a>02511 
<a name="l02512"></a>02512     <span class="comment">/* don&#39;t reenable LSC while waiting for link */</span>
<a name="l02513"></a>02513     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_UPDATE)
<a name="l02514"></a>02514         mask &amp;= ~IXGBE_EIMS_LSC;
<a name="l02515"></a>02515 
<a name="l02516"></a>02516     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE)
<a name="l02517"></a>02517         mask |= IXGBE_EIMS_GPI_SDP0;
<a name="l02518"></a>02518     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE)
<a name="l02519"></a>02519         mask |= IXGBE_EIMS_GPI_SDP1;
<a name="l02520"></a>02520     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02521"></a>02521     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02522"></a>02522     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02523"></a>02523         mask |= IXGBE_EIMS_ECC;
<a name="l02524"></a>02524         mask |= IXGBE_EIMS_GPI_SDP1;
<a name="l02525"></a>02525         mask |= IXGBE_EIMS_GPI_SDP2;
<a name="l02526"></a>02526         mask |= IXGBE_EIMS_MAILBOX;
<a name="l02527"></a>02527         <span class="keywordflow">break</span>;
<a name="l02528"></a>02528     <span class="keywordflow">default</span>:
<a name="l02529"></a>02529         <span class="keywordflow">break</span>;
<a name="l02530"></a>02530     }
<a name="l02531"></a>02531     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE ||
<a name="l02532"></a>02532         adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
<a name="l02533"></a>02533         mask |= IXGBE_EIMS_FLOW_DIR;
<a name="l02534"></a>02534 
<a name="l02535"></a>02535     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMS, mask);
<a name="l02536"></a>02536     <span class="keywordflow">if</span> (queues)
<a name="l02537"></a>02537         ixgbe_irq_enable_queues(adapter, qmask);
<a name="l02538"></a>02538     <span class="keywordflow">if</span> (flush)
<a name="l02539"></a>02539         IXGBE_WRITE_FLUSH(&amp;adapter-&gt;hw);
<a name="l02540"></a>02540 
<a name="l02541"></a>02541     <span class="keywordflow">if</span> (adapter-&gt;num_vfs &gt; 32) {
<a name="l02542"></a>02542         u32 eitrsel = (1 &lt;&lt; (adapter-&gt;num_vfs - 32)) - 1;
<a name="l02543"></a>02543         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EITRSEL, eitrsel);
<a name="l02544"></a>02544     }
<a name="l02545"></a>02545 }
<a name="l02546"></a>02546 
<a name="l02552"></a>02552 <span class="keyword">static</span> irqreturn_t ixgbe_intr(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *data)
<a name="l02553"></a>02553 {
<a name="l02554"></a>02554     <span class="keyword">struct </span>net_device *netdev = data;
<a name="l02555"></a>02555     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l02556"></a>02556     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02557"></a>02557     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[0];
<a name="l02558"></a>02558     u32 eicr;
<a name="l02559"></a>02559 
<a name="l02560"></a>02560     <span class="comment">/*</span>
<a name="l02561"></a>02561 <span class="comment">     * Workaround of Silicon errata #26 on 82598.  Mask the interrupt</span>
<a name="l02562"></a>02562 <span class="comment">     * before the read of EICR.</span>
<a name="l02563"></a>02563 <span class="comment">     */</span>
<a name="l02564"></a>02564     IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_IRQ_CLEAR_MASK);
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     <span class="comment">/* for NAPI, using EIAM to auto-mask tx/rx interrupt bits on read</span>
<a name="l02567"></a>02567 <span class="comment">     * therefore no explict interrupt disable is necessary */</span>
<a name="l02568"></a>02568     eicr = IXGBE_READ_REG(hw, IXGBE_EICR);
<a name="l02569"></a>02569     <span class="keywordflow">if</span> (!eicr) {
<a name="l02570"></a>02570         <span class="comment">/*</span>
<a name="l02571"></a>02571 <span class="comment">         * shared interrupt alert!</span>
<a name="l02572"></a>02572 <span class="comment">         * make sure interrupts are enabled because the read will</span>
<a name="l02573"></a>02573 <span class="comment">         * have disabled interrupts due to EIAM</span>
<a name="l02574"></a>02574 <span class="comment">         * finish the workaround of silicon errata #26 on 82598.  Unmask</span>
<a name="l02575"></a>02575 <span class="comment">         * the interrupt that we masked before the EICR read.</span>
<a name="l02576"></a>02576 <span class="comment">         */</span>
<a name="l02577"></a>02577         <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02578"></a>02578             ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l02579"></a>02579         <span class="keywordflow">return</span> IRQ_NONE;  <span class="comment">/* Not our interrupt */</span>
<a name="l02580"></a>02580     }
<a name="l02581"></a>02581 
<a name="l02582"></a>02582     <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_LSC)
<a name="l02583"></a>02583         ixgbe_check_lsc(adapter);
<a name="l02584"></a>02584 
<a name="l02585"></a>02585     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l02586"></a>02586     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02587"></a>02587     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02588"></a>02588         <span class="keywordflow">if</span> (eicr &amp; IXGBE_EICR_ECC)
<a name="l02589"></a>02589             DPRINTK(LINK, INFO, <span class="stringliteral">&quot;Received unrecoverable ECC Err, &quot;</span>
<a name="l02590"></a>02590                                 <span class="stringliteral">&quot;please reboot\n&quot;</span>);
<a name="l02591"></a>02591         ixgbe_check_sfp_event(adapter, eicr);
<a name="l02592"></a>02592         <span class="keywordflow">if</span> ((adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &amp;&amp;
<a name="l02593"></a>02593             ((eicr &amp; IXGBE_EICR_GPI_SDP0) || (eicr &amp; IXGBE_EICR_LSC))) {
<a name="l02594"></a>02594             <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state)) {
<a name="l02595"></a>02595                 adapter-&gt;interrupt_event = eicr;
<a name="l02596"></a>02596                 adapter-&gt;flags2 |= IXGBE_FLAG2_TEMP_SENSOR_EVENT;
<a name="l02597"></a>02597                 ixgbe_service_event_schedule(adapter);
<a name="l02598"></a>02598             }
<a name="l02599"></a>02599         }
<a name="l02600"></a>02600         <span class="keywordflow">break</span>;
<a name="l02601"></a>02601     <span class="keywordflow">default</span>:
<a name="l02602"></a>02602         <span class="keywordflow">break</span>;
<a name="l02603"></a>02603     }
<a name="l02604"></a>02604 
<a name="l02605"></a>02605     ixgbe_check_fan_failure(adapter, eicr);
<a name="l02606"></a>02606 
<a name="l02607"></a>02607 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l02608"></a>02608 <span class="preprocessor"></span>    <span class="comment">/* would disable interrupts here but EIAM disabled it */</span>
<a name="l02609"></a>02609     napi_schedule(&amp;q_vector-&gt;napi);
<a name="l02610"></a>02610 
<a name="l02611"></a>02611     <span class="comment">/*</span>
<a name="l02612"></a>02612 <span class="comment">     * re-enable link(maybe) and non-queue interrupts, no flush.</span>
<a name="l02613"></a>02613 <span class="comment">     * ixgbe_poll will re-enable the queue interrupts</span>
<a name="l02614"></a>02614 <span class="comment">     */</span>
<a name="l02615"></a>02615     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02616"></a>02616         ixgbe_irq_enable(adapter, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l02617"></a>02617 <span class="preprocessor">#else</span>
<a name="l02618"></a>02618 <span class="preprocessor"></span>    ixgbe_clean_tx_irq(q_vector, adapter-&gt;tx_ring[0],
<a name="l02619"></a>02619                q_vector-&gt;tx_work_limit);
<a name="l02620"></a>02620     ixgbe_clean_rx_irq(q_vector, adapter-&gt;rx_ring[0],
<a name="l02621"></a>02621                q_vector-&gt;rx_work_limit);
<a name="l02622"></a>02622 
<a name="l02623"></a>02623     <span class="comment">/* dynamically adjust throttle */</span>
<a name="l02624"></a>02624     <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting &amp; 1)
<a name="l02625"></a>02625         ixgbe_set_itr(q_vector);
<a name="l02626"></a>02626 
<a name="l02627"></a>02627     <span class="comment">/*</span>
<a name="l02628"></a>02628 <span class="comment">     * Workaround of Silicon errata #26 on 82598.  Unmask</span>
<a name="l02629"></a>02629 <span class="comment">     * the interrupt that we masked before the EICR read</span>
<a name="l02630"></a>02630 <span class="comment">     * no flush of the re-enable is necessary here</span>
<a name="l02631"></a>02631 <span class="comment">     */</span>
<a name="l02632"></a>02632     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l02633"></a>02633         ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">false</span>);
<a name="l02634"></a>02634 <span class="preprocessor">#endif</span>
<a name="l02635"></a>02635 <span class="preprocessor"></span>    <span class="keywordflow">return</span> IRQ_HANDLED;
<a name="l02636"></a>02636 }
<a name="l02637"></a>02637 
<a name="l02638"></a>02638 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_reset_q_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02639"></a>02639 {
<a name="l02640"></a>02640     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l02641"></a>02641     <span class="keywordtype">int</span> i;
<a name="l02642"></a>02642 
<a name="l02643"></a>02643     <span class="comment">/* legacy and MSI only use one vector */</span>
<a name="l02644"></a>02644     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l02645"></a>02645         q_vectors = 1;
<a name="l02646"></a>02646 
<a name="l02647"></a>02647     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l02648"></a>02648         adapter-&gt;rx_ring[i]-&gt;q_vector = NULL;
<a name="l02649"></a>02649         adapter-&gt;rx_ring[i]-&gt;next = NULL;
<a name="l02650"></a>02650     }
<a name="l02651"></a>02651     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l02652"></a>02652         adapter-&gt;tx_ring[i]-&gt;q_vector = NULL;
<a name="l02653"></a>02653         adapter-&gt;tx_ring[i]-&gt;next = NULL;
<a name="l02654"></a>02654     }
<a name="l02655"></a>02655 
<a name="l02656"></a>02656     <span class="keywordflow">for</span> (i = 0; i &lt; q_vectors; i++) {
<a name="l02657"></a>02657         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[i];
<a name="l02658"></a>02658         q_vector-&gt;rx_ring = NULL;
<a name="l02659"></a>02659         q_vector-&gt;tx_ring = NULL;
<a name="l02660"></a>02660         q_vector-&gt;rxr_count = 0;
<a name="l02661"></a>02661         q_vector-&gt;txr_count = 0;
<a name="l02662"></a>02662         q_vector-&gt;tx_work_limit = adapter-&gt;tx_work_limit;
<a name="l02663"></a>02663         q_vector-&gt;rx_work_limit = adapter-&gt;rx_work_limit;
<a name="l02664"></a>02664         q_vector-&gt;total_tx_bytes = 0;
<a name="l02665"></a>02665         q_vector-&gt;total_tx_packets = 0;
<a name="l02666"></a>02666         q_vector-&gt;total_rx_bytes = 0;
<a name="l02667"></a>02667         q_vector-&gt;total_rx_packets = 0;
<a name="l02668"></a>02668         q_vector-&gt;tx_itr = 0;
<a name="l02669"></a>02669         q_vector-&gt;rx_itr = 0;
<a name="l02670"></a>02670         q_vector-&gt;eitr = adapter-&gt;rx_eitr_param;
<a name="l02671"></a>02671     }
<a name="l02672"></a>02672 }
<a name="l02673"></a>02673 
<a name="l02681"></a>02681 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_request_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02682"></a>02682 {
<a name="l02683"></a>02683     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02684"></a>02684     <span class="keywordtype">int</span> err;
<a name="l02685"></a>02685 
<a name="l02686"></a>02686 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l02687"></a>02687 <span class="preprocessor"></span>    DPRINTK(TX_ERR, INFO, <span class="stringliteral">&quot;numa_node before request_irq %d\n&quot;</span>,
<a name="l02688"></a>02688             dev_to_node(&amp;adapter-&gt;pdev-&gt;dev));
<a name="l02689"></a>02689 
<a name="l02690"></a>02690 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l02691"></a>02691     <span class="comment">/* map all of the rings to the q_vectors */</span>
<a name="l02692"></a>02692     ixgbe_map_rings_to_vectors(adapter);
<a name="l02693"></a>02693 
<a name="l02694"></a>02694     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l02695"></a>02695         err = ixgbe_request_msix_irqs(adapter);
<a name="l02696"></a>02696     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED)
<a name="l02697"></a>02697         err = request_irq(adapter-&gt;pdev-&gt;irq, &amp;ixgbe_intr, 0,
<a name="l02698"></a>02698                   netdev-&gt;name, netdev);
<a name="l02699"></a>02699     <span class="keywordflow">else</span>
<a name="l02700"></a>02700         err = request_irq(adapter-&gt;pdev-&gt;irq, &amp;ixgbe_intr, IRQF_SHARED,
<a name="l02701"></a>02701                   netdev-&gt;name, netdev);
<a name="l02702"></a>02702 
<a name="l02703"></a>02703     <span class="keywordflow">if</span> (err) {
<a name="l02704"></a>02704         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;request_irq failed, Error %d\n&quot;</span>, err);
<a name="l02705"></a>02705 
<a name="l02706"></a>02706         <span class="comment">/* place q_vectors and rings back into a known good state */</span>
<a name="l02707"></a>02707         ixgbe_reset_q_vectors(adapter);
<a name="l02708"></a>02708     }
<a name="l02709"></a>02709 
<a name="l02710"></a>02710     <span class="keywordflow">return</span> err;
<a name="l02711"></a>02711 }
<a name="l02712"></a>02712 
<a name="l02713"></a>02713 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_irq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02714"></a>02714 {
<a name="l02715"></a>02715     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l02716"></a>02716 
<a name="l02717"></a>02717     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l02718"></a>02718         <span class="keywordtype">int</span> i, q_vectors;
<a name="l02719"></a>02719 
<a name="l02720"></a>02720         q_vectors = adapter-&gt;num_msix_vectors;
<a name="l02721"></a>02721         i = q_vectors - 1;
<a name="l02722"></a>02722         free_irq(adapter-&gt;msix_entries[i].vector, netdev);
<a name="l02723"></a>02723         i--;
<a name="l02724"></a>02724 
<a name="l02725"></a>02725         <span class="keywordflow">for</span> (; i &gt;= 0; i--) {
<a name="l02726"></a>02726             <span class="comment">/* free only the irqs that were actually requested */</span>
<a name="l02727"></a>02727             <span class="keywordflow">if</span> (!adapter-&gt;q_vector[i]-&gt;rx_ring &amp;&amp;
<a name="l02728"></a>02728                 !adapter-&gt;q_vector[i]-&gt;tx_ring)
<a name="l02729"></a>02729                 <span class="keywordflow">continue</span>;
<a name="l02730"></a>02730 
<a name="l02731"></a>02731 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l02732"></a>02732 <span class="preprocessor"></span>            <span class="comment">/* clear the affinity_mask in the IRQ descriptor */</span>
<a name="l02733"></a>02733             irq_set_affinity_hint(adapter-&gt;msix_entries[i].vector,
<a name="l02734"></a>02734                           NULL);
<a name="l02735"></a>02735 
<a name="l02736"></a>02736 <span class="preprocessor">#endif</span>
<a name="l02737"></a>02737 <span class="preprocessor"></span>            free_irq(adapter-&gt;msix_entries[i].vector,
<a name="l02738"></a>02738                  adapter-&gt;q_vector[i]);
<a name="l02739"></a>02739         }
<a name="l02740"></a>02740     } <span class="keywordflow">else</span> {
<a name="l02741"></a>02741         free_irq(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l02742"></a>02742     }
<a name="l02743"></a>02743 
<a name="l02744"></a>02744     <span class="comment">/* clear q_vector state information */</span>
<a name="l02745"></a>02745     ixgbe_reset_q_vectors(adapter);
<a name="l02746"></a>02746 }
<a name="l02747"></a>02747 
<a name="l02752"></a>02752 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ixgbe_irq_disable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02753"></a>02753 {
<a name="l02754"></a>02754     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02755"></a>02755     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l02756"></a>02756         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, ~0);
<a name="l02757"></a>02757         <span class="keywordflow">break</span>;
<a name="l02758"></a>02758     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02759"></a>02759     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02760"></a>02760         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC, 0xFFFF0000);
<a name="l02761"></a>02761         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC_EX(0), ~0);
<a name="l02762"></a>02762         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EIMC_EX(1), ~0);
<a name="l02763"></a>02763         <span class="keywordflow">if</span> (adapter-&gt;num_vfs &gt; 32)
<a name="l02764"></a>02764             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_EITRSEL, 0);
<a name="l02765"></a>02765         <span class="keywordflow">break</span>;
<a name="l02766"></a>02766     <span class="keywordflow">default</span>:
<a name="l02767"></a>02767         <span class="keywordflow">break</span>;
<a name="l02768"></a>02768     }
<a name="l02769"></a>02769     IXGBE_WRITE_FLUSH(&amp;adapter-&gt;hw);
<a name="l02770"></a>02770     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l02771"></a>02771         <span class="keywordtype">int</span> i;
<a name="l02772"></a>02772         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_msix_vectors; i++)
<a name="l02773"></a>02773             synchronize_irq(adapter-&gt;msix_entries[i].vector);
<a name="l02774"></a>02774     } <span class="keywordflow">else</span> {
<a name="l02775"></a>02775         synchronize_irq(adapter-&gt;pdev-&gt;irq);
<a name="l02776"></a>02776     }
<a name="l02777"></a>02777 }
<a name="l02778"></a>02778 
<a name="l02783"></a>02783 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_msi_and_legacy(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02784"></a>02784 {
<a name="l02785"></a>02785     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02786"></a>02786 
<a name="l02787"></a>02787     IXGBE_WRITE_REG(hw, IXGBE_EITR(0),
<a name="l02788"></a>02788             EITR_INTS_PER_SEC_TO_REG(adapter-&gt;rx_eitr_param));
<a name="l02789"></a>02789 
<a name="l02790"></a>02790     ixgbe_set_ivar(adapter, 0, 0, 0);
<a name="l02791"></a>02791     ixgbe_set_ivar(adapter, 1, 0, 0);
<a name="l02792"></a>02792 
<a name="l02793"></a>02793     DPRINTK(HW, INFO, <span class="stringliteral">&quot;Legacy interrupt IVAR setup done\n&quot;</span>);
<a name="l02794"></a>02794 }
<a name="l02795"></a>02795 
<a name="l02803"></a>02803 <span class="keywordtype">void</span> ixgbe_configure_tx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02804"></a>02804                  <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l02805"></a>02805 {
<a name="l02806"></a>02806     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02807"></a>02807     u64 tdba = ring-&gt;dma;
<a name="l02808"></a>02808     <span class="keywordtype">int</span> wait_loop = 10;
<a name="l02809"></a>02809     u32 txdctl = IXGBE_TXDCTL_ENABLE;
<a name="l02810"></a>02810     u8 reg_idx = ring-&gt;reg_idx;
<a name="l02811"></a>02811 
<a name="l02812"></a>02812     <span class="comment">/* disable queue to avoid issues while updating state */</span>
<a name="l02813"></a>02813     IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), 0);
<a name="l02814"></a>02814     IXGBE_WRITE_FLUSH(hw);
<a name="l02815"></a>02815 
<a name="l02816"></a>02816     IXGBE_WRITE_REG(hw, IXGBE_TDBAL(reg_idx),
<a name="l02817"></a>02817             (tdba &amp; DMA_BIT_MASK(32)));
<a name="l02818"></a>02818     IXGBE_WRITE_REG(hw, IXGBE_TDBAH(reg_idx), (tdba &gt;&gt; 32));
<a name="l02819"></a>02819     IXGBE_WRITE_REG(hw, IXGBE_TDLEN(reg_idx),
<a name="l02820"></a>02820             ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a>));
<a name="l02821"></a>02821     IXGBE_WRITE_REG(hw, IXGBE_TDH(reg_idx), 0);
<a name="l02822"></a>02822     IXGBE_WRITE_REG(hw, IXGBE_TDT(reg_idx), 0);
<a name="l02823"></a>02823     ring-&gt;tail = hw-&gt;hw_addr + IXGBE_TDT(reg_idx);
<a name="l02824"></a>02824 
<a name="l02825"></a>02825     <span class="comment">/*</span>
<a name="l02826"></a>02826 <span class="comment">     * set WTHRESH to encourage burst writeback, it should not be set</span>
<a name="l02827"></a>02827 <span class="comment">     * higher than 1 when ITR is 0 as it could cause false TX hangs</span>
<a name="l02828"></a>02828 <span class="comment">     *</span>
<a name="l02829"></a>02829 <span class="comment">     * In order to avoid issues WTHRESH + PTHRESH should always be equal</span>
<a name="l02830"></a>02830 <span class="comment">     * to or less than the number of on chip descriptors, which is</span>
<a name="l02831"></a>02831 <span class="comment">     * currently 40.</span>
<a name="l02832"></a>02832 <span class="comment">     */</span>
<a name="l02833"></a>02833     <span class="comment">/* AHD - what about tx_itr_setting when using seperate TX/RX queues? */</span>
<a name="l02834"></a>02834     <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting == 0)
<a name="l02835"></a>02835         txdctl |= (1 &lt;&lt; 16);    <span class="comment">/* WTHRESH = 1 */</span>
<a name="l02836"></a>02836     <span class="keywordflow">else</span>
<a name="l02837"></a>02837         txdctl |= (8 &lt;&lt; 16);    <span class="comment">/* WTHRESH = 8 */</span>
<a name="l02838"></a>02838 
<a name="l02839"></a>02839     <span class="comment">/* PTHRESH=32 is needed to avoid a Tx hang with DFP enabled. */</span>
<a name="l02840"></a>02840     txdctl |= (1 &lt;&lt; 8) |    <span class="comment">/* HTHRESH = 1 */</span>
<a name="l02841"></a>02841            32;      <span class="comment">/* PTHRESH = 32 */</span>
<a name="l02842"></a>02842 
<a name="l02843"></a>02843     <span class="comment">/* reinitialize flowdirector state */</span>
<a name="l02844"></a>02844     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) &amp;&amp;
<a name="l02845"></a>02845         adapter-&gt;atr_sample_rate) {
<a name="l02846"></a>02846         ring-&gt;atr_sample_rate = adapter-&gt;atr_sample_rate;
<a name="l02847"></a>02847         ring-&gt;atr_count = 0;
<a name="l02848"></a>02848         set_bit(__IXGBE_TX_FDIR_INIT_DONE, &amp;ring-&gt;state);
<a name="l02849"></a>02849     } <span class="keywordflow">else</span> {
<a name="l02850"></a>02850         ring-&gt;atr_sample_rate = 0;
<a name="l02851"></a>02851     }
<a name="l02852"></a>02852 
<a name="l02853"></a>02853     clear_bit(__IXGBE_HANG_CHECK_ARMED, &amp;ring-&gt;state);
<a name="l02854"></a>02854 
<a name="l02855"></a>02855     <span class="comment">/* enable queue */</span>
<a name="l02856"></a>02856     IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), txdctl);
<a name="l02857"></a>02857 
<a name="l02858"></a>02858     <span class="comment">/* TXDCTL.EN will return 0 on 82598 if link is down, so skip it */</span>
<a name="l02859"></a>02859     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB &amp;&amp;
<a name="l02860"></a>02860         !(IXGBE_READ_REG(hw, IXGBE_LINKS) &amp; IXGBE_LINKS_UP))
<a name="l02861"></a>02861         <span class="keywordflow">return</span>;
<a name="l02862"></a>02862 
<a name="l02863"></a>02863     <span class="comment">/* poll to verify queue is enabled */</span>
<a name="l02864"></a>02864     <span class="keywordflow">do</span> {
<a name="l02865"></a>02865         msleep(1);
<a name="l02866"></a>02866         txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(reg_idx));
<a name="l02867"></a>02867     } <span class="keywordflow">while</span> (--wait_loop &amp;&amp; !(txdctl &amp; IXGBE_TXDCTL_ENABLE));
<a name="l02868"></a>02868     <span class="keywordflow">if</span> (!wait_loop)
<a name="l02869"></a>02869         DPRINTK(DRV, ERR, <span class="stringliteral">&quot;Could not enable Tx Queue %d\n&quot;</span>, reg_idx);
<a name="l02870"></a>02870 }
<a name="l02871"></a>02871 
<a name="l02872"></a>02872 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_mtqc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02873"></a>02873 {
<a name="l02874"></a>02874     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02875"></a>02875     u32 rttdcs;
<a name="l02876"></a>02876     u32 mask;
<a name="l02877"></a>02877 
<a name="l02878"></a>02878     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l02879"></a>02879         <span class="keywordflow">return</span>;
<a name="l02880"></a>02880 
<a name="l02881"></a>02881     <span class="comment">/* disable the arbiter while setting MTQC */</span>
<a name="l02882"></a>02882     rttdcs = IXGBE_READ_REG(hw, IXGBE_RTTDCS);
<a name="l02883"></a>02883     rttdcs |= IXGBE_RTTDCS_ARBDIS;
<a name="l02884"></a>02884     IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, rttdcs);
<a name="l02885"></a>02885 
<a name="l02886"></a>02886     <span class="comment">/* set transmit pool layout */</span>
<a name="l02887"></a>02887     mask = IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_VMDQ_ENABLED;
<a name="l02888"></a>02888     mask |= IXGBE_FLAG_DCB_ENABLED;
<a name="l02889"></a>02889     <span class="keywordflow">switch</span> (adapter-&gt;flags &amp; mask) {
<a name="l02890"></a>02890 
<a name="l02891"></a>02891     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l02892"></a>02892     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED):
<a name="l02893"></a>02893     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l02894"></a>02894         IXGBE_WRITE_REG(hw, IXGBE_MTQC,
<a name="l02895"></a>02895                 (IXGBE_MTQC_VT_ENA | IXGBE_MTQC_64VF));
<a name="l02896"></a>02896         <span class="keywordflow">break</span>;
<a name="l02897"></a>02897     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_DCB_ENABLED):
<a name="l02898"></a>02898     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_DCB_ENABLED):
<a name="l02899"></a>02899     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED | IXGBE_FLAG_VMDQ_ENABLED
<a name="l02900"></a>02900                  | IXGBE_FLAG_DCB_ENABLED):
<a name="l02901"></a>02901         IXGBE_WRITE_REG(hw, IXGBE_MTQC,
<a name="l02902"></a>02902                 (IXGBE_MTQC_RT_ENA
<a name="l02903"></a>02903                     | IXGBE_MTQC_VT_ENA
<a name="l02904"></a>02904                     | IXGBE_MTQC_4TC_4TQ));
<a name="l02905"></a>02905         <span class="keywordflow">break</span>;
<a name="l02906"></a>02906 
<a name="l02907"></a>02907     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED):
<a name="l02908"></a>02908         IXGBE_WRITE_REG(hw, IXGBE_MTQC,
<a name="l02909"></a>02909                 IXGBE_MTQC_RT_ENA | IXGBE_MTQC_8TC_8TQ);
<a name="l02910"></a>02910         <span class="keywordflow">break</span>;
<a name="l02911"></a>02911 
<a name="l02912"></a>02912     <span class="keywordflow">default</span>:
<a name="l02913"></a>02913         IXGBE_WRITE_REG(hw, IXGBE_MTQC, IXGBE_MTQC_64Q_1PB);
<a name="l02914"></a>02914         <span class="keywordflow">break</span>;
<a name="l02915"></a>02915     }
<a name="l02916"></a>02916 
<a name="l02917"></a>02917     <span class="comment">/* re-enable the arbiter */</span>
<a name="l02918"></a>02918     rttdcs &amp;= ~IXGBE_RTTDCS_ARBDIS;
<a name="l02919"></a>02919     IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, rttdcs);
<a name="l02920"></a>02920 }
<a name="l02921"></a>02921 
<a name="l02928"></a>02928 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l02929"></a>02929 {
<a name="l02930"></a>02930     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l02931"></a>02931     u32 dmatxctl;
<a name="l02932"></a>02932     u32 i;
<a name="l02933"></a>02933 
<a name="l02934"></a>02934 <span class="preprocessor">#ifdef CONFIG_NETDEVICES_MULTIQUEUE</span>
<a name="l02935"></a>02935 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;num_tx_queues &gt; 1)
<a name="l02936"></a>02936         adapter-&gt;netdev-&gt;features |= NETIF_F_MULTI_QUEUE;
<a name="l02937"></a>02937     <span class="keywordflow">else</span>
<a name="l02938"></a>02938         adapter-&gt;netdev-&gt;features &amp;= ~NETIF_F_MULTI_QUEUE;
<a name="l02939"></a>02939 
<a name="l02940"></a>02940 <span class="preprocessor">#endif</span>
<a name="l02941"></a>02941 <span class="preprocessor"></span>    ixgbe_setup_mtqc(adapter);
<a name="l02942"></a>02942 
<a name="l02943"></a>02943     <span class="keywordflow">if</span> (hw-&gt;mac.type != ixgbe_mac_82598EB) {
<a name="l02944"></a>02944         <span class="comment">/* DMATXCTL.EN must be before Tx queues are enabled */</span>
<a name="l02945"></a>02945         dmatxctl = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);
<a name="l02946"></a>02946         dmatxctl |= IXGBE_DMATXCTL_TE;
<a name="l02947"></a>02947         IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, dmatxctl);
<a name="l02948"></a>02948     }
<a name="l02949"></a>02949 
<a name="l02950"></a>02950     <span class="comment">/* Setup the HW Tx Head and Tail descriptor pointers */</span>
<a name="l02951"></a>02951     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l02952"></a>02952         ixgbe_configure_tx_ring(adapter, adapter-&gt;tx_ring[i]);
<a name="l02953"></a>02953 }
<a name="l02954"></a>02954 
<a name="l02955"></a>02955 <span class="preprocessor">#define IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT 2</span>
<a name="l02956"></a>02956 <span class="preprocessor"></span>
<a name="l02957"></a>02957 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_srrctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l02958"></a>02958                    <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l02959"></a>02959 {
<a name="l02960"></a>02960     u32 srrctl;
<a name="l02961"></a>02961     u8 reg_idx = rx_ring-&gt;reg_idx;
<a name="l02962"></a>02962 
<a name="l02963"></a>02963     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l02964"></a>02964     <span class="keywordflow">case</span> ixgbe_mac_82598EB: {
<a name="l02965"></a>02965         <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *feature = adapter-&gt;ring_feature;
<a name="l02966"></a>02966         <span class="comment">/* program one srrctl register per VMDq index */</span>
<a name="l02967"></a>02967         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l02968"></a>02968             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask;
<a name="l02969"></a>02969             <span class="keywordtype">long</span> shift, len;
<a name="l02970"></a>02970             mask = (<span class="keywordtype">unsigned</span> long) feature[RING_F_VMDQ].mask;
<a name="l02971"></a>02971             len = <span class="keyword">sizeof</span>(feature[RING_F_VMDQ].mask) * 8;
<a name="l02972"></a>02972             shift = find_first_bit(&amp;mask, len);
<a name="l02973"></a>02973             reg_idx = (reg_idx &amp; mask) &gt;&gt; shift;
<a name="l02974"></a>02974         } <span class="keywordflow">else</span> {
<a name="l02975"></a>02975             <span class="comment">/*</span>
<a name="l02976"></a>02976 <span class="comment">             * if VMDq is not active we must program one srrctl</span>
<a name="l02977"></a>02977 <span class="comment">             * register per RSS queue since we have enabled</span>
<a name="l02978"></a>02978 <span class="comment">             * RDRXCTL.MVMEN</span>
<a name="l02979"></a>02979 <span class="comment">             */</span>
<a name="l02980"></a>02980             <span class="keyword">const</span> <span class="keywordtype">int</span> mask = feature[RING_F_RSS].mask;
<a name="l02981"></a>02981             reg_idx = reg_idx &amp; mask;
<a name="l02982"></a>02982         }
<a name="l02983"></a>02983     }
<a name="l02984"></a>02984         <span class="keywordflow">break</span>;
<a name="l02985"></a>02985     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l02986"></a>02986     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l02987"></a>02987     <span class="keywordflow">default</span>:
<a name="l02988"></a>02988         <span class="keywordflow">break</span>;
<a name="l02989"></a>02989     }
<a name="l02990"></a>02990 
<a name="l02991"></a>02991     srrctl = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_SRRCTL(reg_idx));
<a name="l02992"></a>02992 
<a name="l02993"></a>02993     srrctl &amp;= ~IXGBE_SRRCTL_BSIZEHDR_MASK;
<a name="l02994"></a>02994     srrctl &amp;= ~IXGBE_SRRCTL_BSIZEPKT_MASK;
<a name="l02995"></a>02995     <span class="keywordflow">if</span> (adapter-&gt;num_vfs)
<a name="l02996"></a>02996         srrctl |= IXGBE_SRRCTL_DROP_EN;
<a name="l02997"></a>02997 
<a name="l02998"></a>02998     srrctl |= (IXGBE_RX_HDR_SIZE &lt;&lt; IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT) &amp;
<a name="l02999"></a>02999            IXGBE_SRRCTL_BSIZEHDR_MASK;
<a name="l03000"></a>03000 
<a name="l03001"></a>03001     <span class="keywordflow">if</span> (ring_is_ps_enabled(rx_ring)) {
<a name="l03002"></a>03002 <span class="preprocessor">#if (PAGE_SIZE / 2) &gt; IXGBE_MAX_RXBUFFER</span>
<a name="l03003"></a>03003 <span class="preprocessor"></span>        srrctl |= IXGBE_MAX_RXBUFFER &gt;&gt; IXGBE_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03004"></a>03004 <span class="preprocessor">#else</span>
<a name="l03005"></a>03005 <span class="preprocessor"></span>        srrctl |= (PAGE_SIZE / 2) &gt;&gt; IXGBE_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03006"></a>03006 <span class="preprocessor">#endif</span>
<a name="l03007"></a>03007 <span class="preprocessor"></span>        srrctl |= IXGBE_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS;
<a name="l03008"></a>03008     } <span class="keywordflow">else</span> {
<a name="l03009"></a>03009         srrctl |= ALIGN(rx_ring-&gt;rx_buf_len, 1024) &gt;&gt;
<a name="l03010"></a>03010                   IXGBE_SRRCTL_BSIZEPKT_SHIFT;
<a name="l03011"></a>03011         srrctl |= IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF;
<a name="l03012"></a>03012     }
<a name="l03013"></a>03013 
<a name="l03014"></a>03014     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_SRRCTL(reg_idx), srrctl);
<a name="l03015"></a>03015 }
<a name="l03016"></a>03016 
<a name="l03017"></a>03017 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_mrqc(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03018"></a>03018 {
<a name="l03019"></a>03019     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03020"></a>03020     <span class="keyword">static</span> <span class="keyword">const</span> u32 seed[10] = { 0xE291D73D, 0x1805EC6C, 0x2A94B30D,
<a name="l03021"></a>03021               0xA54F2BEC, 0xEA49AF7C, 0xE214AD3D, 0xB855AABE,
<a name="l03022"></a>03022               0x6A3E67EA, 0x14364D17, 0x3BED200D};
<a name="l03023"></a>03023     u32 mrqc = 0, reta = 0;
<a name="l03024"></a>03024     u32 rxcsum;
<a name="l03025"></a>03025     <span class="keywordtype">int</span> i, j;
<a name="l03026"></a>03026     <span class="keywordtype">int</span> mask;
<a name="l03027"></a>03027 
<a name="l03028"></a>03028     <span class="comment">/* Fill out hash function seeds */</span>
<a name="l03029"></a>03029     <span class="keywordflow">for</span> (i = 0; i &lt; 10; i++)
<a name="l03030"></a>03030         IXGBE_WRITE_REG(hw, IXGBE_RSSRK(i), seed[i]);
<a name="l03031"></a>03031 
<a name="l03032"></a>03032     <span class="comment">/* Fill out redirection table */</span>
<a name="l03033"></a>03033     <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; 128; i++, j++) {
<a name="l03034"></a>03034         <span class="keywordflow">if</span> (j == adapter-&gt;ring_feature[RING_F_RSS].indices)
<a name="l03035"></a>03035             j = 0;
<a name="l03036"></a>03036         <span class="comment">/* reta = 4-byte sliding window of</span>
<a name="l03037"></a>03037 <span class="comment">         * 0x00..(indices-1)(indices-1)00..etc. */</span>
<a name="l03038"></a>03038         reta = (reta &lt;&lt; 8) | (j * 0x11);
<a name="l03039"></a>03039         <span class="keywordflow">if</span> ((i &amp; 3) == 3)
<a name="l03040"></a>03040             IXGBE_WRITE_REG(hw, IXGBE_RETA(i &gt;&gt; 2), reta);
<a name="l03041"></a>03041     }
<a name="l03042"></a>03042 
<a name="l03043"></a>03043     <span class="comment">/* Disable indicating checksum in descriptor, enables RSS hash */</span>
<a name="l03044"></a>03044     rxcsum = IXGBE_READ_REG(hw, IXGBE_RXCSUM);
<a name="l03045"></a>03045     rxcsum |= IXGBE_RXCSUM_PCSD;
<a name="l03046"></a>03046     IXGBE_WRITE_REG(hw, IXGBE_RXCSUM, rxcsum);
<a name="l03047"></a>03047 
<a name="l03048"></a>03048     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l03049"></a>03049         mask = adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED;
<a name="l03050"></a>03050     <span class="keywordflow">else</span>
<a name="l03051"></a>03051         mask = adapter-&gt;flags &amp; (IXGBE_FLAG_RSS_ENABLED
<a name="l03052"></a>03052                      | IXGBE_FLAG_DCB_ENABLED
<a name="l03053"></a>03053                      | IXGBE_FLAG_VMDQ_ENABLED
<a name="l03054"></a>03054                      | IXGBE_FLAG_SRIOV_ENABLED
<a name="l03055"></a>03055                     );
<a name="l03056"></a>03056 
<a name="l03057"></a>03057     <span class="keywordflow">switch</span> (mask) {
<a name="l03058"></a>03058     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED):
<a name="l03059"></a>03059         mrqc = IXGBE_MRQC_RSSEN;
<a name="l03060"></a>03060         <span class="keywordflow">break</span>;
<a name="l03061"></a>03061     <span class="keywordflow">case</span> (IXGBE_FLAG_SRIOV_ENABLED):
<a name="l03062"></a>03062         mrqc = IXGBE_MRQC_VMDQEN;
<a name="l03063"></a>03063         <span class="keywordflow">break</span>;
<a name="l03064"></a>03064     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l03065"></a>03065     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_SRIOV_ENABLED):
<a name="l03066"></a>03066         mrqc = IXGBE_MRQC_VMDQEN;
<a name="l03067"></a>03067         <span class="keywordflow">break</span>;
<a name="l03068"></a>03068     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l03069"></a>03069         <span class="keywordflow">if</span> (adapter-&gt;ring_feature[RING_F_RSS].indices == 4)
<a name="l03070"></a>03070             mrqc = IXGBE_MRQC_VMDQRSS32EN;
<a name="l03071"></a>03071         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;ring_feature[RING_F_RSS].indices == 2)
<a name="l03072"></a>03072             mrqc = IXGBE_MRQC_VMDQRSS64EN;
<a name="l03073"></a>03073         <span class="keywordflow">else</span>
<a name="l03074"></a>03074             mrqc = IXGBE_MRQC_VMDQEN;
<a name="l03075"></a>03075         <span class="keywordflow">break</span>;
<a name="l03076"></a>03076     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l03077"></a>03077     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED | IXGBE_FLAG_VMDQ_ENABLED
<a name="l03078"></a>03078                 | IXGBE_FLAG_SRIOV_ENABLED):
<a name="l03079"></a>03079         mrqc = IXGBE_MRQC_VMDQRT4TCEN;  <span class="comment">/* 4 TCs */</span>
<a name="l03080"></a>03080         <span class="keywordflow">break</span>;
<a name="l03081"></a>03081     <span class="keywordflow">case</span> (IXGBE_FLAG_DCB_ENABLED):
<a name="l03082"></a>03082         mrqc = IXGBE_MRQC_RT8TCEN;
<a name="l03083"></a>03083         <span class="keywordflow">break</span>;
<a name="l03084"></a>03084     <span class="keywordflow">default</span>:
<a name="l03085"></a>03085         <span class="keywordflow">break</span>;
<a name="l03086"></a>03086     }
<a name="l03087"></a>03087 
<a name="l03088"></a>03088     <span class="comment">/* Perform hash on these packet types */</span>
<a name="l03089"></a>03089     mrqc |= IXGBE_MRQC_RSS_FIELD_IPV4
<a name="l03090"></a>03090           | IXGBE_MRQC_RSS_FIELD_IPV4_TCP
<a name="l03091"></a>03091               | IXGBE_MRQC_RSS_FIELD_IPV4_UDP <span class="comment">/* L.Deri */</span>
<a name="l03092"></a>03092           | IXGBE_MRQC_RSS_FIELD_IPV6
<a name="l03093"></a>03093           | IXGBE_MRQC_RSS_FIELD_IPV6_TCP;
<a name="l03094"></a>03094 
<a name="l03095"></a>03095     IXGBE_WRITE_REG(hw, IXGBE_MRQC, mrqc);
<a name="l03096"></a>03096 }
<a name="l03097"></a>03097 
<a name="l03103"></a>03103 <span class="keywordtype">void</span> ixgbe_configure_rscctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03104"></a>03104                 <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03105"></a>03105 {
<a name="l03106"></a>03106     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03107"></a>03107     u32 rscctrl;
<a name="l03108"></a>03108     <span class="keywordtype">int</span> rx_buf_len;
<a name="l03109"></a>03109     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03110"></a>03110 
<a name="l03111"></a>03111     <span class="keywordflow">if</span> (!ring_is_rsc_enabled(ring))
<a name="l03112"></a>03112         <span class="keywordflow">return</span>;
<a name="l03113"></a>03113 
<a name="l03114"></a>03114     rx_buf_len = ring-&gt;rx_buf_len;
<a name="l03115"></a>03115     rscctrl = IXGBE_READ_REG(hw, IXGBE_RSCCTL(reg_idx));
<a name="l03116"></a>03116     rscctrl |= IXGBE_RSCCTL_RSCEN;
<a name="l03117"></a>03117     <span class="comment">/*</span>
<a name="l03118"></a>03118 <span class="comment">     * we must limit the number of descriptors so that</span>
<a name="l03119"></a>03119 <span class="comment">     * the total size of max desc * buf_len is not greater</span>
<a name="l03120"></a>03120 <span class="comment">     * than 65535</span>
<a name="l03121"></a>03121 <span class="comment">     */</span>
<a name="l03122"></a>03122     <span class="keywordflow">if</span> (ring_is_ps_enabled(ring)) {
<a name="l03123"></a>03123 <span class="preprocessor">#if (MAX_SKB_FRAGS &gt; 16)</span>
<a name="l03124"></a>03124 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_16;
<a name="l03125"></a>03125 <span class="preprocessor">#elif (MAX_SKB_FRAGS &gt; 8)</span>
<a name="l03126"></a>03126 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_8;
<a name="l03127"></a>03127 <span class="preprocessor">#elif (MAX_SKB_FRAGS &gt; 4)</span>
<a name="l03128"></a>03128 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_4;
<a name="l03129"></a>03129 <span class="preprocessor">#else</span>
<a name="l03130"></a>03130 <span class="preprocessor"></span>        rscctrl |= IXGBE_RSCCTL_MAXDESC_1;
<a name="l03131"></a>03131 <span class="preprocessor">#endif</span>
<a name="l03132"></a>03132 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l03133"></a>03133         <span class="keywordflow">if</span> (rx_buf_len &lt; IXGBE_RXBUFFER_4096)
<a name="l03134"></a>03134             rscctrl |= IXGBE_RSCCTL_MAXDESC_16;
<a name="l03135"></a>03135         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rx_buf_len &lt; IXGBE_RXBUFFER_8192)
<a name="l03136"></a>03136             rscctrl |= IXGBE_RSCCTL_MAXDESC_8;
<a name="l03137"></a>03137         <span class="keywordflow">else</span>
<a name="l03138"></a>03138             rscctrl |= IXGBE_RSCCTL_MAXDESC_4;
<a name="l03139"></a>03139     }
<a name="l03140"></a>03140 
<a name="l03141"></a>03141     IXGBE_WRITE_REG(hw, IXGBE_RSCCTL(reg_idx), rscctrl);
<a name="l03142"></a>03142 }
<a name="l03143"></a>03143 
<a name="l03149"></a>03149 <span class="keywordtype">void</span> ixgbe_clear_rscctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03150"></a>03150             <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03151"></a>03151 {
<a name="l03152"></a>03152     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03153"></a>03153     u32 rscctrl;
<a name="l03154"></a>03154     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03155"></a>03155 
<a name="l03156"></a>03156     rscctrl = IXGBE_READ_REG(hw, IXGBE_RSCCTL(reg_idx));
<a name="l03157"></a>03157     rscctrl &amp;= ~IXGBE_RSCCTL_RSCEN;
<a name="l03158"></a>03158     IXGBE_WRITE_REG(hw, IXGBE_RSCCTL(reg_idx), rscctrl);
<a name="l03159"></a>03159 
<a name="l03160"></a>03160     clear_ring_rsc_enabled(ring);
<a name="l03161"></a>03161 }
<a name="l03162"></a>03162 
<a name="l03173"></a>03173 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_uta(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03174"></a>03174 {
<a name="l03175"></a>03175     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03176"></a>03176     <span class="keywordtype">int</span> i;
<a name="l03177"></a>03177 
<a name="l03178"></a>03178     <span class="comment">/* The UTA table only exists on 82599 hardware and newer */</span>
<a name="l03179"></a>03179     <span class="keywordflow">if</span> (hw-&gt;mac.type &lt; ixgbe_mac_82599EB)
<a name="l03180"></a>03180         <span class="keywordflow">return</span>;
<a name="l03181"></a>03181 
<a name="l03182"></a>03182     <span class="comment">/* we only need to do this if VMDq is enabled */</span>
<a name="l03183"></a>03183     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp;
<a name="l03184"></a>03184           (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_SRIOV_ENABLED)))
<a name="l03185"></a>03185         <span class="keywordflow">return</span>;
<a name="l03186"></a>03186 
<a name="l03187"></a>03187     <span class="keywordflow">for</span> (i = 0; i &lt; 128; i++)
<a name="l03188"></a>03188         IXGBE_WRITE_REG(hw, IXGBE_UTA(i), ~0);
<a name="l03189"></a>03189 }
<a name="l03190"></a>03190 
<a name="l03191"></a>03191 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_rx_desc_queue_enable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03192"></a>03192                <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03193"></a>03193 {
<a name="l03194"></a>03194     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03195"></a>03195     <span class="keywordtype">int</span> wait_loop = IXGBE_MAX_RX_DESC_POLL;
<a name="l03196"></a>03196     u32 rxdctl;
<a name="l03197"></a>03197     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03198"></a>03198 
<a name="l03199"></a>03199     <span class="comment">/* RXDCTL.EN will return 0 on 82598 if link is down, so skip it */</span>
<a name="l03200"></a>03200     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB &amp;&amp;
<a name="l03201"></a>03201         !(IXGBE_READ_REG(hw, IXGBE_LINKS) &amp; IXGBE_LINKS_UP))
<a name="l03202"></a>03202         <span class="keywordflow">return</span>;
<a name="l03203"></a>03203 
<a name="l03204"></a>03204     <span class="keywordflow">do</span> {
<a name="l03205"></a>03205         msleep(1);
<a name="l03206"></a>03206         rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03207"></a>03207     } <span class="keywordflow">while</span> (--wait_loop &amp;&amp; !(rxdctl &amp; IXGBE_RXDCTL_ENABLE));
<a name="l03208"></a>03208 
<a name="l03209"></a>03209     <span class="keywordflow">if</span> (!wait_loop) {
<a name="l03210"></a>03210         DPRINTK(DRV, ERR, <span class="stringliteral">&quot;RXDCTL.ENABLE on Rx queue %d &quot;</span>
<a name="l03211"></a>03211                 <span class="stringliteral">&quot;not set within the polling period\n&quot;</span>, reg_idx);
<a name="l03212"></a>03212     }
<a name="l03213"></a>03213 }
<a name="l03214"></a>03214 
<a name="l03215"></a>03215 <span class="keywordtype">void</span> ixgbe_disable_rx_queue(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03216"></a>03216                 <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03217"></a>03217 {
<a name="l03218"></a>03218     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03219"></a>03219     <span class="keywordtype">int</span> wait_loop = IXGBE_MAX_RX_DESC_POLL;
<a name="l03220"></a>03220     u32 rxdctl;
<a name="l03221"></a>03221     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03222"></a>03222 
<a name="l03223"></a>03223     rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03224"></a>03224     rxdctl &amp;= ~IXGBE_RXDCTL_ENABLE;
<a name="l03225"></a>03225 
<a name="l03226"></a>03226     <span class="comment">/* write value back with RXDCTL.ENABLE bit cleared */</span>
<a name="l03227"></a>03227     IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
<a name="l03228"></a>03228 
<a name="l03229"></a>03229     <span class="comment">/* RXDCTL.EN will return 0 on 82598 if link is down, so skip it */</span>
<a name="l03230"></a>03230     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB &amp;&amp;
<a name="l03231"></a>03231         !(IXGBE_READ_REG(hw, IXGBE_LINKS) &amp; IXGBE_LINKS_UP))
<a name="l03232"></a>03232         <span class="keywordflow">return</span>;
<a name="l03233"></a>03233     
<a name="l03234"></a>03234     <span class="comment">/* the hardware may take up to 100us to really disable the rx queue */</span>
<a name="l03235"></a>03235     <span class="keywordflow">do</span> {
<a name="l03236"></a>03236         udelay(10);
<a name="l03237"></a>03237         rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03238"></a>03238     } <span class="keywordflow">while</span> (--wait_loop &amp;&amp; (rxdctl &amp; IXGBE_RXDCTL_ENABLE));
<a name="l03239"></a>03239 
<a name="l03240"></a>03240     <span class="keywordflow">if</span> (!wait_loop) {
<a name="l03241"></a>03241         DPRINTK(DRV, ERR, <span class="stringliteral">&quot;RXDCTL.ENABLE on Rx queue %d &quot;</span>
<a name="l03242"></a>03242                 <span class="stringliteral">&quot;not cleared within the polling period\n&quot;</span>, reg_idx);
<a name="l03243"></a>03243     }
<a name="l03244"></a>03244 }
<a name="l03245"></a>03245 
<a name="l03246"></a>03246 <span class="keywordtype">void</span> ixgbe_configure_rx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l03247"></a>03247                  <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring)
<a name="l03248"></a>03248 {
<a name="l03249"></a>03249     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03250"></a>03250     u64 rdba = ring-&gt;dma;
<a name="l03251"></a>03251     u32 rxdctl;
<a name="l03252"></a>03252     u8 reg_idx = ring-&gt;reg_idx;
<a name="l03253"></a>03253 
<a name="l03254"></a>03254     <span class="comment">/* disable queue to avoid issues while updating state */</span>
<a name="l03255"></a>03255     rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03256"></a>03256     ixgbe_disable_rx_queue(adapter, ring);
<a name="l03257"></a>03257 
<a name="l03258"></a>03258     IXGBE_WRITE_REG(hw, IXGBE_RDBAL(reg_idx), (rdba &amp; DMA_BIT_MASK(32)));
<a name="l03259"></a>03259     IXGBE_WRITE_REG(hw, IXGBE_RDBAH(reg_idx), (rdba &gt;&gt; 32));
<a name="l03260"></a>03260     IXGBE_WRITE_REG(hw, IXGBE_RDLEN(reg_idx),
<a name="l03261"></a>03261             ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union</span> <a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a>));
<a name="l03262"></a>03262     IXGBE_WRITE_REG(hw, IXGBE_RDH(reg_idx), 0);
<a name="l03263"></a>03263     IXGBE_WRITE_REG(hw, IXGBE_RDT(reg_idx), 0);
<a name="l03264"></a>03264     ring-&gt;tail = hw-&gt;hw_addr + IXGBE_RDT(reg_idx);
<a name="l03265"></a>03265 
<a name="l03266"></a>03266     ixgbe_configure_srrctl(adapter, ring);
<a name="l03267"></a>03267     ixgbe_configure_rscctl(adapter, ring);
<a name="l03268"></a>03268 
<a name="l03269"></a>03269     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB) {
<a name="l03270"></a>03270         <span class="comment">/*</span>
<a name="l03271"></a>03271 <span class="comment">         * enable cache line friendly hardware writes:</span>
<a name="l03272"></a>03272 <span class="comment">         * PTHRESH=32 descriptors (half the internal cache),</span>
<a name="l03273"></a>03273 <span class="comment">         * this also removes ugly rx_no_buffer_count increment</span>
<a name="l03274"></a>03274 <span class="comment">         * HTHRESH=4 descriptors (to minimize latency on fetch)</span>
<a name="l03275"></a>03275 <span class="comment">         * WTHRESH=8 burst writeback up to two cache lines</span>
<a name="l03276"></a>03276 <span class="comment">         */</span>
<a name="l03277"></a>03277         rxdctl &amp;= ~0x3FFFFF;
<a name="l03278"></a>03278         rxdctl |=  0x080420;
<a name="l03279"></a>03279     }
<a name="l03280"></a>03280 
<a name="l03281"></a>03281     <span class="comment">/* enable receive descriptor ring */</span>
<a name="l03282"></a>03282     rxdctl |= IXGBE_RXDCTL_ENABLE;
<a name="l03283"></a>03283     IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
<a name="l03284"></a>03284 
<a name="l03285"></a>03285     ixgbe_rx_desc_queue_enable(adapter, ring);
<a name="l03286"></a>03286     ixgbe_alloc_rx_buffers(ring, IXGBE_DESC_UNUSED(ring));
<a name="l03287"></a>03287 }
<a name="l03288"></a>03288 
<a name="l03289"></a>03289 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_psrtype(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03290"></a>03290 {
<a name="l03291"></a>03291     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03292"></a>03292     <span class="keywordtype">int</span> p;
<a name="l03293"></a>03293 
<a name="l03294"></a>03294     <span class="comment">/* PSRTYPE must be initialized in non 82598 adapters */</span>
<a name="l03295"></a>03295     u32 psrtype = IXGBE_PSRTYPE_TCPHDR |
<a name="l03296"></a>03296               IXGBE_PSRTYPE_UDPHDR |
<a name="l03297"></a>03297               IXGBE_PSRTYPE_IPV4HDR |
<a name="l03298"></a>03298               IXGBE_PSRTYPE_L2HDR |
<a name="l03299"></a>03299               IXGBE_PSRTYPE_IPV6HDR;
<a name="l03300"></a>03300 
<a name="l03301"></a>03301     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l03302"></a>03302         <span class="keywordflow">return</span>;
<a name="l03303"></a>03303 
<a name="l03304"></a>03304     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED)
<a name="l03305"></a>03305         psrtype |= (adapter-&gt;num_rx_queues_per_pool &lt;&lt; 29);
<a name="l03306"></a>03306 
<a name="l03307"></a>03307     <span class="keywordflow">for</span> (p = 0; p &lt; adapter-&gt;num_rx_pools; p++)
<a name="l03308"></a>03308         IXGBE_WRITE_REG(hw, IXGBE_PSRTYPE(VMDQ_P(p)), psrtype);
<a name="l03309"></a>03309 }
<a name="l03310"></a>03310 
<a name="l03311"></a>03311 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_virtualization(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03312"></a>03312 {
<a name="l03313"></a>03313     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03314"></a>03314     u32 gcr_ext;
<a name="l03315"></a>03315     u32 vt_reg;
<a name="l03316"></a>03316     u32 vt_reg_bits;
<a name="l03317"></a>03317     u32 pool;
<a name="l03318"></a>03318     u32 vmdctl;
<a name="l03319"></a>03319 
<a name="l03320"></a>03320     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED ||
<a name="l03321"></a>03321           adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED))
<a name="l03322"></a>03322         <span class="keywordflow">return</span>;
<a name="l03323"></a>03323 
<a name="l03324"></a>03324     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03325"></a>03325     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03326"></a>03326         vt_reg = IXGBE_VMD_CTL;
<a name="l03327"></a>03327         vt_reg_bits = IXGBE_VMD_CTL_VMDQ_EN;
<a name="l03328"></a>03328         vmdctl = IXGBE_READ_REG(hw, vt_reg);
<a name="l03329"></a>03329         IXGBE_WRITE_REG(hw, vt_reg, vmdctl | vt_reg_bits);
<a name="l03330"></a>03330         <span class="keywordflow">break</span>;
<a name="l03331"></a>03331     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03332"></a>03332     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03333"></a>03333         vt_reg = IXGBE_VT_CTL;
<a name="l03334"></a>03334         vt_reg_bits = IXGBE_VMD_CTL_VMDQ_EN
<a name="l03335"></a>03335                 | IXGBE_VT_CTL_REPLEN;
<a name="l03336"></a>03336         <span class="keywordflow">if</span> (adapter-&gt;num_vfs) {
<a name="l03337"></a>03337             vt_reg_bits &amp;= ~IXGBE_VT_CTL_POOL_MASK;
<a name="l03338"></a>03338             vt_reg_bits |= (adapter-&gt;num_vfs &lt;&lt;
<a name="l03339"></a>03339                     IXGBE_VT_CTL_POOL_SHIFT);
<a name="l03340"></a>03340         }
<a name="l03341"></a>03341         vmdctl = IXGBE_READ_REG(hw, vt_reg);
<a name="l03342"></a>03342         IXGBE_WRITE_REG(hw, vt_reg, vmdctl | vt_reg_bits);
<a name="l03343"></a>03343         <span class="keywordflow">for</span> (pool = 1; pool &lt; adapter-&gt;num_rx_pools; pool++) {
<a name="l03344"></a>03344             u32 vmolr;
<a name="l03345"></a>03345             <span class="keywordtype">int</span> vmdq_pool = VMDQ_P(pool);
<a name="l03346"></a>03346 
<a name="l03347"></a>03347             <span class="comment">/*</span>
<a name="l03348"></a>03348 <span class="comment">            * accept untagged packets until a vlan tag</span>
<a name="l03349"></a>03349 <span class="comment">            * is specifically set for the VMDQ queue/pool</span>
<a name="l03350"></a>03350 <span class="comment">            */</span>
<a name="l03351"></a>03351             vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vmdq_pool));
<a name="l03352"></a>03352             vmolr |= IXGBE_VMOLR_AUPE;
<a name="l03353"></a>03353             vmolr |= IXGBE_VMOLR_BAM;
<a name="l03354"></a>03354             IXGBE_WRITE_REG(hw, IXGBE_VMOLR(vmdq_pool), vmolr);
<a name="l03355"></a>03355         }
<a name="l03356"></a>03356         IXGBE_WRITE_REG(hw, IXGBE_VFRE(0), 0xFFFFFFFF);
<a name="l03357"></a>03357         IXGBE_WRITE_REG(hw, IXGBE_VFRE(1), 0xFFFFFFFF);
<a name="l03358"></a>03358         IXGBE_WRITE_REG(hw, IXGBE_VFTE(0), 0xFFFFFFFF);
<a name="l03359"></a>03359         IXGBE_WRITE_REG(hw, IXGBE_VFTE(1), 0xFFFFFFFF);
<a name="l03360"></a>03360         <span class="keywordflow">break</span>;
<a name="l03361"></a>03361     <span class="keywordflow">default</span>:
<a name="l03362"></a>03362         <span class="keywordflow">break</span>;
<a name="l03363"></a>03363     }
<a name="l03364"></a>03364 
<a name="l03365"></a>03365     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED))
<a name="l03366"></a>03366         <span class="keywordflow">return</span>;
<a name="l03367"></a>03367 
<a name="l03368"></a>03368     <span class="comment">/* Map PF MAC address in RAR Entry 0 to first pool following VFs */</span>
<a name="l03369"></a>03369     hw-&gt;mac.ops.set_vmdq(hw, 0, adapter-&gt;num_vfs);
<a name="l03370"></a>03370 
<a name="l03371"></a>03371     <span class="comment">/*</span>
<a name="l03372"></a>03372 <span class="comment">     * Set up VF register offsets for selected VT Mode,</span>
<a name="l03373"></a>03373 <span class="comment">     * i.e. 32 or 64 VFs for SR-IOV</span>
<a name="l03374"></a>03374 <span class="comment">     */</span>
<a name="l03375"></a>03375     gcr_ext = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);
<a name="l03376"></a>03376     gcr_ext |= IXGBE_GCR_EXT_MSIX_EN;
<a name="l03377"></a>03377     gcr_ext |= IXGBE_GCR_EXT_VT_MODE_64;
<a name="l03378"></a>03378     IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr_ext);
<a name="l03379"></a>03379 
<a name="l03380"></a>03380     <span class="comment">/* enable Tx loopback for VF/PF communication */</span>
<a name="l03381"></a>03381     IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);
<a name="l03382"></a>03382 
<a name="l03383"></a>03383     hw-&gt;mac.ops.set_mac_anti_spoofing(hw, (adapter-&gt;num_vfs != 0),
<a name="l03384"></a>03384                       adapter-&gt;num_vfs);
<a name="l03385"></a>03385 }
<a name="l03386"></a>03386 
<a name="l03387"></a>03387 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_rx_buffer_len(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03388"></a>03388 {
<a name="l03389"></a>03389     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03390"></a>03390     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l03391"></a>03391     <span class="keywordtype">int</span> max_frame = netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l03392"></a>03392     <span class="keywordtype">int</span> rx_buf_len;
<a name="l03393"></a>03393     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring;
<a name="l03394"></a>03394     <span class="keywordtype">int</span> i;
<a name="l03395"></a>03395     u32 mhadd, hlreg0;
<a name="l03396"></a>03396 
<a name="l03397"></a>03397     <span class="comment">/* Decide whether to use packet split mode or not */</span>
<a name="l03398"></a>03398     <span class="keywordflow">if</span> (netdev-&gt;mtu &gt; ETH_DATA_LEN) {
<a name="l03399"></a>03399         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_PS_CAPABLE)
<a name="l03400"></a>03400             adapter-&gt;flags |= IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03401"></a>03401         <span class="keywordflow">else</span>
<a name="l03402"></a>03402             adapter-&gt;flags &amp;= ~IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03403"></a>03403     } <span class="keywordflow">else</span> {
<a name="l03404"></a>03404         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_1BUF_CAPABLE)
<a name="l03405"></a>03405             adapter-&gt;flags &amp;= ~IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03406"></a>03406         <span class="keywordflow">else</span>
<a name="l03407"></a>03407             adapter-&gt;flags |= IXGBE_FLAG_RX_PS_ENABLED;
<a name="l03408"></a>03408     }
<a name="l03409"></a>03409 
<a name="l03410"></a>03410 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l03411"></a>03411 <span class="preprocessor"></span>    <span class="comment">/* adjust max frame to be able to do baby jumbo for FCoE */</span>
<a name="l03412"></a>03412     <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) &amp;&amp;
<a name="l03413"></a>03413         (max_frame &lt; IXGBE_FCOE_JUMBO_FRAME_SIZE))
<a name="l03414"></a>03414         max_frame = IXGBE_FCOE_JUMBO_FRAME_SIZE;
<a name="l03415"></a>03415 
<a name="l03416"></a>03416 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l03417"></a>03417     mhadd = IXGBE_READ_REG(hw, IXGBE_MHADD);
<a name="l03418"></a>03418     <span class="keywordflow">if</span> (max_frame != (mhadd &gt;&gt; IXGBE_MHADD_MFS_SHIFT)) {
<a name="l03419"></a>03419         mhadd &amp;= ~IXGBE_MHADD_MFS_MASK;
<a name="l03420"></a>03420         mhadd |= max_frame &lt;&lt; IXGBE_MHADD_MFS_SHIFT;
<a name="l03421"></a>03421 
<a name="l03422"></a>03422         IXGBE_WRITE_REG(hw, IXGBE_MHADD, mhadd);
<a name="l03423"></a>03423     }
<a name="l03424"></a>03424 
<a name="l03425"></a>03425     <span class="comment">/* MHADD will allow an extra 4 bytes past for vlan tagged frames */</span>
<a name="l03426"></a>03426     max_frame += VLAN_HLEN;
<a name="l03427"></a>03427 
<a name="l03428"></a>03428     <span class="comment">/* Set the RX buffer length according to the mode */</span>
<a name="l03429"></a>03429     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_PS_ENABLED) {
<a name="l03430"></a>03430         rx_buf_len = IXGBE_RX_HDR_SIZE;
<a name="l03431"></a>03431     } <span class="keywordflow">else</span> {
<a name="l03432"></a>03432         <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) &amp;&amp;
<a name="l03433"></a>03433             (max_frame &lt;= MAXIMUM_ETHERNET_VLAN_SIZE))
<a name="l03434"></a>03434             rx_buf_len = MAXIMUM_ETHERNET_VLAN_SIZE;
<a name="l03435"></a>03435         <span class="keywordflow">else</span>
<a name="l03436"></a>03436             rx_buf_len = ALIGN(max_frame, 1024);
<a name="l03437"></a>03437     }
<a name="l03438"></a>03438 
<a name="l03439"></a>03439     hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
<a name="l03440"></a>03440     <span class="comment">/* set jumbo enable since MHADD.MFS is keeping size locked at max_frame */</span>
<a name="l03441"></a>03441     hlreg0 |= IXGBE_HLREG0_JUMBOEN;
<a name="l03442"></a>03442     IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
<a name="l03443"></a>03443 
<a name="l03444"></a>03444     <span class="comment">/*</span>
<a name="l03445"></a>03445 <span class="comment">     * Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<a name="l03446"></a>03446 <span class="comment">     * the Base and Length of the Rx Descriptor Ring</span>
<a name="l03447"></a>03447 <span class="comment">     */</span>
<a name="l03448"></a>03448     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l03449"></a>03449         rx_ring = adapter-&gt;rx_ring[i];
<a name="l03450"></a>03450         rx_ring-&gt;rx_buf_len = rx_buf_len;
<a name="l03451"></a>03451 
<a name="l03452"></a>03452         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RX_PS_ENABLED)
<a name="l03453"></a>03453             set_ring_ps_enabled(rx_ring);
<a name="l03454"></a>03454         <span class="keywordflow">else</span>
<a name="l03455"></a>03455             clear_ring_ps_enabled(rx_ring);
<a name="l03456"></a>03456 
<a name="l03457"></a>03457         <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l03458"></a>03458             set_ring_rsc_enabled(rx_ring);
<a name="l03459"></a>03459 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l03460"></a>03460 <span class="preprocessor"></span>            clear_ring_lro_enabled(rx_ring);
<a name="l03461"></a>03461         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED) {
<a name="l03462"></a>03462             set_ring_lro_enabled(rx_ring);
<a name="l03463"></a>03463             clear_ring_rsc_enabled(rx_ring);
<a name="l03464"></a>03464         } <span class="keywordflow">else</span> {
<a name="l03465"></a>03465             clear_ring_lro_enabled(rx_ring);
<a name="l03466"></a>03466 <span class="preprocessor">#else</span>
<a name="l03467"></a>03467 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l03468"></a>03468 <span class="preprocessor">#endif</span>
<a name="l03469"></a>03469 <span class="preprocessor"></span>            clear_ring_rsc_enabled(rx_ring);
<a name="l03470"></a>03470         }
<a name="l03471"></a>03471 
<a name="l03472"></a>03472 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l03473"></a>03473 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (netdev-&gt;features &amp; NETIF_F_FCOE_MTU) {
<a name="l03474"></a>03474             <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f;
<a name="l03475"></a>03475             f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l03476"></a>03476             <span class="keywordflow">if</span> ((i &gt;= f-&gt;mask) &amp;&amp; (i &lt; f-&gt;mask + f-&gt;indices)) {
<a name="l03477"></a>03477                 clear_ring_ps_enabled(rx_ring);
<a name="l03478"></a>03478                 <span class="keywordflow">if</span> (rx_buf_len &lt; IXGBE_FCOE_JUMBO_FRAME_SIZE)
<a name="l03479"></a>03479                     rx_ring-&gt;rx_buf_len =
<a name="l03480"></a>03480                             IXGBE_FCOE_JUMBO_FRAME_SIZE;
<a name="l03481"></a>03481             }
<a name="l03482"></a>03482         }
<a name="l03483"></a>03483 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l03484"></a>03484     }
<a name="l03485"></a>03485 }
<a name="l03486"></a>03486 
<a name="l03487"></a>03487 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_rdrxctl(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03488"></a>03488 {
<a name="l03489"></a>03489     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03490"></a>03490     u32 rdrxctl = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
<a name="l03491"></a>03491 
<a name="l03492"></a>03492     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03493"></a>03493     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03494"></a>03494         <span class="comment">/*</span>
<a name="l03495"></a>03495 <span class="comment">         * For VMDq support of different descriptor types or</span>
<a name="l03496"></a>03496 <span class="comment">         * buffer sizes through the use of multiple SRRCTL</span>
<a name="l03497"></a>03497 <span class="comment">         * registers, RDRXCTL.MVMEN must be set to 1</span>
<a name="l03498"></a>03498 <span class="comment">         *</span>
<a name="l03499"></a>03499 <span class="comment">         * also, the manual doesn&#39;t mention it clearly but DCA hints</span>
<a name="l03500"></a>03500 <span class="comment">         * will only use queue 0&#39;s tags unless this bit is set.  Side</span>
<a name="l03501"></a>03501 <span class="comment">         * effects of setting this bit are only that SRRCTL must be</span>
<a name="l03502"></a>03502 <span class="comment">         * fully programmed [0..15]</span>
<a name="l03503"></a>03503 <span class="comment">         */</span>
<a name="l03504"></a>03504         rdrxctl |= IXGBE_RDRXCTL_MVMEN;
<a name="l03505"></a>03505         <span class="keywordflow">break</span>;
<a name="l03506"></a>03506     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03507"></a>03507     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03508"></a>03508         <span class="comment">/* Disable RSC for ACK packets */</span>
<a name="l03509"></a>03509         IXGBE_WRITE_REG(hw, IXGBE_RSCDBU,
<a name="l03510"></a>03510            (IXGBE_RSCDBU_RSCACKDIS | IXGBE_READ_REG(hw, IXGBE_RSCDBU)));
<a name="l03511"></a>03511         rdrxctl &amp;= ~IXGBE_RDRXCTL_RSCFRSTSIZE;
<a name="l03512"></a>03512         <span class="comment">/* hardware requires some bits to be set by default */</span>
<a name="l03513"></a>03513         rdrxctl |= (IXGBE_RDRXCTL_RSCACKC | IXGBE_RDRXCTL_FCOE_WRFIX);
<a name="l03514"></a>03514         rdrxctl |= IXGBE_RDRXCTL_CRCSTRIP;
<a name="l03515"></a>03515         <span class="keywordflow">break</span>;
<a name="l03516"></a>03516     <span class="keywordflow">default</span>:
<a name="l03517"></a>03517         <span class="comment">/* We should do nothing since we don&#39;t know this hardware */</span>
<a name="l03518"></a>03518         <span class="keywordflow">return</span>;
<a name="l03519"></a>03519     }
<a name="l03520"></a>03520 
<a name="l03521"></a>03521     IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, rdrxctl);
<a name="l03522"></a>03522 }
<a name="l03523"></a>03523 
<a name="l03530"></a>03530 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_rx(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03531"></a>03531 {
<a name="l03532"></a>03532     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03533"></a>03533     <span class="keywordtype">int</span> i;
<a name="l03534"></a>03534     u32 rxctrl;
<a name="l03535"></a>03535 
<a name="l03536"></a>03536     <span class="comment">/* disable receives while setting up the descriptors */</span>
<a name="l03537"></a>03537     rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l03538"></a>03538     IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl &amp; ~IXGBE_RXCTRL_RXEN);
<a name="l03539"></a>03539 
<a name="l03540"></a>03540     ixgbe_setup_psrtype(adapter);
<a name="l03541"></a>03541     ixgbe_setup_rdrxctl(adapter);
<a name="l03542"></a>03542 
<a name="l03543"></a>03543     <span class="comment">/* Program registers for the distribution of queues */</span>
<a name="l03544"></a>03544     ixgbe_setup_mrqc(adapter);
<a name="l03545"></a>03545 
<a name="l03546"></a>03546     ixgbe_set_uta(adapter);
<a name="l03547"></a>03547 
<a name="l03548"></a>03548     <span class="comment">/* set_rx_buffer_len must be called before ring initialization */</span>
<a name="l03549"></a>03549     ixgbe_set_rx_buffer_len(adapter);
<a name="l03550"></a>03550 
<a name="l03551"></a>03551     <span class="comment">/*</span>
<a name="l03552"></a>03552 <span class="comment">     * Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<a name="l03553"></a>03553 <span class="comment">     * the Base and Length of the Rx Descriptor Ring</span>
<a name="l03554"></a>03554 <span class="comment">     */</span>
<a name="l03555"></a>03555     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l03556"></a>03556         ixgbe_configure_rx_ring(adapter, adapter-&gt;rx_ring[i]);
<a name="l03557"></a>03557 
<a name="l03558"></a>03558     <span class="comment">/* disable drop enable for 82598 parts */</span>
<a name="l03559"></a>03559     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l03560"></a>03560         rxctrl |= IXGBE_RXCTRL_DMBYPS;
<a name="l03561"></a>03561 
<a name="l03562"></a>03562     <span class="comment">/* enable all receives */</span>
<a name="l03563"></a>03563     rxctrl |= IXGBE_RXCTRL_RXEN;
<a name="l03564"></a>03564     ixgbe_enable_rx_dma(hw, rxctrl);
<a name="l03565"></a>03565 }
<a name="l03566"></a>03566 
<a name="l03567"></a>03567 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l03568"></a>03568 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_rx_add_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l03569"></a>03569 {
<a name="l03570"></a>03570     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03571"></a>03571     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03572"></a>03572     <span class="keywordtype">int</span> pool_ndx = adapter-&gt;num_vfs;
<a name="l03573"></a>03573 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l03574"></a>03574 <span class="preprocessor"></span>    <span class="keyword">struct </span>net_device *v_netdev;
<a name="l03575"></a>03575 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l03576"></a>03576     <span class="keywordtype">int</span> i;
<a name="l03577"></a>03577 
<a name="l03578"></a>03578     <span class="comment">/* add VID to filter table */</span>
<a name="l03579"></a>03579     <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_vfta) {
<a name="l03580"></a>03580         hw-&gt;mac.ops.set_vfta(hw, vid, pool_ndx, <span class="keyword">true</span>);
<a name="l03581"></a>03581         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l03582"></a>03582             <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l03583"></a>03583             <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03584"></a>03584             <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03585"></a>03585                 <span class="comment">/* enable vlan id for all pools */</span>
<a name="l03586"></a>03586                 <span class="keywordflow">for</span> (i = 1; i &lt; adapter-&gt;num_rx_pools; i++) {
<a name="l03587"></a>03587                     hw-&gt;mac.ops.set_vfta(hw, vid, VMDQ_P(i), <span class="keyword">true</span>);
<a name="l03588"></a>03588                 }
<a name="l03589"></a>03589                 <span class="keywordflow">break</span>;
<a name="l03590"></a>03590             <span class="keywordflow">default</span>:
<a name="l03591"></a>03591                 <span class="keywordflow">break</span>;
<a name="l03592"></a>03592             }
<a name="l03593"></a>03593         }
<a name="l03594"></a>03594     }
<a name="l03595"></a>03595 
<a name="l03596"></a>03596 <span class="preprocessor">#ifndef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l03597"></a>03597 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l03598"></a>03598 <span class="comment">     * Copy feature flags from netdev to the vlan netdev for this vid.</span>
<a name="l03599"></a>03599 <span class="comment">     * This allows things like TSO to bubble down to our vlan device.</span>
<a name="l03600"></a>03600 <span class="comment">     * Some vlans, such as VLAN 0 for DCB will not have a v_netdev so</span>
<a name="l03601"></a>03601 <span class="comment">     * we will not have a netdev that needs updating.</span>
<a name="l03602"></a>03602 <span class="comment">     */</span>
<a name="l03603"></a>03603     <span class="keywordflow">if</span> (adapter-&gt;vlgrp) {
<a name="l03604"></a>03604         v_netdev = vlan_group_get_device(adapter-&gt;vlgrp, vid);
<a name="l03605"></a>03605         <span class="keywordflow">if</span> (v_netdev) {
<a name="l03606"></a>03606             v_netdev-&gt;features |= adapter-&gt;netdev-&gt;features;
<a name="l03607"></a>03607             vlan_group_set_device(adapter-&gt;vlgrp, vid, v_netdev);
<a name="l03608"></a>03608         }
<a name="l03609"></a>03609     }
<a name="l03610"></a>03610 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l03611"></a>03611 }
<a name="l03612"></a>03612 
<a name="l03613"></a>03613 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_rx_kill_vid(<span class="keyword">struct</span> net_device *netdev, u16 vid)
<a name="l03614"></a>03614 {
<a name="l03615"></a>03615     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03616"></a>03616     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03617"></a>03617     <span class="keywordtype">int</span> pool_ndx = adapter-&gt;num_vfs;
<a name="l03618"></a>03618     <span class="keywordtype">int</span> i;
<a name="l03619"></a>03619 
<a name="l03620"></a>03620     <span class="comment">/* User is not allowed to remove vlan ID 0 */</span>
<a name="l03621"></a>03621     <span class="keywordflow">if</span> (!vid)
<a name="l03622"></a>03622         <span class="keywordflow">return</span>;
<a name="l03623"></a>03623 
<a name="l03624"></a>03624     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03625"></a>03625         ixgbe_irq_disable(adapter);
<a name="l03626"></a>03626 
<a name="l03627"></a>03627     vlan_group_set_device(adapter-&gt;vlgrp, vid, NULL);
<a name="l03628"></a>03628 
<a name="l03629"></a>03629     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03630"></a>03630         ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l03631"></a>03631 
<a name="l03632"></a>03632     <span class="comment">/* remove VID from filter table */</span>
<a name="l03633"></a>03633 
<a name="l03634"></a>03634     <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_vfta) {
<a name="l03635"></a>03635         hw-&gt;mac.ops.set_vfta(hw, vid, pool_ndx, <span class="keyword">false</span>);
<a name="l03636"></a>03636         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l03637"></a>03637             <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l03638"></a>03638             <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03639"></a>03639             <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03640"></a>03640                 <span class="comment">/* remove vlan id from all pools */</span>
<a name="l03641"></a>03641                 <span class="keywordflow">for</span> (i = 1; i &lt; adapter-&gt;num_rx_pools; i++) {
<a name="l03642"></a>03642                     hw-&gt;mac.ops.set_vfta(hw, vid, VMDQ_P(i), <span class="keyword">false</span>);
<a name="l03643"></a>03643                 }
<a name="l03644"></a>03644                 <span class="keywordflow">break</span>;
<a name="l03645"></a>03645             <span class="keywordflow">default</span>:
<a name="l03646"></a>03646                 <span class="keywordflow">break</span>;
<a name="l03647"></a>03647             }
<a name="l03648"></a>03648         }
<a name="l03649"></a>03649     }
<a name="l03650"></a>03650 }
<a name="l03651"></a>03651 
<a name="l03652"></a>03652 <span class="preprocessor">#ifdef HAVE_8021P_SUPPORT</span>
<a name="l03653"></a>03653 <span class="preprocessor"></span>
<a name="l03657"></a>03657 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_stripping_disable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03658"></a>03658 {
<a name="l03659"></a>03659     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03660"></a>03660     u32 vlnctrl;
<a name="l03661"></a>03661     <span class="keywordtype">int</span> i;
<a name="l03662"></a>03662 
<a name="l03663"></a>03663     <span class="comment">/* leave vlan tag stripping enabled for DCB */</span>
<a name="l03664"></a>03664     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)
<a name="l03665"></a>03665         <span class="keywordflow">return</span>;
<a name="l03666"></a>03666 
<a name="l03667"></a>03667     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03668"></a>03668     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03669"></a>03669         vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l03670"></a>03670         vlnctrl &amp;= ~IXGBE_VLNCTRL_VME;
<a name="l03671"></a>03671         IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
<a name="l03672"></a>03672         <span class="keywordflow">break</span>;
<a name="l03673"></a>03673     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03674"></a>03674     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03675"></a>03675         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l03676"></a>03676             u8 reg_idx = adapter-&gt;rx_ring[i]-&gt;reg_idx;
<a name="l03677"></a>03677             vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03678"></a>03678             vlnctrl &amp;= ~IXGBE_RXDCTL_VME;
<a name="l03679"></a>03679             IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), vlnctrl);
<a name="l03680"></a>03680         }
<a name="l03681"></a>03681         <span class="keywordflow">break</span>;
<a name="l03682"></a>03682     <span class="keywordflow">default</span>:
<a name="l03683"></a>03683         <span class="keywordflow">break</span>;
<a name="l03684"></a>03684     }
<a name="l03685"></a>03685 }
<a name="l03686"></a>03686 
<a name="l03687"></a>03687 <span class="preprocessor">#endif</span>
<a name="l03688"></a>03688 <span class="preprocessor"></span>
<a name="l03689"></a>03689 <span class="preprocessor">#ifndef HAVE_PF_RING</span>
<a name="l03690"></a>03690 <span class="preprocessor"></span>
<a name="l03694"></a>03694 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_stripping_enable(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03695"></a>03695 {
<a name="l03696"></a>03696     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03697"></a>03697     u32 vlnctrl;
<a name="l03698"></a>03698     <span class="keywordtype">int</span> i;
<a name="l03699"></a>03699 
<a name="l03700"></a>03700     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l03701"></a>03701     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l03702"></a>03702         vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l03703"></a>03703         vlnctrl |= IXGBE_VLNCTRL_VME;
<a name="l03704"></a>03704         IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
<a name="l03705"></a>03705         <span class="keywordflow">break</span>;
<a name="l03706"></a>03706     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l03707"></a>03707     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l03708"></a>03708         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l03709"></a>03709             u8 reg_idx = adapter-&gt;rx_ring[i]-&gt;reg_idx;
<a name="l03710"></a>03710             vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
<a name="l03711"></a>03711             vlnctrl |= IXGBE_RXDCTL_VME;
<a name="l03712"></a>03712             IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), vlnctrl);
<a name="l03713"></a>03713         }
<a name="l03714"></a>03714         <span class="keywordflow">break</span>;
<a name="l03715"></a>03715     <span class="keywordflow">default</span>:
<a name="l03716"></a>03716         <span class="keywordflow">break</span>;
<a name="l03717"></a>03717     }
<a name="l03718"></a>03718 }
<a name="l03719"></a>03719 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PF_RING */</span>
<a name="l03720"></a>03720 
<a name="l03721"></a>03721 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_vlan_rx_register(<span class="keyword">struct</span> net_device *netdev,
<a name="l03722"></a>03722                    <span class="keyword">struct</span> vlan_group *grp)
<a name="l03723"></a>03723 {
<a name="l03724"></a>03724     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03725"></a>03725 
<a name="l03726"></a>03726     <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03727"></a>03727         ixgbe_irq_disable(adapter);
<a name="l03728"></a>03728     adapter-&gt;vlgrp = grp;
<a name="l03729"></a>03729 
<a name="l03730"></a>03730 <span class="preprocessor">#ifdef HAVE_8021P_SUPPORT</span>
<a name="l03731"></a>03731 <span class="preprocessor"></span><span class="preprocessor">#ifndef HAVE_PF_RING</span>
<a name="l03732"></a>03732 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (grp || (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l03733"></a>03733         <span class="comment">/* enable VLAN tag insert/strip */</span>
<a name="l03734"></a>03734         ixgbe_vlan_stripping_enable(adapter);
<a name="l03735"></a>03735     <span class="keywordflow">else</span>
<a name="l03736"></a>03736 <span class="preprocessor">#endif</span>
<a name="l03737"></a>03737 <span class="preprocessor"></span>        <span class="comment">/* disable VLAN tag insert/strip */</span>
<a name="l03738"></a>03738         ixgbe_vlan_stripping_disable(adapter);
<a name="l03739"></a>03739 
<a name="l03740"></a>03740 <span class="preprocessor">#endif</span>
<a name="l03741"></a>03741 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l03742"></a>03742         ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l03743"></a>03743 }
<a name="l03744"></a>03744 
<a name="l03745"></a>03745 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_restore_vlan(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03746"></a>03746 {
<a name="l03747"></a>03747     ixgbe_vlan_rx_register(adapter-&gt;netdev, adapter-&gt;vlgrp);
<a name="l03748"></a>03748 
<a name="l03749"></a>03749 <span class="preprocessor">#ifndef HAVE_PF_RING</span>
<a name="l03750"></a>03750 <span class="preprocessor"></span><span class="preprocessor">#ifndef HAVE_8021P_SUPPORT</span>
<a name="l03751"></a>03751 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l03752"></a>03752 <span class="comment">     * add vlan ID 0 and enable vlan tag stripping so we</span>
<a name="l03753"></a>03753 <span class="comment">     * always accept priority-tagged traffic</span>
<a name="l03754"></a>03754 <span class="comment">     */</span>
<a name="l03755"></a>03755     ixgbe_vlan_rx_add_vid(adapter-&gt;netdev, 0);
<a name="l03756"></a>03756     ixgbe_vlan_stripping_enable(adapter);
<a name="l03757"></a>03757 <span class="preprocessor">#endif</span>
<a name="l03758"></a>03758 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03759"></a>03759 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;vlgrp) {
<a name="l03760"></a>03760         u16 vid;
<a name="l03761"></a>03761         <span class="keywordflow">for</span> (vid = 0; vid &lt; VLAN_N_VID; vid++) {
<a name="l03762"></a>03762             <span class="keywordflow">if</span> (!vlan_group_get_device(adapter-&gt;vlgrp, vid))
<a name="l03763"></a>03763                 <span class="keywordflow">continue</span>;
<a name="l03764"></a>03764             ixgbe_vlan_rx_add_vid(adapter-&gt;netdev, vid);
<a name="l03765"></a>03765         }
<a name="l03766"></a>03766     }
<a name="l03767"></a>03767 }
<a name="l03768"></a>03768 
<a name="l03769"></a>03769 <span class="preprocessor">#endif</span>
<a name="l03770"></a>03770 <span class="preprocessor"></span><span class="keyword">static</span> u8 *ixgbe_addr_list_itr(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw, u8 **mc_addr_ptr, u32 *vmdq)
<a name="l03771"></a>03771 {
<a name="l03772"></a>03772 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03773"></a>03773 <span class="preprocessor"></span>    <span class="keyword">struct </span>netdev_hw_addr *mc_ptr;
<a name="l03774"></a>03774 <span class="preprocessor">#else</span>
<a name="l03775"></a>03775 <span class="preprocessor"></span>    <span class="keyword">struct </span>dev_mc_list *mc_ptr;
<a name="l03776"></a>03776 <span class="preprocessor">#endif</span>
<a name="l03777"></a>03777 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = hw-&gt;back;
<a name="l03778"></a>03778     u8 *addr = *mc_addr_ptr;
<a name="l03779"></a>03779 
<a name="l03780"></a>03780     *vmdq = adapter-&gt;num_vfs;
<a name="l03781"></a>03781 
<a name="l03782"></a>03782 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03783"></a>03783 <span class="preprocessor"></span>    mc_ptr = container_of(addr, <span class="keyword">struct</span> netdev_hw_addr, addr[0]);
<a name="l03784"></a>03784     <span class="keywordflow">if</span> (mc_ptr-&gt;list.next) {
<a name="l03785"></a>03785         <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03786"></a>03786 
<a name="l03787"></a>03787         ha = list_entry(mc_ptr-&gt;list.next, <span class="keyword">struct</span> netdev_hw_addr, list);
<a name="l03788"></a>03788         *mc_addr_ptr = ha-&gt;addr;
<a name="l03789"></a>03789     }
<a name="l03790"></a>03790 <span class="preprocessor">#else</span>
<a name="l03791"></a>03791 <span class="preprocessor"></span>    mc_ptr = container_of(addr, <span class="keyword">struct</span> dev_mc_list, dmi_addr[0]);
<a name="l03792"></a>03792     <span class="keywordflow">if</span> (mc_ptr-&gt;next)
<a name="l03793"></a>03793         *mc_addr_ptr = mc_ptr-&gt;next-&gt;dmi_addr;
<a name="l03794"></a>03794 <span class="preprocessor">#endif</span>
<a name="l03795"></a>03795 <span class="preprocessor"></span>    <span class="keywordflow">else</span>
<a name="l03796"></a>03796         *mc_addr_ptr = NULL;
<a name="l03797"></a>03797 
<a name="l03798"></a>03798     <span class="keywordflow">return</span> addr;
<a name="l03799"></a>03799 }
<a name="l03800"></a>03800 
<a name="l03810"></a>03810 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_write_mc_addr_list(<span class="keyword">struct</span> net_device *netdev)
<a name="l03811"></a>03811 {
<a name="l03812"></a>03812     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03813"></a>03813     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03814"></a>03814 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03815"></a>03815 <span class="preprocessor"></span>    <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03816"></a>03816 <span class="preprocessor">#endif</span>
<a name="l03817"></a>03817 <span class="preprocessor"></span>    u8  *addr_list = NULL;
<a name="l03818"></a>03818     <span class="keywordtype">int</span> addr_count;
<a name="l03819"></a>03819 
<a name="l03820"></a>03820     <span class="keywordflow">if</span> (netdev_mc_empty(netdev)) {
<a name="l03821"></a>03821         <span class="comment">/* nothing to program, so clear mc list */</span>
<a name="l03822"></a>03822         hw-&gt;mac.ops.update_mc_addr_list(hw, NULL, 0, ixgbe_addr_list_itr);
<a name="l03823"></a>03823         <span class="keywordflow">return</span> 0;
<a name="l03824"></a>03824     }
<a name="l03825"></a>03825 
<a name="l03826"></a>03826     <span class="keywordflow">if</span> (!hw-&gt;mac.ops.update_mc_addr_list)
<a name="l03827"></a>03827         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03828"></a>03828 
<a name="l03829"></a>03829 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_MULTICAST</span>
<a name="l03830"></a>03830 <span class="preprocessor"></span>    ha = list_first_entry(&amp;netdev-&gt;mc.list, <span class="keyword">struct</span> netdev_hw_addr, list);
<a name="l03831"></a>03831     addr_list = ha-&gt;addr;
<a name="l03832"></a>03832 <span class="preprocessor">#else</span>
<a name="l03833"></a>03833 <span class="preprocessor"></span>    addr_list = netdev-&gt;mc_list-&gt;dmi_addr;
<a name="l03834"></a>03834 <span class="preprocessor">#endif</span>
<a name="l03835"></a>03835 <span class="preprocessor"></span>    addr_count = netdev_mc_count(netdev);
<a name="l03836"></a>03836 
<a name="l03837"></a>03837     hw-&gt;mac.ops.update_mc_addr_list(hw, addr_list, addr_count, ixgbe_addr_list_itr);
<a name="l03838"></a>03838 
<a name="l03839"></a>03839     <span class="keywordflow">return</span> addr_count;
<a name="l03840"></a>03840 }
<a name="l03841"></a>03841 
<a name="l03842"></a>03842 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l03843"></a>03843 <span class="preprocessor"></span>
<a name="l03852"></a>03852 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_write_uc_addr_list(<span class="keyword">struct</span> net_device *netdev)
<a name="l03853"></a>03853 {
<a name="l03854"></a>03854     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03855"></a>03855     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03856"></a>03856     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vfn = adapter-&gt;num_vfs;
<a name="l03857"></a>03857     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rar_entries = hw-&gt;mac.num_rar_entries - (vfn + 1);
<a name="l03858"></a>03858     <span class="keywordtype">int</span> count = 0;
<a name="l03859"></a>03859 
<a name="l03860"></a>03860     <span class="comment">/* return ENOMEM indicating insufficient memory for addresses */</span>
<a name="l03861"></a>03861     <span class="keywordflow">if</span> (netdev_uc_count(netdev) &gt; rar_entries)
<a name="l03862"></a>03862         <span class="keywordflow">return</span> -ENOMEM;
<a name="l03863"></a>03863 
<a name="l03864"></a>03864     <span class="keywordflow">if</span> (!netdev_uc_empty(netdev) &amp;&amp; rar_entries) {
<a name="l03865"></a>03865 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_UNICAST</span>
<a name="l03866"></a>03866 <span class="preprocessor"></span>        <span class="keyword">struct </span>netdev_hw_addr *ha;
<a name="l03867"></a>03867 <span class="preprocessor">#else</span>
<a name="l03868"></a>03868 <span class="preprocessor"></span>        <span class="keyword">struct </span>dev_mc_list *ha;
<a name="l03869"></a>03869 <span class="preprocessor">#endif</span>
<a name="l03870"></a>03870 <span class="preprocessor"></span>        <span class="comment">/* return error if we do not support writing to RAR table */</span>
<a name="l03871"></a>03871         <span class="keywordflow">if</span> (!hw-&gt;mac.ops.set_rar)
<a name="l03872"></a>03872             <span class="keywordflow">return</span> -ENOMEM;
<a name="l03873"></a>03873 
<a name="l03874"></a>03874         netdev_for_each_uc_addr(ha, netdev) {
<a name="l03875"></a>03875             <span class="keywordflow">if</span> (!rar_entries)
<a name="l03876"></a>03876                 <span class="keywordflow">break</span>;
<a name="l03877"></a>03877 <span class="preprocessor">#ifdef NETDEV_HW_ADDR_T_UNICAST</span>
<a name="l03878"></a>03878 <span class="preprocessor"></span>            hw-&gt;mac.ops.set_rar(hw, rar_entries--, ha-&gt;addr,
<a name="l03879"></a>03879                         vfn, IXGBE_RAH_AV);
<a name="l03880"></a>03880 <span class="preprocessor">#else</span>
<a name="l03881"></a>03881 <span class="preprocessor"></span>            hw-&gt;mac.ops.set_rar(hw, rar_entries--, ha-&gt;da_addr,
<a name="l03882"></a>03882                         vfn, IXGBE_RAH_AV);
<a name="l03883"></a>03883 <span class="preprocessor">#endif</span>
<a name="l03884"></a>03884 <span class="preprocessor"></span>            count++;
<a name="l03885"></a>03885         }
<a name="l03886"></a>03886     }
<a name="l03887"></a>03887     <span class="comment">/* write the addresses in reverse order to avoid write combining */</span>
<a name="l03888"></a>03888     <span class="keywordflow">for</span> (; rar_entries &gt; 0 ; rar_entries--)
<a name="l03889"></a>03889         hw-&gt;mac.ops.clear_rar(hw, rar_entries);
<a name="l03890"></a>03890 
<a name="l03891"></a>03891     <span class="keywordflow">return</span> count;
<a name="l03892"></a>03892 }
<a name="l03893"></a>03893 
<a name="l03894"></a>03894 <span class="preprocessor">#endif</span>
<a name="l03895"></a>03895 <span class="preprocessor"></span>
<a name="l03904"></a>03904 <span class="keywordtype">void</span> ixgbe_set_rx_mode(<span class="keyword">struct</span> net_device *netdev)
<a name="l03905"></a>03905 {
<a name="l03906"></a>03906     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l03907"></a>03907     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l03908"></a>03908     u32 fctrl, vmolr = IXGBE_VMOLR_BAM | IXGBE_VMOLR_AUPE;
<a name="l03909"></a>03909     u32 vlnctrl;
<a name="l03910"></a>03910     <span class="keywordtype">int</span> count;
<a name="l03911"></a>03911 
<a name="l03912"></a>03912     <span class="comment">/* Check for Promiscuous and All Multicast modes */</span>
<a name="l03913"></a>03913     fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l03914"></a>03914     vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
<a name="l03915"></a>03915 
<a name="l03916"></a>03916     <span class="comment">/* set all bits that we expect to always be set */</span>
<a name="l03917"></a>03917     fctrl |= IXGBE_FCTRL_BAM;
<a name="l03918"></a>03918     fctrl |= IXGBE_FCTRL_DPF; <span class="comment">/* discard pause frames when FC enabled */</span>
<a name="l03919"></a>03919     fctrl |= IXGBE_FCTRL_PMCF;
<a name="l03920"></a>03920 
<a name="l03921"></a>03921     <span class="comment">/* clear the bits we are changing the status of */</span>
<a name="l03922"></a>03922     fctrl &amp;= ~(IXGBE_FCTRL_UPE | IXGBE_FCTRL_MPE);
<a name="l03923"></a>03923     vlnctrl  &amp;= ~(IXGBE_VLNCTRL_VFE | IXGBE_VLNCTRL_CFIEN);
<a name="l03924"></a>03924 
<a name="l03925"></a>03925     <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_PROMISC) {
<a name="l03926"></a>03926         hw-&gt;addr_ctrl.user_set_promisc = <span class="keyword">true</span>;
<a name="l03927"></a>03927         fctrl |= (IXGBE_FCTRL_UPE | IXGBE_FCTRL_MPE);
<a name="l03928"></a>03928         vmolr |= IXGBE_VMOLR_MPE;
<a name="l03929"></a>03929     } <span class="keywordflow">else</span> {
<a name="l03930"></a>03930         <span class="keywordflow">if</span> (netdev-&gt;flags &amp; IFF_ALLMULTI) {
<a name="l03931"></a>03931             fctrl |= IXGBE_FCTRL_MPE;
<a name="l03932"></a>03932             vmolr |= IXGBE_VMOLR_MPE;
<a name="l03933"></a>03933         } <span class="keywordflow">else</span> {
<a name="l03934"></a>03934             <span class="comment">/*</span>
<a name="l03935"></a>03935 <span class="comment">             * Write addresses to the MTA, if the attempt fails</span>
<a name="l03936"></a>03936 <span class="comment">             * then we should just turn on promiscous mode so</span>
<a name="l03937"></a>03937 <span class="comment">             * that we can at least receive multicast traffic</span>
<a name="l03938"></a>03938 <span class="comment">             */</span>
<a name="l03939"></a>03939             count = ixgbe_write_mc_addr_list(netdev);
<a name="l03940"></a>03940             <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l03941"></a>03941                 fctrl |= IXGBE_FCTRL_MPE;
<a name="l03942"></a>03942                 vmolr |= IXGBE_VMOLR_MPE;
<a name="l03943"></a>03943             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count) {
<a name="l03944"></a>03944                 vmolr |= IXGBE_VMOLR_ROMPE;
<a name="l03945"></a>03945             }
<a name="l03946"></a>03946         }
<a name="l03947"></a>03947 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l03948"></a>03948 <span class="preprocessor"></span>        <span class="comment">/* enable hardware vlan filtering */</span>
<a name="l03949"></a>03949         vlnctrl |= IXGBE_VLNCTRL_VFE;
<a name="l03950"></a>03950 <span class="preprocessor">#endif</span>
<a name="l03951"></a>03951 <span class="preprocessor"></span>        hw-&gt;addr_ctrl.user_set_promisc = <span class="keyword">false</span>;
<a name="l03952"></a>03952 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l03953"></a>03953 <span class="preprocessor"></span>        <span class="comment">/*</span>
<a name="l03954"></a>03954 <span class="comment">         * Write addresses to available RAR registers, if there is not</span>
<a name="l03955"></a>03955 <span class="comment">         * sufficient space to store all the addresses then enable</span>
<a name="l03956"></a>03956 <span class="comment">         * unicast promiscous mode</span>
<a name="l03957"></a>03957 <span class="comment">         */</span>
<a name="l03958"></a>03958         count = ixgbe_write_uc_addr_list(netdev);
<a name="l03959"></a>03959         <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l03960"></a>03960             fctrl |= IXGBE_FCTRL_UPE;
<a name="l03961"></a>03961             vmolr |= IXGBE_VMOLR_ROPE;
<a name="l03962"></a>03962         }
<a name="l03963"></a>03963 <span class="preprocessor">#endif</span>
<a name="l03964"></a>03964 <span class="preprocessor"></span>    }
<a name="l03965"></a>03965 
<a name="l03966"></a>03966 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l03967"></a>03967 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;num_vfs)
<a name="l03968"></a>03968         ixgbe_restore_vf_multicasts(adapter);
<a name="l03969"></a>03969 
<a name="l03970"></a>03970 <span class="preprocessor">#endif</span>
<a name="l03971"></a>03971 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (hw-&gt;mac.type != ixgbe_mac_82598EB) {
<a name="l03972"></a>03972         vmolr |= IXGBE_READ_REG(hw, IXGBE_VMOLR(adapter-&gt;num_vfs)) &amp;
<a name="l03973"></a>03973              ~(IXGBE_VMOLR_MPE | IXGBE_VMOLR_ROMPE |
<a name="l03974"></a>03974                IXGBE_VMOLR_ROPE);
<a name="l03975"></a>03975         IXGBE_WRITE_REG(hw, IXGBE_VMOLR(adapter-&gt;num_vfs), vmolr);
<a name="l03976"></a>03976     }
<a name="l03977"></a>03977 
<a name="l03978"></a>03978     IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
<a name="l03979"></a>03979     IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
<a name="l03980"></a>03980 }
<a name="l03981"></a>03981 
<a name="l03982"></a>03982 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_napi_enable_all(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l03983"></a>03983 {
<a name="l03984"></a>03984 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l03985"></a>03985 <span class="preprocessor"></span>    <span class="keywordtype">int</span> q_idx;
<a name="l03986"></a>03986     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l03987"></a>03987     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l03988"></a>03988 
<a name="l03989"></a>03989     <span class="comment">/* legacy and MSI only use one vector */</span>
<a name="l03990"></a>03990     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l03991"></a>03991         q_vectors = 1;
<a name="l03992"></a>03992 
<a name="l03993"></a>03993     <span class="keywordflow">for</span> (q_idx = 0; q_idx &lt; q_vectors; q_idx++) {
<a name="l03994"></a>03994         q_vector = adapter-&gt;q_vector[q_idx];
<a name="l03995"></a>03995 
<a name="l03996"></a>03996         napi_enable(&amp;q_vector-&gt;napi);
<a name="l03997"></a>03997     }
<a name="l03998"></a>03998 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l03999"></a>03999 }
<a name="l04000"></a>04000 
<a name="l04001"></a>04001 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_napi_disable_all(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04002"></a>04002 {
<a name="l04003"></a>04003 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l04004"></a>04004 <span class="preprocessor"></span>    <span class="keywordtype">int</span> q_idx;
<a name="l04005"></a>04005     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l04006"></a>04006     <span class="keywordtype">int</span> q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l04007"></a>04007 
<a name="l04008"></a>04008     <span class="comment">/* legacy and MSI only use one vector */</span>
<a name="l04009"></a>04009     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l04010"></a>04010         q_vectors = 1;
<a name="l04011"></a>04011 
<a name="l04012"></a>04012     <span class="keywordflow">for</span> (q_idx = 0; q_idx &lt; q_vectors; q_idx++) {
<a name="l04013"></a>04013         q_vector = adapter-&gt;q_vector[q_idx];
<a name="l04014"></a>04014         napi_disable(&amp;q_vector-&gt;napi);
<a name="l04015"></a>04015     }
<a name="l04016"></a>04016 <span class="preprocessor">#endif</span>
<a name="l04017"></a>04017 <span class="preprocessor"></span>}
<a name="l04018"></a>04018 
<a name="l04019"></a>04019 <span class="comment">/*</span>
<a name="l04020"></a>04020 <span class="comment"> * ixgbe_configure_dcb - Configure DCB hardware</span>
<a name="l04021"></a>04021 <span class="comment"> * @adapter: ixgbe adapter struct</span>
<a name="l04022"></a>04022 <span class="comment"> *</span>
<a name="l04023"></a>04023 <span class="comment"> * This is called by the driver on open to configure the DCB hardware.</span>
<a name="l04024"></a>04024 <span class="comment"> * This is also called by the gennetlink interface when reconfiguring</span>
<a name="l04025"></a>04025 <span class="comment"> * the DCB state.</span>
<a name="l04026"></a>04026 <span class="comment"> */</span>
<a name="l04027"></a>04027 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_dcb(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04028"></a>04028 {
<a name="l04029"></a>04029     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04030"></a>04030     s32 err;
<a name="l04031"></a>04031     u32 max_frame = adapter-&gt;netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l04032"></a>04032 
<a name="l04033"></a>04033     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)) {
<a name="l04034"></a>04034         <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l04035"></a>04035             netif_set_gso_max_size(adapter-&gt;netdev, 65536);
<a name="l04036"></a>04036         <span class="keywordflow">return</span>;
<a name="l04037"></a>04037     }
<a name="l04038"></a>04038 
<a name="l04039"></a>04039     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l04040"></a>04040         netif_set_gso_max_size(adapter-&gt;netdev, 32768);
<a name="l04041"></a>04041 
<a name="l04042"></a>04042 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l04043"></a>04043 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;features &amp; NETIF_F_FCOE_MTU)
<a name="l04044"></a>04044         max_frame = max_t(<span class="keywordtype">int</span>, max_frame,
<a name="l04045"></a>04045                   IXGBE_FCOE_JUMBO_FRAME_SIZE);
<a name="l04046"></a>04046 <span class="preprocessor">#endif</span>
<a name="l04047"></a>04047 <span class="preprocessor"></span>
<a name="l04048"></a>04048     adapter-&gt;dcb_cfg.num_tcs.pg_tcs = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l04049"></a>04049     err = ixgbe_dcb_calculate_tc_credits(hw, &amp;adapter-&gt;dcb_cfg, max_frame,
<a name="l04050"></a>04050                          DCB_TX_CONFIG);
<a name="l04051"></a>04051     err = ixgbe_dcb_calculate_tc_credits(hw, &amp;adapter-&gt;dcb_cfg, max_frame,
<a name="l04052"></a>04052                          DCB_RX_CONFIG);
<a name="l04053"></a>04053 
<a name="l04054"></a>04054     <span class="comment">/* reconfigure the hardware */</span>
<a name="l04055"></a>04055     ixgbe_dcb_hw_config(hw, &amp;adapter-&gt;dcb_cfg);
<a name="l04056"></a>04056 }
<a name="l04057"></a>04057 
<a name="l04058"></a>04058 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l04059"></a>04059 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_lli_82599(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04060"></a>04060 {
<a name="l04061"></a>04061     u16 port;
<a name="l04062"></a>04062 
<a name="l04063"></a>04063     <span class="keywordflow">if</span> (adapter-&gt;lli_etype) {
<a name="l04064"></a>04064         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04065"></a>04065                         (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04066"></a>04066                          IXGBE_IMIR_CTRL_BP_82599));
<a name="l04067"></a>04067         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_ETQS(0), IXGBE_ETQS_LLI);
<a name="l04068"></a>04068         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_ETQF(0),
<a name="l04069"></a>04069                         (adapter-&gt;lli_etype | IXGBE_ETQF_FILTER_EN));
<a name="l04070"></a>04070     }
<a name="l04071"></a>04071 
<a name="l04072"></a>04072     <span class="keywordflow">if</span> (adapter-&gt;lli_port) {
<a name="l04073"></a>04073         port = swab16(adapter-&gt;lli_port);
<a name="l04074"></a>04074         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04075"></a>04075                         (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04076"></a>04076                          IXGBE_IMIR_CTRL_BP_82599));
<a name="l04077"></a>04077         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FTQF(0),
<a name="l04078"></a>04078                         (IXGBE_FTQF_POOL_MASK_EN |
<a name="l04079"></a>04079                          (IXGBE_FTQF_PRIORITY_MASK &lt;&lt;
<a name="l04080"></a>04080                           IXGBE_FTQF_PRIORITY_SHIFT) |
<a name="l04081"></a>04081                          (IXGBE_FTQF_DEST_PORT_MASK &lt;&lt;
<a name="l04082"></a>04082                           IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
<a name="l04083"></a>04083         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_SDPQF(0), (port &lt;&lt; 16));
<a name="l04084"></a>04084     }
<a name="l04085"></a>04085 
<a name="l04086"></a>04086     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_LLI_PUSH) {
<a name="l04087"></a>04087         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l04088"></a>04088         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04089"></a>04089             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04090"></a>04090                             (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04091"></a>04091                              IXGBE_IMIR_CTRL_PSH_82599 | IXGBE_IMIR_CTRL_SYN_82599 |
<a name="l04092"></a>04092                              IXGBE_IMIR_CTRL_URG_82599 | IXGBE_IMIR_CTRL_ACK_82599 |
<a name="l04093"></a>04093                              IXGBE_IMIR_CTRL_RST_82599 | IXGBE_IMIR_CTRL_FIN_82599));
<a name="l04094"></a>04094             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_LLITHRESH, 0xfc000000);
<a name="l04095"></a>04095             <span class="keywordflow">break</span>;
<a name="l04096"></a>04096         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04097"></a>04097             IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04098"></a>04098                             (IXGBE_IMIR_LLI_EN_82599 |
<a name="l04099"></a>04099                              IXGBE_IMIR_SIZE_BP_82599 |
<a name="l04100"></a>04100                              IXGBE_IMIR_CTRL_PSH_82599));
<a name="l04101"></a>04101             <span class="keywordflow">break</span>;
<a name="l04102"></a>04102         <span class="keywordflow">default</span>:
<a name="l04103"></a>04103             <span class="keywordflow">break</span>;
<a name="l04104"></a>04104         }
<a name="l04105"></a>04105         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FTQF(0),
<a name="l04106"></a>04106                         (IXGBE_FTQF_POOL_MASK_EN |
<a name="l04107"></a>04107                          (IXGBE_FTQF_PRIORITY_MASK &lt;&lt;
<a name="l04108"></a>04108                           IXGBE_FTQF_PRIORITY_SHIFT) |
<a name="l04109"></a>04109                          (IXGBE_FTQF_5TUPLE_MASK_MASK &lt;&lt;
<a name="l04110"></a>04110                           IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
<a name="l04111"></a>04111 
<a name="l04112"></a>04112         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_SYNQF, 0x80000100);
<a name="l04113"></a>04113     }
<a name="l04114"></a>04114 
<a name="l04115"></a>04115     <span class="keywordflow">if</span> (adapter-&gt;lli_size) {
<a name="l04116"></a>04116         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_L34T_IMIR(0),
<a name="l04117"></a>04117                         (IXGBE_IMIR_LLI_EN_82599 | IXGBE_IMIR_CTRL_BP_82599));
<a name="l04118"></a>04118         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_LLITHRESH, adapter-&gt;lli_size);
<a name="l04119"></a>04119         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_FTQF(0),
<a name="l04120"></a>04120                         (IXGBE_FTQF_POOL_MASK_EN |
<a name="l04121"></a>04121                          (IXGBE_FTQF_PRIORITY_MASK &lt;&lt;
<a name="l04122"></a>04122                           IXGBE_FTQF_PRIORITY_SHIFT) |
<a name="l04123"></a>04123                          (IXGBE_FTQF_5TUPLE_MASK_MASK &lt;&lt;
<a name="l04124"></a>04124                           IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
<a name="l04125"></a>04125     }
<a name="l04126"></a>04126 
<a name="l04127"></a>04127     <span class="keywordflow">if</span> (adapter-&gt;lli_vlan_pri) {
<a name="l04128"></a>04128         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIRVP,
<a name="l04129"></a>04129                         (IXGBE_IMIRVP_PRIORITY_EN | adapter-&gt;lli_vlan_pri));
<a name="l04130"></a>04130     }
<a name="l04131"></a>04131 }
<a name="l04132"></a>04132 
<a name="l04133"></a>04133 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure_lli(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04134"></a>04134 {
<a name="l04135"></a>04135     u16 port;
<a name="l04136"></a>04136 
<a name="l04137"></a>04137     <span class="comment">/* lli should only be enabled with MSI-X and MSI */</span>
<a name="l04138"></a>04138     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED) &amp;&amp;
<a name="l04139"></a>04139         !(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED))
<a name="l04140"></a>04140         <span class="keywordflow">return</span>;
<a name="l04141"></a>04141 
<a name="l04142"></a>04142     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type != ixgbe_mac_82598EB) {
<a name="l04143"></a>04143         ixgbe_configure_lli_82599(adapter);
<a name="l04144"></a>04144         <span class="keywordflow">return</span>;
<a name="l04145"></a>04145     }
<a name="l04146"></a>04146 
<a name="l04147"></a>04147     <span class="keywordflow">if</span> (adapter-&gt;lli_port) {
<a name="l04148"></a>04148         <span class="comment">/* use filter 0 for port */</span>
<a name="l04149"></a>04149         port = swab16(adapter-&gt;lli_port);
<a name="l04150"></a>04150         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIR(0),
<a name="l04151"></a>04151                         (port | IXGBE_IMIR_PORT_IM_EN));
<a name="l04152"></a>04152         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIREXT(0),
<a name="l04153"></a>04153                         (IXGBE_IMIREXT_SIZE_BP |
<a name="l04154"></a>04154                          IXGBE_IMIREXT_CTRL_BP));
<a name="l04155"></a>04155     }
<a name="l04156"></a>04156 
<a name="l04157"></a>04157     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_LLI_PUSH) {
<a name="l04158"></a>04158         <span class="comment">/* use filter 1 for push flag */</span>
<a name="l04159"></a>04159         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIR(1),
<a name="l04160"></a>04160                         (IXGBE_IMIR_PORT_BP | IXGBE_IMIR_PORT_IM_EN));
<a name="l04161"></a>04161         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIREXT(1),
<a name="l04162"></a>04162                         (IXGBE_IMIREXT_SIZE_BP |
<a name="l04163"></a>04163                          IXGBE_IMIREXT_CTRL_PSH));
<a name="l04164"></a>04164     }
<a name="l04165"></a>04165 
<a name="l04166"></a>04166     <span class="keywordflow">if</span> (adapter-&gt;lli_size) {
<a name="l04167"></a>04167         <span class="comment">/* use filter 2 for size */</span>
<a name="l04168"></a>04168         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIR(2),
<a name="l04169"></a>04169                         (IXGBE_IMIR_PORT_BP | IXGBE_IMIR_PORT_IM_EN));
<a name="l04170"></a>04170         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_IMIREXT(2),
<a name="l04171"></a>04171                         (adapter-&gt;lli_size | IXGBE_IMIREXT_CTRL_BP));
<a name="l04172"></a>04172     }
<a name="l04173"></a>04173 }
<a name="l04174"></a>04174 
<a name="l04175"></a>04175 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_NO_LLI */</span>
<a name="l04176"></a>04176 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_configure(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04177"></a>04177 {
<a name="l04178"></a>04178     ixgbe_set_rx_mode(adapter-&gt;netdev);
<a name="l04179"></a>04179 
<a name="l04180"></a>04180 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l04181"></a>04181 <span class="preprocessor"></span>    ixgbe_restore_vlan(adapter);
<a name="l04182"></a>04182 <span class="preprocessor">#endif</span>
<a name="l04183"></a>04183 <span class="preprocessor"></span>    ixgbe_configure_dcb(adapter);
<a name="l04184"></a>04184 
<a name="l04185"></a>04185 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l04186"></a>04186 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED)
<a name="l04187"></a>04187         ixgbe_configure_fcoe(adapter);
<a name="l04188"></a>04188 
<a name="l04189"></a>04189 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l04190"></a>04190     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE)
<a name="l04191"></a>04191         ixgbe_init_fdir_signature_82599(&amp;adapter-&gt;hw,
<a name="l04192"></a>04192                         adapter-&gt;fdir_pballoc);
<a name="l04193"></a>04193     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
<a name="l04194"></a>04194         ixgbe_init_fdir_perfect_82599(&amp;adapter-&gt;hw,
<a name="l04195"></a>04195                           adapter-&gt;fdir_pballoc);
<a name="l04196"></a>04196     ixgbe_configure_virtualization(adapter);
<a name="l04197"></a>04197 
<a name="l04198"></a>04198     ixgbe_configure_tx(adapter);
<a name="l04199"></a>04199     ixgbe_configure_rx(adapter);
<a name="l04200"></a>04200 }
<a name="l04201"></a>04201 
<a name="l04202"></a>04202 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_is_sfp(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw)
<a name="l04203"></a>04203 {
<a name="l04204"></a>04204     <span class="keywordflow">switch</span> (hw-&gt;phy.type) {
<a name="l04205"></a>04205     <span class="keywordflow">case</span> ixgbe_phy_sfp_avago:
<a name="l04206"></a>04206     <span class="keywordflow">case</span> ixgbe_phy_sfp_ftl:
<a name="l04207"></a>04207     <span class="keywordflow">case</span> ixgbe_phy_sfp_intel:
<a name="l04208"></a>04208     <span class="keywordflow">case</span> ixgbe_phy_sfp_unknown:
<a name="l04209"></a>04209     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_tyco:
<a name="l04210"></a>04210     <span class="keywordflow">case</span> ixgbe_phy_sfp_passive_unknown:
<a name="l04211"></a>04211     <span class="keywordflow">case</span> ixgbe_phy_sfp_active_unknown:
<a name="l04212"></a>04212     <span class="keywordflow">case</span> ixgbe_phy_sfp_ftl_active:
<a name="l04213"></a>04213         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04214"></a>04214     <span class="keywordflow">case</span> ixgbe_phy_nl:
<a name="l04215"></a>04215         <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l04216"></a>04216             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04217"></a>04217     <span class="keywordflow">default</span>:
<a name="l04218"></a>04218         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04219"></a>04219     }
<a name="l04220"></a>04220 }
<a name="l04221"></a>04221 
<a name="l04226"></a>04226 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_sfp_link_config(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04227"></a>04227 {
<a name="l04228"></a>04228     <span class="comment">/*</span>
<a name="l04229"></a>04229 <span class="comment">     * We are assuming the worst case scenerio here, and that</span>
<a name="l04230"></a>04230 <span class="comment">     * is that an SFP was inserted/removed after the reset</span>
<a name="l04231"></a>04231 <span class="comment">     * but before SFP detection was enabled.  As such the best</span>
<a name="l04232"></a>04232 <span class="comment">     * solution is to just start searching as soon as we start</span>
<a name="l04233"></a>04233 <span class="comment">     */</span>
<a name="l04234"></a>04234     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l04235"></a>04235         adapter-&gt;flags2 |= IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l04236"></a>04236 
<a name="l04237"></a>04237     adapter-&gt;flags2 |= IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l04238"></a>04238 }
<a name="l04239"></a>04239 
<a name="l04246"></a>04246 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_non_sfp_link_config(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw)
<a name="l04247"></a>04247 {
<a name="l04248"></a>04248     u32 autoneg;
<a name="l04249"></a>04249     <span class="keywordtype">bool</span> negotiation, link_up = <span class="keyword">false</span>;
<a name="l04250"></a>04250     u32 ret = IXGBE_ERR_LINK_SETUP;
<a name="l04251"></a>04251 
<a name="l04252"></a>04252     <span class="keywordflow">if</span> (hw-&gt;mac.ops.check_link)
<a name="l04253"></a>04253         ret = hw-&gt;mac.ops.check_link(hw, &amp;autoneg, &amp;link_up, <span class="keyword">false</span>);
<a name="l04254"></a>04254 
<a name="l04255"></a>04255     <span class="keywordflow">if</span> (ret)
<a name="l04256"></a>04256         <span class="keywordflow">goto</span> link_cfg_out;
<a name="l04257"></a>04257 
<a name="l04258"></a>04258     autoneg = hw-&gt;phy.autoneg_advertised;
<a name="l04259"></a>04259     <span class="keywordflow">if</span> ((!autoneg) &amp;&amp; (hw-&gt;mac.ops.get_link_capabilities))
<a name="l04260"></a>04260         ret = hw-&gt;mac.ops.get_link_capabilities(hw, &amp;autoneg,
<a name="l04261"></a>04261                             &amp;negotiation);
<a name="l04262"></a>04262     <span class="keywordflow">if</span> (ret)
<a name="l04263"></a>04263         <span class="keywordflow">goto</span> link_cfg_out;
<a name="l04264"></a>04264 
<a name="l04265"></a>04265     <span class="keywordflow">if</span> (hw-&gt;mac.ops.setup_link)
<a name="l04266"></a>04266         ret = hw-&gt;mac.ops.setup_link(hw, autoneg, negotiation, link_up);
<a name="l04267"></a>04267 link_cfg_out:
<a name="l04268"></a>04268     <span class="keywordflow">return</span> ret;
<a name="l04269"></a>04269 }
<a name="l04270"></a>04270 
<a name="l04278"></a>04278 <span class="keywordtype">void</span> ixgbe_clear_vf_stats_counters(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04279"></a>04279 {
<a name="l04280"></a>04280     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04281"></a>04281     <span class="keywordtype">int</span> i;
<a name="l04282"></a>04282 
<a name="l04283"></a>04283     <span class="keywordflow">for</span>(i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l04284"></a>04284         adapter-&gt;vfinfo[i].last_vfstats.gprc =
<a name="l04285"></a>04285             IXGBE_READ_REG(hw, IXGBE_PVFGPRC(i));
<a name="l04286"></a>04286         adapter-&gt;vfinfo[i].saved_rst_vfstats.gprc +=
<a name="l04287"></a>04287             adapter-&gt;vfinfo[i].vfstats.gprc;
<a name="l04288"></a>04288         adapter-&gt;vfinfo[i].vfstats.gprc = 0;
<a name="l04289"></a>04289         adapter-&gt;vfinfo[i].last_vfstats.gptc =
<a name="l04290"></a>04290             IXGBE_READ_REG(hw, IXGBE_PVFGPTC(i));
<a name="l04291"></a>04291         adapter-&gt;vfinfo[i].saved_rst_vfstats.gptc +=
<a name="l04292"></a>04292             adapter-&gt;vfinfo[i].vfstats.gptc;
<a name="l04293"></a>04293         adapter-&gt;vfinfo[i].vfstats.gptc = 0;
<a name="l04294"></a>04294         adapter-&gt;vfinfo[i].last_vfstats.gorc =
<a name="l04295"></a>04295             IXGBE_READ_REG(hw, IXGBE_PVFGORC_LSB(i));
<a name="l04296"></a>04296         adapter-&gt;vfinfo[i].saved_rst_vfstats.gorc +=
<a name="l04297"></a>04297             adapter-&gt;vfinfo[i].vfstats.gorc;
<a name="l04298"></a>04298         adapter-&gt;vfinfo[i].vfstats.gorc = 0;
<a name="l04299"></a>04299         adapter-&gt;vfinfo[i].last_vfstats.gotc =
<a name="l04300"></a>04300             IXGBE_READ_REG(hw, IXGBE_PVFGOTC_LSB(i));
<a name="l04301"></a>04301         adapter-&gt;vfinfo[i].saved_rst_vfstats.gotc +=
<a name="l04302"></a>04302             adapter-&gt;vfinfo[i].vfstats.gotc;
<a name="l04303"></a>04303         adapter-&gt;vfinfo[i].vfstats.gotc = 0;
<a name="l04304"></a>04304         adapter-&gt;vfinfo[i].last_vfstats.mprc =
<a name="l04305"></a>04305             IXGBE_READ_REG(hw, IXGBE_PVFMPRC(i));
<a name="l04306"></a>04306         adapter-&gt;vfinfo[i].saved_rst_vfstats.mprc +=
<a name="l04307"></a>04307             adapter-&gt;vfinfo[i].vfstats.mprc;
<a name="l04308"></a>04308         adapter-&gt;vfinfo[i].vfstats.mprc = 0;
<a name="l04309"></a>04309     }
<a name="l04310"></a>04310 }
<a name="l04311"></a>04311 
<a name="l04312"></a>04312 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_setup_gpie(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04313"></a>04313 {
<a name="l04314"></a>04314     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04315"></a>04315     u32 gpie = 0;
<a name="l04316"></a>04316 
<a name="l04317"></a>04317     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l04318"></a>04318         gpie = IXGBE_GPIE_MSIX_MODE | IXGBE_GPIE_PBA_SUPPORT |
<a name="l04319"></a>04319                IXGBE_GPIE_OCD;
<a name="l04320"></a>04320 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l04321"></a>04321 <span class="preprocessor"></span>        gpie |= IXGBE_GPIE_EIAME;
<a name="l04322"></a>04322         <span class="comment">/*</span>
<a name="l04323"></a>04323 <span class="comment">         * use EIAM to auto-mask when MSI-X interrupt is asserted</span>
<a name="l04324"></a>04324 <span class="comment">         * this saves a register write for every interrupt</span>
<a name="l04325"></a>04325 <span class="comment">         */</span>
<a name="l04326"></a>04326         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l04327"></a>04327         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l04328"></a>04328             IXGBE_WRITE_REG(hw, IXGBE_EIAM, IXGBE_EICS_RTX_QUEUE);
<a name="l04329"></a>04329             <span class="keywordflow">break</span>;
<a name="l04330"></a>04330         <span class="keywordflow">default</span>:
<a name="l04331"></a>04331         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04332"></a>04332         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04333"></a>04333             IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(0), 0xFFFFFFFF);
<a name="l04334"></a>04334             IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(1), 0xFFFFFFFF);
<a name="l04335"></a>04335             <span class="keywordflow">break</span>;
<a name="l04336"></a>04336         }
<a name="l04337"></a>04337     } <span class="keywordflow">else</span> {
<a name="l04338"></a>04338         <span class="comment">/* legacy interrupts, use EIAM to auto-mask when reading EICR,</span>
<a name="l04339"></a>04339 <span class="comment">         * specifically only auto mask tx and rx interrupts */</span>
<a name="l04340"></a>04340         IXGBE_WRITE_REG(hw, IXGBE_EIAM, IXGBE_EICS_RTX_QUEUE);
<a name="l04341"></a>04341 <span class="preprocessor">#endif</span>
<a name="l04342"></a>04342 <span class="preprocessor"></span>    }
<a name="l04343"></a>04343 
<a name="l04344"></a>04344     <span class="comment">/* XXX: to interrupt immediately for EICS writes, enable this */</span>
<a name="l04345"></a>04345     <span class="comment">/* gpie |= IXGBE_GPIE_EIMEN; */</span>
<a name="l04346"></a>04346 
<a name="l04347"></a>04347     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l04348"></a>04348         gpie &amp;= ~IXGBE_GPIE_VTMODE_MASK;
<a name="l04349"></a>04349         gpie |= IXGBE_GPIE_VTMODE_64;
<a name="l04350"></a>04350     }
<a name="l04351"></a>04351 
<a name="l04352"></a>04352     <span class="comment">/* Enable Thermal over heat sensor interrupt */</span>
<a name="l04353"></a>04353     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_TEMP_SENSOR_CAPABLE)
<a name="l04354"></a>04354         gpie |= IXGBE_SDP0_GPIEN;
<a name="l04355"></a>04355 
<a name="l04356"></a>04356     <span class="comment">/* Enable fan failure interrupt */</span>
<a name="l04357"></a>04357     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE)
<a name="l04358"></a>04358         gpie |= IXGBE_SDP1_GPIEN;
<a name="l04359"></a>04359 
<a name="l04360"></a>04360     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82599EB)
<a name="l04361"></a>04361         gpie |= IXGBE_SDP1_GPIEN;
<a name="l04362"></a>04362         gpie |= IXGBE_SDP2_GPIEN;
<a name="l04363"></a>04363 
<a name="l04364"></a>04364     IXGBE_WRITE_REG(hw, IXGBE_GPIE, gpie);
<a name="l04365"></a>04365 }
<a name="l04366"></a>04366 
<a name="l04367"></a>04367 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_up_complete(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04368"></a>04368 {
<a name="l04369"></a>04369     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04370"></a>04370     <span class="keywordtype">int</span> err;
<a name="l04371"></a>04371     u32 ctrl_ext;
<a name="l04372"></a>04372 
<a name="l04373"></a>04373     ixgbe_get_hw_control(adapter);
<a name="l04374"></a>04374     ixgbe_setup_gpie(adapter);
<a name="l04375"></a>04375 
<a name="l04376"></a>04376     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l04377"></a>04377         ixgbe_configure_msix(adapter);
<a name="l04378"></a>04378     <span class="keywordflow">else</span>
<a name="l04379"></a>04379         ixgbe_configure_msi_and_legacy(adapter);
<a name="l04380"></a>04380 
<a name="l04381"></a>04381     <span class="comment">/* enable the optics */</span>
<a name="l04382"></a>04382     <span class="keywordflow">if</span> ((hw-&gt;phy.multispeed_fiber) ||
<a name="l04383"></a>04383         ((hw-&gt;phy.type == ixgbe_media_type_fiber) &amp;&amp;
<a name="l04384"></a>04384          (hw-&gt;mac.type = ixgbe_mac_82599EB)))
<a name="l04385"></a>04385         ixgbe_enable_tx_laser(hw);
<a name="l04386"></a>04386 
<a name="l04387"></a>04387     clear_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l04388"></a>04388 
<a name="l04389"></a>04389     ixgbe_napi_enable_all(adapter);
<a name="l04390"></a>04390 <span class="preprocessor">#ifndef IXGBE_NO_LLI</span>
<a name="l04391"></a>04391 <span class="preprocessor"></span>    ixgbe_configure_lli(adapter);
<a name="l04392"></a>04392 <span class="preprocessor">#endif</span>
<a name="l04393"></a>04393 <span class="preprocessor"></span>
<a name="l04394"></a>04394     <span class="keywordflow">if</span> (ixgbe_is_sfp(hw)) {
<a name="l04395"></a>04395         ixgbe_sfp_link_config(adapter);
<a name="l04396"></a>04396     } <span class="keywordflow">else</span> {
<a name="l04397"></a>04397         err = ixgbe_non_sfp_link_config(hw);
<a name="l04398"></a>04398         <span class="keywordflow">if</span> (err)
<a name="l04399"></a>04399             DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;link_config FAILED %d\n&quot;</span>, err);
<a name="l04400"></a>04400     }
<a name="l04401"></a>04401 
<a name="l04402"></a>04402     <span class="comment">/* clear any pending interrupts, may auto mask */</span>
<a name="l04403"></a>04403     IXGBE_READ_REG(hw, IXGBE_EICR);
<a name="l04404"></a>04404 
<a name="l04405"></a>04405     ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l04406"></a>04406 
<a name="l04407"></a>04407     <span class="comment">/*</span>
<a name="l04408"></a>04408 <span class="comment">     * If this adapter has a fan, check to see if we had a failure</span>
<a name="l04409"></a>04409 <span class="comment">     * before we enabled the interrupt.</span>
<a name="l04410"></a>04410 <span class="comment">     */</span>
<a name="l04411"></a>04411     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE) {
<a name="l04412"></a>04412         u32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
<a name="l04413"></a>04413         <span class="keywordflow">if</span> (esdp &amp; IXGBE_ESDP_SDP1)
<a name="l04414"></a>04414             DPRINTK(DRV, CRIT,
<a name="l04415"></a>04415                 <span class="stringliteral">&quot;Fan has stopped, replace the adapter\n&quot;</span>);
<a name="l04416"></a>04416     }
<a name="l04417"></a>04417 
<a name="l04418"></a>04418     <span class="comment">/* enable transmits */</span>
<a name="l04419"></a>04419     netif_tx_start_all_queues(adapter-&gt;netdev);
<a name="l04420"></a>04420 
<a name="l04421"></a>04421     <span class="comment">/* bring the link up in the watchdog, this could race with our first</span>
<a name="l04422"></a>04422 <span class="comment">     * link up interrupt but shouldn&#39;t be a problem */</span>
<a name="l04423"></a>04423     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l04424"></a>04424     adapter-&gt;link_check_timeout = jiffies;
<a name="l04425"></a>04425     mod_timer(&amp;adapter-&gt;service_timer, jiffies);
<a name="l04426"></a>04426 
<a name="l04427"></a>04427     ixgbe_clear_vf_stats_counters(adapter);
<a name="l04428"></a>04428     <span class="comment">/* Set PF Reset Done bit so PF/VF Mail Ops can work */</span>
<a name="l04429"></a>04429     ctrl_ext = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
<a name="l04430"></a>04430     ctrl_ext |= IXGBE_CTRL_EXT_PFRSTD;
<a name="l04431"></a>04431     IXGBE_WRITE_REG(hw, IXGBE_CTRL_EXT, ctrl_ext);
<a name="l04432"></a>04432 
<a name="l04433"></a>04433     <span class="keywordflow">return</span> 0;
<a name="l04434"></a>04434 }
<a name="l04435"></a>04435 
<a name="l04436"></a>04436 <span class="keywordtype">void</span> ixgbe_reinit_locked(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04437"></a>04437 {
<a name="l04438"></a>04438     WARN_ON(in_interrupt());
<a name="l04439"></a>04439     <span class="comment">/* put off any impending NetWatchDogTimeout */</span>
<a name="l04440"></a>04440     adapter-&gt;netdev-&gt;trans_start = jiffies;
<a name="l04441"></a>04441 
<a name="l04442"></a>04442     <span class="keywordflow">while</span> (test_and_set_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l04443"></a>04443         msleep(1);
<a name="l04444"></a>04444     ixgbe_down(adapter);
<a name="l04445"></a>04445     <span class="comment">/*</span>
<a name="l04446"></a>04446 <span class="comment">     * If SR-IOV enabled then wait a bit before bringing the adapter</span>
<a name="l04447"></a>04447 <span class="comment">     * back up to give the VFs time to respond to the reset.  The</span>
<a name="l04448"></a>04448 <span class="comment">     * two second wait is based upon the watchdog timer cycle in</span>
<a name="l04449"></a>04449 <span class="comment">     * the VF driver.</span>
<a name="l04450"></a>04450 <span class="comment">     */</span>
<a name="l04451"></a>04451     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l04452"></a>04452         msleep(2000);
<a name="l04453"></a>04453     ixgbe_up(adapter);
<a name="l04454"></a>04454     clear_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state);
<a name="l04455"></a>04455 }
<a name="l04456"></a>04456 
<a name="l04457"></a>04457 <span class="keywordtype">int</span> ixgbe_up(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04458"></a>04458 {
<a name="l04459"></a>04459     <span class="keywordtype">int</span> err;
<a name="l04460"></a>04460 
<a name="l04461"></a>04461     ixgbe_configure(adapter);
<a name="l04462"></a>04462 
<a name="l04463"></a>04463     err = ixgbe_up_complete(adapter);
<a name="l04464"></a>04464 
<a name="l04465"></a>04465     <span class="keywordflow">return</span> err;
<a name="l04466"></a>04466 }
<a name="l04467"></a>04467 
<a name="l04468"></a>04468 <span class="keywordtype">void</span> ixgbe_reset(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04469"></a>04469 {
<a name="l04470"></a>04470     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04471"></a>04471     <span class="keywordtype">int</span> err;
<a name="l04472"></a>04472 
<a name="l04473"></a>04473     <span class="comment">/* lock SFP init bit to prevent race conditions with the watchdog */</span>
<a name="l04474"></a>04474     <span class="keywordflow">while</span> (test_and_set_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state))
<a name="l04475"></a>04475         msleep(1);
<a name="l04476"></a>04476 
<a name="l04477"></a>04477     <span class="comment">/* clear all SFP and link config related flags while holding SFP_INIT */</span>
<a name="l04478"></a>04478     adapter-&gt;flags2 &amp;= ~(IXGBE_FLAG2_SEARCH_FOR_SFP |
<a name="l04479"></a>04479                  IXGBE_FLAG2_SFP_NEEDS_RESET);
<a name="l04480"></a>04480     adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l04481"></a>04481 
<a name="l04482"></a>04482     err = hw-&gt;mac.ops.init_hw(hw);
<a name="l04483"></a>04483     <span class="keywordflow">switch</span> (err) {
<a name="l04484"></a>04484     <span class="keywordflow">case</span> 0:
<a name="l04485"></a>04485     <span class="keywordflow">case</span> IXGBE_ERR_SFP_NOT_PRESENT:
<a name="l04486"></a>04486     <span class="keywordflow">case</span> IXGBE_ERR_SFP_NOT_SUPPORTED:
<a name="l04487"></a>04487         <span class="keywordflow">break</span>;
<a name="l04488"></a>04488     <span class="keywordflow">case</span> IXGBE_ERR_MASTER_REQUESTS_PENDING:
<a name="l04489"></a>04489         DPRINTK(HW, INFO, <span class="stringliteral">&quot;master disable timed out\n&quot;</span>);
<a name="l04490"></a>04490         <span class="keywordflow">break</span>;
<a name="l04491"></a>04491     <span class="keywordflow">case</span> IXGBE_ERR_EEPROM_VERSION:
<a name="l04492"></a>04492         <span class="comment">/* We are running on a pre-production device, log a warning */</span>
<a name="l04493"></a>04493         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;This device is a pre-production adapter/&quot;</span>
<a name="l04494"></a>04494                 <span class="stringliteral">&quot;LOM.  Please be aware there may be issues associated &quot;</span>
<a name="l04495"></a>04495                 <span class="stringliteral">&quot;with your hardware.  If you are experiencing problems &quot;</span>
<a name="l04496"></a>04496                 <span class="stringliteral">&quot;please contact your Intel or hardware representative &quot;</span>
<a name="l04497"></a>04497                 <span class="stringliteral">&quot;who provided you with this hardware.\n&quot;</span>);
<a name="l04498"></a>04498         <span class="keywordflow">break</span>;
<a name="l04499"></a>04499     <span class="keywordflow">default</span>:
<a name="l04500"></a>04500         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;Hardware Error: %d\n&quot;</span>, err);
<a name="l04501"></a>04501     }
<a name="l04502"></a>04502 
<a name="l04503"></a>04503     clear_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state);
<a name="l04504"></a>04504 
<a name="l04505"></a>04505     <span class="comment">/* reprogram the RAR[0] in case user changed it. */</span>
<a name="l04506"></a>04506     <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_rar)
<a name="l04507"></a>04507         hw-&gt;mac.ops.set_rar(hw, 0, hw-&gt;mac.addr, 0, IXGBE_RAH_AV);
<a name="l04508"></a>04508 }
<a name="l04509"></a>04509 
<a name="l04514"></a>04514 <span class="keywordtype">void</span> ixgbe_clean_rx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l04515"></a>04515 {
<a name="l04516"></a>04516     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = rx_ring-&gt;dev;
<a name="l04517"></a>04517     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
<a name="l04518"></a>04518     u16 i;
<a name="l04519"></a>04519 
<a name="l04520"></a>04520     <span class="comment">/* ring already cleared, nothing to do */</span>
<a name="l04521"></a>04521     <span class="keywordflow">if</span> (!rx_ring-&gt;rx_buffer_info)
<a name="l04522"></a>04522         <span class="keywordflow">return</span>;
<a name="l04523"></a>04523 
<a name="l04524"></a>04524     <span class="comment">/* Free all the Rx ring sk_buffs */</span>
<a name="l04525"></a>04525     <span class="keywordflow">for</span> (i = 0; i &lt; rx_ring-&gt;count; i++) {
<a name="l04526"></a>04526         <span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a> *rx_buffer_info;
<a name="l04527"></a>04527 
<a name="l04528"></a>04528         rx_buffer_info = &amp;rx_ring-&gt;rx_buffer_info[i];
<a name="l04529"></a>04529         <span class="keywordflow">if</span> (rx_buffer_info-&gt;dma) {
<a name="l04530"></a>04530             dma_unmap_single(dev,
<a name="l04531"></a>04531                      rx_buffer_info-&gt;dma,
<a name="l04532"></a>04532                      rx_ring-&gt;rx_buf_len,
<a name="l04533"></a>04533                      DMA_FROM_DEVICE);
<a name="l04534"></a>04534             rx_buffer_info-&gt;dma = 0;
<a name="l04535"></a>04535         }
<a name="l04536"></a>04536         <span class="keywordflow">if</span> (rx_buffer_info-&gt;skb) {
<a name="l04537"></a>04537             <span class="keyword">struct </span>sk_buff *skb = rx_buffer_info-&gt;skb;
<a name="l04538"></a>04538             rx_buffer_info-&gt;skb = NULL;
<a name="l04539"></a>04539             <span class="comment">/* We need to clean up RSC frag lists */</span>
<a name="l04540"></a>04540             skb = ixgbe_merge_active_tail(skb);
<a name="l04541"></a>04541             ixgbe_close_active_frag_list(skb);
<a name="l04542"></a>04542             <span class="keywordflow">if</span> (IXGBE_RSC_CB(skb)-&gt;delay_unmap) {
<a name="l04543"></a>04543                 dma_unmap_single(dev,
<a name="l04544"></a>04544                          IXGBE_RSC_CB(skb)-&gt;dma,
<a name="l04545"></a>04545                          rx_ring-&gt;rx_buf_len,
<a name="l04546"></a>04546                          DMA_FROM_DEVICE);
<a name="l04547"></a>04547                 IXGBE_RSC_CB(skb)-&gt;dma = 0;
<a name="l04548"></a>04548                 IXGBE_RSC_CB(skb)-&gt;delay_unmap = <span class="keyword">false</span>;
<a name="l04549"></a>04549             }
<a name="l04550"></a>04550             dev_kfree_skb(skb);
<a name="l04551"></a>04551         }
<a name="l04552"></a>04552         <span class="keywordflow">if</span> (!rx_buffer_info-&gt;page)
<a name="l04553"></a>04553             <span class="keywordflow">continue</span>;
<a name="l04554"></a>04554         <span class="keywordflow">if</span> (rx_buffer_info-&gt;page_dma) {
<a name="l04555"></a>04555             dma_unmap_page(dev,
<a name="l04556"></a>04556                        rx_buffer_info-&gt;page_dma,
<a name="l04557"></a>04557                        PAGE_SIZE / 2,
<a name="l04558"></a>04558                        DMA_FROM_DEVICE);
<a name="l04559"></a>04559             rx_buffer_info-&gt;page_dma = 0;
<a name="l04560"></a>04560         }
<a name="l04561"></a>04561         put_page(rx_buffer_info-&gt;page);
<a name="l04562"></a>04562         rx_buffer_info-&gt;page = NULL;
<a name="l04563"></a>04563         rx_buffer_info-&gt;page_offset = 0;
<a name="l04564"></a>04564     }
<a name="l04565"></a>04565 
<a name="l04566"></a>04566     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a>) * rx_ring-&gt;count;
<a name="l04567"></a>04567     memset(rx_ring-&gt;rx_buffer_info, 0, size);
<a name="l04568"></a>04568 
<a name="l04569"></a>04569     <span class="comment">/* Zero out the descriptor ring */</span>
<a name="l04570"></a>04570     memset(rx_ring-&gt;desc, 0, rx_ring-&gt;size);
<a name="l04571"></a>04571 
<a name="l04572"></a>04572     rx_ring-&gt;next_to_clean = 0;
<a name="l04573"></a>04573     rx_ring-&gt;next_to_use = 0;
<a name="l04574"></a>04574 }
<a name="l04575"></a>04575 
<a name="l04580"></a>04580 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_clean_tx_ring(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l04581"></a>04581 {
<a name="l04582"></a>04582     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info;
<a name="l04583"></a>04583     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size;
<a name="l04584"></a>04584     u16 i;
<a name="l04585"></a>04585 
<a name="l04586"></a>04586     <span class="comment">/* ring already cleared, nothing to do */</span>
<a name="l04587"></a>04587     <span class="keywordflow">if</span> (!tx_ring-&gt;tx_buffer_info)
<a name="l04588"></a>04588         <span class="keywordflow">return</span>;
<a name="l04589"></a>04589 
<a name="l04590"></a>04590     <span class="comment">/* Free all the Tx ring sk_buffs */</span>
<a name="l04591"></a>04591     <span class="keywordflow">for</span> (i = 0; i &lt; tx_ring-&gt;count; i++) {
<a name="l04592"></a>04592         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l04593"></a>04593         ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer_info);
<a name="l04594"></a>04594     }
<a name="l04595"></a>04595 
<a name="l04596"></a>04596     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a>) * tx_ring-&gt;count;
<a name="l04597"></a>04597     memset(tx_ring-&gt;tx_buffer_info, 0, size);
<a name="l04598"></a>04598 
<a name="l04599"></a>04599     <span class="comment">/* Zero out the descriptor ring */</span>
<a name="l04600"></a>04600     memset(tx_ring-&gt;desc, 0, tx_ring-&gt;size);
<a name="l04601"></a>04601 
<a name="l04602"></a>04602     tx_ring-&gt;next_to_use = 0;
<a name="l04603"></a>04603     tx_ring-&gt;next_to_clean = 0;
<a name="l04604"></a>04604 }
<a name="l04605"></a>04605 
<a name="l04610"></a>04610 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_clean_all_rx_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04611"></a>04611 {
<a name="l04612"></a>04612     <span class="keywordtype">int</span> i;
<a name="l04613"></a>04613 
<a name="l04614"></a>04614     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l04615"></a>04615         ixgbe_clean_rx_ring(adapter-&gt;rx_ring[i]);
<a name="l04616"></a>04616 }
<a name="l04617"></a>04617 
<a name="l04622"></a>04622 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_clean_all_tx_rings(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04623"></a>04623 {
<a name="l04624"></a>04624     <span class="keywordtype">int</span> i;
<a name="l04625"></a>04625 
<a name="l04626"></a>04626     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l04627"></a>04627         ixgbe_clean_tx_ring(adapter-&gt;tx_ring[i]);
<a name="l04628"></a>04628 }
<a name="l04629"></a>04629 
<a name="l04630"></a>04630 <span class="keywordtype">void</span> ixgbe_down(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04631"></a>04631 {
<a name="l04632"></a>04632     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l04633"></a>04633     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l04634"></a>04634     u32 rxctrl;
<a name="l04635"></a>04635     <span class="keywordtype">int</span> i;
<a name="l04636"></a>04636 
<a name="l04637"></a>04637     <span class="comment">/* signal that we are down to the interrupt handler */</span>
<a name="l04638"></a>04638     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l04639"></a>04639 
<a name="l04640"></a>04640     <span class="comment">/* disable receives */</span>
<a name="l04641"></a>04641     rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
<a name="l04642"></a>04642     IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl &amp; ~IXGBE_RXCTRL_RXEN);
<a name="l04643"></a>04643 
<a name="l04644"></a>04644     <span class="comment">/* disable all enabled rx queues */</span>
<a name="l04645"></a>04645     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l04646"></a>04646         <span class="comment">/* this call also flushes the previous write */</span>
<a name="l04647"></a>04647         ixgbe_disable_rx_queue(adapter, adapter-&gt;rx_ring[i]);
<a name="l04648"></a>04648 
<a name="l04649"></a>04649     msleep(10);
<a name="l04650"></a>04650 
<a name="l04651"></a>04651     netif_tx_stop_all_queues(netdev);
<a name="l04652"></a>04652 
<a name="l04653"></a>04653     <span class="comment">/* call carrier off first to avoid false dev_watchdog timeouts */</span>
<a name="l04654"></a>04654     netif_carrier_off(netdev);
<a name="l04655"></a>04655     netif_tx_disable(netdev);
<a name="l04656"></a>04656 
<a name="l04657"></a>04657     ixgbe_irq_disable(adapter);
<a name="l04658"></a>04658 
<a name="l04659"></a>04659     ixgbe_napi_disable_all(adapter);
<a name="l04660"></a>04660 
<a name="l04661"></a>04661     adapter-&gt;flags2 &amp;= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
<a name="l04662"></a>04662                  IXGBE_FLAG2_RESET_REQUESTED);
<a name="l04663"></a>04663     adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l04664"></a>04664 
<a name="l04665"></a>04665     del_timer_sync(&amp;adapter-&gt;service_timer);
<a name="l04666"></a>04666 
<a name="l04667"></a>04667     <span class="comment">/* disable receive for all VFs and wait one second */</span>
<a name="l04668"></a>04668     <span class="keywordflow">if</span> (adapter-&gt;num_vfs) {
<a name="l04669"></a>04669         <span class="comment">/* Mark all the VFs as inactive */</span>
<a name="l04670"></a>04670         <span class="keywordflow">for</span> (i = 0 ; i &lt; adapter-&gt;num_vfs; i++)
<a name="l04671"></a>04671             adapter-&gt;vfinfo[i].clear_to_send = 0;
<a name="l04672"></a>04672 
<a name="l04673"></a>04673         <span class="comment">/* ping all the active vfs to let them know we are going down */</span>
<a name="l04674"></a>04674         ixgbe_ping_all_vfs(adapter);
<a name="l04675"></a>04675 
<a name="l04676"></a>04676         <span class="comment">/* Disable all VFTE/VFRE TX/RX */</span>
<a name="l04677"></a>04677         ixgbe_disable_tx_rx(adapter);
<a name="l04678"></a>04678     }
<a name="l04679"></a>04679 
<a name="l04680"></a>04680     <span class="comment">/* disable transmits in the hardware now that interrupts are off */</span>
<a name="l04681"></a>04681     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l04682"></a>04682         u8 reg_idx = adapter-&gt;tx_ring[i]-&gt;reg_idx;
<a name="l04683"></a>04683         IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), 0);
<a name="l04684"></a>04684     }
<a name="l04685"></a>04685 
<a name="l04686"></a>04686     <span class="comment">/* Disable the Tx DMA engine on 82599 and X540 */</span>
<a name="l04687"></a>04687     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l04688"></a>04688     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04689"></a>04689     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04690"></a>04690         IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL,
<a name="l04691"></a>04691                 (IXGBE_READ_REG(hw, IXGBE_DMATXCTL) &amp;
<a name="l04692"></a>04692                  ~IXGBE_DMATXCTL_TE));
<a name="l04693"></a>04693         <span class="keywordflow">break</span>;
<a name="l04694"></a>04694     <span class="keywordflow">default</span>:
<a name="l04695"></a>04695         <span class="keywordflow">break</span>;
<a name="l04696"></a>04696     }
<a name="l04697"></a>04697 
<a name="l04698"></a>04698 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l04699"></a>04699 <span class="preprocessor"></span>    ethtool_ntuple_flush(netdev);
<a name="l04700"></a>04700 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l04701"></a>04701 
<a name="l04702"></a>04702 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l04703"></a>04703 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!pci_channel_offline(adapter-&gt;pdev))
<a name="l04704"></a>04704 <span class="preprocessor">#endif</span>
<a name="l04705"></a>04705 <span class="preprocessor"></span>        ixgbe_reset(adapter);
<a name="l04706"></a>04706     <span class="comment">/* power down the optics */</span>
<a name="l04707"></a>04707     <span class="keywordflow">if</span> ((hw-&gt;phy.multispeed_fiber) ||
<a name="l04708"></a>04708         ((hw-&gt;phy.type == ixgbe_media_type_fiber) &amp;&amp;
<a name="l04709"></a>04709          (hw-&gt;mac.type = ixgbe_mac_82599EB)))
<a name="l04710"></a>04710         ixgbe_disable_tx_laser(hw);
<a name="l04711"></a>04711 
<a name="l04712"></a>04712     ixgbe_clean_all_tx_rings(adapter);
<a name="l04713"></a>04713     ixgbe_clean_all_rx_rings(adapter);
<a name="l04714"></a>04714 
<a name="l04715"></a>04715     <span class="comment">/* since we reset the hardware DCA settings were cleared */</span>
<a name="l04716"></a>04716     ixgbe_setup_dca(adapter);
<a name="l04717"></a>04717 }
<a name="l04718"></a>04718 
<a name="l04719"></a>04719 
<a name="l04729"></a>04729 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_dcb_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04730"></a>04730 {
<a name="l04731"></a>04731     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l04732"></a>04732     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_DCB];
<a name="l04733"></a>04733 
<a name="l04734"></a>04734     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l04735"></a>04735         <span class="keywordflow">return</span> ret;
<a name="l04736"></a>04736 
<a name="l04737"></a>04737 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l04738"></a>04738 <span class="preprocessor"></span>    f-&gt;mask = 0x7 &lt;&lt; 3;
<a name="l04739"></a>04739     adapter-&gt;num_rx_queues = f-&gt;indices;
<a name="l04740"></a>04740     adapter-&gt;num_tx_queues = f-&gt;indices;
<a name="l04741"></a>04741     ret = <span class="keyword">true</span>;
<a name="l04742"></a>04742 <span class="preprocessor">#else</span>
<a name="l04743"></a>04743 <span class="preprocessor"></span>    DPRINTK(DRV, INFO, <span class="stringliteral">&quot;Kernel has no multiqueue support, disabling DCB\n&quot;</span>);
<a name="l04744"></a>04744     f-&gt;mask = 0;
<a name="l04745"></a>04745     f-&gt;indices = 0;
<a name="l04746"></a>04746 <span class="preprocessor">#endif</span>
<a name="l04747"></a>04747 <span class="preprocessor"></span>
<a name="l04748"></a>04748     <span class="keywordflow">return</span> ret;
<a name="l04749"></a>04749 }
<a name="l04750"></a>04750 
<a name="l04760"></a>04760 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_vmdq_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04761"></a>04761 {
<a name="l04762"></a>04762     <span class="keywordtype">int</span> vmdq_i = adapter-&gt;ring_feature[RING_F_VMDQ].indices;
<a name="l04763"></a>04763     <span class="keywordtype">int</span> vmdq_m = 0;
<a name="l04764"></a>04764     <span class="keywordtype">int</span> rss_i = adapter-&gt;ring_feature[RING_F_RSS].indices;
<a name="l04765"></a>04765     <span class="keywordtype">int</span> rss_m = adapter-&gt;ring_feature[RING_F_RSS].mask;
<a name="l04766"></a>04766     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l04767"></a>04767     <span class="keywordtype">int</span> rss_shift;
<a name="l04768"></a>04768     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l04769"></a>04769 
<a name="l04770"></a>04770     <span class="keywordflow">switch</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_RSS_ENABLED
<a name="l04771"></a>04771                    | IXGBE_FLAG_DCB_ENABLED
<a name="l04772"></a>04772                    | IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l04773"></a>04773 
<a name="l04774"></a>04774     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l04775"></a>04775         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l04776"></a>04776         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04777"></a>04777         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04778"></a>04778             vmdq_i = min(IXGBE_MAX_VMDQ_INDICES, vmdq_i);
<a name="l04779"></a>04779             <span class="keywordflow">if</span> (vmdq_i &gt; 32)
<a name="l04780"></a>04780                 rss_i = 2;
<a name="l04781"></a>04781             <span class="keywordflow">else</span>
<a name="l04782"></a>04782                 rss_i = 4;
<a name="l04783"></a>04783             i = rss_i;
<a name="l04784"></a>04784             rss_shift = find_first_bit(&amp;i, <span class="keyword">sizeof</span>(i) * 8);
<a name="l04785"></a>04785             rss_m = (rss_i - 1);
<a name="l04786"></a>04786             vmdq_m = ((IXGBE_MAX_VMDQ_INDICES - 1) &lt;&lt;
<a name="l04787"></a>04787                        rss_shift) &amp; (MAX_RX_QUEUES - 1);
<a name="l04788"></a>04788             <span class="keywordflow">break</span>;
<a name="l04789"></a>04789         <span class="keywordflow">default</span>:
<a name="l04790"></a>04790             <span class="keywordflow">break</span>;
<a name="l04791"></a>04791         }
<a name="l04792"></a>04792         adapter-&gt;num_rx_queues = vmdq_i * rss_i;
<a name="l04793"></a>04793         adapter-&gt;num_tx_queues = min(MAX_TX_QUEUES, vmdq_i * rss_i);
<a name="l04794"></a>04794         ret = <span class="keyword">true</span>;
<a name="l04795"></a>04795         <span class="keywordflow">break</span>;
<a name="l04796"></a>04796 
<a name="l04797"></a>04797     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l04798"></a>04798         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l04799"></a>04799         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l04800"></a>04800             vmdq_m = (IXGBE_MAX_VMDQ_INDICES - 1);
<a name="l04801"></a>04801             <span class="keywordflow">break</span>;
<a name="l04802"></a>04802         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l04803"></a>04803         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l04804"></a>04804             vmdq_m = (IXGBE_MAX_VMDQ_INDICES - 1) &lt;&lt; 1;
<a name="l04805"></a>04805             <span class="keywordflow">break</span>;
<a name="l04806"></a>04806         <span class="keywordflow">default</span>:
<a name="l04807"></a>04807             <span class="keywordflow">break</span>;
<a name="l04808"></a>04808         }
<a name="l04809"></a>04809         adapter-&gt;num_rx_queues = vmdq_i;
<a name="l04810"></a>04810         adapter-&gt;num_tx_queues = vmdq_i;
<a name="l04811"></a>04811         ret = <span class="keyword">true</span>;
<a name="l04812"></a>04812         <span class="keywordflow">break</span>;
<a name="l04813"></a>04813 
<a name="l04814"></a>04814     <span class="keywordflow">default</span>:
<a name="l04815"></a>04815         ret = <span class="keyword">false</span>;
<a name="l04816"></a>04816         <span class="keywordflow">goto</span> vmdq_queues_out;
<a name="l04817"></a>04817     }
<a name="l04818"></a>04818 
<a name="l04819"></a>04819     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l04820"></a>04820         adapter-&gt;num_rx_pools = vmdq_i;
<a name="l04821"></a>04821         adapter-&gt;num_rx_queues_per_pool = adapter-&gt;num_rx_queues /
<a name="l04822"></a>04822                                           vmdq_i;
<a name="l04823"></a>04823     } <span class="keywordflow">else</span> {
<a name="l04824"></a>04824         adapter-&gt;num_rx_pools = adapter-&gt;num_rx_queues;
<a name="l04825"></a>04825         adapter-&gt;num_rx_queues_per_pool = 1;
<a name="l04826"></a>04826     }
<a name="l04827"></a>04827     <span class="comment">/* save the mask for later use */</span>
<a name="l04828"></a>04828     adapter-&gt;ring_feature[RING_F_VMDQ].mask = vmdq_m;
<a name="l04829"></a>04829 vmdq_queues_out:
<a name="l04830"></a>04830     <span class="keywordflow">return</span> ret;
<a name="l04831"></a>04831 }
<a name="l04832"></a>04832 
<a name="l04841"></a>04841 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_rss_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04842"></a>04842 {
<a name="l04843"></a>04843     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l04844"></a>04844     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_RSS];
<a name="l04845"></a>04845 
<a name="l04846"></a>04846     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) {
<a name="l04847"></a>04847         f-&gt;mask = 0xF;
<a name="l04848"></a>04848         adapter-&gt;num_rx_queues = f-&gt;indices;
<a name="l04849"></a>04849 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l04850"></a>04850 <span class="preprocessor"></span>        adapter-&gt;num_tx_queues = f-&gt;indices;
<a name="l04851"></a>04851 <span class="preprocessor">#endif</span>
<a name="l04852"></a>04852 <span class="preprocessor"></span>        ret = <span class="keyword">true</span>;
<a name="l04853"></a>04853     }
<a name="l04854"></a>04854 
<a name="l04855"></a>04855     <span class="keywordflow">return</span> ret;
<a name="l04856"></a>04856 }
<a name="l04857"></a>04857 
<a name="l04868"></a>04868 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_fdir_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04869"></a>04869 {
<a name="l04870"></a>04870     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l04871"></a>04871     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f_fdir = &amp;adapter-&gt;ring_feature[RING_F_FDIR];
<a name="l04872"></a>04872 
<a name="l04873"></a>04873     f_fdir-&gt;indices = min((<span class="keywordtype">int</span>)num_online_cpus(), f_fdir-&gt;indices);
<a name="l04874"></a>04874     f_fdir-&gt;mask = 0;
<a name="l04875"></a>04875 
<a name="l04876"></a>04876     <span class="comment">/*</span>
<a name="l04877"></a>04877 <span class="comment">     * Use RSS in addition to Flow Director to ensure the best</span>
<a name="l04878"></a>04878 <span class="comment">     * distribution of flows across cores, even when an FDIR flow</span>
<a name="l04879"></a>04879 <span class="comment">     * isn&#39;t matched.</span>
<a name="l04880"></a>04880 <span class="comment">     */</span>
<a name="l04881"></a>04881     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED &amp;&amp;
<a name="l04882"></a>04882         ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE ||
<a name="l04883"></a>04883          (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)))) {
<a name="l04884"></a>04884 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l04885"></a>04885 <span class="preprocessor"></span>        adapter-&gt;num_tx_queues = f_fdir-&gt;indices;
<a name="l04886"></a>04886 <span class="preprocessor">#endif</span>
<a name="l04887"></a>04887 <span class="preprocessor"></span>        adapter-&gt;num_rx_queues = f_fdir-&gt;indices;
<a name="l04888"></a>04888         ret = <span class="keyword">true</span>;
<a name="l04889"></a>04889     } <span class="keywordflow">else</span> {
<a name="l04890"></a>04890         adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l04891"></a>04891         adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
<a name="l04892"></a>04892     }
<a name="l04893"></a>04893     <span class="keywordflow">return</span> ret;
<a name="l04894"></a>04894 }
<a name="l04895"></a>04895 
<a name="l04896"></a>04896 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l04897"></a>04897 <span class="preprocessor"></span>
<a name="l04907"></a>04907 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_fcoe_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04908"></a>04908 {
<a name="l04909"></a>04909     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l04910"></a>04910     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l04911"></a>04911 
<a name="l04912"></a>04912     f-&gt;indices = min((<span class="keywordtype">int</span>)num_online_cpus(), f-&gt;indices);
<a name="l04913"></a>04913     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) {
<a name="l04914"></a>04914         adapter-&gt;num_rx_queues = 1;
<a name="l04915"></a>04915         adapter-&gt;num_tx_queues = 1;
<a name="l04916"></a>04916         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l04917"></a>04917             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;FCoE enabled with DCB \n&quot;</span>);
<a name="l04918"></a>04918             ixgbe_set_dcb_queues(adapter);
<a name="l04919"></a>04919         }
<a name="l04920"></a>04920         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) {
<a name="l04921"></a>04921             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;FCoE enabled with RSS \n&quot;</span>);
<a name="l04922"></a>04922             <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) ||
<a name="l04923"></a>04923                 (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE))
<a name="l04924"></a>04924                 ixgbe_set_fdir_queues(adapter);
<a name="l04925"></a>04925             <span class="keywordflow">else</span>
<a name="l04926"></a>04926                 ixgbe_set_rss_queues(adapter);
<a name="l04927"></a>04927         }
<a name="l04928"></a>04928         <span class="comment">/* adding FCoE queues */</span>
<a name="l04929"></a>04929         f-&gt;mask = adapter-&gt;num_rx_queues;
<a name="l04930"></a>04930         adapter-&gt;num_rx_queues += f-&gt;indices;
<a name="l04931"></a>04931         adapter-&gt;num_tx_queues += f-&gt;indices;
<a name="l04932"></a>04932 
<a name="l04933"></a>04933         ret = <span class="keyword">true</span>;
<a name="l04934"></a>04934     }
<a name="l04935"></a>04935 
<a name="l04936"></a>04936     <span class="keywordflow">return</span> ret;
<a name="l04937"></a>04937 }
<a name="l04938"></a>04938 
<a name="l04939"></a>04939 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l04940"></a>04940 
<a name="l04949"></a>04949 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_set_sriov_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04950"></a>04950 {
<a name="l04951"></a>04951     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04952"></a>04952 }
<a name="l04953"></a>04953 
<a name="l04954"></a>04954 <span class="comment">/*</span>
<a name="l04955"></a>04955 <span class="comment"> * ixgbe_set_num_queues: Allocate queues for device, feature dependant</span>
<a name="l04956"></a>04956 <span class="comment"> * @adapter: board private structure to initialize</span>
<a name="l04957"></a>04957 <span class="comment"> *</span>
<a name="l04958"></a>04958 <span class="comment"> * This is the top level queue allocation routine.  The order here is very</span>
<a name="l04959"></a>04959 <span class="comment"> * important, starting with the &quot;most&quot; number of features turned on at once,</span>
<a name="l04960"></a>04960 <span class="comment"> * and ending with the smallest set of features.  This way large combinations</span>
<a name="l04961"></a>04961 <span class="comment"> * can be allocated if they&#39;re turned on, and smaller combinations are the</span>
<a name="l04962"></a>04962 <span class="comment"> * fallthrough conditions.</span>
<a name="l04963"></a>04963 <span class="comment"> *</span>
<a name="l04964"></a>04964 <span class="comment"> **/</span>
<a name="l04965"></a>04965 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_set_num_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l04966"></a>04966 {
<a name="l04967"></a>04967     <span class="comment">/* Start with base case */</span>
<a name="l04968"></a>04968     adapter-&gt;num_rx_queues = 1;
<a name="l04969"></a>04969     adapter-&gt;num_tx_queues = 1;
<a name="l04970"></a>04970     adapter-&gt;num_rx_pools = adapter-&gt;num_rx_queues;
<a name="l04971"></a>04971     adapter-&gt;num_rx_queues_per_pool = 1;
<a name="l04972"></a>04972 
<a name="l04973"></a>04973     <span class="keywordflow">if</span> (ixgbe_set_sriov_queues(adapter))
<a name="l04974"></a>04974         <span class="keywordflow">return</span>;
<a name="l04975"></a>04975 
<a name="l04976"></a>04976     <span class="keywordflow">if</span> (ixgbe_set_vmdq_queues(adapter))
<a name="l04977"></a>04977         <span class="keywordflow">return</span>;
<a name="l04978"></a>04978 
<a name="l04979"></a>04979 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l04980"></a>04980 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ixgbe_set_fcoe_queues(adapter))
<a name="l04981"></a>04981         <span class="keywordflow">return</span>;
<a name="l04982"></a>04982 
<a name="l04983"></a>04983 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l04984"></a>04984     <span class="keywordflow">if</span> (ixgbe_set_dcb_queues(adapter))
<a name="l04985"></a>04985         <span class="keywordflow">return</span>;
<a name="l04986"></a>04986 
<a name="l04987"></a>04987     <span class="keywordflow">if</span> (ixgbe_set_fdir_queues(adapter))
<a name="l04988"></a>04988         <span class="keywordflow">return</span>;
<a name="l04989"></a>04989 
<a name="l04990"></a>04990     <span class="keywordflow">if</span> (ixgbe_set_rss_queues(adapter))
<a name="l04991"></a>04991         <span class="keywordflow">return</span>;
<a name="l04992"></a>04992 }
<a name="l04993"></a>04993 
<a name="l04994"></a>04994 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_acquire_msix_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l04995"></a>04995                        <span class="keywordtype">int</span> vectors)
<a name="l04996"></a>04996 {
<a name="l04997"></a>04997     <span class="keywordtype">int</span> err, vector_threshold;
<a name="l04998"></a>04998 
<a name="l04999"></a>04999     <span class="comment">/* We&#39;ll want at least 3 (vector_threshold):</span>
<a name="l05000"></a>05000 <span class="comment">     * 1) TxQ[0] Cleanup</span>
<a name="l05001"></a>05001 <span class="comment">     * 2) RxQ[0] Cleanup</span>
<a name="l05002"></a>05002 <span class="comment">     * 3) Other (Link Status Change, etc.)</span>
<a name="l05003"></a>05003 <span class="comment">     * 4) TCP Timer (optional)</span>
<a name="l05004"></a>05004 <span class="comment">     */</span>
<a name="l05005"></a>05005     vector_threshold = MIN_MSIX_COUNT;
<a name="l05006"></a>05006 
<a name="l05007"></a>05007     <span class="comment">/* The more we get, the more we will assign to Tx/Rx Cleanup</span>
<a name="l05008"></a>05008 <span class="comment">     * for the separate queues...where Rx Cleanup &gt;= Tx Cleanup.</span>
<a name="l05009"></a>05009 <span class="comment">     * Right now, we simply care about how many we&#39;ll get; we&#39;ll</span>
<a name="l05010"></a>05010 <span class="comment">     * set them up later while requesting irq&#39;s.</span>
<a name="l05011"></a>05011 <span class="comment">     */</span>
<a name="l05012"></a>05012     <span class="keywordflow">while</span> (vectors &gt;= vector_threshold) {
<a name="l05013"></a>05013         err = pci_enable_msix(adapter-&gt;pdev, adapter-&gt;msix_entries,
<a name="l05014"></a>05014                       vectors);
<a name="l05015"></a>05015         <span class="keywordflow">if</span> (!err) <span class="comment">/* Success in acquiring all requested vectors. */</span>
<a name="l05016"></a>05016             <span class="keywordflow">break</span>;
<a name="l05017"></a>05017         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err &lt; 0)
<a name="l05018"></a>05018             vectors = 0; <span class="comment">/* Nasty failure, quit now */</span>
<a name="l05019"></a>05019         <span class="keywordflow">else</span> <span class="comment">/* err == number of vectors we should try again with */</span>
<a name="l05020"></a>05020             vectors = err;
<a name="l05021"></a>05021     }
<a name="l05022"></a>05022 
<a name="l05023"></a>05023     <span class="keywordflow">if</span> (vectors &lt; vector_threshold) {
<a name="l05024"></a>05024         <span class="comment">/* Can&#39;t allocate enough MSI-X interrupts?  Oh well.</span>
<a name="l05025"></a>05025 <span class="comment">         * This just means we&#39;ll go with either a single MSI</span>
<a name="l05026"></a>05026 <span class="comment">         * vector or fall back to legacy interrupts.</span>
<a name="l05027"></a>05027 <span class="comment">         */</span>
<a name="l05028"></a>05028         DPRINTK(HW, DEBUG, <span class="stringliteral">&quot;Unable to allocate MSI-X interrupts\n&quot;</span>);
<a name="l05029"></a>05029         adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSIX_ENABLED;
<a name="l05030"></a>05030         kfree(adapter-&gt;msix_entries);
<a name="l05031"></a>05031         adapter-&gt;msix_entries = NULL;
<a name="l05032"></a>05032     } <span class="keywordflow">else</span> {
<a name="l05033"></a>05033         adapter-&gt;flags |= IXGBE_FLAG_MSIX_ENABLED; <span class="comment">/* Woot! */</span>
<a name="l05034"></a>05034         <span class="comment">/*</span>
<a name="l05035"></a>05035 <span class="comment">         * Adjust for only the vectors we&#39;ll use, which is minimum</span>
<a name="l05036"></a>05036 <span class="comment">         * of max_msix_q_vectors + NON_Q_VECTORS, or the number of</span>
<a name="l05037"></a>05037 <span class="comment">         * vectors we were allocated.</span>
<a name="l05038"></a>05038 <span class="comment">         */</span>
<a name="l05039"></a>05039         adapter-&gt;num_msix_vectors = min(vectors,
<a name="l05040"></a>05040                    adapter-&gt;max_msix_q_vectors + NON_Q_VECTORS);
<a name="l05041"></a>05041     }
<a name="l05042"></a>05042 }
<a name="l05043"></a>05043 
<a name="l05051"></a>05051 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_rss(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05052"></a>05052 {
<a name="l05053"></a>05053     <span class="keywordtype">int</span> i;
<a name="l05054"></a>05054 
<a name="l05055"></a>05055     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED))
<a name="l05056"></a>05056         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05057"></a>05057 
<a name="l05058"></a>05058     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05059"></a>05059         adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05060"></a>05060     for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05061"></a>05061         adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05062"></a>05062 
<a name="l05063"></a>05063     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05064"></a>05064 }
<a name="l05065"></a>05065 
<a name="l05073"></a>05073 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_dcb(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05074"></a>05074 {
<a name="l05075"></a>05075     <span class="keywordtype">int</span> i;
<a name="l05076"></a>05076     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05077"></a>05077     <span class="keywordtype">int</span> dcb_i = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l05078"></a>05078 
<a name="l05079"></a>05079     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED))
<a name="l05080"></a>05080         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05081"></a>05081 
<a name="l05082"></a>05082     <span class="comment">/* the number of queues is assumed to be symmetric */</span>
<a name="l05083"></a>05083     <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l05084"></a>05084     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l05085"></a>05085         <span class="keywordflow">for</span> (i = 0; i &lt; dcb_i; i++) {
<a name="l05086"></a>05086             adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 3;
<a name="l05087"></a>05087             adapter-&gt;tx_ring[i]-&gt;reg_idx = i &lt;&lt; 2;
<a name="l05088"></a>05088         }
<a name="l05089"></a>05089         ret = <span class="keyword">true</span>;
<a name="l05090"></a>05090         <span class="keywordflow">break</span>;
<a name="l05091"></a>05091     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05092"></a>05092     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05093"></a>05093         <span class="keywordflow">if</span> (dcb_i == 8) {
<a name="l05094"></a>05094             <span class="comment">/*</span>
<a name="l05095"></a>05095 <span class="comment">             * Tx TC0 starts at: descriptor queue 0</span>
<a name="l05096"></a>05096 <span class="comment">             * Tx TC1 starts at: descriptor queue 32</span>
<a name="l05097"></a>05097 <span class="comment">             * Tx TC2 starts at: descriptor queue 64</span>
<a name="l05098"></a>05098 <span class="comment">             * Tx TC3 starts at: descriptor queue 80</span>
<a name="l05099"></a>05099 <span class="comment">             * Tx TC4 starts at: descriptor queue 96</span>
<a name="l05100"></a>05100 <span class="comment">             * Tx TC5 starts at: descriptor queue 104</span>
<a name="l05101"></a>05101 <span class="comment">             * Tx TC6 starts at: descriptor queue 112</span>
<a name="l05102"></a>05102 <span class="comment">             * Tx TC7 starts at: descriptor queue 120</span>
<a name="l05103"></a>05103 <span class="comment">             *</span>
<a name="l05104"></a>05104 <span class="comment">             * Rx TC0-TC7 are offset by 16 queues each</span>
<a name="l05105"></a>05105 <span class="comment">             */</span>
<a name="l05106"></a>05106             <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l05107"></a>05107                 adapter-&gt;tx_ring[i]-&gt;reg_idx = i &lt;&lt; 5;
<a name="l05108"></a>05108                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 4;
<a name="l05109"></a>05109             }
<a name="l05110"></a>05110             <span class="keywordflow">for</span> ( ; i &lt; 5; i++) {
<a name="l05111"></a>05111                 adapter-&gt;tx_ring[i]-&gt;reg_idx = ((i + 2) &lt;&lt; 4);
<a name="l05112"></a>05112                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 4;
<a name="l05113"></a>05113             }
<a name="l05114"></a>05114             <span class="keywordflow">for</span> ( ; i &lt; dcb_i; i++) {
<a name="l05115"></a>05115                 adapter-&gt;tx_ring[i]-&gt;reg_idx = ((i + 8) &lt;&lt; 3);
<a name="l05116"></a>05116                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 4;
<a name="l05117"></a>05117             }
<a name="l05118"></a>05118             ret = <span class="keyword">true</span>;
<a name="l05119"></a>05119         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dcb_i == 4) {
<a name="l05120"></a>05120             <span class="comment">/*</span>
<a name="l05121"></a>05121 <span class="comment">             * Tx TC0 starts at: descriptor queue 0</span>
<a name="l05122"></a>05122 <span class="comment">             * Tx TC1 starts at: descriptor queue 64</span>
<a name="l05123"></a>05123 <span class="comment">             * Tx TC2 starts at: descriptor queue 96</span>
<a name="l05124"></a>05124 <span class="comment">             * Tx TC3 starts at: descriptor queue 112</span>
<a name="l05125"></a>05125 <span class="comment">             *</span>
<a name="l05126"></a>05126 <span class="comment">             * Rx TC0-TC3 are offset by 32 queues each</span>
<a name="l05127"></a>05127 <span class="comment">             */</span>
<a name="l05128"></a>05128             adapter-&gt;tx_ring[0]-&gt;reg_idx = 0;
<a name="l05129"></a>05129             adapter-&gt;tx_ring[1]-&gt;reg_idx = 64;
<a name="l05130"></a>05130             adapter-&gt;tx_ring[2]-&gt;reg_idx = 96;
<a name="l05131"></a>05131             adapter-&gt;tx_ring[3]-&gt;reg_idx = 112;
<a name="l05132"></a>05132             <span class="keywordflow">for</span> (i = 0 ; i &lt; dcb_i; i++)
<a name="l05133"></a>05133                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i &lt;&lt; 5;
<a name="l05134"></a>05134             ret = <span class="keyword">true</span>;
<a name="l05135"></a>05135         }
<a name="l05136"></a>05136         <span class="keywordflow">break</span>;
<a name="l05137"></a>05137     <span class="keywordflow">default</span>:
<a name="l05138"></a>05138         <span class="keywordflow">break</span>;
<a name="l05139"></a>05139     }
<a name="l05140"></a>05140     <span class="keywordflow">return</span> ret;
<a name="l05141"></a>05141 }
<a name="l05142"></a>05142 
<a name="l05152"></a>05152 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_vmdq(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05153"></a>05153 {
<a name="l05154"></a>05154     <span class="keywordtype">int</span> i;
<a name="l05155"></a>05155     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05156"></a>05156 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05157"></a>05157 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l05158"></a>05158 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05159"></a>05159     <span class="keywordflow">switch</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_RSS_ENABLED
<a name="l05160"></a>05160                    | IXGBE_FLAG_DCB_ENABLED
<a name="l05161"></a>05161                    | IXGBE_FLAG_VMDQ_ENABLED)) {
<a name="l05162"></a>05162 
<a name="l05163"></a>05163     <span class="keywordflow">case</span> (IXGBE_FLAG_RSS_ENABLED | IXGBE_FLAG_VMDQ_ENABLED):
<a name="l05164"></a>05164         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l05165"></a>05165         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05166"></a>05166         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05167"></a>05167             <span class="comment">/* since the # of rss queues per vmdq pool is</span>
<a name="l05168"></a>05168 <span class="comment">             * limited to either 2 or 4, there is no index</span>
<a name="l05169"></a>05169 <span class="comment">             * skipping and we can set them up with no</span>
<a name="l05170"></a>05170 <span class="comment">             * funky mapping</span>
<a name="l05171"></a>05171 <span class="comment">             */</span>
<a name="l05172"></a>05172             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05173"></a>05173                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05174"></a>05174             for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05175"></a>05175                 adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05176"></a>05176             ret = <span class="keyword">true</span>;
<a name="l05177"></a>05177             <span class="keywordflow">break</span>;
<a name="l05178"></a>05178         <span class="keywordflow">default</span>:
<a name="l05179"></a>05179             <span class="keywordflow">break</span>;
<a name="l05180"></a>05180         }
<a name="l05181"></a>05181         <span class="keywordflow">break</span>;
<a name="l05182"></a>05182 
<a name="l05183"></a>05183     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_DCB_ENABLED):
<a name="l05184"></a>05184         <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82599EB) {
<a name="l05185"></a>05185             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l05186"></a>05186                 adapter-&gt;rx_ring[i]-&gt;reg_idx =
<a name="l05187"></a>05187                     (adapter-&gt;num_vfs + i) *
<a name="l05188"></a>05188                      adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l05189"></a>05189 #ifdef IXGBE_FCOE
<a name="l05190"></a>05190                 adapter-&gt;rx_ring[i]-&gt;reg_idx +=
<a name="l05191"></a>05191                     (i &gt;= f-&gt;mask ? adapter-&gt;fcoe.tc : 0);
<a name="l05192"></a>05192 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05193"></a>05193             }
<a name="l05194"></a>05194 
<a name="l05195"></a>05195             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l05196"></a>05196                 adapter-&gt;tx_ring[i]-&gt;reg_idx =
<a name="l05197"></a>05197                     (adapter-&gt;num_vfs + i) *
<a name="l05198"></a>05198                      adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l05199"></a>05199 #ifdef IXGBE_FCOE
<a name="l05200"></a>05200                 adapter-&gt;tx_ring[i]-&gt;reg_idx +=
<a name="l05201"></a>05201                     (i &gt;= f-&gt;mask ? adapter-&gt;fcoe.tc : 0);
<a name="l05202"></a>05202 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05203"></a>05203             }
<a name="l05204"></a>05204             ret = <span class="keyword">true</span>;
<a name="l05205"></a>05205         }
<a name="l05206"></a>05206         <span class="keywordflow">break</span>;
<a name="l05207"></a>05207 
<a name="l05208"></a>05208     <span class="keywordflow">case</span> (IXGBE_FLAG_VMDQ_ENABLED):
<a name="l05209"></a>05209         <span class="keywordflow">switch</span> (adapter-&gt;hw.mac.type) {
<a name="l05210"></a>05210         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l05211"></a>05211             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05212"></a>05212                 adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05213"></a>05213             for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05214"></a>05214                 adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05215"></a>05215             ret = <span class="keyword">true</span>;
<a name="l05216"></a>05216             <span class="keywordflow">break</span>;
<a name="l05217"></a>05217         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05218"></a>05218         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05219"></a>05219             <span class="comment">/* even without rss, there are 2 queues per</span>
<a name="l05220"></a>05220 <span class="comment">             * pool, the odd numbered ones are unused.</span>
<a name="l05221"></a>05221 <span class="comment">             */</span>
<a name="l05222"></a>05222             for (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05223"></a>05223                 adapter-&gt;rx_ring[i]-&gt;reg_idx = VMDQ_P(i) * 2;
<a name="l05224"></a>05224             <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05225"></a>05225                 adapter-&gt;tx_ring[i]-&gt;reg_idx = VMDQ_P(i) * 2;
<a name="l05226"></a>05226             ret = <span class="keyword">true</span>;
<a name="l05227"></a>05227             <span class="keywordflow">break</span>;
<a name="l05228"></a>05228         <span class="keywordflow">default</span>:
<a name="l05229"></a>05229             <span class="keywordflow">break</span>;
<a name="l05230"></a>05230         }
<a name="l05231"></a>05231         <span class="keywordflow">break</span>;
<a name="l05232"></a>05232     }
<a name="l05233"></a>05233 
<a name="l05234"></a>05234     <span class="keywordflow">return</span> ret;
<a name="l05235"></a>05235 }
<a name="l05236"></a>05236 
<a name="l05244"></a>05244 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_fdir(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05245"></a>05245 {
<a name="l05246"></a>05246     <span class="keywordtype">int</span> i;
<a name="l05247"></a>05247     <span class="keywordtype">bool</span> ret = <span class="keyword">false</span>;
<a name="l05248"></a>05248 
<a name="l05249"></a>05249     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED &amp;&amp;
<a name="l05250"></a>05250         ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) ||
<a name="l05251"></a>05251          (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE))) {
<a name="l05252"></a>05252         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l05253"></a>05253             adapter-&gt;rx_ring[i]-&gt;reg_idx = i;
<a name="l05254"></a>05254         for (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05255"></a>05255             adapter-&gt;tx_ring[i]-&gt;reg_idx = i;
<a name="l05256"></a>05256         ret = <span class="keyword">true</span>;
<a name="l05257"></a>05257     }
<a name="l05258"></a>05258 
<a name="l05259"></a>05259     <span class="keywordflow">return</span> ret;
<a name="l05260"></a>05260 }
<a name="l05261"></a>05261 
<a name="l05262"></a>05262 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05263"></a>05263 <span class="preprocessor"></span>
<a name="l05270"></a>05270 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_fcoe(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05271"></a>05271 {
<a name="l05272"></a>05272     <span class="keyword">struct </span><a class="code" href="structixgbe__ring__feature.html">ixgbe_ring_feature</a> *f = &amp;adapter-&gt;ring_feature[RING_F_FCOE];
<a name="l05273"></a>05273     <span class="keywordtype">int</span> i;
<a name="l05274"></a>05274     u8 fcoe_rx_i = 0, fcoe_tx_i = 0;
<a name="l05275"></a>05275 
<a name="l05276"></a>05276     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED))
<a name="l05277"></a>05277         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05278"></a>05278 
<a name="l05279"></a>05279     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l05280"></a>05280         <span class="keyword">struct </span>ixgbe_fcoe *fcoe = &amp;adapter-&gt;fcoe;
<a name="l05281"></a>05281 
<a name="l05282"></a>05282         ixgbe_cache_ring_dcb(adapter);
<a name="l05283"></a>05283         <span class="comment">/* find out queues in TC for FCoE */</span>
<a name="l05284"></a>05284         fcoe_rx_i = adapter-&gt;rx_ring[fcoe-&gt;tc]-&gt;reg_idx + 1;
<a name="l05285"></a>05285         fcoe_tx_i = adapter-&gt;tx_ring[fcoe-&gt;tc]-&gt;reg_idx + 1;
<a name="l05286"></a>05286         <span class="comment">/*</span>
<a name="l05287"></a>05287 <span class="comment">         * In 82599, the number of Tx queues for each traffic</span>
<a name="l05288"></a>05288 <span class="comment">         * class for both 8-TC and 4-TC modes are:</span>
<a name="l05289"></a>05289 <span class="comment">         * TCs  : TC0 TC1 TC2 TC3 TC4 TC5 TC6 TC7</span>
<a name="l05290"></a>05290 <span class="comment">         * 8 TCs:  32  32  16  16   8   8   8   8</span>
<a name="l05291"></a>05291 <span class="comment">         * 4 TCs:  64  64  32  32</span>
<a name="l05292"></a>05292 <span class="comment">         * We have max 8 queues for FCoE, where 8 the is</span>
<a name="l05293"></a>05293 <span class="comment">         * FCoE redirection table size. If TC for FCoE is</span>
<a name="l05294"></a>05294 <span class="comment">         * less than or equal to TC3, we have enough queues</span>
<a name="l05295"></a>05295 <span class="comment">         * to add max of 8 queues for FCoE, so we start FCoE</span>
<a name="l05296"></a>05296 <span class="comment">         * tx queue from the next one, i.e., reg_idx + 1.</span>
<a name="l05297"></a>05297 <span class="comment">         * If TC for FCoE is above TC3, implying 8 TC mode,</span>
<a name="l05298"></a>05298 <span class="comment">         * and we need 8 for FCoE, we have to take all queues</span>
<a name="l05299"></a>05299 <span class="comment">         * in that traffic class for FCoE.</span>
<a name="l05300"></a>05300 <span class="comment">         */</span>
<a name="l05301"></a>05301         <span class="keywordflow">if</span> ((f-&gt;indices == IXGBE_FCRETA_SIZE) &amp;&amp; (fcoe-&gt;tc &gt; 3))
<a name="l05302"></a>05302             fcoe_tx_i--;
<a name="l05303"></a>05303     }
<a name="l05304"></a>05304     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_RSS_ENABLED) {
<a name="l05305"></a>05305         <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) ||
<a name="l05306"></a>05306             (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE))
<a name="l05307"></a>05307             ixgbe_cache_ring_fdir(adapter);
<a name="l05308"></a>05308         <span class="keywordflow">else</span>
<a name="l05309"></a>05309             ixgbe_cache_ring_rss(adapter);
<a name="l05310"></a>05310 
<a name="l05311"></a>05311         fcoe_rx_i = f-&gt;mask;
<a name="l05312"></a>05312         fcoe_tx_i = f-&gt;mask;
<a name="l05313"></a>05313     }
<a name="l05314"></a>05314     <span class="keywordflow">for</span> (i = 0; i &lt; f-&gt;indices; i++, fcoe_rx_i++, fcoe_tx_i++) {
<a name="l05315"></a>05315         adapter-&gt;rx_ring[f-&gt;mask + i]-&gt;reg_idx = fcoe_rx_i;
<a name="l05316"></a>05316         adapter-&gt;tx_ring[f-&gt;mask + i]-&gt;reg_idx = fcoe_tx_i;
<a name="l05317"></a>05317     }
<a name="l05318"></a>05318     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05319"></a>05319 }
<a name="l05320"></a>05320 
<a name="l05321"></a>05321 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05322"></a>05322 
<a name="l05330"></a>05330 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ixgbe_cache_ring_sriov(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05331"></a>05331 {
<a name="l05332"></a>05332     adapter-&gt;rx_ring[0]-&gt;reg_idx = adapter-&gt;num_vfs * 2;
<a name="l05333"></a>05333     adapter-&gt;tx_ring[0]-&gt;reg_idx = adapter-&gt;num_vfs * 2;
<a name="l05334"></a>05334     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05335"></a>05335 }
<a name="l05336"></a>05336 
<a name="l05348"></a>05348 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_cache_ring_register(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05349"></a>05349 {
<a name="l05350"></a>05350     <span class="comment">/* start with default case */</span>
<a name="l05351"></a>05351     adapter-&gt;rx_ring[0]-&gt;reg_idx = 0;
<a name="l05352"></a>05352     adapter-&gt;tx_ring[0]-&gt;reg_idx = 0;
<a name="l05353"></a>05353 
<a name="l05354"></a>05354     <span class="keywordflow">if</span> (ixgbe_cache_ring_sriov(adapter))
<a name="l05355"></a>05355         <span class="keywordflow">return</span>;
<a name="l05356"></a>05356 
<a name="l05357"></a>05357     <span class="keywordflow">if</span> (ixgbe_cache_ring_vmdq(adapter))
<a name="l05358"></a>05358         <span class="keywordflow">return</span>;
<a name="l05359"></a>05359 
<a name="l05360"></a>05360 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05361"></a>05361 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ixgbe_cache_ring_fcoe(adapter))
<a name="l05362"></a>05362         <span class="keywordflow">return</span>;
<a name="l05363"></a>05363 
<a name="l05364"></a>05364 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l05365"></a>05365     <span class="keywordflow">if</span> (ixgbe_cache_ring_dcb(adapter))
<a name="l05366"></a>05366         <span class="keywordflow">return</span>;
<a name="l05367"></a>05367 
<a name="l05368"></a>05368     <span class="keywordflow">if</span> (ixgbe_cache_ring_fdir(adapter))
<a name="l05369"></a>05369         <span class="keywordflow">return</span>;
<a name="l05370"></a>05370 
<a name="l05371"></a>05371     <span class="keywordflow">if</span> (ixgbe_cache_ring_rss(adapter))
<a name="l05372"></a>05372         <span class="keywordflow">return</span>;
<a name="l05373"></a>05373 }
<a name="l05374"></a>05374 
<a name="l05383"></a>05383 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_alloc_queues(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05384"></a>05384 {
<a name="l05385"></a>05385     <span class="keywordtype">int</span> i;
<a name="l05386"></a>05386     <span class="keywordtype">int</span> rx_count;
<a name="l05387"></a>05387 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05388"></a>05388 <span class="preprocessor"></span>    <span class="keywordtype">int</span> orig_node = adapter-&gt;node;
<a name="l05389"></a>05389 
<a name="l05390"></a>05390     WARN_ON(orig_node != -1 &amp;&amp; !node_online(orig_node));
<a name="l05391"></a>05391 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05392"></a>05392 
<a name="l05393"></a>05393     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l05394"></a>05394         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;tx_ring[i];
<a name="l05395"></a>05395 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05396"></a>05396 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (orig_node == -1) {
<a name="l05397"></a>05397             <span class="keywordtype">int</span> cur_node = next_online_node(adapter-&gt;node);
<a name="l05398"></a>05398             <span class="keywordflow">if</span> (cur_node == MAX_NUMNODES)
<a name="l05399"></a>05399                 cur_node = first_online_node;
<a name="l05400"></a>05400             adapter-&gt;node = cur_node;
<a name="l05401"></a>05401         }
<a name="l05402"></a>05402 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05403"></a>05403         ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL,
<a name="l05404"></a>05404                     adapter-&gt;node);
<a name="l05405"></a>05405         <span class="keywordflow">if</span> (!ring)
<a name="l05406"></a>05406             ring = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL);
<a name="l05407"></a>05407         <span class="keywordflow">if</span> (!ring)
<a name="l05408"></a>05408             <span class="keywordflow">goto</span> err_tx_ring_allocation;
<a name="l05409"></a>05409         ring-&gt;count = adapter-&gt;tx_ring_count;
<a name="l05410"></a>05410         ring-&gt;queue_index = i;
<a name="l05411"></a>05411         ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l05412"></a>05412         ring-&gt;netdev = adapter-&gt;netdev;
<a name="l05413"></a>05413         ring-&gt;numa_node = adapter-&gt;node;
<a name="l05414"></a>05414 
<a name="l05415"></a>05415         adapter-&gt;tx_ring[i] = ring;
<a name="l05416"></a>05416     }
<a name="l05417"></a>05417 
<a name="l05418"></a>05418 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05419"></a>05419 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l05420"></a>05420     adapter-&gt;node = orig_node;
<a name="l05421"></a>05421 
<a name="l05422"></a>05422 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05423"></a>05423     rx_count = adapter-&gt;rx_ring_count;
<a name="l05424"></a>05424     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l05425"></a>05425         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring = adapter-&gt;rx_ring[i];
<a name="l05426"></a>05426 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05427"></a>05427 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (orig_node == -1) {
<a name="l05428"></a>05428             <span class="keywordtype">int</span> cur_node = next_online_node(adapter-&gt;node);
<a name="l05429"></a>05429             <span class="keywordflow">if</span> (cur_node == MAX_NUMNODES)
<a name="l05430"></a>05430                 cur_node = first_online_node;
<a name="l05431"></a>05431             adapter-&gt;node = cur_node;
<a name="l05432"></a>05432         }
<a name="l05433"></a>05433 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05434"></a>05434         ring = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL,
<a name="l05435"></a>05435                     adapter-&gt;node);
<a name="l05436"></a>05436         <span class="keywordflow">if</span> (!ring)
<a name="l05437"></a>05437             ring = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a>), GFP_KERNEL);
<a name="l05438"></a>05438         <span class="keywordflow">if</span> (!ring)
<a name="l05439"></a>05439             <span class="keywordflow">goto</span> err_rx_ring_allocation;
<a name="l05440"></a>05440         ring-&gt;count = rx_count;
<a name="l05441"></a>05441         ring-&gt;queue_index = i;
<a name="l05442"></a>05442         ring-&gt;dev = pci_dev_to_dev(adapter-&gt;pdev);
<a name="l05443"></a>05443         ring-&gt;netdev = adapter-&gt;netdev;
<a name="l05444"></a>05444         ring-&gt;numa_node = adapter-&gt;node;
<a name="l05445"></a>05445 
<a name="l05446"></a>05446         adapter-&gt;rx_ring[i] = ring;
<a name="l05447"></a>05447     }
<a name="l05448"></a>05448 
<a name="l05449"></a>05449 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05450"></a>05450 <span class="preprocessor"></span>    <span class="comment">/* Restore the adapter&#39;s original node */</span>
<a name="l05451"></a>05451     adapter-&gt;node = orig_node;
<a name="l05452"></a>05452 
<a name="l05453"></a>05453 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05454"></a>05454     ixgbe_cache_ring_register(adapter);
<a name="l05455"></a>05455 
<a name="l05456"></a>05456     <span class="keywordflow">return</span> 0;
<a name="l05457"></a>05457 
<a name="l05458"></a>05458 err_rx_ring_allocation:
<a name="l05459"></a>05459     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l05460"></a>05460         kfree(adapter-&gt;tx_ring[i]);
<a name="l05461"></a>05461 err_tx_ring_allocation:
<a name="l05462"></a>05462     <span class="keywordflow">return</span> -ENOMEM;
<a name="l05463"></a>05463 }
<a name="l05464"></a>05464 
<a name="l05472"></a>05472 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05473"></a>05473 {
<a name="l05474"></a>05474     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05475"></a>05475     <span class="keywordtype">int</span> err = 0;
<a name="l05476"></a>05476     <span class="keywordtype">int</span> vector, v_budget;
<a name="l05477"></a>05477 
<a name="l05478"></a>05478     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_CAPABLE))
<a name="l05479"></a>05479         <span class="keywordflow">goto</span> try_msi;
<a name="l05480"></a>05480 
<a name="l05481"></a>05481     <span class="comment">/*</span>
<a name="l05482"></a>05482 <span class="comment">     * It&#39;s easy to be greedy for MSI-X vectors, but it really</span>
<a name="l05483"></a>05483 <span class="comment">     * doesn&#39;t do us much good if we have a lot more vectors</span>
<a name="l05484"></a>05484 <span class="comment">     * than CPU&#39;s.  So let&#39;s be conservative and only ask for</span>
<a name="l05485"></a>05485 <span class="comment">     * (roughly) the same number of vectors as there are CPU&#39;s.</span>
<a name="l05486"></a>05486 <span class="comment">     */</span>
<a name="l05487"></a>05487     v_budget = min(adapter-&gt;num_rx_queues + adapter-&gt;num_tx_queues,
<a name="l05488"></a>05488                (<span class="keywordtype">int</span>)num_online_cpus()) + NON_Q_VECTORS;
<a name="l05489"></a>05489 
<a name="l05490"></a>05490     <span class="comment">/*</span>
<a name="l05491"></a>05491 <span class="comment">     * At the same time, hardware can only support a maximum of</span>
<a name="l05492"></a>05492 <span class="comment">     * hw.mac-&gt;max_msix_vectors vectors.  With features</span>
<a name="l05493"></a>05493 <span class="comment">     * such as RSS and VMDq, we can easily surpass the number of Rx and Tx</span>
<a name="l05494"></a>05494 <span class="comment">     * descriptor queues supported by our device.  Thus, we cap it off in</span>
<a name="l05495"></a>05495 <span class="comment">     * those rare cases where the cpu count also exceeds our vector limit.</span>
<a name="l05496"></a>05496 <span class="comment">     */</span>
<a name="l05497"></a>05497     v_budget = min(v_budget, (<span class="keywordtype">int</span>)hw-&gt;mac.max_msix_vectors);
<a name="l05498"></a>05498 
<a name="l05499"></a>05499     <span class="comment">/* A failure in MSI-X entry allocation isn&#39;t fatal, but it does</span>
<a name="l05500"></a>05500 <span class="comment">     * mean we disable MSI-X capabilities of the adapter. */</span>
<a name="l05501"></a>05501     adapter-&gt;msix_entries = kcalloc(v_budget,
<a name="l05502"></a>05502                     <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msix_entry), GFP_KERNEL);
<a name="l05503"></a>05503     <span class="keywordflow">if</span> (adapter-&gt;msix_entries) {
<a name="l05504"></a>05504         <span class="keywordflow">for</span> (vector = 0; vector &lt; v_budget; vector++)
<a name="l05505"></a>05505             adapter-&gt;msix_entries[vector].entry = vector;
<a name="l05506"></a>05506 
<a name="l05507"></a>05507         ixgbe_acquire_msix_vectors(adapter, v_budget);
<a name="l05508"></a>05508 
<a name="l05509"></a>05509         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l05510"></a>05510             <span class="keywordflow">goto</span> out;
<a name="l05511"></a>05511     }
<a name="l05512"></a>05512 
<a name="l05513"></a>05513     adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCB_ENABLED;
<a name="l05514"></a>05514     adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCB_CAPABLE;
<a name="l05515"></a>05515     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; (IXGBE_FLAG_FDIR_HASH_CAPABLE |
<a name="l05516"></a>05516                   IXGBE_FLAG_FDIR_PERFECT_CAPABLE)) {
<a name="l05517"></a>05517         DPRINTK(PROBE, ERR,
<a name="l05518"></a>05518             <span class="stringliteral">&quot;Flow Director is not supported while multiple &quot;</span>
<a name="l05519"></a>05519             <span class="stringliteral">&quot;queues are disabled.  Disabling Flow Director\n&quot;</span>);
<a name="l05520"></a>05520     }
<a name="l05521"></a>05521     adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
<a name="l05522"></a>05522     adapter-&gt;flags &amp;= ~IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
<a name="l05523"></a>05523     adapter-&gt;atr_sample_rate = 0;
<a name="l05524"></a>05524     adapter-&gt;flags &amp;= ~IXGBE_FLAG_VMDQ_ENABLED;
<a name="l05525"></a>05525     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l05526"></a>05526         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;MSIX interrupt not available - &quot;</span>
<a name="l05527"></a>05527             <span class="stringliteral">&quot;disabling SR-IOV\n&quot;</span>);
<a name="l05528"></a>05528         ixgbe_disable_sriov(adapter);
<a name="l05529"></a>05529     }
<a name="l05530"></a>05530 
<a name="l05531"></a>05531     adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l05532"></a>05532     ixgbe_set_num_queues(adapter);
<a name="l05533"></a>05533 
<a name="l05534"></a>05534 try_msi:
<a name="l05535"></a>05535     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSI_CAPABLE))
<a name="l05536"></a>05536         <span class="keywordflow">goto</span> out;
<a name="l05537"></a>05537 
<a name="l05538"></a>05538     err = pci_enable_msi(adapter-&gt;pdev);
<a name="l05539"></a>05539     <span class="keywordflow">if</span> (!err) {
<a name="l05540"></a>05540         adapter-&gt;flags |= IXGBE_FLAG_MSI_ENABLED;
<a name="l05541"></a>05541     } <span class="keywordflow">else</span> {
<a name="l05542"></a>05542         DPRINTK(HW, DEBUG, <span class="stringliteral">&quot;Unable to allocate MSI interrupt, &quot;</span>
<a name="l05543"></a>05543                            <span class="stringliteral">&quot;falling back to legacy.  Error: %d\n&quot;</span>, err);
<a name="l05544"></a>05544         <span class="comment">/* reset err */</span>
<a name="l05545"></a>05545         err = 0;
<a name="l05546"></a>05546     }
<a name="l05547"></a>05547 
<a name="l05548"></a>05548 out:
<a name="l05549"></a>05549     <span class="comment">/* Notify the stack of the (possibly) reduced Tx Queue count. */</span>
<a name="l05550"></a>05550     netif_set_real_num_tx_queues(adapter-&gt;netdev, adapter-&gt;num_tx_queues);
<a name="l05551"></a>05551     <span class="keywordflow">return</span> err;
<a name="l05552"></a>05552 }
<a name="l05553"></a>05553 
<a name="l05561"></a>05561 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_alloc_q_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05562"></a>05562 {
<a name="l05563"></a>05563     <span class="keywordtype">int</span> v_idx, num_q_vectors;
<a name="l05564"></a>05564     <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector;
<a name="l05565"></a>05565     <span class="keywordtype">int</span> rx_vectors;
<a name="l05566"></a>05566 
<a name="l05567"></a>05567     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l05568"></a>05568         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l05569"></a>05569         rx_vectors = adapter-&gt;num_rx_queues;
<a name="l05570"></a>05570     } <span class="keywordflow">else</span> {
<a name="l05571"></a>05571         num_q_vectors = 1;
<a name="l05572"></a>05572         rx_vectors = 1;
<a name="l05573"></a>05573     }
<a name="l05574"></a>05574 
<a name="l05575"></a>05575     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; num_q_vectors; v_idx++) {
<a name="l05576"></a>05576         q_vector = kzalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a>),
<a name="l05577"></a>05577                     GFP_KERNEL, adapter-&gt;node);
<a name="l05578"></a>05578         <span class="keywordflow">if</span> (!q_vector)
<a name="l05579"></a>05579             q_vector = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a>),
<a name="l05580"></a>05580                        GFP_KERNEL);
<a name="l05581"></a>05581         <span class="keywordflow">if</span> (!q_vector)
<a name="l05582"></a>05582             <span class="keywordflow">goto</span> err_out;
<a name="l05583"></a>05583 
<a name="l05584"></a>05584         q_vector-&gt;adapter = adapter;
<a name="l05585"></a>05585         q_vector-&gt;v_idx = v_idx;
<a name="l05586"></a>05586         q_vector-&gt;tx_work_limit = adapter-&gt;tx_work_limit;
<a name="l05587"></a>05587         q_vector-&gt;rx_work_limit = adapter-&gt;rx_work_limit;
<a name="l05588"></a>05588 
<a name="l05589"></a>05589 <span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l05590"></a>05590 <span class="preprocessor"></span>        <span class="comment">/* Allocate the affinity_hint cpumask, configure the mask */</span>
<a name="l05591"></a>05591         <span class="keywordflow">if</span> (!alloc_cpumask_var(&amp;q_vector-&gt;affinity_mask, GFP_KERNEL))
<a name="l05592"></a>05592             <span class="keywordflow">goto</span> err_out;
<a name="l05593"></a>05593         cpumask_set_cpu(v_idx, q_vector-&gt;affinity_mask);
<a name="l05594"></a>05594 <span class="preprocessor">#endif</span>
<a name="l05595"></a>05595 <span class="preprocessor"></span><span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l05596"></a>05596 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (v_idx &lt; rx_vectors) {
<a name="l05597"></a>05597             <span class="keywordtype">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__lro__list.html">ixgbe_lro_list</a>);
<a name="l05598"></a>05598             q_vector-&gt;lrolist = vmalloc_node(size, adapter-&gt;node);
<a name="l05599"></a>05599             <span class="keywordflow">if</span> (!q_vector-&gt;lrolist)
<a name="l05600"></a>05600                 q_vector-&gt;lrolist = vmalloc(size);
<a name="l05601"></a>05601             <span class="keywordflow">if</span> (!q_vector-&gt;lrolist) {
<a name="l05602"></a>05602                 kfree(q_vector);
<a name="l05603"></a>05603                 <span class="keywordflow">goto</span> err_out;
<a name="l05604"></a>05604             }
<a name="l05605"></a>05605             memset(q_vector-&gt;lrolist, 0, size);
<a name="l05606"></a>05606             ixgbe_lro_ring_init(q_vector-&gt;lrolist);
<a name="l05607"></a>05607         }
<a name="l05608"></a>05608 <span class="preprocessor">#endif</span>
<a name="l05609"></a>05609 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l05610"></a>05610 <span class="preprocessor"></span>        netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi,
<a name="l05611"></a>05611                    ixgbe_poll, 64);
<a name="l05612"></a>05612 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_IXGBE_NAPI */</span>
<a name="l05613"></a>05613         adapter-&gt;q_vector[v_idx] = q_vector;
<a name="l05614"></a>05614     }
<a name="l05615"></a>05615 
<a name="l05616"></a>05616     <span class="keywordflow">return</span> 0;
<a name="l05617"></a>05617 
<a name="l05618"></a>05618 err_out:
<a name="l05619"></a>05619     <span class="keywordflow">while</span> (v_idx) {
<a name="l05620"></a>05620         v_idx--;
<a name="l05621"></a>05621         q_vector = adapter-&gt;q_vector[v_idx];
<a name="l05622"></a>05622 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l05623"></a>05623 <span class="preprocessor"></span>            netif_napi_del(&amp;q_vector-&gt;napi);
<a name="l05624"></a>05624 <span class="preprocessor">#endif</span>
<a name="l05625"></a>05625 <span class="preprocessor"></span><span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l05626"></a>05626 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (q_vector-&gt;lrolist) {
<a name="l05627"></a>05627             ixgbe_lro_ring_exit(q_vector-&gt;lrolist);
<a name="l05628"></a>05628             vfree(q_vector-&gt;lrolist);
<a name="l05629"></a>05629             q_vector-&gt;lrolist = NULL;
<a name="l05630"></a>05630         }
<a name="l05631"></a>05631 <span class="preprocessor">#endif</span>
<a name="l05632"></a>05632 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l05633"></a>05633 <span class="preprocessor"></span>        free_cpumask_var(q_vector-&gt;affinity_mask);
<a name="l05634"></a>05634 <span class="preprocessor">#endif</span>
<a name="l05635"></a>05635 <span class="preprocessor"></span>        kfree(q_vector);
<a name="l05636"></a>05636         adapter-&gt;q_vector[v_idx] = NULL;
<a name="l05637"></a>05637     }
<a name="l05638"></a>05638     <span class="keywordflow">return</span> -ENOMEM;
<a name="l05639"></a>05639 }
<a name="l05640"></a>05640 
<a name="l05649"></a>05649 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_q_vectors(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05650"></a>05650 {
<a name="l05651"></a>05651     <span class="keywordtype">int</span> v_idx, num_q_vectors;
<a name="l05652"></a>05652 
<a name="l05653"></a>05653     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l05654"></a>05654         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l05655"></a>05655     <span class="keywordflow">else</span>
<a name="l05656"></a>05656         num_q_vectors = 1;
<a name="l05657"></a>05657 
<a name="l05658"></a>05658     <span class="keywordflow">for</span> (v_idx = 0; v_idx &lt; num_q_vectors; v_idx++) {
<a name="l05659"></a>05659         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[v_idx];
<a name="l05660"></a>05660 
<a name="l05661"></a>05661         adapter-&gt;q_vector[v_idx] = NULL;
<a name="l05662"></a>05662 <span class="preprocessor">#ifdef CONFIG_IXGBE_NAPI</span>
<a name="l05663"></a>05663 <span class="preprocessor"></span>        netif_napi_del(&amp;q_vector-&gt;napi);
<a name="l05664"></a>05664 <span class="preprocessor">#endif</span>
<a name="l05665"></a>05665 <span class="preprocessor"></span><span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l05666"></a>05666 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (q_vector-&gt;lrolist) {
<a name="l05667"></a>05667             ixgbe_lro_ring_exit(q_vector-&gt;lrolist);
<a name="l05668"></a>05668             vfree(q_vector-&gt;lrolist);
<a name="l05669"></a>05669             q_vector-&gt;lrolist = NULL;
<a name="l05670"></a>05670         }
<a name="l05671"></a>05671 <span class="preprocessor">#endif</span>
<a name="l05672"></a>05672 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_IRQ_AFFINITY_HINT</span>
<a name="l05673"></a>05673 <span class="preprocessor"></span>        free_cpumask_var(q_vector-&gt;affinity_mask);
<a name="l05674"></a>05674 <span class="preprocessor">#endif</span>
<a name="l05675"></a>05675 <span class="preprocessor"></span>        kfree(q_vector);
<a name="l05676"></a>05676     }
<a name="l05677"></a>05677 }
<a name="l05678"></a>05678 
<a name="l05679"></a>05679 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_reset_interrupt_capability(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05680"></a>05680 {
<a name="l05681"></a>05681     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l05682"></a>05682         adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSIX_ENABLED;
<a name="l05683"></a>05683         pci_disable_msix(adapter-&gt;pdev);
<a name="l05684"></a>05684         kfree(adapter-&gt;msix_entries);
<a name="l05685"></a>05685         adapter-&gt;msix_entries = NULL;
<a name="l05686"></a>05686     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSI_ENABLED) {
<a name="l05687"></a>05687         adapter-&gt;flags &amp;= ~IXGBE_FLAG_MSI_ENABLED;
<a name="l05688"></a>05688         pci_disable_msi(adapter-&gt;pdev);
<a name="l05689"></a>05689     }
<a name="l05690"></a>05690 }
<a name="l05691"></a>05691 
<a name="l05702"></a>05702 <span class="keywordtype">int</span> ixgbe_init_interrupt_scheme(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05703"></a>05703 {
<a name="l05704"></a>05704     <span class="keywordtype">int</span> err;
<a name="l05705"></a>05705 
<a name="l05706"></a>05706     <span class="comment">/* Number of supported queues */</span>
<a name="l05707"></a>05707     ixgbe_set_num_queues(adapter);
<a name="l05708"></a>05708 
<a name="l05709"></a>05709     err = ixgbe_set_interrupt_capability(adapter);
<a name="l05710"></a>05710     <span class="keywordflow">if</span> (err) {
<a name="l05711"></a>05711         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;Unable to setup interrupt capabilities\n&quot;</span>);
<a name="l05712"></a>05712         <span class="keywordflow">goto</span> err_set_interrupt;
<a name="l05713"></a>05713     }
<a name="l05714"></a>05714 
<a name="l05715"></a>05715     err = ixgbe_alloc_q_vectors(adapter);
<a name="l05716"></a>05716     <span class="keywordflow">if</span> (err) {
<a name="l05717"></a>05717         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;Unable to allocate memory for queue &quot;</span>
<a name="l05718"></a>05718                 <span class="stringliteral">&quot;vectors\n&quot;</span>);
<a name="l05719"></a>05719         <span class="keywordflow">goto</span> err_alloc_q_vectors;
<a name="l05720"></a>05720     }
<a name="l05721"></a>05721 
<a name="l05722"></a>05722     err = ixgbe_alloc_queues(adapter);
<a name="l05723"></a>05723     <span class="keywordflow">if</span> (err) {
<a name="l05724"></a>05724         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;Unable to allocate memory for queues\n&quot;</span>);
<a name="l05725"></a>05725         <span class="keywordflow">goto</span> err_alloc_queues;
<a name="l05726"></a>05726     }
<a name="l05727"></a>05727 
<a name="l05728"></a>05728     DPRINTK(DRV, INFO, <span class="stringliteral">&quot;Multiqueue %s: Rx Queue count = %u, &quot;</span>
<a name="l05729"></a>05729                        <span class="stringliteral">&quot;Tx Queue count = %u\n&quot;</span>,
<a name="l05730"></a>05730             (adapter-&gt;num_rx_queues &gt; 1) ? <span class="stringliteral">&quot;Enabled&quot;</span> :
<a name="l05731"></a>05731             <span class="stringliteral">&quot;Disabled&quot;</span>, adapter-&gt;num_rx_queues, adapter-&gt;num_tx_queues);
<a name="l05732"></a>05732 
<a name="l05733"></a>05733     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l05734"></a>05734 
<a name="l05735"></a>05735     <span class="keywordflow">return</span> 0;
<a name="l05736"></a>05736 
<a name="l05737"></a>05737 err_alloc_queues:
<a name="l05738"></a>05738     ixgbe_free_q_vectors(adapter);
<a name="l05739"></a>05739 err_alloc_q_vectors:
<a name="l05740"></a>05740     ixgbe_reset_interrupt_capability(adapter);
<a name="l05741"></a>05741 err_set_interrupt:
<a name="l05742"></a>05742     <span class="keywordflow">return</span> err;
<a name="l05743"></a>05743 }
<a name="l05744"></a>05744 
<a name="l05752"></a>05752 <span class="keywordtype">void</span> ixgbe_clear_interrupt_scheme(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05753"></a>05753 {
<a name="l05754"></a>05754     <span class="keywordtype">int</span> i;
<a name="l05755"></a>05755 
<a name="l05756"></a>05756     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l05757"></a>05757         kfree(adapter-&gt;tx_ring[i]);
<a name="l05758"></a>05758         adapter-&gt;tx_ring[i] = NULL;
<a name="l05759"></a>05759     }
<a name="l05760"></a>05760     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l05761"></a>05761         kfree(adapter-&gt;rx_ring[i]);
<a name="l05762"></a>05762         adapter-&gt;rx_ring[i] = NULL;
<a name="l05763"></a>05763     }
<a name="l05764"></a>05764 
<a name="l05765"></a>05765     ixgbe_free_q_vectors(adapter);
<a name="l05766"></a>05766     ixgbe_reset_interrupt_capability(adapter);
<a name="l05767"></a>05767 }
<a name="l05768"></a>05768 
<a name="l05777"></a>05777 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit ixgbe_sw_init(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05778"></a>05778 {
<a name="l05779"></a>05779     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l05780"></a>05780     <span class="keyword">struct </span>pci_dev *pdev = adapter-&gt;pdev;
<a name="l05781"></a>05781     <span class="keywordtype">int</span> err;
<a name="l05782"></a>05782     <span class="keywordtype">int</span> max_frame = adapter-&gt;netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l05783"></a>05783 
<a name="l05784"></a>05784     <span class="comment">/* PCI config space info */</span>
<a name="l05785"></a>05785 
<a name="l05786"></a>05786     hw-&gt;vendor_id = pdev-&gt;vendor;
<a name="l05787"></a>05787     hw-&gt;device_id = pdev-&gt;device;
<a name="l05788"></a>05788     pci_read_config_byte(pdev, PCI_REVISION_ID, &amp;hw-&gt;revision_id);
<a name="l05789"></a>05789     hw-&gt;subsystem_vendor_id = pdev-&gt;subsystem_vendor;
<a name="l05790"></a>05790     hw-&gt;subsystem_device_id = pdev-&gt;subsystem_device;
<a name="l05791"></a>05791 
<a name="l05792"></a>05792     err = ixgbe_init_shared_code(hw);
<a name="l05793"></a>05793     <span class="keywordflow">if</span> (err) {
<a name="l05794"></a>05794         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;init_shared_code failed: %d\n&quot;</span>, err);
<a name="l05795"></a>05795         <span class="keywordflow">goto</span> out;
<a name="l05796"></a>05796     }
<a name="l05797"></a>05797 
<a name="l05798"></a>05798     <span class="comment">/* Set capability flags */</span>
<a name="l05799"></a>05799     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l05800"></a>05800     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l05801"></a>05801         <span class="keywordflow">if</span> (hw-&gt;device_id == IXGBE_DEV_ID_82598AT)
<a name="l05802"></a>05802             adapter-&gt;flags |= IXGBE_FLAG_FAN_FAIL_CAPABLE;
<a name="l05803"></a>05803 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l05804"></a>05804 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_DCA_CAPABLE;
<a name="l05805"></a>05805 <span class="preprocessor">#endif</span>
<a name="l05806"></a>05806 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_MSI_CAPABLE;
<a name="l05807"></a>05807         adapter-&gt;flags |= IXGBE_FLAG_MSIX_CAPABLE;
<a name="l05808"></a>05808         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_CAPABLE)
<a name="l05809"></a>05809             adapter-&gt;flags |= IXGBE_FLAG_MQ_CAPABLE;
<a name="l05810"></a>05810         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05811"></a>05811             adapter-&gt;flags |= IXGBE_FLAG_DCB_CAPABLE;
<a name="l05812"></a>05812         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05813"></a>05813             adapter-&gt;flags |= IXGBE_FLAG_RSS_CAPABLE;
<a name="l05814"></a>05814         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05815"></a>05815             adapter-&gt;flags |= IXGBE_FLAG_VMDQ_CAPABLE;
<a name="l05816"></a>05816         adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_CAPABLE;
<a name="l05817"></a>05817         adapter-&gt;flags &amp;= ~IXGBE_FLAG_SRIOV_CAPABLE;
<a name="l05818"></a>05818         adapter-&gt;max_msix_q_vectors = IXGBE_MAX_MSIX_Q_VECTORS_82598;
<a name="l05819"></a>05819         <span class="keywordflow">break</span>;
<a name="l05820"></a>05820     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l05821"></a>05821     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l05822"></a>05822 <span class="preprocessor">#ifndef IXGBE_NO_SMART_SPEED</span>
<a name="l05823"></a>05823 <span class="preprocessor"></span>        hw-&gt;phy.smart_speed = ixgbe_smart_speed_on;
<a name="l05824"></a>05824 <span class="preprocessor">#else</span>
<a name="l05825"></a>05825 <span class="preprocessor"></span>        hw-&gt;phy.smart_speed = ixgbe_smart_speed_off;
<a name="l05826"></a>05826 <span class="preprocessor">#endif</span>
<a name="l05827"></a>05827 <span class="preprocessor"></span>        adapter-&gt;flags2 |= IXGBE_FLAG2_RSC_CAPABLE;
<a name="l05828"></a>05828 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l05829"></a>05829 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_DCA_CAPABLE;
<a name="l05830"></a>05830 <span class="preprocessor">#endif</span>
<a name="l05831"></a>05831 <span class="preprocessor"></span>        adapter-&gt;flags |= IXGBE_FLAG_MSI_CAPABLE;
<a name="l05832"></a>05832         adapter-&gt;flags |= IXGBE_FLAG_MSIX_CAPABLE;
<a name="l05833"></a>05833         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_CAPABLE)
<a name="l05834"></a>05834             adapter-&gt;flags |= IXGBE_FLAG_MQ_CAPABLE;
<a name="l05835"></a>05835         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05836"></a>05836             adapter-&gt;flags |= IXGBE_FLAG_DCB_CAPABLE;
<a name="l05837"></a>05837         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05838"></a>05838             adapter-&gt;flags |= IXGBE_FLAG_RSS_CAPABLE;
<a name="l05839"></a>05839         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05840"></a>05840             adapter-&gt;flags |= IXGBE_FLAG_VMDQ_CAPABLE;
<a name="l05841"></a>05841 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l05842"></a>05842 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE) {
<a name="l05843"></a>05843             adapter-&gt;flags |= IXGBE_FLAG_FCOE_CAPABLE;
<a name="l05844"></a>05844             adapter-&gt;flags &amp;= ~IXGBE_FLAG_FCOE_ENABLED;
<a name="l05845"></a>05845             adapter-&gt;ring_feature[RING_F_FCOE].indices = 0;
<a name="l05846"></a>05846 <span class="preprocessor">#ifdef CONFIG_DCB</span>
<a name="l05847"></a>05847 <span class="preprocessor"></span>            <span class="comment">/* Default traffic class to use for FCoE */</span>
<a name="l05848"></a>05848             adapter-&gt;fcoe.tc = IXGBE_FCOE_DEFTC;
<a name="l05849"></a>05849             adapter-&gt;fcoe.up = IXGBE_FCOE_DEFTC;
<a name="l05850"></a>05850 <span class="preprocessor">#endif</span>
<a name="l05851"></a>05851 <span class="preprocessor"></span>        }
<a name="l05852"></a>05852 <span class="preprocessor">#endif</span>
<a name="l05853"></a>05853 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MQ_CAPABLE)
<a name="l05854"></a>05854             adapter-&gt;flags |= IXGBE_FLAG_SRIOV_CAPABLE;
<a name="l05855"></a>05855         <span class="keywordflow">if</span> (hw-&gt;device_id == IXGBE_DEV_ID_82599_T3_LOM)
<a name="l05856"></a>05856             adapter-&gt;flags2 |= IXGBE_FLAG2_TEMP_SENSOR_CAPABLE;
<a name="l05857"></a>05857 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l05858"></a>05858 <span class="preprocessor"></span>        <span class="comment">/* n-tuple support exists, always init our spinlock */</span>
<a name="l05859"></a>05859         spin_lock_init(&amp;adapter-&gt;fdir_perfect_lock);
<a name="l05860"></a>05860 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l05861"></a>05861         adapter-&gt;max_msix_q_vectors = IXGBE_MAX_MSIX_Q_VECTORS_82599;
<a name="l05862"></a>05862         <span class="keywordflow">break</span>;
<a name="l05863"></a>05863     <span class="keywordflow">default</span>:
<a name="l05864"></a>05864         <span class="keywordflow">break</span>;
<a name="l05865"></a>05865     }
<a name="l05866"></a>05866 
<a name="l05867"></a>05867     <span class="comment">/* Default DCB settings, if applicable */</span>
<a name="l05868"></a>05868     adapter-&gt;ring_feature[RING_F_DCB].indices = 8;
<a name="l05869"></a>05869 
<a name="l05870"></a>05870     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_CAPABLE) {
<a name="l05871"></a>05871         <span class="keywordtype">int</span> j, dcb_i;
<a name="l05872"></a>05872         <span class="keyword">struct </span><a class="code" href="structtc__configuration.html">tc_configuration</a> *tc;
<a name="l05873"></a>05873         dcb_i = adapter-&gt;ring_feature[RING_F_DCB].indices;
<a name="l05874"></a>05874         adapter-&gt;dcb_cfg.num_tcs.pg_tcs = dcb_i;
<a name="l05875"></a>05875         adapter-&gt;dcb_cfg.num_tcs.pfc_tcs = dcb_i;
<a name="l05876"></a>05876         <span class="keywordflow">for</span> (j = 0; j &lt; dcb_i; j++) {
<a name="l05877"></a>05877             tc = &amp;adapter-&gt;dcb_cfg.tc_config[j];
<a name="l05878"></a>05878             tc-&gt;path[DCB_TX_CONFIG].bwg_id = 0;
<a name="l05879"></a>05879             tc-&gt;path[DCB_TX_CONFIG].bwg_percent = 100 / dcb_i;
<a name="l05880"></a>05880             tc-&gt;path[DCB_RX_CONFIG].bwg_id = 0;
<a name="l05881"></a>05881             tc-&gt;path[DCB_RX_CONFIG].bwg_percent = 100 / dcb_i;
<a name="l05882"></a>05882             tc-&gt;dcb_pfc = pfc_disabled;
<a name="l05883"></a>05883             <span class="keywordflow">if</span> (j == 0) {
<a name="l05884"></a>05884                 <span class="comment">/* total of all TCs bandwidth needs to be 100 */</span>
<a name="l05885"></a>05885                 tc-&gt;path[DCB_TX_CONFIG].bwg_percent += 100 % dcb_i;
<a name="l05886"></a>05886                 tc-&gt;path[DCB_RX_CONFIG].bwg_percent += 100 % dcb_i;
<a name="l05887"></a>05887             }
<a name="l05888"></a>05888         }
<a name="l05889"></a>05889         adapter-&gt;dcb_cfg.bw_percentage[DCB_TX_CONFIG][0] = 100;
<a name="l05890"></a>05890         adapter-&gt;dcb_cfg.bw_percentage[DCB_RX_CONFIG][0] = 100;
<a name="l05891"></a>05891         adapter-&gt;dcb_cfg.rx_pba_cfg = pba_equal;
<a name="l05892"></a>05892         adapter-&gt;dcb_cfg.pfc_mode_enable = <span class="keyword">false</span>;
<a name="l05893"></a>05893 
<a name="l05894"></a>05894         adapter-&gt;dcb_cfg.round_robin_enable = <span class="keyword">false</span>;
<a name="l05895"></a>05895         adapter-&gt;dcb_set_bitmap = 0x00;
<a name="l05896"></a>05896 
<a name="l05897"></a>05897     }
<a name="l05898"></a>05898     <span class="comment">/* XXX does this need to be initialized even w/o DCB? */</span>
<a name="l05899"></a>05899     ixgbe_copy_dcb_cfg(&amp;adapter-&gt;dcb_cfg, &amp;adapter-&gt;temp_dcb_cfg,
<a name="l05900"></a>05900                adapter-&gt;ring_feature[RING_F_DCB].indices);
<a name="l05901"></a>05901 
<a name="l05902"></a>05902     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82599EB ||
<a name="l05903"></a>05903         hw-&gt;mac.type == ixgbe_mac_X540)
<a name="l05904"></a>05904         hw-&gt;mbx.ops.init_params(hw);
<a name="l05905"></a>05905 
<a name="l05906"></a>05906     <span class="comment">/* default flow control settings */</span>
<a name="l05907"></a>05907     hw-&gt;fc.requested_mode = ixgbe_fc_full;
<a name="l05908"></a>05908     hw-&gt;fc.current_mode = ixgbe_fc_full;    <span class="comment">/* init for ethtool output */</span>
<a name="l05909"></a>05909 
<a name="l05910"></a>05910     adapter-&gt;last_lfc_mode = hw-&gt;fc.current_mode;
<a name="l05911"></a>05911     hw-&gt;fc.high_water = FC_HIGH_WATER(max_frame);
<a name="l05912"></a>05912     hw-&gt;fc.low_water = FC_LOW_WATER(max_frame);
<a name="l05913"></a>05913     hw-&gt;fc.pause_time = IXGBE_DEFAULT_FCPAUSE;
<a name="l05914"></a>05914     hw-&gt;fc.send_xon = <span class="keyword">true</span>;
<a name="l05915"></a>05915     hw-&gt;fc.disable_fc_autoneg = <span class="keyword">false</span>;
<a name="l05916"></a>05916 
<a name="l05917"></a>05917     <span class="comment">/* set default ring sizes */</span>
<a name="l05918"></a>05918     adapter-&gt;tx_ring_count = IXGBE_DEFAULT_TXD;
<a name="l05919"></a>05919     adapter-&gt;rx_ring_count = IXGBE_DEFAULT_RXD;
<a name="l05920"></a>05920 
<a name="l05921"></a>05921     <span class="comment">/* set default work limits */</span>
<a name="l05922"></a>05922     adapter-&gt;tx_work_limit = adapter-&gt;tx_ring_count;
<a name="l05923"></a>05923     adapter-&gt;rx_work_limit = adapter-&gt;rx_ring_count / 2;
<a name="l05924"></a>05924 
<a name="l05925"></a>05925     <span class="comment">/* enable rx csum by default */</span>
<a name="l05926"></a>05926     adapter-&gt;flags |= IXGBE_FLAG_RX_CSUM_ENABLED;
<a name="l05927"></a>05927 
<a name="l05928"></a>05928     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l05929"></a>05929 out:
<a name="l05930"></a>05930     <span class="keywordflow">return</span> err;
<a name="l05931"></a>05931 }
<a name="l05932"></a>05932 
<a name="l05939"></a>05939 <span class="keywordtype">int</span> ixgbe_setup_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l05940"></a>05940 {
<a name="l05941"></a>05941     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = tx_ring-&gt;dev;
<a name="l05942"></a>05942     <span class="keywordtype">int</span> size;
<a name="l05943"></a>05943 
<a name="l05944"></a>05944     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a>) * tx_ring-&gt;count;
<a name="l05945"></a>05945     tx_ring-&gt;tx_buffer_info = vmalloc_node(size, tx_ring-&gt;numa_node);
<a name="l05946"></a>05946     <span class="keywordflow">if</span> (!tx_ring-&gt;tx_buffer_info)
<a name="l05947"></a>05947         tx_ring-&gt;tx_buffer_info = vmalloc(size);
<a name="l05948"></a>05948     <span class="keywordflow">if</span> (!tx_ring-&gt;tx_buffer_info)
<a name="l05949"></a>05949         <span class="keywordflow">goto</span> err;
<a name="l05950"></a>05950     memset(tx_ring-&gt;tx_buffer_info, 0, size);
<a name="l05951"></a>05951 
<a name="l05952"></a>05952     <span class="comment">/* round up to nearest 4K */</span>
<a name="l05953"></a>05953     tx_ring-&gt;size = tx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a>);
<a name="l05954"></a>05954     tx_ring-&gt;size = ALIGN(tx_ring-&gt;size, 4096);
<a name="l05955"></a>05955 
<a name="l05956"></a>05956     tx_ring-&gt;desc = dma_alloc_coherent(dev, tx_ring-&gt;size,
<a name="l05957"></a>05957                                        &amp;tx_ring-&gt;dma, GFP_KERNEL);
<a name="l05958"></a>05958     <span class="keywordflow">if</span> (!tx_ring-&gt;desc)
<a name="l05959"></a>05959         <span class="keywordflow">goto</span> err;
<a name="l05960"></a>05960 
<a name="l05961"></a>05961     tx_ring-&gt;next_to_use = 0;
<a name="l05962"></a>05962     tx_ring-&gt;next_to_clean = 0;
<a name="l05963"></a>05963     <span class="keywordflow">return</span> 0;
<a name="l05964"></a>05964 
<a name="l05965"></a>05965 err:
<a name="l05966"></a>05966     vfree(tx_ring-&gt;tx_buffer_info);
<a name="l05967"></a>05967     tx_ring-&gt;tx_buffer_info = NULL;
<a name="l05968"></a>05968     dev_err(dev, <span class="stringliteral">&quot;Unable to allocate memory for the Tx descriptor ring\n&quot;</span>);
<a name="l05969"></a>05969     <span class="keywordflow">return</span> -ENOMEM;
<a name="l05970"></a>05970 }
<a name="l05971"></a>05971 
<a name="l05982"></a>05982 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l05983"></a>05983 {
<a name="l05984"></a>05984     <span class="keywordtype">int</span> i, err = 0;
<a name="l05985"></a>05985 
<a name="l05986"></a>05986     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l05987"></a>05987 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l05988"></a>05988 <span class="preprocessor"></span>        DPRINTK(TX_ERR, INFO, <span class="stringliteral">&quot;tx[%02d] bd: %d - assigning node %d\n&quot;</span>,
<a name="l05989"></a>05989                 i, adapter-&gt;bd_number, adapter-&gt;tx_ring[i]-&gt;numa_node);
<a name="l05990"></a>05990 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l05991"></a>05991         err = ixgbe_setup_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l05992"></a>05992         <span class="keywordflow">if</span> (!err)
<a name="l05993"></a>05993             <span class="keywordflow">continue</span>;
<a name="l05994"></a>05994         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;Allocation for Tx Queue %u failed\n&quot;</span>, i);
<a name="l05995"></a>05995         <span class="keywordflow">break</span>;
<a name="l05996"></a>05996     }
<a name="l05997"></a>05997 
<a name="l05998"></a>05998     <span class="keywordflow">return</span> err;
<a name="l05999"></a>05999 }
<a name="l06000"></a>06000 
<a name="l06007"></a>06007 <span class="keywordtype">int</span> ixgbe_setup_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l06008"></a>06008 {
<a name="l06009"></a>06009     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = rx_ring-&gt;dev;
<a name="l06010"></a>06010     <span class="keywordtype">int</span> size;
<a name="l06011"></a>06011 
<a name="l06012"></a>06012     size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structixgbe__rx__buffer.html">ixgbe_rx_buffer</a>) * rx_ring-&gt;count;
<a name="l06013"></a>06013     rx_ring-&gt;rx_buffer_info = vmalloc_node(size, rx_ring-&gt;numa_node);
<a name="l06014"></a>06014     <span class="keywordflow">if</span> (!rx_ring-&gt;rx_buffer_info)
<a name="l06015"></a>06015         rx_ring-&gt;rx_buffer_info = vmalloc(size);
<a name="l06016"></a>06016     <span class="keywordflow">if</span> (!rx_ring-&gt;rx_buffer_info)
<a name="l06017"></a>06017         <span class="keywordflow">goto</span> err;
<a name="l06018"></a>06018     memset(rx_ring-&gt;rx_buffer_info, 0, size);
<a name="l06019"></a>06019 
<a name="l06020"></a>06020     <span class="comment">/* Round up to nearest 4K */</span>
<a name="l06021"></a>06021     rx_ring-&gt;size = rx_ring-&gt;count * <span class="keyword">sizeof</span>(<span class="keyword">union </span><a class="code" href="unionixgbe__adv__rx__desc.html">ixgbe_adv_rx_desc</a>);
<a name="l06022"></a>06022     rx_ring-&gt;size = ALIGN(rx_ring-&gt;size, 4096);
<a name="l06023"></a>06023 
<a name="l06024"></a>06024     rx_ring-&gt;desc = dma_alloc_coherent(dev, rx_ring-&gt;size,
<a name="l06025"></a>06025                        &amp;rx_ring-&gt;dma, GFP_KERNEL);
<a name="l06026"></a>06026 
<a name="l06027"></a>06027     <span class="keywordflow">if</span> (!rx_ring-&gt;desc)
<a name="l06028"></a>06028         <span class="keywordflow">goto</span> err;
<a name="l06029"></a>06029 
<a name="l06030"></a>06030     rx_ring-&gt;next_to_clean = 0;
<a name="l06031"></a>06031     rx_ring-&gt;next_to_use = 0;
<a name="l06032"></a>06032 
<a name="l06033"></a>06033     <span class="keywordflow">return</span> 0;
<a name="l06034"></a>06034 err:
<a name="l06035"></a>06035     vfree(rx_ring-&gt;rx_buffer_info);
<a name="l06036"></a>06036     rx_ring-&gt;rx_buffer_info = NULL;
<a name="l06037"></a>06037     dev_err(dev, <span class="stringliteral">&quot;Unable to allocate memory for the Rx descriptor ring\n&quot;</span>);
<a name="l06038"></a>06038     <span class="keywordflow">return</span> -ENOMEM;
<a name="l06039"></a>06039 }
<a name="l06040"></a>06040 
<a name="l06051"></a>06051 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_setup_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06052"></a>06052 {
<a name="l06053"></a>06053     <span class="keywordtype">int</span> i, err = 0;
<a name="l06054"></a>06054 
<a name="l06055"></a>06055     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l06056"></a>06056 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l06057"></a>06057 <span class="preprocessor"></span>        DPRINTK(RX_ERR, INFO, <span class="stringliteral">&quot;rx[%02d] bd: %d - assigning node %d\n&quot;</span>,
<a name="l06058"></a>06058                 i, adapter-&gt;bd_number, adapter-&gt;rx_ring[i]-&gt;numa_node);
<a name="l06059"></a>06059 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l06060"></a>06060         err = ixgbe_setup_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l06061"></a>06061         <span class="keywordflow">if</span> (!err)
<a name="l06062"></a>06062             <span class="keywordflow">continue</span>;
<a name="l06063"></a>06063         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;Allocation for Rx Queue %u failed\n&quot;</span>, i);
<a name="l06064"></a>06064         <span class="keywordflow">break</span>;
<a name="l06065"></a>06065     }
<a name="l06066"></a>06066 
<a name="l06067"></a>06067     <span class="keywordflow">return</span> err;
<a name="l06068"></a>06068 }
<a name="l06069"></a>06069 
<a name="l06076"></a>06076 <span class="keywordtype">void</span> ixgbe_free_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l06077"></a>06077 {
<a name="l06078"></a>06078     ixgbe_clean_tx_ring(tx_ring);
<a name="l06079"></a>06079 
<a name="l06080"></a>06080     vfree(tx_ring-&gt;tx_buffer_info);
<a name="l06081"></a>06081     tx_ring-&gt;tx_buffer_info = NULL;
<a name="l06082"></a>06082 
<a name="l06083"></a>06083     <span class="comment">/* if not set, then don&#39;t free */</span>
<a name="l06084"></a>06084     <span class="keywordflow">if</span> (!tx_ring-&gt;desc)
<a name="l06085"></a>06085         <span class="keywordflow">return</span>;
<a name="l06086"></a>06086 
<a name="l06087"></a>06087     dma_free_coherent(tx_ring-&gt;dev, tx_ring-&gt;size,
<a name="l06088"></a>06088               tx_ring-&gt;desc, tx_ring-&gt;dma);
<a name="l06089"></a>06089 
<a name="l06090"></a>06090     tx_ring-&gt;desc = NULL;
<a name="l06091"></a>06091 }
<a name="l06092"></a>06092 
<a name="l06099"></a>06099 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_all_tx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06100"></a>06100 {
<a name="l06101"></a>06101     <span class="keywordtype">int</span> i;
<a name="l06102"></a>06102 
<a name="l06103"></a>06103     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l06104"></a>06104         <span class="keywordflow">if</span> (adapter-&gt;tx_ring[i]-&gt;desc)
<a name="l06105"></a>06105             ixgbe_free_tx_resources(adapter-&gt;tx_ring[i]);
<a name="l06106"></a>06106 }
<a name="l06107"></a>06107 
<a name="l06114"></a>06114 <span class="keywordtype">void</span> ixgbe_free_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring)
<a name="l06115"></a>06115 {
<a name="l06116"></a>06116     ixgbe_clean_rx_ring(rx_ring);
<a name="l06117"></a>06117 
<a name="l06118"></a>06118     vfree(rx_ring-&gt;rx_buffer_info);
<a name="l06119"></a>06119     rx_ring-&gt;rx_buffer_info = NULL;
<a name="l06120"></a>06120 
<a name="l06121"></a>06121     <span class="comment">/* if not set, then don&#39;t free */</span>
<a name="l06122"></a>06122     <span class="keywordflow">if</span> (!rx_ring-&gt;desc)
<a name="l06123"></a>06123         <span class="keywordflow">return</span>;
<a name="l06124"></a>06124 
<a name="l06125"></a>06125     dma_free_coherent(rx_ring-&gt;dev, rx_ring-&gt;size,
<a name="l06126"></a>06126               rx_ring-&gt;desc, rx_ring-&gt;dma);
<a name="l06127"></a>06127 
<a name="l06128"></a>06128     rx_ring-&gt;desc = NULL;
<a name="l06129"></a>06129 }
<a name="l06130"></a>06130 
<a name="l06137"></a>06137 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_free_all_rx_resources(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06138"></a>06138 {
<a name="l06139"></a>06139     <span class="keywordtype">int</span> i;
<a name="l06140"></a>06140 
<a name="l06141"></a>06141     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++)
<a name="l06142"></a>06142         <span class="keywordflow">if</span> (adapter-&gt;rx_ring[i]-&gt;desc)
<a name="l06143"></a>06143             ixgbe_free_rx_resources(adapter-&gt;rx_ring[i]);
<a name="l06144"></a>06144 }
<a name="l06145"></a>06145 
<a name="l06153"></a>06153 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_change_mtu(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">int</span> new_mtu)
<a name="l06154"></a>06154 {
<a name="l06155"></a>06155     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06156"></a>06156     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06157"></a>06157     <span class="keywordtype">int</span> max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;
<a name="l06158"></a>06158 
<a name="l06159"></a>06159     <span class="comment">/* MTU &lt; 68 is an error and causes problems on some kernels */</span>
<a name="l06160"></a>06160     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l06161"></a>06161         <span class="keywordflow">if</span> ((new_mtu &lt; 68) || (max_frame &gt; MAXIMUM_ETHERNET_VLAN_SIZE))
<a name="l06162"></a>06162             <span class="keywordflow">return</span> -EINVAL;
<a name="l06163"></a>06163     } <span class="keywordflow">else</span> {
<a name="l06164"></a>06164         <span class="keywordflow">if</span> ((new_mtu &lt; 68) || (max_frame &gt; IXGBE_MAX_JUMBO_FRAME_SIZE))
<a name="l06165"></a>06165             <span class="keywordflow">return</span> -EINVAL;
<a name="l06166"></a>06166     }
<a name="l06167"></a>06167 
<a name="l06168"></a>06168     DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;changing MTU from %d to %d\n&quot;</span>,
<a name="l06169"></a>06169             netdev-&gt;mtu, new_mtu);
<a name="l06170"></a>06170     <span class="comment">/* must set new MTU before calling down or up */</span>
<a name="l06171"></a>06171     netdev-&gt;mtu = new_mtu;
<a name="l06172"></a>06172 
<a name="l06173"></a>06173     hw-&gt;fc.high_water = FC_HIGH_WATER(max_frame);
<a name="l06174"></a>06174     hw-&gt;fc.low_water = FC_LOW_WATER(max_frame);
<a name="l06175"></a>06175 
<a name="l06176"></a>06176     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l06177"></a>06177         ixgbe_reinit_locked(adapter);
<a name="l06178"></a>06178 
<a name="l06179"></a>06179     <span class="keywordflow">return</span> 0;
<a name="l06180"></a>06180 }
<a name="l06181"></a>06181 
<a name="l06194"></a>06194 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_open(<span class="keyword">struct</span> net_device *netdev)
<a name="l06195"></a>06195 {
<a name="l06196"></a>06196     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06197"></a>06197     <span class="keywordtype">int</span> err;
<a name="l06198"></a>06198 
<a name="l06199"></a>06199     <span class="comment">/* disallow open during test */</span>
<a name="l06200"></a>06200     <span class="keywordflow">if</span> (test_bit(__IXGBE_TESTING, &amp;adapter-&gt;state))
<a name="l06201"></a>06201         <span class="keywordflow">return</span> -EBUSY;
<a name="l06202"></a>06202 
<a name="l06203"></a>06203     netif_carrier_off(netdev);
<a name="l06204"></a>06204 
<a name="l06205"></a>06205     <span class="comment">/* allocate transmit descriptors */</span>
<a name="l06206"></a>06206     err = ixgbe_setup_all_tx_resources(adapter);
<a name="l06207"></a>06207     <span class="keywordflow">if</span> (err)
<a name="l06208"></a>06208         <span class="keywordflow">goto</span> err_setup_tx;
<a name="l06209"></a>06209 
<a name="l06210"></a>06210     <span class="comment">/* allocate receive descriptors */</span>
<a name="l06211"></a>06211     err = ixgbe_setup_all_rx_resources(adapter);
<a name="l06212"></a>06212     <span class="keywordflow">if</span> (err)
<a name="l06213"></a>06213         <span class="keywordflow">goto</span> err_setup_rx;
<a name="l06214"></a>06214 
<a name="l06215"></a>06215     ixgbe_configure(adapter);
<a name="l06216"></a>06216 
<a name="l06217"></a>06217     err = ixgbe_request_irq(adapter);
<a name="l06218"></a>06218     <span class="keywordflow">if</span> (err)
<a name="l06219"></a>06219         <span class="keywordflow">goto</span> err_req_irq;
<a name="l06220"></a>06220 
<a name="l06221"></a>06221     err = ixgbe_up_complete(adapter);
<a name="l06222"></a>06222     <span class="keywordflow">if</span> (err)
<a name="l06223"></a>06223         <span class="keywordflow">goto</span> err_setup_rx;
<a name="l06224"></a>06224 
<a name="l06225"></a>06225     <span class="keywordflow">return</span> 0;
<a name="l06226"></a>06226 
<a name="l06227"></a>06227 err_req_irq:
<a name="l06228"></a>06228     ixgbe_down(adapter);
<a name="l06229"></a>06229     ixgbe_release_hw_control(adapter);
<a name="l06230"></a>06230     ixgbe_free_irq(adapter);
<a name="l06231"></a>06231 err_setup_rx:
<a name="l06232"></a>06232     ixgbe_free_all_rx_resources(adapter);
<a name="l06233"></a>06233 err_setup_tx:
<a name="l06234"></a>06234     ixgbe_free_all_tx_resources(adapter);
<a name="l06235"></a>06235     ixgbe_reset(adapter);
<a name="l06236"></a>06236 
<a name="l06237"></a>06237     <span class="keywordflow">return</span> err;
<a name="l06238"></a>06238 }
<a name="l06239"></a>06239 
<a name="l06251"></a>06251 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_close(<span class="keyword">struct</span> net_device *netdev)
<a name="l06252"></a>06252 {
<a name="l06253"></a>06253     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06254"></a>06254 
<a name="l06255"></a>06255     ixgbe_down(adapter);
<a name="l06256"></a>06256     ixgbe_free_irq(adapter);
<a name="l06257"></a>06257 
<a name="l06258"></a>06258     ixgbe_free_all_tx_resources(adapter);
<a name="l06259"></a>06259     ixgbe_free_all_rx_resources(adapter);
<a name="l06260"></a>06260 
<a name="l06261"></a>06261     ixgbe_release_hw_control(adapter);
<a name="l06262"></a>06262 
<a name="l06263"></a>06263     <span class="keywordflow">return</span> 0;
<a name="l06264"></a>06264 }
<a name="l06265"></a>06265 
<a name="l06266"></a>06266 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06267"></a>06267 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06268"></a>06268 {
<a name="l06269"></a>06269     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l06270"></a>06270     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06271"></a>06271     u32 err;
<a name="l06272"></a>06272 
<a name="l06273"></a>06273     pci_set_power_state(pdev, PCI_D0);
<a name="l06274"></a>06274     pci_restore_state(pdev);
<a name="l06275"></a>06275     <span class="comment">/*</span>
<a name="l06276"></a>06276 <span class="comment">     * pci_restore_state clears dev-&gt;state_saved so call</span>
<a name="l06277"></a>06277 <span class="comment">     * pci_save_state to restore it.</span>
<a name="l06278"></a>06278 <span class="comment">     */</span>
<a name="l06279"></a>06279     pci_save_state(pdev);
<a name="l06280"></a>06280 
<a name="l06281"></a>06281     err = pci_enable_device_mem(pdev);
<a name="l06282"></a>06282     <span class="keywordflow">if</span> (err) {
<a name="l06283"></a>06283         printk(KERN_ERR <span class="stringliteral">&quot;ixgbe: Cannot enable PCI device from &quot;</span>
<a name="l06284"></a>06284                <span class="stringliteral">&quot;suspend\n&quot;</span>);
<a name="l06285"></a>06285         <span class="keywordflow">return</span> err;
<a name="l06286"></a>06286     }
<a name="l06287"></a>06287     pci_set_master(pdev);
<a name="l06288"></a>06288 
<a name="l06289"></a>06289     pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l06290"></a>06290 
<a name="l06291"></a>06291     err = ixgbe_init_interrupt_scheme(adapter);
<a name="l06292"></a>06292     <span class="keywordflow">if</span> (err) {
<a name="l06293"></a>06293         printk(KERN_ERR <span class="stringliteral">&quot;ixgbe: Cannot initialize interrupts for &quot;</span>
<a name="l06294"></a>06294                <span class="stringliteral">&quot;device\n&quot;</span>);
<a name="l06295"></a>06295         <span class="keywordflow">return</span> err;
<a name="l06296"></a>06296     }
<a name="l06297"></a>06297 
<a name="l06298"></a>06298     ixgbe_reset(adapter);
<a name="l06299"></a>06299 
<a name="l06300"></a>06300     IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_WUS, ~0);
<a name="l06301"></a>06301 
<a name="l06302"></a>06302     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l06303"></a>06303         err = ixgbe_open(netdev);
<a name="l06304"></a>06304         <span class="keywordflow">if</span> (err)
<a name="l06305"></a>06305             <span class="keywordflow">return</span> err;
<a name="l06306"></a>06306     }
<a name="l06307"></a>06307 
<a name="l06308"></a>06308     netif_device_attach(netdev);
<a name="l06309"></a>06309 
<a name="l06310"></a>06310     <span class="keywordflow">return</span> 0;
<a name="l06311"></a>06311 }
<a name="l06312"></a>06312 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PM */</span>
<a name="l06313"></a>06313 
<a name="l06314"></a>06314 <span class="comment">/*</span>
<a name="l06315"></a>06315 <span class="comment"> * __ixgbe_shutdown is not used when power management</span>
<a name="l06316"></a>06316 <span class="comment"> * is disabled on older kernels (&lt;2.6.12). causes a compile</span>
<a name="l06317"></a>06317 <span class="comment"> * warning/error, because it is defined and not used.</span>
<a name="l06318"></a>06318 <span class="comment"> */</span>
<a name="l06319"></a>06319 <span class="preprocessor">#if defined(CONFIG_PM) || !defined(USE_REBOOT_NOTIFIER)</span>
<a name="l06320"></a>06320 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> __ixgbe_shutdown(<span class="keyword">struct</span> pci_dev *pdev, <span class="keywordtype">bool</span> *enable_wake)
<a name="l06321"></a>06321 {
<a name="l06322"></a>06322     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l06323"></a>06323     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06324"></a>06324     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06325"></a>06325     u32 ctrl, fctrl;
<a name="l06326"></a>06326     u32 wufc = adapter-&gt;wol;
<a name="l06327"></a>06327 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06328"></a>06328 <span class="preprocessor"></span>    <span class="keywordtype">int</span> retval = 0;
<a name="l06329"></a>06329 <span class="preprocessor">#endif</span>
<a name="l06330"></a>06330 <span class="preprocessor"></span>
<a name="l06331"></a>06331     netif_device_detach(netdev);
<a name="l06332"></a>06332 
<a name="l06333"></a>06333     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l06334"></a>06334         ixgbe_down(adapter);
<a name="l06335"></a>06335         ixgbe_free_irq(adapter);
<a name="l06336"></a>06336         ixgbe_free_all_tx_resources(adapter);
<a name="l06337"></a>06337         ixgbe_free_all_rx_resources(adapter);
<a name="l06338"></a>06338     }
<a name="l06339"></a>06339 
<a name="l06340"></a>06340     ixgbe_clear_interrupt_scheme(adapter);
<a name="l06341"></a>06341 
<a name="l06342"></a>06342 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06343"></a>06343 <span class="preprocessor"></span>    retval = pci_save_state(pdev);
<a name="l06344"></a>06344     <span class="keywordflow">if</span> (retval)
<a name="l06345"></a>06345         <span class="keywordflow">return</span> retval;
<a name="l06346"></a>06346 
<a name="l06347"></a>06347 <span class="preprocessor">#endif</span>
<a name="l06348"></a>06348 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (wufc) {
<a name="l06349"></a>06349         ixgbe_set_rx_mode(netdev);
<a name="l06350"></a>06350 
<a name="l06351"></a>06351         <span class="comment">/* turn on all-multi mode if wake on multicast is enabled */</span>
<a name="l06352"></a>06352         <span class="keywordflow">if</span> (wufc &amp; IXGBE_WUFC_MC) {
<a name="l06353"></a>06353             fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l06354"></a>06354             fctrl |= IXGBE_FCTRL_MPE;
<a name="l06355"></a>06355             IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
<a name="l06356"></a>06356         }
<a name="l06357"></a>06357 
<a name="l06358"></a>06358         ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
<a name="l06359"></a>06359         ctrl |= IXGBE_CTRL_GIO_DIS;
<a name="l06360"></a>06360         IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
<a name="l06361"></a>06361 
<a name="l06362"></a>06362         IXGBE_WRITE_REG(hw, IXGBE_WUFC, wufc);
<a name="l06363"></a>06363     } <span class="keywordflow">else</span> {
<a name="l06364"></a>06364         IXGBE_WRITE_REG(hw, IXGBE_WUC, 0);
<a name="l06365"></a>06365         IXGBE_WRITE_REG(hw, IXGBE_WUFC, 0);
<a name="l06366"></a>06366     }
<a name="l06367"></a>06367 
<a name="l06368"></a>06368     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l06369"></a>06369     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l06370"></a>06370         pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l06371"></a>06371         <span class="keywordflow">break</span>;
<a name="l06372"></a>06372     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l06373"></a>06373     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l06374"></a>06374         pci_wake_from_d3(pdev, !!wufc);
<a name="l06375"></a>06375         <span class="keywordflow">break</span>;
<a name="l06376"></a>06376     <span class="keywordflow">default</span>:
<a name="l06377"></a>06377         <span class="keywordflow">break</span>;
<a name="l06378"></a>06378     }
<a name="l06379"></a>06379 
<a name="l06380"></a>06380     *enable_wake = !!wufc;
<a name="l06381"></a>06381 
<a name="l06382"></a>06382     ixgbe_release_hw_control(adapter);
<a name="l06383"></a>06383 
<a name="l06384"></a>06384     pci_disable_device(pdev);
<a name="l06385"></a>06385 
<a name="l06386"></a>06386     <span class="keywordflow">return</span> 0;
<a name="l06387"></a>06387 }
<a name="l06388"></a>06388 <span class="preprocessor">#endif </span><span class="comment">/* defined(CONFIG_PM) || !defined(USE_REBOOT_NOTIFIER) */</span>
<a name="l06389"></a>06389 
<a name="l06390"></a>06390 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l06391"></a>06391 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_suspend(<span class="keyword">struct</span> pci_dev *pdev, pm_message_t <a class="code" href="structstate.html">state</a>)
<a name="l06392"></a>06392 {
<a name="l06393"></a>06393     <span class="keywordtype">int</span> retval;
<a name="l06394"></a>06394     <span class="keywordtype">bool</span> wake;
<a name="l06395"></a>06395 
<a name="l06396"></a>06396     retval = __ixgbe_shutdown(pdev, &amp;wake);
<a name="l06397"></a>06397     <span class="keywordflow">if</span> (retval)
<a name="l06398"></a>06398         <span class="keywordflow">return</span> retval;
<a name="l06399"></a>06399 
<a name="l06400"></a>06400     <span class="keywordflow">if</span> (wake) {
<a name="l06401"></a>06401         pci_prepare_to_sleep(pdev);
<a name="l06402"></a>06402     } <span class="keywordflow">else</span> {
<a name="l06403"></a>06403         pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l06404"></a>06404         pci_set_power_state(pdev, PCI_D3hot);
<a name="l06405"></a>06405     }
<a name="l06406"></a>06406 
<a name="l06407"></a>06407     <span class="keywordflow">return</span> 0;
<a name="l06408"></a>06408 }
<a name="l06409"></a>06409 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PM */</span>
<a name="l06410"></a>06410 
<a name="l06411"></a>06411 <span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l06412"></a>06412 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_shutdown(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l06413"></a>06413 {
<a name="l06414"></a>06414     <span class="keywordtype">bool</span> wake;
<a name="l06415"></a>06415 
<a name="l06416"></a>06416     __ixgbe_shutdown(pdev, &amp;wake);
<a name="l06417"></a>06417 
<a name="l06418"></a>06418     <span class="keywordflow">if</span> (system_state == SYSTEM_POWER_OFF) {
<a name="l06419"></a>06419         pci_wake_from_d3(pdev, wake);
<a name="l06420"></a>06420         pci_set_power_state(pdev, PCI_D3hot);
<a name="l06421"></a>06421     }
<a name="l06422"></a>06422 }
<a name="l06423"></a>06423 
<a name="l06424"></a>06424 <span class="preprocessor">#endif</span>
<a name="l06425"></a>06425 <span class="preprocessor"></span>
<a name="l06432"></a>06432 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *ixgbe_get_stats(<span class="keyword">struct</span> net_device *netdev)
<a name="l06433"></a>06433 {
<a name="l06434"></a>06434 <span class="preprocessor">#ifdef HAVE_NETDEV_STATS_IN_NETDEV</span>
<a name="l06435"></a>06435 <span class="preprocessor"></span>    <span class="comment">/* only return the current stats */</span>
<a name="l06436"></a>06436     <span class="keywordflow">return</span> &amp;netdev-&gt;stats;
<a name="l06437"></a>06437 <span class="preprocessor">#else</span>
<a name="l06438"></a>06438 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l06439"></a>06439 
<a name="l06440"></a>06440     <span class="comment">/* only return the current stats */</span>
<a name="l06441"></a>06441     <span class="keywordflow">return</span> &amp;adapter-&gt;net_stats;
<a name="l06442"></a>06442 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_STATS_IN_NETDEV */</span>
<a name="l06443"></a>06443 }
<a name="l06444"></a>06444 
<a name="l06449"></a>06449 <span class="keywordtype">void</span> ixgbe_update_stats(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06450"></a>06450 {
<a name="l06451"></a>06451     <span class="keyword">struct </span><a class="code" href="structnet__device__stats.html">net_device_stats</a> *net_stats = ixgbe_get_stats(adapter-&gt;netdev);
<a name="l06452"></a>06452     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06453"></a>06453     <span class="keyword">struct </span><a class="code" href="structixgbe__hw__stats.html">ixgbe_hw_stats</a> *hwstats = &amp;adapter-&gt;stats;
<a name="l06454"></a>06454     u64 total_mpc = 0;
<a name="l06455"></a>06455     u32 i, missed_rx = 0, mpc, bprc, lxon, lxoff, xon_off_tot;
<a name="l06456"></a>06456     u64 non_eop_descs = 0, restart_queue = 0, tx_busy = 0;
<a name="l06457"></a>06457     u64 alloc_rx_page_failed = 0, alloc_rx_buff_failed = 0;
<a name="l06458"></a>06458     u64 bytes = 0, packets = 0;
<a name="l06459"></a>06459 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l06460"></a>06460 <span class="preprocessor"></span>    u32 flushed = 0, coal = 0, recycled = 0;
<a name="l06461"></a>06461     <span class="keywordtype">int</span> num_q_vectors = 1;
<a name="l06462"></a>06462 <span class="preprocessor">#endif</span>
<a name="l06463"></a>06463 <span class="preprocessor"></span>
<a name="l06464"></a>06464     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) ||
<a name="l06465"></a>06465         test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l06466"></a>06466         <span class="keywordflow">return</span>;
<a name="l06467"></a>06467 
<a name="l06468"></a>06468 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l06469"></a>06469 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)
<a name="l06470"></a>06470         num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l06471"></a>06471 
<a name="l06472"></a>06472 <span class="preprocessor">#endif</span>
<a name="l06473"></a>06473 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED) {
<a name="l06474"></a>06474         u64 rsc_count = 0;
<a name="l06475"></a>06475         u64 rsc_flush = 0;
<a name="l06476"></a>06476         <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++)
<a name="l06477"></a>06477             adapter-&gt;hw_rx_no_dma_resources +=
<a name="l06478"></a>06478                          IXGBE_READ_REG(hw, IXGBE_QPRDC(i));
<a name="l06479"></a>06479         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l06480"></a>06480             rsc_count += adapter-&gt;rx_ring[i]-&gt;rx_stats.rsc_count;
<a name="l06481"></a>06481             rsc_flush += adapter-&gt;rx_ring[i]-&gt;rx_stats.rsc_flush;
<a name="l06482"></a>06482         }
<a name="l06483"></a>06483         adapter-&gt;rsc_total_count = rsc_count;
<a name="l06484"></a>06484         adapter-&gt;rsc_total_flush = rsc_flush;
<a name="l06485"></a>06485     }
<a name="l06486"></a>06486 
<a name="l06487"></a>06487 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l06488"></a>06488 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; num_q_vectors; i++) {
<a name="l06489"></a>06489         <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[i];
<a name="l06490"></a>06490         <span class="keywordflow">if</span> (!q_vector || !q_vector-&gt;lrolist)
<a name="l06491"></a>06491             <span class="keywordflow">continue</span>;
<a name="l06492"></a>06492         flushed += q_vector-&gt;lrolist-&gt;stats.flushed;
<a name="l06493"></a>06493         coal += q_vector-&gt;lrolist-&gt;stats.coal;
<a name="l06494"></a>06494         recycled += q_vector-&gt;lrolist-&gt;stats.recycled;
<a name="l06495"></a>06495     }
<a name="l06496"></a>06496     adapter-&gt;lro_stats.flushed = flushed;
<a name="l06497"></a>06497     adapter-&gt;lro_stats.coal = coal;
<a name="l06498"></a>06498     adapter-&gt;lro_stats.recycled = recycled;
<a name="l06499"></a>06499 
<a name="l06500"></a>06500 <span class="preprocessor">#endif</span>
<a name="l06501"></a>06501 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_rx_queues; i++) {
<a name="l06502"></a>06502         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *rx_ring = adapter-&gt;rx_ring[i];
<a name="l06503"></a>06503         non_eop_descs += rx_ring-&gt;rx_stats.non_eop_descs;
<a name="l06504"></a>06504         alloc_rx_page_failed += rx_ring-&gt;rx_stats.alloc_rx_page_failed;
<a name="l06505"></a>06505         alloc_rx_buff_failed += rx_ring-&gt;rx_stats.alloc_rx_buff_failed;
<a name="l06506"></a>06506         bytes += rx_ring-&gt;stats.bytes;
<a name="l06507"></a>06507         packets += rx_ring-&gt;stats.packets;
<a name="l06508"></a>06508         
<a name="l06509"></a>06509     }
<a name="l06510"></a>06510     adapter-&gt;non_eop_descs = non_eop_descs;
<a name="l06511"></a>06511     adapter-&gt;alloc_rx_page_failed = alloc_rx_page_failed;
<a name="l06512"></a>06512     adapter-&gt;alloc_rx_buff_failed = alloc_rx_buff_failed;
<a name="l06513"></a>06513     net_stats-&gt;rx_bytes = bytes;
<a name="l06514"></a>06514     net_stats-&gt;rx_packets = packets;
<a name="l06515"></a>06515 
<a name="l06516"></a>06516     bytes = 0;
<a name="l06517"></a>06517     packets = 0;
<a name="l06518"></a>06518     <span class="comment">/* gather some stats to the adapter struct that are per queue */</span>
<a name="l06519"></a>06519     <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l06520"></a>06520         <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l06521"></a>06521         restart_queue += tx_ring-&gt;tx_stats.restart_queue;
<a name="l06522"></a>06522         tx_busy += tx_ring-&gt;tx_stats.tx_busy;
<a name="l06523"></a>06523         bytes += tx_ring-&gt;stats.bytes;
<a name="l06524"></a>06524         packets += tx_ring-&gt;stats.packets;
<a name="l06525"></a>06525     }
<a name="l06526"></a>06526     adapter-&gt;restart_queue = restart_queue;
<a name="l06527"></a>06527     adapter-&gt;tx_busy = tx_busy;
<a name="l06528"></a>06528     net_stats-&gt;tx_bytes = bytes;
<a name="l06529"></a>06529     net_stats-&gt;tx_packets = packets;
<a name="l06530"></a>06530 
<a name="l06531"></a>06531     hwstats-&gt;crcerrs += IXGBE_READ_REG(hw, IXGBE_CRCERRS);
<a name="l06532"></a>06532     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {
<a name="l06533"></a>06533         <span class="comment">/* for packet buffers not used, the register should read 0 */</span>
<a name="l06534"></a>06534         mpc = IXGBE_READ_REG(hw, IXGBE_MPC(i));
<a name="l06535"></a>06535         missed_rx += mpc;
<a name="l06536"></a>06536         hwstats-&gt;mpc[i] += mpc;
<a name="l06537"></a>06537         total_mpc += hwstats-&gt;mpc[i];
<a name="l06538"></a>06538         <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l06539"></a>06539             hwstats-&gt;rnbc[i] += IXGBE_READ_REG(hw, IXGBE_RNBC(i));
<a name="l06540"></a>06540         hwstats-&gt;qptc[i] += IXGBE_READ_REG(hw, IXGBE_QPTC(i));
<a name="l06541"></a>06541         hwstats-&gt;qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC(i));
<a name="l06542"></a>06542         hwstats-&gt;qprc[i] += IXGBE_READ_REG(hw, IXGBE_QPRC(i));
<a name="l06543"></a>06543         hwstats-&gt;qbrc[i] += IXGBE_READ_REG(hw, IXGBE_QBRC(i));
<a name="l06544"></a>06544         <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l06545"></a>06545         <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l06546"></a>06546             hwstats-&gt;pxonrxc[i] += IXGBE_READ_REG(hw,
<a name="l06547"></a>06547                                   IXGBE_PXONRXC(i));
<a name="l06548"></a>06548             <span class="keywordflow">break</span>;
<a name="l06549"></a>06549         <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l06550"></a>06550         <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l06551"></a>06551             hwstats-&gt;pxonrxc[i] += IXGBE_READ_REG(hw,
<a name="l06552"></a>06552                                 IXGBE_PXONRXCNT(i));
<a name="l06553"></a>06553             <span class="keywordflow">break</span>;
<a name="l06554"></a>06554         <span class="keywordflow">default</span>:
<a name="l06555"></a>06555             <span class="keywordflow">break</span>;
<a name="l06556"></a>06556         }
<a name="l06557"></a>06557         hwstats-&gt;pxontxc[i] += IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
<a name="l06558"></a>06558         hwstats-&gt;pxofftxc[i] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
<a name="l06559"></a>06559     }
<a name="l06560"></a>06560     hwstats-&gt;gprc += IXGBE_READ_REG(hw, IXGBE_GPRC);
<a name="l06561"></a>06561     <span class="comment">/* work around hardware counting issue */</span>
<a name="l06562"></a>06562     hwstats-&gt;gprc -= missed_rx;
<a name="l06563"></a>06563 
<a name="l06564"></a>06564 
<a name="l06565"></a>06565     ixgbe_update_xoff_received(adapter);
<a name="l06566"></a>06566 
<a name="l06567"></a>06567     <span class="comment">/* 82598 hardware only has a 32 bit counter in the high register */</span>
<a name="l06568"></a>06568     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l06569"></a>06569     <span class="keywordflow">case</span> ixgbe_mac_82598EB:
<a name="l06570"></a>06570         hwstats-&gt;lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXC);
<a name="l06571"></a>06571         hwstats-&gt;gorc += IXGBE_READ_REG(hw, IXGBE_GORCH);
<a name="l06572"></a>06572         hwstats-&gt;gotc += IXGBE_READ_REG(hw, IXGBE_GOTCH);
<a name="l06573"></a>06573         hwstats-&gt;tor += IXGBE_READ_REG(hw, IXGBE_TORH);
<a name="l06574"></a>06574         <span class="keywordflow">break</span>;
<a name="l06575"></a>06575     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l06576"></a>06576     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l06577"></a>06577         hwstats-&gt;gorc += IXGBE_READ_REG(hw, IXGBE_GORCL);
<a name="l06578"></a>06578         IXGBE_READ_REG(hw, IXGBE_GORCH); <span class="comment">/* to clear */</span>
<a name="l06579"></a>06579         hwstats-&gt;gotc += IXGBE_READ_REG(hw, IXGBE_GOTCL);
<a name="l06580"></a>06580         IXGBE_READ_REG(hw, IXGBE_GOTCH); <span class="comment">/* to clear */</span>
<a name="l06581"></a>06581         hwstats-&gt;tor += IXGBE_READ_REG(hw, IXGBE_TORL);
<a name="l06582"></a>06582         IXGBE_READ_REG(hw, IXGBE_TORH); <span class="comment">/* to clear */</span>
<a name="l06583"></a>06583         hwstats-&gt;lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
<a name="l06584"></a>06584 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l06585"></a>06585 <span class="preprocessor"></span>        hwstats-&gt;fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
<a name="l06586"></a>06586         hwstats-&gt;fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
<a name="l06587"></a>06587 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l06588"></a>06588 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l06589"></a>06589 <span class="preprocessor"></span>        hwstats-&gt;fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
<a name="l06590"></a>06590         hwstats-&gt;fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
<a name="l06591"></a>06591         hwstats-&gt;fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
<a name="l06592"></a>06592         hwstats-&gt;fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
<a name="l06593"></a>06593         hwstats-&gt;fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
<a name="l06594"></a>06594         hwstats-&gt;fcoedwrc += IXGBE_READ_REG(hw, IXGBE_FCOEDWRC);
<a name="l06595"></a>06595         hwstats-&gt;fcoedwtc += IXGBE_READ_REG(hw, IXGBE_FCOEDWTC);
<a name="l06596"></a>06596 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l06597"></a>06597         <span class="keywordflow">break</span>;
<a name="l06598"></a>06598     <span class="keywordflow">default</span>:
<a name="l06599"></a>06599         <span class="keywordflow">break</span>;
<a name="l06600"></a>06600     }
<a name="l06601"></a>06601     bprc = IXGBE_READ_REG(hw, IXGBE_BPRC);
<a name="l06602"></a>06602     hwstats-&gt;bprc += bprc;
<a name="l06603"></a>06603     hwstats-&gt;mprc += IXGBE_READ_REG(hw, IXGBE_MPRC);
<a name="l06604"></a>06604     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l06605"></a>06605         hwstats-&gt;mprc -= bprc;
<a name="l06606"></a>06606     hwstats-&gt;roc += IXGBE_READ_REG(hw, IXGBE_ROC);
<a name="l06607"></a>06607     hwstats-&gt;prc64 += IXGBE_READ_REG(hw, IXGBE_PRC64);
<a name="l06608"></a>06608     hwstats-&gt;prc127 += IXGBE_READ_REG(hw, IXGBE_PRC127);
<a name="l06609"></a>06609     hwstats-&gt;prc255 += IXGBE_READ_REG(hw, IXGBE_PRC255);
<a name="l06610"></a>06610     hwstats-&gt;prc511 += IXGBE_READ_REG(hw, IXGBE_PRC511);
<a name="l06611"></a>06611     hwstats-&gt;prc1023 += IXGBE_READ_REG(hw, IXGBE_PRC1023);
<a name="l06612"></a>06612     hwstats-&gt;prc1522 += IXGBE_READ_REG(hw, IXGBE_PRC1522);
<a name="l06613"></a>06613     hwstats-&gt;rlec += IXGBE_READ_REG(hw, IXGBE_RLEC);
<a name="l06614"></a>06614     lxon = IXGBE_READ_REG(hw, IXGBE_LXONTXC);
<a name="l06615"></a>06615     hwstats-&gt;lxontxc += lxon;
<a name="l06616"></a>06616     lxoff = IXGBE_READ_REG(hw, IXGBE_LXOFFTXC);
<a name="l06617"></a>06617     hwstats-&gt;lxofftxc += lxoff;
<a name="l06618"></a>06618     hwstats-&gt;ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
<a name="l06619"></a>06619     hwstats-&gt;gptc += IXGBE_READ_REG(hw, IXGBE_GPTC);
<a name="l06620"></a>06620     hwstats-&gt;mptc += IXGBE_READ_REG(hw, IXGBE_MPTC);
<a name="l06621"></a>06621     <span class="comment">/*</span>
<a name="l06622"></a>06622 <span class="comment">     * 82598 errata - tx of flow control packets is included in tx counters</span>
<a name="l06623"></a>06623 <span class="comment">     */</span>
<a name="l06624"></a>06624     xon_off_tot = lxon + lxoff;
<a name="l06625"></a>06625     hwstats-&gt;gptc -= xon_off_tot;
<a name="l06626"></a>06626     hwstats-&gt;mptc -= xon_off_tot;
<a name="l06627"></a>06627     hwstats-&gt;gotc -= (xon_off_tot * (ETH_ZLEN + ETH_FCS_LEN));
<a name="l06628"></a>06628     hwstats-&gt;ruc += IXGBE_READ_REG(hw, IXGBE_RUC);
<a name="l06629"></a>06629     hwstats-&gt;rfc += IXGBE_READ_REG(hw, IXGBE_RFC);
<a name="l06630"></a>06630     hwstats-&gt;rjc += IXGBE_READ_REG(hw, IXGBE_RJC);
<a name="l06631"></a>06631     hwstats-&gt;tpr += IXGBE_READ_REG(hw, IXGBE_TPR);
<a name="l06632"></a>06632     hwstats-&gt;ptc64 += IXGBE_READ_REG(hw, IXGBE_PTC64);
<a name="l06633"></a>06633     hwstats-&gt;ptc64 -= xon_off_tot;
<a name="l06634"></a>06634     hwstats-&gt;ptc127 += IXGBE_READ_REG(hw, IXGBE_PTC127);
<a name="l06635"></a>06635     hwstats-&gt;ptc255 += IXGBE_READ_REG(hw, IXGBE_PTC255);
<a name="l06636"></a>06636     hwstats-&gt;ptc511 += IXGBE_READ_REG(hw, IXGBE_PTC511);
<a name="l06637"></a>06637     hwstats-&gt;ptc1023 += IXGBE_READ_REG(hw, IXGBE_PTC1023);
<a name="l06638"></a>06638     hwstats-&gt;ptc1522 += IXGBE_READ_REG(hw, IXGBE_PTC1522);
<a name="l06639"></a>06639     hwstats-&gt;bptc += IXGBE_READ_REG(hw, IXGBE_BPTC);
<a name="l06640"></a>06640 
<a name="l06641"></a>06641     <span class="comment">/* Fill out the OS statistics structure */</span>
<a name="l06642"></a>06642     net_stats-&gt;multicast = hwstats-&gt;mprc;
<a name="l06643"></a>06643 
<a name="l06644"></a>06644     <span class="comment">/* Rx Errors */</span>
<a name="l06645"></a>06645     net_stats-&gt;rx_errors = hwstats-&gt;crcerrs +
<a name="l06646"></a>06646                        hwstats-&gt;rlec;
<a name="l06647"></a>06647     net_stats-&gt;rx_dropped = 0;
<a name="l06648"></a>06648     net_stats-&gt;rx_length_errors = hwstats-&gt;rlec;
<a name="l06649"></a>06649     net_stats-&gt;rx_crc_errors = hwstats-&gt;crcerrs;
<a name="l06650"></a>06650     net_stats-&gt;rx_missed_errors = total_mpc;
<a name="l06651"></a>06651 
<a name="l06652"></a>06652     <span class="comment">/*</span>
<a name="l06653"></a>06653 <span class="comment">     * VF Stats Collection - skip while resetting because these</span>
<a name="l06654"></a>06654 <span class="comment">     * are not clear on read and otherwise you&#39;ll sometimes get</span>
<a name="l06655"></a>06655 <span class="comment">     * crazy values.</span>
<a name="l06656"></a>06656 <span class="comment">     */</span>
<a name="l06657"></a>06657     <span class="keywordflow">if</span> (!test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state)) {
<a name="l06658"></a>06658         <span class="keywordflow">for</span>(i = 0; i &lt; adapter-&gt;num_vfs; i++) {
<a name="l06659"></a>06659             UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPRC(i),         \
<a name="l06660"></a>06660                     adapter-&gt;vfinfo[i].last_vfstats.gprc, \
<a name="l06661"></a>06661                     adapter-&gt;vfinfo[i].vfstats.gprc);
<a name="l06662"></a>06662             UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPTC(i),         \
<a name="l06663"></a>06663                     adapter-&gt;vfinfo[i].last_vfstats.gptc, \
<a name="l06664"></a>06664                     adapter-&gt;vfinfo[i].vfstats.gptc);
<a name="l06665"></a>06665             UPDATE_VF_COUNTER_36bit(IXGBE_PVFGORC_LSB(i),         \
<a name="l06666"></a>06666                     IXGBE_PVFGORC_MSB(i),             \
<a name="l06667"></a>06667                     adapter-&gt;vfinfo[i].last_vfstats.gorc, \
<a name="l06668"></a>06668                     adapter-&gt;vfinfo[i].vfstats.gorc);
<a name="l06669"></a>06669             UPDATE_VF_COUNTER_36bit(IXGBE_PVFGOTC_LSB(i),         \
<a name="l06670"></a>06670                     IXGBE_PVFGOTC_MSB(i),             \
<a name="l06671"></a>06671                     adapter-&gt;vfinfo[i].last_vfstats.gotc, \
<a name="l06672"></a>06672                     adapter-&gt;vfinfo[i].vfstats.gotc);
<a name="l06673"></a>06673             UPDATE_VF_COUNTER_32bit(IXGBE_PVFMPRC(i),         \
<a name="l06674"></a>06674                     adapter-&gt;vfinfo[i].last_vfstats.mprc, \
<a name="l06675"></a>06675                     adapter-&gt;vfinfo[i].vfstats.mprc);
<a name="l06676"></a>06676         }
<a name="l06677"></a>06677     }
<a name="l06678"></a>06678 }
<a name="l06679"></a>06679 
<a name="l06680"></a>06680 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l06681"></a>06681 <span class="preprocessor"></span>
<a name="l06685"></a>06685 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_fdir_reinit_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06686"></a>06686 {
<a name="l06687"></a>06687     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06688"></a>06688     <span class="keywordtype">int</span> i;
<a name="l06689"></a>06689 
<a name="l06690"></a>06690     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_FDIR_REQUIRES_REINIT))
<a name="l06691"></a>06691         <span class="keywordflow">return</span>;
<a name="l06692"></a>06692 
<a name="l06693"></a>06693     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_FDIR_REQUIRES_REINIT;
<a name="l06694"></a>06694     
<a name="l06695"></a>06695     <span class="comment">/* if interface is down do nothing */</span>
<a name="l06696"></a>06696     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l06697"></a>06697         <span class="keywordflow">return</span>;
<a name="l06698"></a>06698 
<a name="l06699"></a>06699     adapter-&gt;fdir_overflow++;
<a name="l06700"></a>06700 
<a name="l06701"></a>06701     <span class="keywordflow">if</span> (ixgbe_reinit_fdir_tables_82599(hw) == 0) {
<a name="l06702"></a>06702         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l06703"></a>06703             set_bit(__IXGBE_TX_FDIR_INIT_DONE,
<a name="l06704"></a>06704                     &amp;(adapter-&gt;tx_ring[i]-&gt;state));
<a name="l06705"></a>06705         <span class="comment">/* re-enable flow director interrupts */</span>
<a name="l06706"></a>06706         IXGBE_WRITE_REG(hw, IXGBE_EIMS, IXGBE_EIMS_FLOW_DIR);
<a name="l06707"></a>06707     } <span class="keywordflow">else</span> {
<a name="l06708"></a>06708         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;failed to finish FDIR re-initialization, &quot;</span>
<a name="l06709"></a>06709                 <span class="stringliteral">&quot;ignored adding FDIR ATR filters \n&quot;</span>);
<a name="l06710"></a>06710     }
<a name="l06711"></a>06711 }
<a name="l06712"></a>06712 
<a name="l06713"></a>06713 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l06714"></a>06714 
<a name="l06723"></a>06723 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_check_hang_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06724"></a>06724 {
<a name="l06725"></a>06725     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06726"></a>06726     u64 eics = 0;
<a name="l06727"></a>06727     <span class="keywordtype">int</span> i;
<a name="l06728"></a>06728 
<a name="l06729"></a>06729     <span class="comment">/* If we&#39;re down or resetting, just bail */</span>
<a name="l06730"></a>06730     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) ||
<a name="l06731"></a>06731         test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l06732"></a>06732         <span class="keywordflow">return</span>;
<a name="l06733"></a>06733 
<a name="l06734"></a>06734     <span class="comment">/* Force detection of hung controller */</span>
<a name="l06735"></a>06735     <span class="keywordflow">if</span> (netif_carrier_ok(adapter-&gt;netdev)) {
<a name="l06736"></a>06736         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++)
<a name="l06737"></a>06737             set_check_for_tx_hang(adapter-&gt;tx_ring[i]);
<a name="l06738"></a>06738     }
<a name="l06739"></a>06739 
<a name="l06740"></a>06740     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED)) {
<a name="l06741"></a>06741         <span class="comment">/*</span>
<a name="l06742"></a>06742 <span class="comment">         * for legacy and MSI interrupts don&#39;t set any bits</span>
<a name="l06743"></a>06743 <span class="comment">         * that are enabled for EIAM, because this operation</span>
<a name="l06744"></a>06744 <span class="comment">         * would set *both* EIMS and EICS for any bit in EIAM</span>
<a name="l06745"></a>06745 <span class="comment">         */</span>
<a name="l06746"></a>06746         IXGBE_WRITE_REG(hw, IXGBE_EICS,
<a name="l06747"></a>06747             (IXGBE_EICS_TCP_TIMER | IXGBE_EICS_OTHER));
<a name="l06748"></a>06748     } <span class="keywordflow">else</span> {
<a name="l06749"></a>06749         <span class="comment">/* get one bit for every active tx/rx interrupt vector */</span>
<a name="l06750"></a>06750         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_msix_vectors - NON_Q_VECTORS; i++) {
<a name="l06751"></a>06751             <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *qv = adapter-&gt;q_vector[i];
<a name="l06752"></a>06752             <span class="keywordflow">if</span> (qv-&gt;rx_ring || qv-&gt;tx_ring)
<a name="l06753"></a>06753                 eics |= ((u64)1 &lt;&lt; i);
<a name="l06754"></a>06754         }
<a name="l06755"></a>06755     }
<a name="l06756"></a>06756 
<a name="l06757"></a>06757     <span class="comment">/* Cause software interrupt to ensure rings are cleaned */</span>
<a name="l06758"></a>06758     ixgbe_irq_rearm_queues(adapter, eics);
<a name="l06759"></a>06759 
<a name="l06760"></a>06760 }
<a name="l06761"></a>06761 
<a name="l06767"></a>06767 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_update_link(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06768"></a>06768 {
<a name="l06769"></a>06769     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06770"></a>06770     u32 link_speed = adapter-&gt;link_speed;
<a name="l06771"></a>06771     <span class="keywordtype">bool</span> link_up = adapter-&gt;link_up;
<a name="l06772"></a>06772     <span class="keywordtype">int</span> i;
<a name="l06773"></a>06773 
<a name="l06774"></a>06774     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_UPDATE))
<a name="l06775"></a>06775         <span class="keywordflow">return</span>;
<a name="l06776"></a>06776 
<a name="l06777"></a>06777     <span class="keywordflow">if</span> (hw-&gt;mac.ops.check_link) {
<a name="l06778"></a>06778         hw-&gt;mac.ops.check_link(hw, &amp;link_speed, &amp;link_up, <span class="keyword">false</span>);
<a name="l06779"></a>06779     } <span class="keywordflow">else</span> {
<a name="l06780"></a>06780         <span class="comment">/* always assume link is up, if no check link function */</span>
<a name="l06781"></a>06781         link_speed = IXGBE_LINK_SPEED_10GB_FULL;
<a name="l06782"></a>06782         link_up = <span class="keyword">true</span>;
<a name="l06783"></a>06783     }
<a name="l06784"></a>06784     <span class="keywordflow">if</span> (link_up) {
<a name="l06785"></a>06785         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l06786"></a>06786             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_TRAFFIC_CLASS; i++)
<a name="l06787"></a>06787                 hw-&gt;mac.ops.fc_enable(hw, i);
<a name="l06788"></a>06788         } <span class="keywordflow">else</span> {
<a name="l06789"></a>06789             hw-&gt;mac.ops.fc_enable(hw, 0);
<a name="l06790"></a>06790         }
<a name="l06791"></a>06791     }
<a name="l06792"></a>06792 
<a name="l06793"></a>06793     <span class="keywordflow">if</span> (link_up ||
<a name="l06794"></a>06794         time_after(jiffies, (adapter-&gt;link_check_timeout +
<a name="l06795"></a>06795                  IXGBE_TRY_LINK_TIMEOUT))) {
<a name="l06796"></a>06796         adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l06797"></a>06797         IXGBE_WRITE_REG(hw, IXGBE_EIMS, IXGBE_EIMC_LSC);
<a name="l06798"></a>06798         IXGBE_WRITE_FLUSH(hw);
<a name="l06799"></a>06799     }
<a name="l06800"></a>06800 
<a name="l06801"></a>06801     adapter-&gt;link_up = link_up;
<a name="l06802"></a>06802     adapter-&gt;link_speed = link_speed;
<a name="l06803"></a>06803 }
<a name="l06804"></a>06804 
<a name="l06810"></a>06810 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_link_is_up(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06811"></a>06811 {
<a name="l06812"></a>06812     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06813"></a>06813     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06814"></a>06814     u32 link_speed = adapter-&gt;link_speed;
<a name="l06815"></a>06815     <span class="keywordtype">bool</span> flow_rx, flow_tx;
<a name="l06816"></a>06816 
<a name="l06817"></a>06817     <span class="comment">/* only continue if link was previously down */</span>
<a name="l06818"></a>06818     <span class="keywordflow">if</span> (netif_carrier_ok(netdev))
<a name="l06819"></a>06819         <span class="keywordflow">return</span>;
<a name="l06820"></a>06820 
<a name="l06821"></a>06821     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l06822"></a>06822 
<a name="l06823"></a>06823     <span class="keywordflow">switch</span> (hw-&gt;mac.type) {
<a name="l06824"></a>06824     <span class="keywordflow">case</span> ixgbe_mac_82598EB: {
<a name="l06825"></a>06825         u32 frctl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
<a name="l06826"></a>06826         u32 rmcs = IXGBE_READ_REG(hw, IXGBE_RMCS);
<a name="l06827"></a>06827         flow_rx = !!(frctl &amp; IXGBE_FCTRL_RFCE);
<a name="l06828"></a>06828         flow_tx = !!(rmcs &amp; IXGBE_RMCS_TFCE_802_3X);
<a name="l06829"></a>06829     }
<a name="l06830"></a>06830         <span class="keywordflow">break</span>;
<a name="l06831"></a>06831     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l06832"></a>06832     <span class="keywordflow">case</span> ixgbe_mac_82599EB: {
<a name="l06833"></a>06833         u32 mflcn = IXGBE_READ_REG(hw, IXGBE_MFLCN);
<a name="l06834"></a>06834         u32 fccfg = IXGBE_READ_REG(hw, IXGBE_FCCFG);
<a name="l06835"></a>06835         flow_rx = !!(mflcn &amp; IXGBE_MFLCN_RFCE);
<a name="l06836"></a>06836         flow_tx = !!(fccfg &amp; IXGBE_FCCFG_TFCE_802_3X);
<a name="l06837"></a>06837     }
<a name="l06838"></a>06838         <span class="keywordflow">break</span>;
<a name="l06839"></a>06839     <span class="keywordflow">default</span>:
<a name="l06840"></a>06840         flow_tx = <span class="keyword">false</span>;
<a name="l06841"></a>06841         flow_rx = <span class="keyword">false</span>;
<a name="l06842"></a>06842         <span class="keywordflow">break</span>;
<a name="l06843"></a>06843     }
<a name="l06844"></a>06844     DPRINTK(LINK, INFO, <span class="stringliteral">&quot;NIC Link is Up %s, &quot;</span>
<a name="l06845"></a>06845             <span class="stringliteral">&quot;Flow Control: %s\n&quot;</span>,
<a name="l06846"></a>06846             (link_speed == IXGBE_LINK_SPEED_10GB_FULL ?
<a name="l06847"></a>06847              <span class="stringliteral">&quot;10 Gbps&quot;</span> :
<a name="l06848"></a>06848              (link_speed == IXGBE_LINK_SPEED_1GB_FULL ?
<a name="l06849"></a>06849               <span class="stringliteral">&quot;1 Gbps&quot;</span> : <span class="stringliteral">&quot;unknown speed&quot;</span>)),
<a name="l06850"></a>06850             ((flow_rx &amp;&amp; flow_tx) ? <span class="stringliteral">&quot;RX/TX&quot;</span> :
<a name="l06851"></a>06851              (flow_rx ? <span class="stringliteral">&quot;RX&quot;</span> :
<a name="l06852"></a>06852              (flow_tx ? <span class="stringliteral">&quot;TX&quot;</span> : <span class="stringliteral">&quot;None&quot;</span>))));
<a name="l06853"></a>06853 
<a name="l06854"></a>06854     netif_carrier_on(netdev);
<a name="l06855"></a>06855     netif_tx_wake_all_queues(netdev);
<a name="l06856"></a>06856 }
<a name="l06857"></a>06857 
<a name="l06863"></a>06863 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_link_is_down(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>* adapter)
<a name="l06864"></a>06864 {
<a name="l06865"></a>06865     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l06866"></a>06866     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06867"></a>06867 
<a name="l06868"></a>06868     adapter-&gt;link_up = <span class="keyword">false</span>;
<a name="l06869"></a>06869     adapter-&gt;link_speed = 0;
<a name="l06870"></a>06870 
<a name="l06871"></a>06871     <span class="comment">/* only continue if link was up previously */</span>
<a name="l06872"></a>06872     <span class="keywordflow">if</span> (!netif_carrier_ok(netdev))
<a name="l06873"></a>06873         <span class="keywordflow">return</span>;
<a name="l06874"></a>06874 
<a name="l06875"></a>06875     <span class="comment">/* poll for SFP+ cable when link is down */</span>
<a name="l06876"></a>06876     <span class="keywordflow">if</span> (ixgbe_is_sfp(hw) &amp;&amp; hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l06877"></a>06877         adapter-&gt;flags2 |= IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l06878"></a>06878 
<a name="l06879"></a>06879     DPRINTK(LINK, INFO, <span class="stringliteral">&quot;NIC Link is Down\n&quot;</span>);
<a name="l06880"></a>06880     netif_carrier_off(netdev);
<a name="l06881"></a>06881     netif_tx_stop_all_queues(netdev);
<a name="l06882"></a>06882 }
<a name="l06883"></a>06883 
<a name="l06888"></a>06888 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_flush_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06889"></a>06889 {
<a name="l06890"></a>06890     <span class="keywordtype">int</span> i;
<a name="l06891"></a>06891     <span class="keywordtype">int</span> some_tx_pending = 0;
<a name="l06892"></a>06892 
<a name="l06893"></a>06893     <span class="keywordflow">if</span> (!netif_carrier_ok(adapter-&gt;netdev)) {
<a name="l06894"></a>06894         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_tx_queues; i++) {
<a name="l06895"></a>06895             <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring = adapter-&gt;tx_ring[i];
<a name="l06896"></a>06896             <span class="keywordflow">if</span> (tx_ring-&gt;next_to_use != tx_ring-&gt;next_to_clean) {
<a name="l06897"></a>06897                 some_tx_pending = 1;
<a name="l06898"></a>06898                 <span class="keywordflow">break</span>;
<a name="l06899"></a>06899             }
<a name="l06900"></a>06900         }
<a name="l06901"></a>06901 
<a name="l06902"></a>06902         <span class="keywordflow">if</span> (some_tx_pending) {
<a name="l06903"></a>06903             <span class="comment">/* We&#39;ve lost link, so the controller stops DMA,</span>
<a name="l06904"></a>06904 <span class="comment">             * but we&#39;ve got queued Tx work that&#39;s never going</span>
<a name="l06905"></a>06905 <span class="comment">             * to get done, so reset controller to flush Tx.</span>
<a name="l06906"></a>06906 <span class="comment">             * (Do the reset outside of interrupt context).</span>
<a name="l06907"></a>06907 <span class="comment">             */</span>
<a name="l06908"></a>06908             adapter-&gt;flags2 |= IXGBE_FLAG2_RESET_REQUESTED;
<a name="l06909"></a>06909         }
<a name="l06910"></a>06910     }
<a name="l06911"></a>06911 }
<a name="l06912"></a>06912 
<a name="l06913"></a>06913 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_spoof_check(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06914"></a>06914 {
<a name="l06915"></a>06915     u32 ssvpc;
<a name="l06916"></a>06916 
<a name="l06917"></a>06917     <span class="comment">/* Do not perform spoof check for 82598 */</span>
<a name="l06918"></a>06918     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82598EB)
<a name="l06919"></a>06919         <span class="keywordflow">return</span>;
<a name="l06920"></a>06920 
<a name="l06921"></a>06921     ssvpc = IXGBE_READ_REG(&amp;adapter-&gt;hw, IXGBE_SSVPC);
<a name="l06922"></a>06922 
<a name="l06923"></a>06923     <span class="comment">/*</span>
<a name="l06924"></a>06924 <span class="comment">     * ssvpc register is cleared on read, if zero then no</span>
<a name="l06925"></a>06925 <span class="comment">     * spoofed packets in the last interval.</span>
<a name="l06926"></a>06926 <span class="comment">     */</span>
<a name="l06927"></a>06927     <span class="keywordflow">if</span> (!ssvpc)
<a name="l06928"></a>06928         <span class="keywordflow">return</span>;
<a name="l06929"></a>06929 
<a name="l06930"></a>06930     DPRINTK(DRV, WARNING, <span class="stringliteral">&quot;%d Spoofed packets detected\n&quot;</span>, ssvpc);
<a name="l06931"></a>06931 }
<a name="l06932"></a>06932 
<a name="l06937"></a>06937 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_watchdog_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06938"></a>06938 {
<a name="l06939"></a>06939     <span class="comment">/* if interface is down do nothing */</span>
<a name="l06940"></a>06940     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l06941"></a>06941         <span class="keywordflow">return</span>;
<a name="l06942"></a>06942 
<a name="l06943"></a>06943     ixgbe_watchdog_update_link(adapter);
<a name="l06944"></a>06944 
<a name="l06945"></a>06945     <span class="keywordflow">if</span> (adapter-&gt;link_up)
<a name="l06946"></a>06946         ixgbe_watchdog_link_is_up(adapter);
<a name="l06947"></a>06947     <span class="keywordflow">else</span>
<a name="l06948"></a>06948         ixgbe_watchdog_link_is_down(adapter);
<a name="l06949"></a>06949 
<a name="l06950"></a>06950     ixgbe_spoof_check(adapter);
<a name="l06951"></a>06951     ixgbe_update_stats(adapter);
<a name="l06952"></a>06952 
<a name="l06953"></a>06953     ixgbe_watchdog_flush_tx(adapter);
<a name="l06954"></a>06954 }
<a name="l06955"></a>06955 
<a name="l06960"></a>06960 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_sfp_detection_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l06961"></a>06961 {
<a name="l06962"></a>06962     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l06963"></a>06963     s32 err;
<a name="l06964"></a>06964 
<a name="l06965"></a>06965     <span class="comment">/* not searching for SFP so there is nothing to do here */</span>
<a name="l06966"></a>06966     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SEARCH_FOR_SFP) &amp;&amp;
<a name="l06967"></a>06967         !(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SFP_NEEDS_RESET))
<a name="l06968"></a>06968         <span class="keywordflow">return</span>;
<a name="l06969"></a>06969 
<a name="l06970"></a>06970     <span class="comment">/* someone else is in init, wait until next service event */</span>
<a name="l06971"></a>06971     <span class="keywordflow">if</span> (test_and_set_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state))
<a name="l06972"></a>06972         <span class="keywordflow">return</span>;
<a name="l06973"></a>06973 
<a name="l06974"></a>06974     err = hw-&gt;phy.ops.identify_sfp(hw);
<a name="l06975"></a>06975     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_SUPPORTED) 
<a name="l06976"></a>06976         <span class="keywordflow">goto</span> sfp_out;
<a name="l06977"></a>06977 
<a name="l06978"></a>06978     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_PRESENT) {
<a name="l06979"></a>06979         <span class="comment">/* If no cable is present, then we need to reset</span>
<a name="l06980"></a>06980 <span class="comment">         * the next time we find a good cable. */</span>
<a name="l06981"></a>06981         adapter-&gt;flags2 |= IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l06982"></a>06982     }
<a name="l06983"></a>06983 
<a name="l06984"></a>06984     <span class="comment">/* exit on error */</span>
<a name="l06985"></a>06985     <span class="keywordflow">if</span> (err)
<a name="l06986"></a>06986         <span class="keywordflow">goto</span> sfp_out;
<a name="l06987"></a>06987 
<a name="l06988"></a>06988     <span class="comment">/* exit if reset not needed */</span>
<a name="l06989"></a>06989     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_SFP_NEEDS_RESET))
<a name="l06990"></a>06990         <span class="keywordflow">goto</span> sfp_out;
<a name="l06991"></a>06991 
<a name="l06992"></a>06992     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SFP_NEEDS_RESET;
<a name="l06993"></a>06993 
<a name="l06994"></a>06994     <span class="comment">/*</span>
<a name="l06995"></a>06995 <span class="comment">     * A module may be identified correctly, but the EEPROM may not have</span>
<a name="l06996"></a>06996 <span class="comment">     * support for that module.  setup_sfp() will fail in that case, so</span>
<a name="l06997"></a>06997 <span class="comment">     * we should not allow that module to load.</span>
<a name="l06998"></a>06998 <span class="comment">     */</span>
<a name="l06999"></a>06999     <span class="keywordflow">if</span> (hw-&gt;mac.type == ixgbe_mac_82598EB)
<a name="l07000"></a>07000         err = hw-&gt;phy.ops.reset(hw);
<a name="l07001"></a>07001     <span class="keywordflow">else</span>
<a name="l07002"></a>07002         err = hw-&gt;mac.ops.setup_sfp(hw);
<a name="l07003"></a>07003 
<a name="l07004"></a>07004     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_SUPPORTED)
<a name="l07005"></a>07005         <span class="keywordflow">goto</span> sfp_out;
<a name="l07006"></a>07006 
<a name="l07007"></a>07007     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l07008"></a>07008     DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;detected SFP+: %d\n&quot;</span>, hw-&gt;phy.sfp_type);
<a name="l07009"></a>07009 
<a name="l07010"></a>07010 sfp_out:
<a name="l07011"></a>07011     clear_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state);
<a name="l07012"></a>07012 
<a name="l07013"></a>07013     <span class="keywordflow">if</span> ((err == IXGBE_ERR_SFP_NOT_SUPPORTED) &amp;&amp;
<a name="l07014"></a>07014         adapter-&gt;netdev_registered) {
<a name="l07015"></a>07015         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;failed to initialize because an &quot;</span>
<a name="l07016"></a>07016             <span class="stringliteral">&quot;unsupported SFP+ module type was detected.\n&quot;</span>
<a name="l07017"></a>07017             <span class="stringliteral">&quot;Reload the driver after installing a &quot;</span>
<a name="l07018"></a>07018             <span class="stringliteral">&quot;supported module.\n&quot;</span>);
<a name="l07019"></a>07019         unregister_netdev(adapter-&gt;netdev);
<a name="l07020"></a>07020         adapter-&gt;netdev_registered = <span class="keyword">false</span>;
<a name="l07021"></a>07021     }
<a name="l07022"></a>07022 }
<a name="l07023"></a>07023 
<a name="l07028"></a>07028 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_sfp_link_config_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07029"></a>07029 {
<a name="l07030"></a>07030     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07031"></a>07031     u32 autoneg;
<a name="l07032"></a>07032     <span class="keywordtype">bool</span> negotiation;
<a name="l07033"></a>07033 
<a name="l07034"></a>07034     <span class="keywordflow">if</span> (!(adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_CONFIG))
<a name="l07035"></a>07035         <span class="keywordflow">return</span>;
<a name="l07036"></a>07036 
<a name="l07037"></a>07037     <span class="comment">/* someone else is in init, wait until next service event */</span>
<a name="l07038"></a>07038     <span class="keywordflow">if</span> (test_and_set_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state))
<a name="l07039"></a>07039         <span class="keywordflow">return</span>;
<a name="l07040"></a>07040 
<a name="l07041"></a>07041     adapter-&gt;flags &amp;= ~IXGBE_FLAG_NEED_LINK_CONFIG;
<a name="l07042"></a>07042 
<a name="l07043"></a>07043     autoneg = hw-&gt;phy.autoneg_advertised;
<a name="l07044"></a>07044     <span class="keywordflow">if</span> ((!autoneg) &amp;&amp; (hw-&gt;mac.ops.get_link_capabilities))
<a name="l07045"></a>07045         hw-&gt;mac.ops.get_link_capabilities(hw, &amp;autoneg, &amp;negotiation);
<a name="l07046"></a>07046     hw-&gt;mac.autotry_restart = <span class="keyword">false</span>;
<a name="l07047"></a>07047     <span class="keywordflow">if</span> (hw-&gt;mac.ops.setup_link)
<a name="l07048"></a>07048         hw-&gt;mac.ops.setup_link(hw, autoneg, negotiation, <span class="keyword">true</span>);
<a name="l07049"></a>07049 
<a name="l07050"></a>07050     adapter-&gt;flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
<a name="l07051"></a>07051     adapter-&gt;link_check_timeout = jiffies;
<a name="l07052"></a>07052     clear_bit(__IXGBE_IN_SFP_INIT, &amp;adapter-&gt;state);
<a name="l07053"></a>07053 }
<a name="l07054"></a>07054 
<a name="l07059"></a>07059 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_timer(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> data)
<a name="l07060"></a>07060 {
<a name="l07061"></a>07061     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = (<span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *)data;
<a name="l07062"></a>07062     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> next_event_offset;
<a name="l07063"></a>07063 
<a name="l07064"></a>07064     <span class="comment">/* poll faster when waiting for link */</span>
<a name="l07065"></a>07065     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_NEED_LINK_UPDATE)
<a name="l07066"></a>07066         next_event_offset = HZ / 10;
<a name="l07067"></a>07067     <span class="keywordflow">else</span>
<a name="l07068"></a>07068         next_event_offset = HZ * 2;
<a name="l07069"></a>07069 
<a name="l07070"></a>07070     <span class="comment">/* Reset the timer */</span>
<a name="l07071"></a>07071     mod_timer(&amp;adapter-&gt;service_timer, next_event_offset + jiffies);
<a name="l07072"></a>07072 
<a name="l07073"></a>07073     ixgbe_service_event_schedule(adapter);
<a name="l07074"></a>07074 }
<a name="l07075"></a>07075 
<a name="l07076"></a>07076 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_reset_subtask(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l07077"></a>07077 {
<a name="l07078"></a>07078     <span class="keywordflow">if</span> (!(adapter-&gt;flags2 &amp; IXGBE_FLAG2_RESET_REQUESTED))
<a name="l07079"></a>07079         <span class="keywordflow">return</span>;
<a name="l07080"></a>07080 
<a name="l07081"></a>07081     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RESET_REQUESTED;
<a name="l07082"></a>07082     
<a name="l07083"></a>07083     <span class="comment">/* If we&#39;re already down or resetting, just bail */</span>
<a name="l07084"></a>07084     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state) ||
<a name="l07085"></a>07085         test_bit(__IXGBE_RESETTING, &amp;adapter-&gt;state))
<a name="l07086"></a>07086         <span class="keywordflow">return</span>;
<a name="l07087"></a>07087 
<a name="l07088"></a>07088     adapter-&gt;tx_timeout_count++;
<a name="l07089"></a>07089 
<a name="l07090"></a>07090     ixgbe_reinit_locked(adapter);
<a name="l07091"></a>07091 }
<a name="l07092"></a>07092 
<a name="l07097"></a>07097 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_service_task(<span class="keyword">struct</span> work_struct *work)
<a name="l07098"></a>07098 {
<a name="l07099"></a>07099     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = container_of(work,
<a name="l07100"></a>07100                              <span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>,
<a name="l07101"></a>07101                              service_task);
<a name="l07102"></a>07102 
<a name="l07103"></a>07103     ixgbe_reset_subtask(adapter);
<a name="l07104"></a>07104     ixgbe_sfp_detection_subtask(adapter);
<a name="l07105"></a>07105     ixgbe_sfp_link_config_subtask(adapter);
<a name="l07106"></a>07106     ixgbe_check_overtemp_subtask(adapter);
<a name="l07107"></a>07107     ixgbe_watchdog_subtask(adapter);
<a name="l07108"></a>07108 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l07109"></a>07109 <span class="preprocessor"></span>    ixgbe_fdir_reinit_subtask(adapter);
<a name="l07110"></a>07110 <span class="preprocessor">#endif</span>
<a name="l07111"></a>07111 <span class="preprocessor"></span>    ixgbe_check_hang_subtask(adapter);
<a name="l07112"></a>07112 
<a name="l07113"></a>07113     ixgbe_service_event_complete(adapter);
<a name="l07114"></a>07114 }
<a name="l07115"></a>07115 
<a name="l07116"></a>07116 <span class="keywordtype">void</span> ixgbe_tx_ctxtdesc(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, u32 vlan_macip_lens,
<a name="l07117"></a>07117                u32 fcoe_sof_eof, u32 type_tucmd, u32 mss_l4len_idx)
<a name="l07118"></a>07118 {
<a name="l07119"></a>07119     <span class="keyword">struct </span><a class="code" href="structixgbe__adv__tx__context__desc.html">ixgbe_adv_tx_context_desc</a> *context_desc;
<a name="l07120"></a>07120     u16 i = tx_ring-&gt;next_to_use;
<a name="l07121"></a>07121 
<a name="l07122"></a>07122     context_desc = IXGBE_TX_CTXTDESC_ADV(tx_ring, i);
<a name="l07123"></a>07123 
<a name="l07124"></a>07124     i++;
<a name="l07125"></a>07125     <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l07126"></a>07126         tx_ring-&gt;next_to_use = 0;
<a name="l07127"></a>07127     <span class="keywordflow">else</span>
<a name="l07128"></a>07128         tx_ring-&gt;next_to_use = i;
<a name="l07129"></a>07129 
<a name="l07130"></a>07130     <span class="comment">/* set bits to identify this as an advanced context descriptor */</span>
<a name="l07131"></a>07131     type_tucmd |= IXGBE_TXD_CMD_DEXT | IXGBE_ADVTXD_DTYP_CTXT;
<a name="l07132"></a>07132 
<a name="l07133"></a>07133     context_desc-&gt;vlan_macip_lens   = cpu_to_le32(vlan_macip_lens);
<a name="l07134"></a>07134     context_desc-&gt;seqnum_seed   = cpu_to_le32(fcoe_sof_eof);
<a name="l07135"></a>07135     context_desc-&gt;type_tucmd_mlhl   = cpu_to_le32(type_tucmd);
<a name="l07136"></a>07136     context_desc-&gt;mss_l4len_idx = cpu_to_le32(mss_l4len_idx);
<a name="l07137"></a>07137 }
<a name="l07138"></a>07138 
<a name="l07139"></a>07139 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_tso(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, <span class="keyword">struct</span> sk_buff *skb,
<a name="l07140"></a>07140              u32 tx_flags, __be16 protocol, u8 *hdr_len)
<a name="l07141"></a>07141 {
<a name="l07142"></a>07142 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l07143"></a>07143 <span class="preprocessor"></span>    <span class="keywordtype">int</span> err;
<a name="l07144"></a>07144     u32 vlan_macip_lens, type_tucmd;
<a name="l07145"></a>07145     u32 mss_l4len_idx, l4len;
<a name="l07146"></a>07146 
<a name="l07147"></a>07147     <span class="keywordflow">if</span> (!skb_is_gso(skb))
<a name="l07148"></a>07148 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l07149"></a>07149         <span class="keywordflow">return</span> 0;
<a name="l07150"></a>07150 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l07151"></a>07151 <span class="preprocessor"></span>
<a name="l07152"></a>07152     <span class="keywordflow">if</span> (skb_header_cloned(skb)) {
<a name="l07153"></a>07153         err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
<a name="l07154"></a>07154         <span class="keywordflow">if</span> (err)
<a name="l07155"></a>07155             <span class="keywordflow">return</span> err;
<a name="l07156"></a>07156     }
<a name="l07157"></a>07157 
<a name="l07158"></a>07158     <span class="comment">/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */</span>
<a name="l07159"></a>07159     type_tucmd = IXGBE_ADVTXD_TUCMD_L4T_TCP;
<a name="l07160"></a>07160 
<a name="l07161"></a>07161     <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_IP)) {
<a name="l07162"></a>07162         <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = ip_hdr(skb);
<a name="l07163"></a>07163         iph-&gt;tot_len = 0;
<a name="l07164"></a>07164         iph-&gt;check = 0;
<a name="l07165"></a>07165         tcp_hdr(skb)-&gt;check = ~csum_tcpudp_magic(iph-&gt;saddr,
<a name="l07166"></a>07166                              iph-&gt;daddr, 0,
<a name="l07167"></a>07167                              IPPROTO_TCP,
<a name="l07168"></a>07168                              0);
<a name="l07169"></a>07169         type_tucmd |= IXGBE_ADVTXD_TUCMD_IPV4;
<a name="l07170"></a>07170 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l07171"></a>07171 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (skb_is_gso_v6(skb)) {
<a name="l07172"></a>07172         ipv6_hdr(skb)-&gt;payload_len = 0;
<a name="l07173"></a>07173         tcp_hdr(skb)-&gt;check =
<a name="l07174"></a>07174             ~csum_ipv6_magic(&amp;ipv6_hdr(skb)-&gt;saddr,
<a name="l07175"></a>07175                      &amp;ipv6_hdr(skb)-&gt;daddr,
<a name="l07176"></a>07176                      0, IPPROTO_TCP, 0);
<a name="l07177"></a>07177 <span class="preprocessor">#endif</span>
<a name="l07178"></a>07178 <span class="preprocessor"></span>    }
<a name="l07179"></a>07179 
<a name="l07180"></a>07180     l4len = tcp_hdrlen(skb);
<a name="l07181"></a>07181     *hdr_len = skb_transport_offset(skb) + l4len;
<a name="l07182"></a>07182 
<a name="l07183"></a>07183     <span class="comment">/* mss_l4len_id: use 1 as index for TSO */</span>
<a name="l07184"></a>07184     mss_l4len_idx = l4len &lt;&lt; IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07185"></a>07185     mss_l4len_idx |= skb_shinfo(skb)-&gt;gso_size &lt;&lt; IXGBE_ADVTXD_MSS_SHIFT;
<a name="l07186"></a>07186     mss_l4len_idx |= 1 &lt;&lt; IXGBE_ADVTXD_IDX_SHIFT;
<a name="l07187"></a>07187 
<a name="l07188"></a>07188     <span class="comment">/* vlan_macip_lens: HEADLEN, MACLEN, VLAN tag */</span>
<a name="l07189"></a>07189     vlan_macip_lens = skb_network_header_len(skb);
<a name="l07190"></a>07190     vlan_macip_lens |= skb_network_offset(skb) &lt;&lt; IXGBE_ADVTXD_MACLEN_SHIFT;
<a name="l07191"></a>07191     vlan_macip_lens |= tx_flags &amp; IXGBE_TX_FLAGS_VLAN_MASK;
<a name="l07192"></a>07192 
<a name="l07193"></a>07193     ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0, type_tucmd,
<a name="l07194"></a>07194                       mss_l4len_idx);
<a name="l07195"></a>07195 
<a name="l07196"></a>07196     <span class="keywordflow">return</span> 1;
<a name="l07197"></a>07197 <span class="preprocessor">#endif</span>
<a name="l07198"></a>07198 <span class="preprocessor"></span>}
<a name="l07199"></a>07199 
<a name="l07200"></a>07200 <span class="keyword">static</span> <span class="keywordtype">bool</span> ixgbe_tx_csum(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l07201"></a>07201               <span class="keyword">struct</span> sk_buff *skb, u32 tx_flags,
<a name="l07202"></a>07202               __be16 protocol)
<a name="l07203"></a>07203 {
<a name="l07204"></a>07204     u32 vlan_macip_lens = 0;
<a name="l07205"></a>07205     u32 mss_l4len_idx = 0;
<a name="l07206"></a>07206     u32 type_tucmd = 0;
<a name="l07207"></a>07207 
<a name="l07208"></a>07208     <span class="keywordflow">if</span> (skb-&gt;ip_summed != CHECKSUM_PARTIAL) {
<a name="l07209"></a>07209         <span class="keywordflow">if</span> (!(tx_flags &amp; IXGBE_TX_FLAGS_HW_VLAN) &amp;&amp;
<a name="l07210"></a>07210         !(tx_flags &amp; IXGBE_TX_FLAGS_TXSW))
<a name="l07211"></a>07211             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l07212"></a>07212     } <span class="keywordflow">else</span> {
<a name="l07213"></a>07213         u8 l4_hdr = 0;
<a name="l07214"></a>07214         <span class="keywordflow">switch</span> (protocol) {
<a name="l07215"></a>07215         <span class="keywordflow">case</span> __constant_htons(ETH_P_IP):
<a name="l07216"></a>07216             vlan_macip_lens |= skb_network_header_len(skb);
<a name="l07217"></a>07217             type_tucmd |= IXGBE_ADVTXD_TUCMD_IPV4;
<a name="l07218"></a>07218             l4_hdr = ip_hdr(skb)-&gt;protocol;
<a name="l07219"></a>07219             <span class="keywordflow">break</span>;
<a name="l07220"></a>07220 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l07221"></a>07221 <span class="preprocessor"></span>        <span class="keywordflow">case</span> __constant_htons(ETH_P_IPV6):
<a name="l07222"></a>07222             vlan_macip_lens |= skb_network_header_len(skb);
<a name="l07223"></a>07223             l4_hdr = ipv6_hdr(skb)-&gt;nexthdr;
<a name="l07224"></a>07224             <span class="keywordflow">break</span>;
<a name="l07225"></a>07225 <span class="preprocessor">#endif</span>
<a name="l07226"></a>07226 <span class="preprocessor"></span>        <span class="keywordflow">default</span>:
<a name="l07227"></a>07227             <span class="keywordflow">if</span> (unlikely(net_ratelimit())) {
<a name="l07228"></a>07228                 dev_warn(tx_ring-&gt;dev,
<a name="l07229"></a>07229                  <span class="stringliteral">&quot;partial checksum but proto=%x!\n&quot;</span>,
<a name="l07230"></a>07230                  skb-&gt;protocol);
<a name="l07231"></a>07231             }
<a name="l07232"></a>07232             <span class="keywordflow">break</span>;
<a name="l07233"></a>07233         }
<a name="l07234"></a>07234 
<a name="l07235"></a>07235         <span class="keywordflow">switch</span> (l4_hdr) {
<a name="l07236"></a>07236         <span class="keywordflow">case</span> IPPROTO_TCP:
<a name="l07237"></a>07237             type_tucmd |= IXGBE_ADVTXD_TUCMD_L4T_TCP;
<a name="l07238"></a>07238             mss_l4len_idx = tcp_hdrlen(skb) &lt;&lt;
<a name="l07239"></a>07239                     IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07240"></a>07240             <span class="keywordflow">break</span>;
<a name="l07241"></a>07241         <span class="keywordflow">case</span> IPPROTO_SCTP:
<a name="l07242"></a>07242             type_tucmd |= IXGBE_ADVTXD_TUCMD_L4T_SCTP;
<a name="l07243"></a>07243             mss_l4len_idx = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sctphdr) &lt;&lt;
<a name="l07244"></a>07244                     IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07245"></a>07245             <span class="keywordflow">break</span>;
<a name="l07246"></a>07246         <span class="keywordflow">case</span> IPPROTO_UDP:
<a name="l07247"></a>07247             mss_l4len_idx = <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structudphdr.html">udphdr</a>) &lt;&lt;
<a name="l07248"></a>07248                     IXGBE_ADVTXD_L4LEN_SHIFT;
<a name="l07249"></a>07249             <span class="keywordflow">break</span>;
<a name="l07250"></a>07250         <span class="keywordflow">default</span>:
<a name="l07251"></a>07251             <span class="keywordflow">if</span> (unlikely(net_ratelimit())) {
<a name="l07252"></a>07252                 dev_warn(tx_ring-&gt;dev,
<a name="l07253"></a>07253                  <span class="stringliteral">&quot;partial checksum but l4 proto=%x!\n&quot;</span>,
<a name="l07254"></a>07254                  skb-&gt;protocol);
<a name="l07255"></a>07255             }
<a name="l07256"></a>07256             <span class="keywordflow">break</span>;
<a name="l07257"></a>07257         }
<a name="l07258"></a>07258     }
<a name="l07259"></a>07259 
<a name="l07260"></a>07260     vlan_macip_lens |= skb_network_offset(skb) &lt;&lt; IXGBE_ADVTXD_MACLEN_SHIFT;
<a name="l07261"></a>07261     vlan_macip_lens |= tx_flags &amp; IXGBE_TX_FLAGS_VLAN_MASK;
<a name="l07262"></a>07262 
<a name="l07263"></a>07263     ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0,
<a name="l07264"></a>07264               type_tucmd, mss_l4len_idx);
<a name="l07265"></a>07265 
<a name="l07266"></a>07266     <span class="keywordflow">return</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL);
<a name="l07267"></a>07267 }
<a name="l07268"></a>07268 
<a name="l07269"></a>07269 <span class="keyword">static</span> __le32 ixgbe_tx_cmd_type(u32 tx_flags)
<a name="l07270"></a>07270 {
<a name="l07271"></a>07271     <span class="comment">/* set type for advanced descriptor with frame checksum insertion */</span>
<a name="l07272"></a>07272     __le32 cmd_type = cpu_to_le32(IXGBE_ADVTXD_DTYP_DATA |
<a name="l07273"></a>07273                       IXGBE_ADVTXD_DCMD_IFCS |
<a name="l07274"></a>07274                       IXGBE_ADVTXD_DCMD_DEXT);
<a name="l07275"></a>07275 
<a name="l07276"></a>07276     <span class="comment">/* set HW vlan bit if vlan is present */</span>
<a name="l07277"></a>07277     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_HW_VLAN)
<a name="l07278"></a>07278         cmd_type |= cpu_to_le32(IXGBE_ADVTXD_DCMD_VLE);
<a name="l07279"></a>07279 
<a name="l07280"></a>07280     <span class="comment">/* set segmentation enable bits for TSO/FSO */</span>
<a name="l07281"></a>07281 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07282"></a>07282 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((tx_flags &amp; IXGBE_TX_FLAGS_TSO) || (tx_flags &amp; IXGBE_TX_FLAGS_FSO))
<a name="l07283"></a>07283 <span class="preprocessor">#else</span>
<a name="l07284"></a>07284 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TSO)
<a name="l07285"></a>07285 <span class="preprocessor">#endif</span>
<a name="l07286"></a>07286 <span class="preprocessor"></span>        cmd_type |= cpu_to_le32(IXGBE_ADVTXD_DCMD_TSE);
<a name="l07287"></a>07287 
<a name="l07288"></a>07288     <span class="keywordflow">return</span> cmd_type;
<a name="l07289"></a>07289 }
<a name="l07290"></a>07290 
<a name="l07291"></a>07291 <span class="keyword">static</span> __le32 ixgbe_tx_olinfo_status(u32 tx_flags, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> paylen)
<a name="l07292"></a>07292 {
<a name="l07293"></a>07293     __le32 olinfo_status =
<a name="l07294"></a>07294         cpu_to_le32(paylen &lt;&lt; IXGBE_ADVTXD_PAYLEN_SHIFT);
<a name="l07295"></a>07295 
<a name="l07296"></a>07296     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TSO) {
<a name="l07297"></a>07297         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_POPTS_TXSM |
<a name="l07298"></a>07298                         (1 &lt;&lt; IXGBE_ADVTXD_IDX_SHIFT));
<a name="l07299"></a>07299         <span class="comment">/* enble IPv4 checksum for TSO */</span>
<a name="l07300"></a>07300         <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_IPV4)
<a name="l07301"></a>07301             olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_POPTS_IXSM);
<a name="l07302"></a>07302     }
<a name="l07303"></a>07303 
<a name="l07304"></a>07304     <span class="comment">/* enable L4 checksum for TSO and TX checksum offload */</span>
<a name="l07305"></a>07305     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_CSUM)
<a name="l07306"></a>07306         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_POPTS_TXSM);
<a name="l07307"></a>07307 
<a name="l07308"></a>07308 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07309"></a>07309 <span class="preprocessor"></span>    <span class="comment">/* use index 1 context for FCOE/FSO */</span>
<a name="l07310"></a>07310     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_FCOE)
<a name="l07311"></a>07311         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_CC |
<a name="l07312"></a>07312                         (1 &lt;&lt; IXGBE_ADVTXD_IDX_SHIFT));
<a name="l07313"></a>07313 
<a name="l07314"></a>07314 <span class="preprocessor">#endif</span>
<a name="l07315"></a>07315 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l07316"></a>07316 <span class="comment">     * Check Context must be set if Tx switch is enabled, which it</span>
<a name="l07317"></a>07317 <span class="comment">     * always is for case where virtual functions are running</span>
<a name="l07318"></a>07318 <span class="comment">     */</span>
<a name="l07319"></a>07319     <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TXSW)
<a name="l07320"></a>07320         olinfo_status |= cpu_to_le32(IXGBE_ADVTXD_CC);
<a name="l07321"></a>07321 
<a name="l07322"></a>07322     <span class="keywordflow">return</span> olinfo_status;
<a name="l07323"></a>07323 }
<a name="l07324"></a>07324 
<a name="l07325"></a>07325 <span class="preprocessor">#define IXGBE_TXD_CMD (IXGBE_TXD_CMD_EOP | \</span>
<a name="l07326"></a>07326 <span class="preprocessor">               IXGBE_TXD_CMD_RS)</span>
<a name="l07327"></a>07327 <span class="preprocessor"></span>
<a name="l07328"></a>07328 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_tx_map(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring,
<a name="l07329"></a>07329              <span class="keyword">struct</span> sk_buff *skb,
<a name="l07330"></a>07330              <span class="keyword">struct</span> <a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *first,
<a name="l07331"></a>07331              u32 tx_flags,
<a name="l07332"></a>07332              <span class="keyword">const</span> u8 hdr_len)
<a name="l07333"></a>07333 {
<a name="l07334"></a>07334     <span class="keyword">struct </span><a class="code" href="structdevice.html">device</a> *dev = tx_ring-&gt;dev;
<a name="l07335"></a>07335     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *tx_buffer_info;
<a name="l07336"></a>07336     <span class="keyword">union </span><a class="code" href="unionixgbe__adv__tx__desc.html">ixgbe_adv_tx_desc</a> *tx_desc;
<a name="l07337"></a>07337     dma_addr_t dma;
<a name="l07338"></a>07338     __le32 cmd_type, olinfo_status;
<a name="l07339"></a>07339 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07340"></a>07340 <span class="preprocessor"></span>    <span class="keyword">struct </span>skb_frag_struct *frag;
<a name="l07341"></a>07341     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0;
<a name="l07342"></a>07342     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> data_len = skb-&gt;data_len;
<a name="l07343"></a>07343 <span class="preprocessor">#endif</span>
<a name="l07344"></a>07344 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = skb_headlen(skb);
<a name="l07345"></a>07345     u32 offset = 0;
<a name="l07346"></a>07346     u32 paylen = skb-&gt;len - hdr_len;
<a name="l07347"></a>07347     u16 i = tx_ring-&gt;next_to_use;
<a name="l07348"></a>07348     u16 gso_segs;
<a name="l07349"></a>07349 
<a name="l07350"></a>07350 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07351"></a>07351 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_FCOE) {
<a name="l07352"></a>07352         <span class="keywordflow">if</span> (data_len &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fcoe_crc_eof)) {
<a name="l07353"></a>07353             data_len -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fcoe_crc_eof);
<a name="l07354"></a>07354         } <span class="keywordflow">else</span> {
<a name="l07355"></a>07355             size -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fcoe_crc_eof) - data_len;
<a name="l07356"></a>07356             data_len = 0;
<a name="l07357"></a>07357         }
<a name="l07358"></a>07358     }
<a name="l07359"></a>07359 
<a name="l07360"></a>07360 <span class="preprocessor">#endif</span>
<a name="l07361"></a>07361 <span class="preprocessor"></span>    dma = dma_map_single(dev, skb-&gt;data, size, DMA_TO_DEVICE);
<a name="l07362"></a>07362     <span class="keywordflow">if</span> (dma_mapping_error(dev, dma))
<a name="l07363"></a>07363         <span class="keywordflow">goto</span> dma_error;
<a name="l07364"></a>07364 
<a name="l07365"></a>07365     cmd_type = ixgbe_tx_cmd_type(tx_flags);
<a name="l07366"></a>07366     olinfo_status = ixgbe_tx_olinfo_status(tx_flags, paylen);
<a name="l07367"></a>07367 
<a name="l07368"></a>07368     tx_desc = IXGBE_TX_DESC_ADV(tx_ring, i);
<a name="l07369"></a>07369  
<a name="l07370"></a>07370 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07371"></a>07371 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (;;) {
<a name="l07372"></a>07372 <span class="preprocessor">#endif</span>
<a name="l07373"></a>07373 <span class="preprocessor"></span>        <span class="keywordflow">while</span> (size &gt; IXGBE_MAX_DATA_PER_TXD) {
<a name="l07374"></a>07374             tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma + offset);
<a name="l07375"></a>07375             tx_desc-&gt;read.cmd_type_len =
<a name="l07376"></a>07376                 cmd_type | cpu_to_le32(IXGBE_MAX_DATA_PER_TXD);
<a name="l07377"></a>07377             tx_desc-&gt;read.olinfo_status = olinfo_status;
<a name="l07378"></a>07378 
<a name="l07379"></a>07379             offset += IXGBE_MAX_DATA_PER_TXD;
<a name="l07380"></a>07380             size -= IXGBE_MAX_DATA_PER_TXD;
<a name="l07381"></a>07381 
<a name="l07382"></a>07382             tx_desc++;
<a name="l07383"></a>07383             i++;
<a name="l07384"></a>07384             <span class="keywordflow">if</span> (i == tx_ring-&gt;count) {
<a name="l07385"></a>07385                 tx_desc = IXGBE_TX_DESC_ADV(tx_ring, 0);
<a name="l07386"></a>07386                 i = 0;
<a name="l07387"></a>07387             }
<a name="l07388"></a>07388         }
<a name="l07389"></a>07389 
<a name="l07390"></a>07390         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l07391"></a>07391         tx_buffer_info-&gt;length = offset + size;
<a name="l07392"></a>07392         tx_buffer_info-&gt;tx_flags = tx_flags;
<a name="l07393"></a>07393         tx_buffer_info-&gt;dma = dma;
<a name="l07394"></a>07394 
<a name="l07395"></a>07395         tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma + offset);
<a name="l07396"></a>07396         tx_desc-&gt;read.cmd_type_len = cmd_type | cpu_to_le32(size);
<a name="l07397"></a>07397         tx_desc-&gt;read.olinfo_status = olinfo_status;
<a name="l07398"></a>07398 
<a name="l07399"></a>07399 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07400"></a>07400 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!data_len)
<a name="l07401"></a>07401             <span class="keywordflow">break</span>;
<a name="l07402"></a>07402 
<a name="l07403"></a>07403         frag = &amp;skb_shinfo(skb)-&gt;frags[f];
<a name="l07404"></a>07404 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07405"></a>07405 <span class="preprocessor"></span>        size = min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, data_len, frag-&gt;size);
<a name="l07406"></a>07406 <span class="preprocessor">#else</span>
<a name="l07407"></a>07407 <span class="preprocessor"></span>        size = frag-&gt;size;
<a name="l07408"></a>07408 <span class="preprocessor">#endif</span>
<a name="l07409"></a>07409 <span class="preprocessor"></span>        data_len -= size;
<a name="l07410"></a>07410         f++;
<a name="l07411"></a>07411 
<a name="l07412"></a>07412         offset = 0;
<a name="l07413"></a>07413         tx_flags |= IXGBE_TX_FLAGS_MAPPED_AS_PAGE;
<a name="l07414"></a>07414 
<a name="l07415"></a>07415         dma = dma_map_page(dev, frag-&gt;page, frag-&gt;page_offset,
<a name="l07416"></a>07416                    size, DMA_TO_DEVICE);
<a name="l07417"></a>07417         <span class="keywordflow">if</span> (dma_mapping_error(dev, dma))
<a name="l07418"></a>07418             <span class="keywordflow">goto</span> dma_error;
<a name="l07419"></a>07419 
<a name="l07420"></a>07420         tx_desc++;
<a name="l07421"></a>07421         i++;
<a name="l07422"></a>07422         <span class="keywordflow">if</span> (i == tx_ring-&gt;count) {
<a name="l07423"></a>07423             tx_desc = IXGBE_TX_DESC_ADV(tx_ring, 0);
<a name="l07424"></a>07424             i = 0;
<a name="l07425"></a>07425         }
<a name="l07426"></a>07426     }
<a name="l07427"></a>07427 
<a name="l07428"></a>07428 <span class="preprocessor">#endif </span><span class="comment">/* MAX_SKB_FRAGS */</span>
<a name="l07429"></a>07429     tx_desc-&gt;read.cmd_type_len |= cpu_to_le32(IXGBE_TXD_CMD);
<a name="l07430"></a>07430 
<a name="l07431"></a>07431     i++;
<a name="l07432"></a>07432     <span class="keywordflow">if</span> (i == tx_ring-&gt;count)
<a name="l07433"></a>07433         i = 0;
<a name="l07434"></a>07434 
<a name="l07435"></a>07435     tx_ring-&gt;next_to_use = i;
<a name="l07436"></a>07436 
<a name="l07437"></a>07437 <span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l07438"></a>07438 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_TSO)
<a name="l07439"></a>07439         gso_segs = skb_shinfo(skb)-&gt;gso_segs;
<a name="l07440"></a>07440 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07441"></a>07441 <span class="preprocessor"></span>    <span class="comment">/* adjust for FCoE Sequence Offload */</span>
<a name="l07442"></a>07442     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_FSO)
<a name="l07443"></a>07443         gso_segs = DIV_ROUND_UP(skb-&gt;len - hdr_len,
<a name="l07444"></a>07444                     skb_shinfo(skb)-&gt;gso_size);
<a name="l07445"></a>07445 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07446"></a>07446     <span class="keywordflow">else</span>
<a name="l07447"></a>07447 <span class="preprocessor">#endif</span>
<a name="l07448"></a>07448 <span class="preprocessor"></span>        gso_segs = 1;
<a name="l07449"></a>07449 
<a name="l07450"></a>07450     <span class="comment">/* multiply data chunks by size of headers */</span>
<a name="l07451"></a>07451     tx_buffer_info-&gt;bytecount = paylen + (gso_segs * hdr_len);
<a name="l07452"></a>07452     tx_buffer_info-&gt;gso_segs = gso_segs;
<a name="l07453"></a>07453     tx_buffer_info-&gt;skb = skb;
<a name="l07454"></a>07454 
<a name="l07455"></a>07455     <span class="comment">/* set the timestamp and next to watch values */</span>
<a name="l07456"></a>07456     first-&gt;time_stamp = jiffies;
<a name="l07457"></a>07457     first-&gt;next_to_watch = tx_desc;
<a name="l07458"></a>07458 
<a name="l07459"></a>07459     <span class="comment">/*</span>
<a name="l07460"></a>07460 <span class="comment">     * Force memory writes to complete before letting h/w</span>
<a name="l07461"></a>07461 <span class="comment">     * know there are new descriptors to fetch.  (Only</span>
<a name="l07462"></a>07462 <span class="comment">     * applicable for weak-ordered memory model archs,</span>
<a name="l07463"></a>07463 <span class="comment">     * such as IA-64).</span>
<a name="l07464"></a>07464 <span class="comment">     */</span>
<a name="l07465"></a>07465     wmb();
<a name="l07466"></a>07466 
<a name="l07467"></a>07467     writel(i, tx_ring-&gt;tail);
<a name="l07468"></a>07468 
<a name="l07469"></a>07469     <span class="keywordflow">return</span>;
<a name="l07470"></a>07470 dma_error:
<a name="l07471"></a>07471     dev_err(dev, <span class="stringliteral">&quot;TX DMA map failed\n&quot;</span>);
<a name="l07472"></a>07472 
<a name="l07473"></a>07473     <span class="comment">/* clear dma mappings for failed tx_buffer_info map */</span>
<a name="l07474"></a>07474     <span class="keywordflow">for</span> (;;) {
<a name="l07475"></a>07475         tx_buffer_info = &amp;tx_ring-&gt;tx_buffer_info[i];
<a name="l07476"></a>07476         ixgbe_unmap_tx_resource(tx_ring, tx_buffer_info);
<a name="l07477"></a>07477         <span class="keywordflow">if</span> (tx_buffer_info == first)
<a name="l07478"></a>07478             <span class="keywordflow">break</span>;
<a name="l07479"></a>07479         <span class="keywordflow">if</span> (i == 0)
<a name="l07480"></a>07480             i = tx_ring-&gt;count;
<a name="l07481"></a>07481         i--;
<a name="l07482"></a>07482     }
<a name="l07483"></a>07483 
<a name="l07484"></a>07484     dev_kfree_skb_any(skb);
<a name="l07485"></a>07485 
<a name="l07486"></a>07486     tx_ring-&gt;next_to_use = i;
<a name="l07487"></a>07487 }
<a name="l07488"></a>07488 
<a name="l07489"></a>07489 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_atr(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *ring, <span class="keyword">struct</span> sk_buff *skb,
<a name="l07490"></a>07490               u32 tx_flags, __be16 protocol)
<a name="l07491"></a>07491 {
<a name="l07492"></a>07492     <span class="keyword">union </span><a class="code" href="unionixgbe__atr__input.html">ixgbe_atr_input</a> atr_input;
<a name="l07493"></a>07493     <span class="keyword">struct </span><a class="code" href="structiphdr.html">iphdr</a> *iph = ip_hdr(skb);
<a name="l07494"></a>07494     <span class="keyword">struct </span>ipv6hdr *ipv6h = ipv6_hdr(skb);
<a name="l07495"></a>07495     <span class="keyword">struct </span><a class="code" href="structtcphdr.html">tcphdr</a> *th;
<a name="l07496"></a>07496     __be16 vlan_id;
<a name="l07497"></a>07497 
<a name="l07498"></a>07498     <span class="comment">/* do nothing if sampling is disabled */</span>
<a name="l07499"></a>07499     <span class="keywordflow">if</span> (!ring-&gt;atr_sample_rate)
<a name="l07500"></a>07500         <span class="keywordflow">return</span>;
<a name="l07501"></a>07501 
<a name="l07502"></a>07502     ring-&gt;atr_count++;
<a name="l07503"></a>07503 
<a name="l07504"></a>07504     <span class="comment">/* Currently only IPv4/IPv6 with TCP is supported */</span>
<a name="l07505"></a>07505     <span class="keywordflow">if</span> ((protocol != __constant_htons(ETH_P_IPV6) ||
<a name="l07506"></a>07506          ipv6h-&gt;nexthdr != IPPROTO_TCP) &amp;&amp;
<a name="l07507"></a>07507         (protocol != __constant_htons(ETH_P_IP) ||
<a name="l07508"></a>07508          iph-&gt;protocol != IPPROTO_TCP))
<a name="l07509"></a>07509         <span class="keywordflow">return</span>;
<a name="l07510"></a>07510 
<a name="l07511"></a>07511     th = tcp_hdr(skb);
<a name="l07512"></a>07512 
<a name="l07513"></a>07513     <span class="comment">/* skip this packet since the socket is closing */</span>
<a name="l07514"></a>07514     <span class="keywordflow">if</span> (th-&gt;fin)
<a name="l07515"></a>07515         <span class="keywordflow">return</span>;
<a name="l07516"></a>07516 
<a name="l07517"></a>07517     <span class="comment">/* sample on all syn packets or once every atr sample count */</span>
<a name="l07518"></a>07518     <span class="keywordflow">if</span> (!th-&gt;syn &amp;&amp; (ring-&gt;atr_count &lt; ring-&gt;atr_sample_rate))
<a name="l07519"></a>07519         <span class="keywordflow">return</span>;
<a name="l07520"></a>07520 
<a name="l07521"></a>07521     <span class="comment">/* reset sample count */</span>
<a name="l07522"></a>07522     ring-&gt;atr_count = 0;
<a name="l07523"></a>07523 
<a name="l07524"></a>07524     vlan_id = htons(tx_flags &gt;&gt; IXGBE_TX_FLAGS_VLAN_SHIFT);
<a name="l07525"></a>07525 
<a name="l07526"></a>07526     atr_input.formatted.rsvd0 = 0;
<a name="l07527"></a>07527     atr_input.formatted.vlan_id = vlan_id;
<a name="l07528"></a>07528 
<a name="l07529"></a>07529     <span class="comment">/* src and dst are inverted, think how the receiver sees them */</span>
<a name="l07530"></a>07530     <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_IP)) {
<a name="l07531"></a>07531         atr_input.formatted.dst_ip[0] = iph-&gt;saddr;
<a name="l07532"></a>07532         atr_input.formatted.dst_ip[1] = 0;
<a name="l07533"></a>07533         atr_input.formatted.dst_ip[2] = 0;
<a name="l07534"></a>07534         atr_input.formatted.dst_ip[3] = 0;
<a name="l07535"></a>07535         atr_input.formatted.src_ip[0] = iph-&gt;daddr;
<a name="l07536"></a>07536         atr_input.formatted.src_ip[1] = 0;
<a name="l07537"></a>07537         atr_input.formatted.src_ip[2] = 0;
<a name="l07538"></a>07538         atr_input.formatted.src_ip[3] = 0;
<a name="l07539"></a>07539         atr_input.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;
<a name="l07540"></a>07540     } <span class="keywordflow">else</span> {
<a name="l07541"></a>07541         atr_input.formatted.dst_ip[0] = ipv6h-&gt;saddr.s6_addr32[0];
<a name="l07542"></a>07542         atr_input.formatted.dst_ip[1] = ipv6h-&gt;saddr.s6_addr32[1];
<a name="l07543"></a>07543         atr_input.formatted.dst_ip[2] = ipv6h-&gt;saddr.s6_addr32[2];
<a name="l07544"></a>07544         atr_input.formatted.dst_ip[3] = ipv6h-&gt;saddr.s6_addr32[3];
<a name="l07545"></a>07545         atr_input.formatted.src_ip[0] = ipv6h-&gt;daddr.s6_addr32[0];
<a name="l07546"></a>07546         atr_input.formatted.src_ip[1] = ipv6h-&gt;daddr.s6_addr32[1];
<a name="l07547"></a>07547         atr_input.formatted.src_ip[2] = ipv6h-&gt;daddr.s6_addr32[2];
<a name="l07548"></a>07548         atr_input.formatted.src_ip[3] = ipv6h-&gt;daddr.s6_addr32[3];
<a name="l07549"></a>07549         atr_input.formatted.flow_type = IXGBE_ATR_FLOW_TYPE_TCPV6;
<a name="l07550"></a>07550     }
<a name="l07551"></a>07551 
<a name="l07552"></a>07552     atr_input.formatted.dst_port = th-&gt;source;
<a name="l07553"></a>07553     atr_input.formatted.src_port = th-&gt;dest;
<a name="l07554"></a>07554 
<a name="l07555"></a>07555     <span class="keywordflow">if</span> (vlan_id)
<a name="l07556"></a>07556         atr_input.formatted.flex_bytes = __constant_htons(ETH_P_8021Q);
<a name="l07557"></a>07557     <span class="keywordflow">else</span>
<a name="l07558"></a>07558         atr_input.formatted.flex_bytes =  protocol;
<a name="l07559"></a>07559     atr_input.formatted.vm_pool = 0;
<a name="l07560"></a>07560 
<a name="l07561"></a>07561     <span class="comment">/* This assumes the Rx queue and Tx queue are bound to the same CPU */</span>
<a name="l07562"></a>07562     ixgbe_fdir_add_signature_filter_82599(&amp;ring-&gt;q_vector-&gt;adapter-&gt;hw,
<a name="l07563"></a>07563                           &amp;atr_input, ring-&gt;queue_index);
<a name="l07564"></a>07564 }
<a name="l07565"></a>07565 
<a name="l07566"></a>07566 <span class="keyword">static</span> <span class="keywordtype">int</span> __ixgbe_maybe_stop_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, <span class="keywordtype">int</span> size)
<a name="l07567"></a>07567 {
<a name="l07568"></a>07568     netif_stop_subqueue(tx_ring-&gt;netdev, tx_ring-&gt;queue_index);
<a name="l07569"></a>07569     <span class="comment">/* Herbert&#39;s original patch had:</span>
<a name="l07570"></a>07570 <span class="comment">     *  smp_mb__after_netif_stop_queue();</span>
<a name="l07571"></a>07571 <span class="comment">     * but since that doesn&#39;t exist yet, just open code it. */</span>
<a name="l07572"></a>07572     smp_mb();
<a name="l07573"></a>07573 
<a name="l07574"></a>07574     <span class="comment">/* We need to check again in a case another CPU has just</span>
<a name="l07575"></a>07575 <span class="comment">     * made room available. */</span>
<a name="l07576"></a>07576     <span class="keywordflow">if</span> (likely(IXGBE_DESC_UNUSED(tx_ring) &lt; size))
<a name="l07577"></a>07577         <span class="keywordflow">return</span> -EBUSY;
<a name="l07578"></a>07578 
<a name="l07579"></a>07579     <span class="comment">/* A reprieve! - use start_queue because it doesn&#39;t call schedule */</span>
<a name="l07580"></a>07580     netif_start_subqueue(tx_ring-&gt;netdev, tx_ring-&gt;queue_index);
<a name="l07581"></a>07581     ++tx_ring-&gt;tx_stats.restart_queue;
<a name="l07582"></a>07582     <span class="keywordflow">return</span> 0;
<a name="l07583"></a>07583 }
<a name="l07584"></a>07584 
<a name="l07585"></a>07585 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> ixgbe_maybe_stop_tx(<span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring, <span class="keywordtype">int</span> size)
<a name="l07586"></a>07586 {
<a name="l07587"></a>07587     <span class="keywordflow">if</span> (likely(IXGBE_DESC_UNUSED(tx_ring) &gt;= size))
<a name="l07588"></a>07588         <span class="keywordflow">return</span> 0;
<a name="l07589"></a>07589     <span class="keywordflow">return</span> __ixgbe_maybe_stop_tx(tx_ring, size);
<a name="l07590"></a>07590 }
<a name="l07591"></a>07591 
<a name="l07592"></a>07592 netdev_tx_t ixgbe_xmit_frame_ring(<span class="keyword">struct</span> sk_buff *skb,
<a name="l07593"></a>07593               <span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter,
<a name="l07594"></a>07594               <span class="keyword">struct</span> <a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring)
<a name="l07595"></a>07595 {
<a name="l07596"></a>07596     <span class="keyword">struct </span><a class="code" href="structixgbe__tx__buffer.html">ixgbe_tx_buffer</a> *first;
<a name="l07597"></a>07597     <span class="keywordtype">int</span> tso, count = 0;
<a name="l07598"></a>07598 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07599"></a>07599 <span class="preprocessor"></span><span class="preprocessor">#if PAGE_SIZE &gt; IXGBE_MAX_DATA_PER_TXD</span>
<a name="l07600"></a>07600 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f;
<a name="l07601"></a>07601 <span class="preprocessor">#endif</span>
<a name="l07602"></a>07602 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l07603"></a>07603 <span class="preprocessor"></span>    u32 tx_flags = 0;
<a name="l07604"></a>07604     __be16 protocol;
<a name="l07605"></a>07605     u8 hdr_len = 0;
<a name="l07606"></a>07606 
<a name="l07607"></a>07607     <span class="comment">/*</span>
<a name="l07608"></a>07608 <span class="comment">     * need: 1 descriptor per page * PAGE_SIZE/IXGBE_MAX_DATA_PER_TXD,</span>
<a name="l07609"></a>07609 <span class="comment">     *       + 1 desc for skb_head_len/IXGBE_MAX_DATA_PER_TXD,</span>
<a name="l07610"></a>07610 <span class="comment">     *       + 2 desc gap to keep tail from touching head,</span>
<a name="l07611"></a>07611 <span class="comment">     *       + 1 desc for context descriptor,</span>
<a name="l07612"></a>07612 <span class="comment">     * otherwise try next time</span>
<a name="l07613"></a>07613 <span class="comment">     */</span>
<a name="l07614"></a>07614 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l07615"></a>07615 <span class="preprocessor"></span><span class="preprocessor">#if PAGE_SIZE &gt; IXGBE_MAX_DATA_PER_TXD</span>
<a name="l07616"></a>07616 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (f = 0; f &lt; skb_shinfo(skb)-&gt;nr_frags; f++)
<a name="l07617"></a>07617         count += TXD_USE_COUNT(skb_shinfo(skb)-&gt;frags[f].size);
<a name="l07618"></a>07618 <span class="preprocessor">#else</span>
<a name="l07619"></a>07619 <span class="preprocessor"></span>    count += skb_shinfo(skb)-&gt;nr_frags;
<a name="l07620"></a>07620 <span class="preprocessor">#endif</span>
<a name="l07621"></a>07621 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l07622"></a>07622 <span class="preprocessor"></span>    count += TXD_USE_COUNT(skb_headlen(skb));
<a name="l07623"></a>07623     <span class="keywordflow">if</span> (ixgbe_maybe_stop_tx(tx_ring, count + 3)) {
<a name="l07624"></a>07624         tx_ring-&gt;tx_stats.tx_busy++;
<a name="l07625"></a>07625         <span class="keywordflow">return</span> NETDEV_TX_BUSY;
<a name="l07626"></a>07626     }
<a name="l07627"></a>07627 
<a name="l07628"></a>07628 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l07629"></a>07629 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l07630"></a>07630 <span class="comment">     * Use the l2switch_enable flag - would be false if the DMA</span>
<a name="l07631"></a>07631 <span class="comment">     * Tx switch had been disabled.</span>
<a name="l07632"></a>07632 <span class="comment">     */</span>
<a name="l07633"></a>07633     <span class="keywordflow">if</span> (adapter-&gt;l2switch_enable)
<a name="l07634"></a>07634         tx_flags |= IXGBE_TX_FLAGS_TXSW;
<a name="l07635"></a>07635 
<a name="l07636"></a>07636 <span class="preprocessor">#endif</span>
<a name="l07637"></a>07637 <span class="preprocessor"></span>    <span class="comment">/* obtain protocol of skb */</span>
<a name="l07638"></a>07638     protocol = skb-&gt;protocol;
<a name="l07639"></a>07639 
<a name="l07640"></a>07640     <span class="comment">/* if we have a HW VLAN tag being added default to the HW one */</span>
<a name="l07641"></a>07641     <span class="keywordflow">if</span> (vlan_tx_tag_present(skb)) {
<a name="l07642"></a>07642         tx_flags |= vlan_tx_tag_get(skb) &lt;&lt; IXGBE_TX_FLAGS_VLAN_SHIFT;
<a name="l07643"></a>07643         tx_flags |= IXGBE_TX_FLAGS_HW_VLAN;
<a name="l07644"></a>07644     <span class="comment">/* else if it is a SW VLAN check the next protocol and store the tag */</span>
<a name="l07645"></a>07645     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_8021Q)) {
<a name="l07646"></a>07646         <span class="keyword">struct </span>vlan_hdr *vhdr, _vhdr;
<a name="l07647"></a>07647         vhdr = skb_header_pointer(skb, ETH_HLEN, <span class="keyword">sizeof</span>(_vhdr), &amp;_vhdr);
<a name="l07648"></a>07648         <span class="keywordflow">if</span> (!vhdr)
<a name="l07649"></a>07649             <span class="keywordflow">goto</span> out_drop;
<a name="l07650"></a>07650 
<a name="l07651"></a>07651         protocol = vhdr-&gt;h_vlan_encapsulated_proto;
<a name="l07652"></a>07652         tx_flags |= ntohs(vhdr-&gt;h_vlan_TCI) &lt;&lt; IXGBE_TX_FLAGS_VLAN_SHIFT;
<a name="l07653"></a>07653         tx_flags |= IXGBE_TX_FLAGS_SW_VLAN;
<a name="l07654"></a>07654     }
<a name="l07655"></a>07655 
<a name="l07656"></a>07656 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l07657"></a>07657 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) &amp;&amp;
<a name="l07658"></a>07658         skb-&gt;priority != TC_PRIO_CONTROL) {
<a name="l07659"></a>07659         tx_flags &amp;= ~IXGBE_TX_FLAGS_VLAN_PRIO_MASK;
<a name="l07660"></a>07660 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07661"></a>07661 <span class="preprocessor"></span>        <span class="comment">/* for FCoE with DCB, we force the priority to what</span>
<a name="l07662"></a>07662 <span class="comment">         * was specified by the switch */</span>
<a name="l07663"></a>07663         <span class="keywordflow">if</span> ((adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) &amp;&amp;
<a name="l07664"></a>07664             ((protocol == __constant_htons(ETH_P_FCOE)) ||
<a name="l07665"></a>07665              (protocol == __constant_htons(ETH_P_FIP))))
<a name="l07666"></a>07666             tx_flags |= adapter-&gt;fcoe.up &lt;&lt; 
<a name="l07667"></a>07667                         IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT;
<a name="l07668"></a>07668         <span class="keywordflow">else</span>
<a name="l07669"></a>07669 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07670"></a>07670             tx_flags |= skb-&gt;queue_mapping &lt;&lt;
<a name="l07671"></a>07671                     IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT;
<a name="l07672"></a>07672         <span class="keywordflow">if</span> (tx_flags &amp; IXGBE_TX_FLAGS_SW_VLAN) {
<a name="l07673"></a>07673             <span class="keyword">struct </span>vlan_ethhdr *vhdr;
<a name="l07674"></a>07674             <span class="keywordflow">if</span> (skb_header_cloned(skb) &amp;&amp;
<a name="l07675"></a>07675                 pskb_expand_head(skb, 0, 0, GFP_ATOMIC))
<a name="l07676"></a>07676                 <span class="keywordflow">goto</span> out_drop;
<a name="l07677"></a>07677             vhdr = (<span class="keyword">struct </span>vlan_ethhdr *)skb-&gt;data;
<a name="l07678"></a>07678             vhdr-&gt;h_vlan_TCI = htons(tx_flags &gt;&gt;
<a name="l07679"></a>07679                          IXGBE_TX_FLAGS_VLAN_SHIFT);
<a name="l07680"></a>07680         } <span class="keywordflow">else</span> {
<a name="l07681"></a>07681             tx_flags |= IXGBE_TX_FLAGS_HW_VLAN;
<a name="l07682"></a>07682         }
<a name="l07683"></a>07683     }
<a name="l07684"></a>07684 
<a name="l07685"></a>07685 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_TX_MQ */</span>
<a name="l07686"></a>07686     <span class="comment">/* record the location of the first descriptor for this packet */</span>
<a name="l07687"></a>07687     first = &amp;tx_ring-&gt;tx_buffer_info[tx_ring-&gt;next_to_use];
<a name="l07688"></a>07688 
<a name="l07689"></a>07689 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07690"></a>07690 <span class="preprocessor"></span>    <span class="comment">/* setup tx offload for FCoE */</span>
<a name="l07691"></a>07691     <span class="keywordflow">if</span> ((protocol == __constant_htons(ETH_P_FCOE)) &amp;&amp;
<a name="l07692"></a>07692         (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED)) {
<a name="l07693"></a>07693         tso = ixgbe_fso(tx_ring, skb, tx_flags, &amp;hdr_len);
<a name="l07694"></a>07694         <span class="keywordflow">if</span> (tso &lt; 0)
<a name="l07695"></a>07695             <span class="keywordflow">goto</span> out_drop;
<a name="l07696"></a>07696         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tso)
<a name="l07697"></a>07697             tx_flags |= IXGBE_TX_FLAGS_FSO |
<a name="l07698"></a>07698                     IXGBE_TX_FLAGS_FCOE;
<a name="l07699"></a>07699         <span class="keywordflow">else</span>
<a name="l07700"></a>07700             tx_flags |= IXGBE_TX_FLAGS_FCOE;
<a name="l07701"></a>07701 
<a name="l07702"></a>07702         <span class="keywordflow">goto</span> xmit_fcoe;
<a name="l07703"></a>07703     }
<a name="l07704"></a>07704 
<a name="l07705"></a>07705 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07706"></a>07706     <span class="comment">/* setup IPv4/IPv6 offloads */</span>
<a name="l07707"></a>07707     <span class="keywordflow">if</span> (protocol == __constant_htons(ETH_P_IP))
<a name="l07708"></a>07708         tx_flags |= IXGBE_TX_FLAGS_IPV4;
<a name="l07709"></a>07709 
<a name="l07710"></a>07710     tso = ixgbe_tso(tx_ring, skb, tx_flags, protocol, &amp;hdr_len);
<a name="l07711"></a>07711     <span class="keywordflow">if</span> (tso &lt; 0)
<a name="l07712"></a>07712         <span class="keywordflow">goto</span> out_drop;
<a name="l07713"></a>07713     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tso)
<a name="l07714"></a>07714         tx_flags |= IXGBE_TX_FLAGS_TSO;
<a name="l07715"></a>07715     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ixgbe_tx_csum(tx_ring, skb, tx_flags, protocol))
<a name="l07716"></a>07716         tx_flags |= IXGBE_TX_FLAGS_CSUM;
<a name="l07717"></a>07717 
<a name="l07718"></a>07718     <span class="comment">/* add the ATR filter if ATR is on */</span>
<a name="l07719"></a>07719     <span class="keywordflow">if</span> (test_bit(__IXGBE_TX_FDIR_INIT_DONE, &amp;tx_ring-&gt;state))
<a name="l07720"></a>07720         ixgbe_atr(tx_ring, skb, tx_flags, protocol);
<a name="l07721"></a>07721 
<a name="l07722"></a>07722 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07723"></a>07723 <span class="preprocessor"></span>xmit_fcoe:
<a name="l07724"></a>07724 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07725"></a>07725     ixgbe_tx_map(tx_ring, skb, first, tx_flags, hdr_len);
<a name="l07726"></a>07726 
<a name="l07727"></a>07727 <span class="preprocessor">#ifndef HAVE_TRANS_START_IN_QUEUE</span>
<a name="l07728"></a>07728 <span class="preprocessor"></span>    tx_ring-&gt;netdev-&gt;trans_start = jiffies;
<a name="l07729"></a>07729 
<a name="l07730"></a>07730 <span class="preprocessor">#endif</span>
<a name="l07731"></a>07731 <span class="preprocessor"></span>    ixgbe_maybe_stop_tx(tx_ring, DESC_NEEDED);
<a name="l07732"></a>07732 
<a name="l07733"></a>07733     <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l07734"></a>07734 
<a name="l07735"></a>07735 out_drop:
<a name="l07736"></a>07736     dev_kfree_skb_any(skb);
<a name="l07737"></a>07737     <span class="keywordflow">return</span> NETDEV_TX_OK;
<a name="l07738"></a>07738 }
<a name="l07739"></a>07739 
<a name="l07740"></a>07740 <span class="keyword">static</span> netdev_tx_t ixgbe_xmit_frame(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *netdev)
<a name="l07741"></a>07741 {
<a name="l07742"></a>07742     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07743"></a>07743     <span class="keyword">struct </span><a class="code" href="structixgbe__ring.html">ixgbe_ring</a> *tx_ring;
<a name="l07744"></a>07744 
<a name="l07745"></a>07745 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l07746"></a>07746 <span class="preprocessor"></span>    tx_ring = adapter-&gt;tx_ring[skb-&gt;queue_mapping];
<a name="l07747"></a>07747 <span class="preprocessor">#else</span>
<a name="l07748"></a>07748 <span class="preprocessor"></span>    tx_ring = adapter-&gt;tx_ring[0];
<a name="l07749"></a>07749 <span class="preprocessor">#endif</span>
<a name="l07750"></a>07750 <span class="preprocessor"></span>    <span class="keywordflow">return</span> ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
<a name="l07751"></a>07751 }
<a name="l07752"></a>07752 
<a name="l07760"></a>07760 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_set_mac(<span class="keyword">struct</span> net_device *netdev, <span class="keywordtype">void</span> *p)
<a name="l07761"></a>07761 {
<a name="l07762"></a>07762     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07763"></a>07763     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = &amp;adapter-&gt;hw;
<a name="l07764"></a>07764     <span class="keyword">struct </span>sockaddr *addr = p;
<a name="l07765"></a>07765 
<a name="l07766"></a>07766     <span class="keywordflow">if</span> (!is_valid_ether_addr(addr-&gt;sa_data))
<a name="l07767"></a>07767         <span class="keywordflow">return</span> -EADDRNOTAVAIL;
<a name="l07768"></a>07768 
<a name="l07769"></a>07769     memcpy(netdev-&gt;dev_addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l07770"></a>07770     memcpy(hw-&gt;mac.addr, addr-&gt;sa_data, netdev-&gt;addr_len);
<a name="l07771"></a>07771 
<a name="l07772"></a>07772     <span class="keywordflow">if</span> (hw-&gt;mac.ops.set_rar)
<a name="l07773"></a>07773         hw-&gt;mac.ops.set_rar(hw, 0, hw-&gt;mac.addr, 0, IXGBE_RAH_AV);
<a name="l07774"></a>07774 
<a name="l07775"></a>07775     <span class="keywordflow">return</span> 0;
<a name="l07776"></a>07776 }
<a name="l07777"></a>07777 
<a name="l07778"></a>07778 <span class="preprocessor">#if defined(HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN)</span>
<a name="l07779"></a>07779 <span class="preprocessor"></span>
<a name="l07786"></a>07786 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_add_sanmac_netdev(<span class="keyword">struct</span> net_device *dev)
<a name="l07787"></a>07787 {
<a name="l07788"></a>07788     <span class="keywordtype">int</span> err = 0;
<a name="l07789"></a>07789     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l07790"></a>07790     <span class="keyword">struct </span><a class="code" href="structixgbe__mac__info.html">ixgbe_mac_info</a> *mac = &amp;adapter-&gt;hw.mac;
<a name="l07791"></a>07791 
<a name="l07792"></a>07792     <span class="keywordflow">if</span> (is_valid_ether_addr(mac-&gt;san_addr)) {
<a name="l07793"></a>07793         rtnl_lock();
<a name="l07794"></a>07794         err = dev_addr_add(dev, mac-&gt;san_addr, NETDEV_HW_ADDR_T_SAN);
<a name="l07795"></a>07795         rtnl_unlock();
<a name="l07796"></a>07796     }
<a name="l07797"></a>07797     <span class="keywordflow">return</span> err;
<a name="l07798"></a>07798 }
<a name="l07799"></a>07799 
<a name="l07807"></a>07807 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_del_sanmac_netdev(<span class="keyword">struct</span> net_device *dev)
<a name="l07808"></a>07808 {
<a name="l07809"></a>07809     <span class="keywordtype">int</span> err = 0;
<a name="l07810"></a>07810     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l07811"></a>07811     <span class="keyword">struct </span><a class="code" href="structixgbe__mac__info.html">ixgbe_mac_info</a> *mac = &amp;adapter-&gt;hw.mac;
<a name="l07812"></a>07812 
<a name="l07813"></a>07813     <span class="keywordflow">if</span> (is_valid_ether_addr(mac-&gt;san_addr)) {
<a name="l07814"></a>07814         rtnl_lock();
<a name="l07815"></a>07815         err = dev_addr_del(dev, mac-&gt;san_addr, NETDEV_HW_ADDR_T_SAN);
<a name="l07816"></a>07816         rtnl_unlock();
<a name="l07817"></a>07817     }
<a name="l07818"></a>07818     <span class="keywordflow">return</span> err;
<a name="l07819"></a>07819 }
<a name="l07820"></a>07820 
<a name="l07821"></a>07821 <span class="preprocessor">#endif </span><span class="comment">/* (HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN) */</span>
<a name="l07822"></a>07822 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l07823"></a>07823 <span class="preprocessor"></span>
<a name="l07829"></a>07829 <span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_ioctl(<span class="keyword">struct</span> net_device *netdev, <span class="keyword">struct</span> <a class="code" href="structifreq.html">ifreq</a> *ifr, <span class="keywordtype">int</span> cmd)
<a name="l07830"></a>07830 {
<a name="l07831"></a>07831     <span class="keywordflow">switch</span> (cmd) {
<a name="l07832"></a>07832     <span class="keywordflow">case</span> SIOCETHTOOL:
<a name="l07833"></a>07833         <span class="keywordflow">return</span> ethtool_ioctl(ifr);
<a name="l07834"></a>07834     <span class="keywordflow">default</span>:
<a name="l07835"></a>07835         <span class="keywordflow">return</span> -EOPNOTSUPP;
<a name="l07836"></a>07836     }
<a name="l07837"></a>07837 }
<a name="l07838"></a>07838 
<a name="l07839"></a>07839 <span class="preprocessor">#endif</span>
<a name="l07840"></a>07840 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l07841"></a>07841 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l07842"></a>07842 <span class="comment"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<a name="l07843"></a>07843 <span class="comment"> * without having to re-enable interrupts. It&#39;s not called while</span>
<a name="l07844"></a>07844 <span class="comment"> * the interrupt routine is executing.</span>
<a name="l07845"></a>07845 <span class="comment"> */</span>
<a name="l07846"></a>07846 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_netpoll(<span class="keyword">struct</span> net_device *netdev)
<a name="l07847"></a>07847 {
<a name="l07848"></a>07848     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(netdev);
<a name="l07849"></a>07849     <span class="keywordtype">int</span> i;
<a name="l07850"></a>07850 
<a name="l07851"></a>07851     <span class="comment">/* if interface is down do nothing */</span>
<a name="l07852"></a>07852     <span class="keywordflow">if</span> (test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))
<a name="l07853"></a>07853         <span class="keywordflow">return</span>;
<a name="l07854"></a>07854 
<a name="l07855"></a>07855 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l07856"></a>07856 <span class="preprocessor"></span>    ixgbe_irq_disable(adapter);
<a name="l07857"></a>07857 <span class="preprocessor">#endif</span>
<a name="l07858"></a>07858 <span class="preprocessor"></span>    adapter-&gt;flags |= IXGBE_FLAG_IN_NETPOLL;
<a name="l07859"></a>07859     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_MSIX_ENABLED) {
<a name="l07860"></a>07860         <span class="keywordtype">int</span> num_q_vectors = adapter-&gt;num_msix_vectors - NON_Q_VECTORS;
<a name="l07861"></a>07861         <span class="keywordflow">for</span> (i = 0; i &lt; num_q_vectors; i++) {
<a name="l07862"></a>07862             <span class="keyword">struct </span><a class="code" href="structixgbe__q__vector.html">ixgbe_q_vector</a> *q_vector = adapter-&gt;q_vector[i];
<a name="l07863"></a>07863             ixgbe_msix_clean_rings(0, q_vector);
<a name="l07864"></a>07864         }
<a name="l07865"></a>07865     } <span class="keywordflow">else</span> {
<a name="l07866"></a>07866         ixgbe_intr(adapter-&gt;pdev-&gt;irq, netdev);
<a name="l07867"></a>07867     }
<a name="l07868"></a>07868     adapter-&gt;flags &amp;= ~IXGBE_FLAG_IN_NETPOLL;
<a name="l07869"></a>07869 <span class="preprocessor">#ifndef CONFIG_IXGBE_NAPI</span>
<a name="l07870"></a>07870 <span class="preprocessor"></span>    ixgbe_irq_enable(adapter, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l07871"></a>07871 <span class="preprocessor">#endif</span>
<a name="l07872"></a>07872 <span class="preprocessor"></span>}
<a name="l07873"></a>07873 
<a name="l07874"></a>07874 <span class="preprocessor">#endif</span>
<a name="l07875"></a>07875 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NETDEV_SELECT_QUEUE</span>
<a name="l07876"></a>07876 <span class="preprocessor"></span><span class="keyword">static</span> u16 ixgbe_select_queue(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> sk_buff *skb)
<a name="l07877"></a>07877 {
<a name="l07878"></a>07878     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = netdev_priv(dev);
<a name="l07879"></a>07879     <span class="keywordtype">int</span> txq = smp_processor_id();
<a name="l07880"></a>07880 
<a name="l07881"></a>07881 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07882"></a>07882 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((skb-&gt;protocol == __constant_htons(ETH_P_FCOE)) ||
<a name="l07883"></a>07883         (skb-&gt;protocol == __constant_htons(ETH_P_FIP))) {
<a name="l07884"></a>07884         <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED) {
<a name="l07885"></a>07885             txq &amp;= (adapter-&gt;ring_feature[RING_F_FCOE].indices - 1);
<a name="l07886"></a>07886             txq += adapter-&gt;ring_feature[RING_F_FCOE].mask;
<a name="l07887"></a>07887             <span class="keywordflow">return</span> txq;
<a name="l07888"></a>07888         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l07889"></a>07889             txq = adapter-&gt;fcoe.up;
<a name="l07890"></a>07890             <span class="keywordflow">return</span> txq;
<a name="l07891"></a>07891         }
<a name="l07892"></a>07892     }
<a name="l07893"></a>07893 
<a name="l07894"></a>07894 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07895"></a>07895     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) {
<a name="l07896"></a>07896         <span class="keywordflow">while</span> (unlikely(txq &gt;= dev-&gt;real_num_tx_queues))
<a name="l07897"></a>07897             txq -= dev-&gt;real_num_tx_queues;
<a name="l07898"></a>07898         <span class="keywordflow">return</span> txq;
<a name="l07899"></a>07899     }
<a name="l07900"></a>07900 
<a name="l07901"></a>07901     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED) {
<a name="l07902"></a>07902         <span class="keywordflow">if</span> (skb-&gt;priority == TC_PRIO_CONTROL)
<a name="l07903"></a>07903             txq = adapter-&gt;ring_feature[RING_F_DCB].indices - 1;
<a name="l07904"></a>07904         <span class="keywordflow">else</span>
<a name="l07905"></a>07905             txq = (skb-&gt;vlan_tci &amp; IXGBE_TX_FLAGS_VLAN_PRIO_MASK)
<a name="l07906"></a>07906                    &gt;&gt; 13;
<a name="l07907"></a>07907         <span class="keywordflow">return</span> txq;
<a name="l07908"></a>07908     }
<a name="l07909"></a>07909     <span class="keywordflow">return</span> skb_tx_hash(dev, skb);
<a name="l07910"></a>07910 }
<a name="l07911"></a>07911 
<a name="l07912"></a>07912 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_SELECT_QUEUE */</span>
<a name="l07913"></a>07913 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l07914"></a>07914 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>net_device_ops ixgbe_netdev_ops = {
<a name="l07915"></a>07915     .ndo_open       = &amp;ixgbe_open,
<a name="l07916"></a>07916     .ndo_stop       = &amp;ixgbe_close,
<a name="l07917"></a>07917     .ndo_start_xmit     = &amp;ixgbe_xmit_frame,
<a name="l07918"></a>07918     .ndo_get_stats      = &amp;ixgbe_get_stats,
<a name="l07919"></a>07919     .ndo_set_rx_mode    = &amp;ixgbe_set_rx_mode,
<a name="l07920"></a>07920     .ndo_set_multicast_list = &amp;ixgbe_set_rx_mode,
<a name="l07921"></a>07921     .ndo_validate_addr  = eth_validate_addr,
<a name="l07922"></a>07922     .ndo_set_mac_address    = &amp;ixgbe_set_mac,
<a name="l07923"></a>07923     .ndo_change_mtu     = &amp;ixgbe_change_mtu,
<a name="l07924"></a>07924 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l07925"></a>07925 <span class="preprocessor"></span>    .ndo_do_ioctl       = &amp;ixgbe_ioctl,
<a name="l07926"></a>07926 <span class="preprocessor">#endif</span>
<a name="l07927"></a>07927 <span class="preprocessor"></span>    .ndo_tx_timeout     = &amp;ixgbe_tx_timeout,
<a name="l07928"></a>07928 <span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l07929"></a>07929 <span class="preprocessor"></span>    .ndo_vlan_rx_register   = &amp;ixgbe_vlan_rx_register,
<a name="l07930"></a>07930     .ndo_vlan_rx_add_vid    = &amp;ixgbe_vlan_rx_add_vid,
<a name="l07931"></a>07931     .ndo_vlan_rx_kill_vid   = &amp;ixgbe_vlan_rx_kill_vid,
<a name="l07932"></a>07932 <span class="preprocessor">#endif</span>
<a name="l07933"></a>07933 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_IPLINK_VF_CONFIG</span>
<a name="l07934"></a>07934 <span class="preprocessor"></span>    .ndo_set_vf_mac     = ixgbe_ndo_set_vf_mac,
<a name="l07935"></a>07935     .ndo_set_vf_vlan    = ixgbe_ndo_set_vf_vlan,
<a name="l07936"></a>07936     .ndo_set_vf_tx_rate = ixgbe_ndo_set_vf_bw,
<a name="l07937"></a>07937     .ndo_get_vf_config  = ixgbe_ndo_get_vf_config,
<a name="l07938"></a>07938 <span class="preprocessor">#endif</span>
<a name="l07939"></a>07939 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l07940"></a>07940 <span class="preprocessor"></span>    .ndo_poll_controller    = &amp;ixgbe_netpoll,
<a name="l07941"></a>07941 <span class="preprocessor">#endif</span>
<a name="l07942"></a>07942 <span class="preprocessor"></span>    .ndo_select_queue   = &amp;ixgbe_select_queue,
<a name="l07943"></a>07943 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l07944"></a>07944 <span class="preprocessor"></span>    .ndo_fcoe_ddp_setup = ixgbe_fcoe_ddp_get,
<a name="l07945"></a>07945     .ndo_fcoe_ddp_done = ixgbe_fcoe_ddp_put,
<a name="l07946"></a>07946 <span class="preprocessor">#ifdef HAVE_NETDEV_OPS_FCOE_ENABLE</span>
<a name="l07947"></a>07947 <span class="preprocessor"></span>    .ndo_fcoe_enable = ixgbe_fcoe_enable,
<a name="l07948"></a>07948     .ndo_fcoe_disable = ixgbe_fcoe_disable,
<a name="l07949"></a>07949 <span class="preprocessor">#endif</span>
<a name="l07950"></a>07950 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NETDEV_OPS_FCOE_GETWWN</span>
<a name="l07951"></a>07951 <span class="preprocessor"></span>    .ndo_fcoe_get_wwn = ixgbe_fcoe_get_wwn,
<a name="l07952"></a>07952 <span class="preprocessor">#endif</span>
<a name="l07953"></a>07953 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l07954"></a>07954 };
<a name="l07955"></a>07955 
<a name="l07956"></a>07956 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l07957"></a>07957 
<a name="l07958"></a>07958 
<a name="l07959"></a>07959 
<a name="l07960"></a>07960 <span class="keywordtype">void</span> ixgbe_assign_netdev_ops(<span class="keyword">struct</span> net_device *dev)
<a name="l07961"></a>07961 {
<a name="l07962"></a>07962     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter;
<a name="l07963"></a>07963     adapter = netdev_priv(dev);
<a name="l07964"></a>07964 <span class="preprocessor">#ifdef HAVE_NET_DEVICE_OPS</span>
<a name="l07965"></a>07965 <span class="preprocessor"></span>    dev-&gt;netdev_ops = &amp;ixgbe_netdev_ops;
<a name="l07966"></a>07966 <span class="preprocessor">#else </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l07967"></a>07967     dev-&gt;open = &amp;ixgbe_open;
<a name="l07968"></a>07968     dev-&gt;stop = &amp;ixgbe_close;
<a name="l07969"></a>07969     dev-&gt;hard_start_xmit = &amp;ixgbe_xmit_frame;
<a name="l07970"></a>07970     dev-&gt;get_stats = &amp;ixgbe_get_stats;
<a name="l07971"></a>07971 <span class="preprocessor">#ifdef HAVE_SET_RX_MODE</span>
<a name="l07972"></a>07972 <span class="preprocessor"></span>    dev-&gt;set_rx_mode = &amp;ixgbe_set_rx_mode;
<a name="l07973"></a>07973 <span class="preprocessor">#endif</span>
<a name="l07974"></a>07974 <span class="preprocessor"></span>    dev-&gt;set_multicast_list = &amp;ixgbe_set_rx_mode;
<a name="l07975"></a>07975     dev-&gt;set_mac_address = &amp;ixgbe_set_mac;
<a name="l07976"></a>07976     dev-&gt;change_mtu = &amp;ixgbe_change_mtu;
<a name="l07977"></a>07977 <span class="preprocessor">#ifdef ETHTOOL_OPS_COMPAT</span>
<a name="l07978"></a>07978 <span class="preprocessor"></span>    dev-&gt;do_ioctl = &amp;ixgbe_ioctl;
<a name="l07979"></a>07979 <span class="preprocessor">#endif</span>
<a name="l07980"></a>07980 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_TX_TIMEOUT</span>
<a name="l07981"></a>07981 <span class="preprocessor"></span>    dev-&gt;tx_timeout = &amp;ixgbe_tx_timeout;
<a name="l07982"></a>07982 <span class="preprocessor">#endif</span>
<a name="l07983"></a>07983 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l07984"></a>07984 <span class="preprocessor"></span>    dev-&gt;vlan_rx_register = &amp;ixgbe_vlan_rx_register;
<a name="l07985"></a>07985     dev-&gt;vlan_rx_add_vid = &amp;ixgbe_vlan_rx_add_vid;
<a name="l07986"></a>07986     dev-&gt;vlan_rx_kill_vid = &amp;ixgbe_vlan_rx_kill_vid;
<a name="l07987"></a>07987 <span class="preprocessor">#endif</span>
<a name="l07988"></a>07988 <span class="preprocessor"></span><span class="preprocessor">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<a name="l07989"></a>07989 <span class="preprocessor"></span>    dev-&gt;poll_controller = &amp;ixgbe_netpoll;
<a name="l07990"></a>07990 <span class="preprocessor">#endif</span>
<a name="l07991"></a>07991 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NETDEV_SELECT_QUEUE</span>
<a name="l07992"></a>07992 <span class="preprocessor"></span>    dev-&gt;select_queue = &amp;ixgbe_select_queue;
<a name="l07993"></a>07993 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_SELECT_QUEUE */</span>
<a name="l07994"></a>07994 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NET_DEVICE_OPS */</span>
<a name="l07995"></a>07995     ixgbe_set_ethtool_ops(dev);
<a name="l07996"></a>07996     dev-&gt;watchdog_timeo = 5 * HZ;
<a name="l07997"></a>07997 }
<a name="l07998"></a>07998 
<a name="l07999"></a>07999 <span class="keyword">static</span> <span class="keywordtype">void</span> __devinit ixgbe_probe_vf(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter)
<a name="l08000"></a>08000 {
<a name="l08001"></a>08001 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l08002"></a>08002 <span class="preprocessor"></span>    <span class="keywordtype">int</span> err;
<a name="l08003"></a>08003 
<a name="l08004"></a>08004     err = pci_enable_sriov(adapter-&gt;pdev, adapter-&gt;num_vfs);
<a name="l08005"></a>08005     <span class="keywordflow">if</span> (err) {
<a name="l08006"></a>08006         DPRINTK(PROBE, ERR,
<a name="l08007"></a>08007             <span class="stringliteral">&quot;Failed to enable PCI sriov: %d\n&quot;</span>, err);
<a name="l08008"></a>08008         <span class="keywordflow">goto</span> err_novfs;
<a name="l08009"></a>08009     }
<a name="l08010"></a>08010     <span class="comment">/* If call to enable VFs succeeded then allocate memory</span>
<a name="l08011"></a>08011 <span class="comment">     * for per VF control structures.</span>
<a name="l08012"></a>08012 <span class="comment">     */</span>
<a name="l08013"></a>08013     adapter-&gt;vfinfo =
<a name="l08014"></a>08014         kcalloc(adapter-&gt;num_vfs,
<a name="l08015"></a>08015             <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvf__data__storage.html">vf_data_storage</a>), GFP_KERNEL);
<a name="l08016"></a>08016     <span class="keywordflow">if</span> (adapter-&gt;vfinfo) {
<a name="l08017"></a>08017         adapter-&gt;l2switch_enable = <span class="keyword">true</span>;
<a name="l08018"></a>08018         adapter-&gt;repl_enable = <span class="keyword">true</span>;
<a name="l08019"></a>08019 
<a name="l08020"></a>08020         <span class="comment">/* RSS not compatible with SR-IOV operation */</span>
<a name="l08021"></a>08021         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l08022"></a>08022 
<a name="l08023"></a>08023         <span class="comment">/* Disable RSC when in SR-IOV mode */</span>
<a name="l08024"></a>08024         adapter-&gt;flags2 &amp;= ~(IXGBE_FLAG2_RSC_CAPABLE |
<a name="l08025"></a>08025                      IXGBE_FLAG2_RSC_ENABLED);
<a name="l08026"></a>08026 
<a name="l08027"></a>08027         adapter-&gt;flags &amp;= ~(IXGBE_FLAG_RX_PS_ENABLED |
<a name="l08028"></a>08028                     IXGBE_FLAG_RX_PS_CAPABLE);
<a name="l08029"></a>08029 
<a name="l08030"></a>08030         <span class="keywordflow">return</span>;
<a name="l08031"></a>08031     }
<a name="l08032"></a>08032 
<a name="l08033"></a>08033     <span class="comment">/* Oh oh */</span>
<a name="l08034"></a>08034     DPRINTK(PROBE, ERR,
<a name="l08035"></a>08035         <span class="stringliteral">&quot;Unable to allocate memory for VF &quot;</span>
<a name="l08036"></a>08036         <span class="stringliteral">&quot;Data Storage - SRIOV disabled\n&quot;</span>);
<a name="l08037"></a>08037     pci_disable_sriov(adapter-&gt;pdev);
<a name="l08038"></a>08038 
<a name="l08039"></a>08039 err_novfs:
<a name="l08040"></a>08040     adapter-&gt;flags &amp;= ~IXGBE_FLAG_SRIOV_ENABLED;
<a name="l08041"></a>08041     adapter-&gt;num_vfs = 0;
<a name="l08042"></a>08042 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_PCI_IOV */</span>
<a name="l08043"></a>08043 }
<a name="l08044"></a>08044 
<a name="l08056"></a>08056 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit ixgbe_probe(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l08057"></a>08057                  <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *ent)
<a name="l08058"></a>08058 {
<a name="l08059"></a>08059     <span class="keyword">struct </span>net_device *netdev;
<a name="l08060"></a>08060     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = NULL;
<a name="l08061"></a>08061     <span class="keyword">struct </span><a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw = NULL;
<a name="l08062"></a>08062     <span class="keyword">static</span> <span class="keywordtype">int</span> cards_found;
<a name="l08063"></a>08063     <span class="keywordtype">int</span> i, err, pci_using_dac;
<a name="l08064"></a>08064 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l08065"></a>08065 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices;
<a name="l08066"></a>08066 <span class="preprocessor">#endif</span>
<a name="l08067"></a>08067 <span class="preprocessor"></span>    u8 part_str[IXGBE_PBANUM_LENGTH];
<a name="l08068"></a>08068     <span class="keyword">enum</span> ixgbe_mac_type mac_type = ixgbe_mac_unknown;
<a name="l08069"></a>08069 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08070"></a>08070 <span class="preprocessor"></span>    u16 device_caps;
<a name="l08071"></a>08071 <span class="preprocessor">#endif</span>
<a name="l08072"></a>08072 <span class="preprocessor"></span>
<a name="l08073"></a>08073     err = pci_enable_device_mem(pdev);
<a name="l08074"></a>08074     <span class="keywordflow">if</span> (err)
<a name="l08075"></a>08075         <span class="keywordflow">return</span> err;
<a name="l08076"></a>08076 
<a name="l08077"></a>08077     <span class="keywordflow">if</span> (!dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64)) &amp;&amp;
<a name="l08078"></a>08078         !dma_set_coherent_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64))) {
<a name="l08079"></a>08079         pci_using_dac = 1;
<a name="l08080"></a>08080     } <span class="keywordflow">else</span> {
<a name="l08081"></a>08081         err = dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(32));
<a name="l08082"></a>08082         <span class="keywordflow">if</span> (err) {
<a name="l08083"></a>08083             err = dma_set_coherent_mask(pci_dev_to_dev(pdev),
<a name="l08084"></a>08084                                               DMA_BIT_MASK(32));
<a name="l08085"></a>08085             <span class="keywordflow">if</span> (err) {
<a name="l08086"></a>08086                 dev_err(pci_dev_to_dev(pdev), <span class="stringliteral">&quot;No usable DMA &quot;</span>
<a name="l08087"></a>08087                         <span class="stringliteral">&quot;configuration, aborting\n&quot;</span>);
<a name="l08088"></a>08088                 <span class="keywordflow">goto</span> err_dma;
<a name="l08089"></a>08089             }
<a name="l08090"></a>08090         }
<a name="l08091"></a>08091         pci_using_dac = 0;
<a name="l08092"></a>08092     }
<a name="l08093"></a>08093 
<a name="l08094"></a>08094     err = pci_request_selected_regions(pdev, pci_select_bars(pdev,
<a name="l08095"></a>08095                        IORESOURCE_MEM), ixgbe_driver_name);
<a name="l08096"></a>08096     <span class="keywordflow">if</span> (err) {
<a name="l08097"></a>08097         dev_err(pci_dev_to_dev(pdev),
<a name="l08098"></a>08098             <span class="stringliteral">&quot;pci_request_selected_regions failed 0x%x\n&quot;</span>, err);
<a name="l08099"></a>08099         <span class="keywordflow">goto</span> err_pci_reg;
<a name="l08100"></a>08100     }
<a name="l08101"></a>08101 
<a name="l08102"></a>08102     <span class="comment">/*</span>
<a name="l08103"></a>08103 <span class="comment">     * The mac_type is needed before we have the adapter is  set up</span>
<a name="l08104"></a>08104 <span class="comment">     * so rather than maintain two devID -&gt; MAC tables we dummy up</span>
<a name="l08105"></a>08105 <span class="comment">     * an ixgbe_hw stuct and use ixgbe_set_mac_type.</span>
<a name="l08106"></a>08106 <span class="comment">     */</span>
<a name="l08107"></a>08107     hw = vmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a>));
<a name="l08108"></a>08108     <span class="keywordflow">if</span> (!hw) {
<a name="l08109"></a>08109         printk(KERN_INFO <span class="stringliteral">&quot;Unable to allocate memory for early mac &quot;</span>
<a name="l08110"></a>08110             <span class="stringliteral">&quot;check\n&quot;</span>);
<a name="l08111"></a>08111     } <span class="keywordflow">else</span> {
<a name="l08112"></a>08112         hw-&gt;vendor_id = pdev-&gt;vendor;
<a name="l08113"></a>08113         hw-&gt;device_id = pdev-&gt;device;
<a name="l08114"></a>08114         ixgbe_set_mac_type(hw);
<a name="l08115"></a>08115         mac_type = hw-&gt;mac.type;
<a name="l08116"></a>08116         vfree(hw);
<a name="l08117"></a>08117     }
<a name="l08118"></a>08118 
<a name="l08119"></a>08119     <span class="comment">/*</span>
<a name="l08120"></a>08120 <span class="comment">     * Workaround of Silicon errata on 82598. Disable LOs in the PCI switch</span>
<a name="l08121"></a>08121 <span class="comment">     * port to which the 82598 is connected to prevent duplicate</span>
<a name="l08122"></a>08122 <span class="comment">     * completions caused by LOs.  We need the mac type so that we only</span>
<a name="l08123"></a>08123 <span class="comment">     * do this on 82598 devices, ixgbe_set_mac_type does this for us if</span>
<a name="l08124"></a>08124 <span class="comment">     * we set it&#39;s device ID.</span>
<a name="l08125"></a>08125 <span class="comment">     */</span>
<a name="l08126"></a>08126     <span class="keywordflow">if</span> (mac_type == ixgbe_mac_82598EB)
<a name="l08127"></a>08127         pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S);
<a name="l08128"></a>08128 
<a name="l08129"></a>08129     pci_enable_pcie_error_reporting(pdev);
<a name="l08130"></a>08130 
<a name="l08131"></a>08131     pci_set_master(pdev);
<a name="l08132"></a>08132 
<a name="l08133"></a>08133 <span class="preprocessor">#ifdef HAVE_TX_MQ</span>
<a name="l08134"></a>08134 <span class="preprocessor"></span>    indices = num_possible_cpus();
<a name="l08135"></a>08135     <span class="keywordflow">if</span> (mac_type == ixgbe_mac_unknown)
<a name="l08136"></a>08136         indices = max_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, IXGBE_MAX_RSS_INDICES,
<a name="l08137"></a>08137                 IXGBE_MAX_FDIR_INDICES);
<a name="l08138"></a>08138     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mac_type == ixgbe_mac_82598EB)
<a name="l08139"></a>08139         indices = min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, indices, IXGBE_MAX_RSS_INDICES);
<a name="l08140"></a>08140     <span class="keywordflow">else</span>
<a name="l08141"></a>08141         indices = min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, indices, IXGBE_MAX_FDIR_INDICES);
<a name="l08142"></a>08142     indices = max_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, indices, IXGBE_MAX_DCB_INDICES);
<a name="l08143"></a>08143 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08144"></a>08144 <span class="preprocessor"></span>    indices += min_t(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, num_possible_cpus(),
<a name="l08145"></a>08145               IXGBE_MAX_FCOE_INDICES);
<a name="l08146"></a>08146 <span class="preprocessor">#endif</span>
<a name="l08147"></a>08147 <span class="preprocessor"></span>    netdev = alloc_etherdev_mq(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>), indices);
<a name="l08148"></a>08148 <span class="preprocessor">#else</span>
<a name="l08149"></a>08149 <span class="preprocessor"></span>    netdev = alloc_etherdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a>));
<a name="l08150"></a>08150 <span class="preprocessor">#endif</span>
<a name="l08151"></a>08151 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!netdev) {
<a name="l08152"></a>08152         err = -ENOMEM;
<a name="l08153"></a>08153         <span class="keywordflow">goto</span> err_alloc_etherdev;
<a name="l08154"></a>08154     }
<a name="l08155"></a>08155 
<a name="l08156"></a>08156     SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);
<a name="l08157"></a>08157 
<a name="l08158"></a>08158     adapter = netdev_priv(netdev);
<a name="l08159"></a>08159     pci_set_drvdata(pdev, adapter);
<a name="l08160"></a>08160 
<a name="l08161"></a>08161     adapter-&gt;netdev = netdev;
<a name="l08162"></a>08162     adapter-&gt;pdev = pdev;
<a name="l08163"></a>08163     hw = &amp;adapter-&gt;hw;
<a name="l08164"></a>08164     hw-&gt;back = adapter;
<a name="l08165"></a>08165     adapter-&gt;msg_enable = (1 &lt;&lt; DEFAULT_DEBUG_LEVEL_SHIFT) - 1;
<a name="l08166"></a>08166 
<a name="l08167"></a>08167 <span class="preprocessor">#ifdef HAVE_DEVICE_NUMA_NODE</span>
<a name="l08168"></a>08168 <span class="preprocessor"></span>    DPRINTK(TX_ERR, INFO, <span class="stringliteral">&quot;my (original) node was: %d\n&quot;</span>,
<a name="l08169"></a>08169             dev_to_node(&amp;pdev-&gt;dev));
<a name="l08170"></a>08170 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DEVICE_NUMA_NODE */</span>
<a name="l08171"></a>08171 
<a name="l08172"></a>08172 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l08173"></a>08173 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l08174"></a>08174 <span class="comment">     * call save state here in standalone driver because it relies on</span>
<a name="l08175"></a>08175 <span class="comment">     * adapter struct to exist, and needs to call netdev_priv</span>
<a name="l08176"></a>08176 <span class="comment">     */</span>
<a name="l08177"></a>08177     pci_save_state(pdev);
<a name="l08178"></a>08178 
<a name="l08179"></a>08179 <span class="preprocessor">#endif</span>
<a name="l08180"></a>08180 <span class="preprocessor"></span>    hw-&gt;hw_addr = ioremap(pci_resource_start(pdev, 0),
<a name="l08181"></a>08181                   pci_resource_len(pdev, 0));
<a name="l08182"></a>08182     <span class="keywordflow">if</span> (!hw-&gt;hw_addr) {
<a name="l08183"></a>08183         err = -EIO;
<a name="l08184"></a>08184         <span class="keywordflow">goto</span> err_ioremap;
<a name="l08185"></a>08185     }
<a name="l08186"></a>08186 
<a name="l08187"></a>08187     ixgbe_assign_netdev_ops(netdev);
<a name="l08188"></a>08188 
<a name="l08189"></a>08189     strcpy(netdev-&gt;name, pci_name(pdev));
<a name="l08190"></a>08190 
<a name="l08191"></a>08191     adapter-&gt;bd_number = cards_found;
<a name="l08192"></a>08192 
<a name="l08193"></a>08193     <span class="comment">/* setup the private structure */</span>
<a name="l08194"></a>08194     err = ixgbe_sw_init(adapter);
<a name="l08195"></a>08195     <span class="keywordflow">if</span> (err)
<a name="l08196"></a>08196         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08197"></a>08197 
<a name="l08198"></a>08198     <span class="comment">/* Make it possible the adapter to be woken up via WOL */</span>
<a name="l08199"></a>08199     <span class="keywordflow">switch</span>(adapter-&gt;hw.mac.type) {
<a name="l08200"></a>08200     <span class="keywordflow">case</span> ixgbe_mac_82599EB:
<a name="l08201"></a>08201     <span class="keywordflow">case</span> ixgbe_mac_X540:
<a name="l08202"></a>08202         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_WUS, ~0);
<a name="l08203"></a>08203         <span class="keywordflow">break</span>;
<a name="l08204"></a>08204     <span class="keywordflow">default</span>:
<a name="l08205"></a>08205         <span class="keywordflow">break</span>;
<a name="l08206"></a>08206     }
<a name="l08207"></a>08207 
<a name="l08208"></a>08208     <span class="comment">/*</span>
<a name="l08209"></a>08209 <span class="comment">     * If we have a fan, this is as early we know, warn if we</span>
<a name="l08210"></a>08210 <span class="comment">     * have had a failure.</span>
<a name="l08211"></a>08211 <span class="comment">     */</span>
<a name="l08212"></a>08212     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FAN_FAIL_CAPABLE) {
<a name="l08213"></a>08213         u32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
<a name="l08214"></a>08214         <span class="keywordflow">if</span> (esdp &amp; IXGBE_ESDP_SDP1)
<a name="l08215"></a>08215             DPRINTK(PROBE, CRIT,
<a name="l08216"></a>08216                 <span class="stringliteral">&quot;Fan has stopped, replace the adapter\n&quot;</span>);
<a name="l08217"></a>08217     }
<a name="l08218"></a>08218 
<a name="l08219"></a>08219     <span class="comment">/* reset_hw fills in the perm_addr as well */</span>
<a name="l08220"></a>08220     hw-&gt;phy.reset_if_overtemp = <span class="keyword">true</span>;
<a name="l08221"></a>08221     err = hw-&gt;mac.ops.reset_hw(hw);
<a name="l08222"></a>08222     hw-&gt;phy.reset_if_overtemp = <span class="keyword">false</span>;
<a name="l08223"></a>08223     <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_PRESENT &amp;&amp;
<a name="l08224"></a>08224         hw-&gt;mac.type == ixgbe_mac_82598EB) {
<a name="l08225"></a>08225         err = 0;
<a name="l08226"></a>08226     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err == IXGBE_ERR_SFP_NOT_SUPPORTED) {
<a name="l08227"></a>08227         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;failed to load because an &quot;</span>
<a name="l08228"></a>08228                 <span class="stringliteral">&quot;unsupported SFP+ module type was detected.\n&quot;</span>
<a name="l08229"></a>08229                 <span class="stringliteral">&quot;Reload the driver after installing a &quot;</span>
<a name="l08230"></a>08230                 <span class="stringliteral">&quot;supported module.\n&quot;</span>);
<a name="l08231"></a>08231         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08232"></a>08232     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err) {
<a name="l08233"></a>08233         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;HW Init failed: %d\n&quot;</span>, err);
<a name="l08234"></a>08234         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08235"></a>08235     }
<a name="l08236"></a>08236 
<a name="l08237"></a>08237     <span class="comment">/*</span>
<a name="l08238"></a>08238 <span class="comment">     * check_options must be called before setup_link to set up</span>
<a name="l08239"></a>08239 <span class="comment">     * hw-&gt;fc completely</span>
<a name="l08240"></a>08240 <span class="comment">     */</span>
<a name="l08241"></a>08241     ixgbe_check_options(adapter);
<a name="l08242"></a>08242 
<a name="l08243"></a>08243     DPRINTK(TX_ERR, INFO, <span class="stringliteral">&quot;my (preferred) node is: %d\n&quot;</span>, adapter-&gt;node);
<a name="l08244"></a>08244 
<a name="l08245"></a>08245     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l08246"></a>08246         ixgbe_probe_vf(adapter);
<a name="l08247"></a>08247 
<a name="l08248"></a>08248 <span class="preprocessor">#ifdef MAX_SKB_FRAGS</span>
<a name="l08249"></a>08249 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_HW_VLAN_TX</span>
<a name="l08250"></a>08250 <span class="preprocessor"></span>    netdev-&gt;features = NETIF_F_SG |
<a name="l08251"></a>08251                NETIF_F_IP_CSUM |
<a name="l08252"></a>08252                NETIF_F_HW_VLAN_TX |
<a name="l08253"></a>08253                NETIF_F_HW_VLAN_RX |
<a name="l08254"></a>08254                NETIF_F_HW_VLAN_FILTER;
<a name="l08255"></a>08255 
<a name="l08256"></a>08256 <span class="preprocessor">#else</span>
<a name="l08257"></a>08257 <span class="preprocessor"></span>    netdev-&gt;features = NETIF_F_SG | NETIF_F_IP_CSUM;
<a name="l08258"></a>08258 
<a name="l08259"></a>08259 <span class="preprocessor">#endif</span>
<a name="l08260"></a>08260 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l08261"></a>08261 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_IPV6_CSUM;
<a name="l08262"></a>08262 <span class="preprocessor">#endif</span>
<a name="l08263"></a>08263 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l08264"></a>08264 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO;
<a name="l08265"></a>08265 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l08266"></a>08266 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_TSO6;
<a name="l08267"></a>08267 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO6 */</span>
<a name="l08268"></a>08268 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l08269"></a>08269 <span class="preprocessor">#ifdef NETIF_F_GRO</span>
<a name="l08270"></a>08270 <span class="preprocessor"></span>    netdev-&gt;features |= NETIF_F_GRO;
<a name="l08271"></a>08271 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_GRO */</span>
<a name="l08272"></a>08272 
<a name="l08273"></a>08273     <span class="keywordflow">if</span> (adapter-&gt;hw.mac.type == ixgbe_mac_82599EB)
<a name="l08274"></a>08274         netdev-&gt;features |= NETIF_F_SCTP_CSUM;
<a name="l08275"></a>08275 
<a name="l08276"></a>08276 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l08277"></a>08277 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_TSO</span>
<a name="l08278"></a>08278 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_TSO;
<a name="l08279"></a>08279 <span class="preprocessor">#ifdef NETIF_F_TSO6</span>
<a name="l08280"></a>08280 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_TSO6;
<a name="l08281"></a>08281 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO6 */</span>
<a name="l08282"></a>08282 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_TSO */</span>
<a name="l08283"></a>08283     netdev-&gt;vlan_features |= NETIF_F_IP_CSUM;
<a name="l08284"></a>08284 <span class="preprocessor">#ifdef NETIF_F_IPV6_CSUM</span>
<a name="l08285"></a>08285 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_IPV6_CSUM;
<a name="l08286"></a>08286 <span class="preprocessor">#endif</span>
<a name="l08287"></a>08287 <span class="preprocessor"></span>    netdev-&gt;vlan_features |= NETIF_F_SG;
<a name="l08288"></a>08288 
<a name="l08289"></a>08289 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l08290"></a>08290 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l08291"></a>08291 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l08292"></a>08292 <span class="comment">     * If perfect filters were enabled in check_options(), enable them</span>
<a name="l08293"></a>08293 <span class="comment">     * on the netdevice too.</span>
<a name="l08294"></a>08294 <span class="comment">     */</span>
<a name="l08295"></a>08295     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
<a name="l08296"></a>08296         netdev-&gt;features |= NETIF_F_NTUPLE;
<a name="l08297"></a>08297 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l08298"></a>08298     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED)
<a name="l08299"></a>08299         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l08300"></a>08300     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCB_ENABLED)
<a name="l08301"></a>08301         adapter-&gt;flags &amp;= ~IXGBE_FLAG_RSS_ENABLED;
<a name="l08302"></a>08302     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_VMDQ_ENABLED) {
<a name="l08303"></a>08303         adapter-&gt;flags &amp;= ~(IXGBE_FLAG_FDIR_HASH_CAPABLE
<a name="l08304"></a>08304                     | IXGBE_FLAG_FDIR_PERFECT_CAPABLE);
<a name="l08305"></a>08305 <span class="preprocessor">#ifdef NETIF_F_NTUPLE</span>
<a name="l08306"></a>08306 <span class="preprocessor"></span>        <span class="comment">/* clear n-tuple support in the netdev unconditionally */</span>
<a name="l08307"></a>08307         netdev-&gt;features &amp;= ~NETIF_F_NTUPLE;
<a name="l08308"></a>08308 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_NTUPLE */</span>
<a name="l08309"></a>08309     }
<a name="l08310"></a>08310 
<a name="l08311"></a>08311     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE) {
<a name="l08312"></a>08312         netdev-&gt;features |= NETIF_F_LRO;
<a name="l08313"></a>08313         adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SWLRO_ENABLED;
<a name="l08314"></a>08314         <span class="keywordflow">if</span> (adapter-&gt;rx_itr_setting == 0 ||
<a name="l08315"></a>08315             adapter-&gt;rx_itr_setting &gt; IXGBE_MAX_RSC_INT_RATE) {
<a name="l08316"></a>08316             adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_ENABLED;
<a name="l08317"></a>08317             DPRINTK(PROBE, INFO,
<a name="l08318"></a>08318                  <span class="stringliteral">&quot;InterruptThrottleRate set too high, disabling RSC\n&quot;</span>);
<a name="l08319"></a>08319         } <span class="keywordflow">else</span> {
<a name="l08320"></a>08320             adapter-&gt;flags2 |= IXGBE_FLAG2_RSC_ENABLED;
<a name="l08321"></a>08321         }
<a name="l08322"></a>08322     } <span class="keywordflow">else</span> {
<a name="l08323"></a>08323 <span class="preprocessor">#ifndef IXGBE_NO_LRO</span>
<a name="l08324"></a>08324 <span class="preprocessor"></span>        netdev-&gt;features |= NETIF_F_LRO;
<a name="l08325"></a>08325         adapter-&gt;flags2 |= IXGBE_FLAG2_SWLRO_ENABLED;
<a name="l08326"></a>08326 <span class="preprocessor">#endif</span>
<a name="l08327"></a>08327 <span class="preprocessor"></span>        adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_RSC_ENABLED;
<a name="l08328"></a>08328     }
<a name="l08329"></a>08329 <span class="preprocessor">#ifdef CONFIG_DCB</span>
<a name="l08330"></a>08330 <span class="preprocessor"></span>    netdev-&gt;dcbnl_ops = &amp;dcbnl_ops;
<a name="l08331"></a>08331 <span class="preprocessor">#endif</span>
<a name="l08332"></a>08332 <span class="preprocessor"></span>
<a name="l08333"></a>08333 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08334"></a>08334 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETIF_F_FSO</span>
<a name="l08335"></a>08335 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_CAPABLE) {
<a name="l08336"></a>08336         ixgbe_get_device_caps(hw, &amp;device_caps);
<a name="l08337"></a>08337         <span class="keywordflow">if</span> (device_caps &amp; IXGBE_DEVICE_CAPS_FCOE_OFFLOADS) {
<a name="l08338"></a>08338             adapter-&gt;flags &amp;= ~IXGBE_FLAG_FCOE_ENABLED;
<a name="l08339"></a>08339             adapter-&gt;flags &amp;= ~IXGBE_FLAG_FCOE_CAPABLE;
<a name="l08340"></a>08340             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;FCoE offload feature &quot;</span>
<a name="l08341"></a>08341                 <span class="stringliteral">&quot;is not available. Disabling FCoE &quot;</span>
<a name="l08342"></a>08342                 <span class="stringliteral">&quot;offload feature\n&quot;</span>);
<a name="l08343"></a>08343         }
<a name="l08344"></a>08344 <span class="preprocessor">#ifndef HAVE_NETDEV_OPS_FCOE_ENABLE</span>
<a name="l08345"></a>08345 <span class="preprocessor"></span>        <span class="keywordflow">else</span> {
<a name="l08346"></a>08346             adapter-&gt;flags |= IXGBE_FLAG_FCOE_ENABLED;
<a name="l08347"></a>08347             adapter-&gt;ring_feature[RING_F_FCOE].indices =
<a name="l08348"></a>08348                     IXGBE_FCRETA_SIZE;
<a name="l08349"></a>08349             netdev-&gt;features |= NETIF_F_FSO;
<a name="l08350"></a>08350             netdev-&gt;features |= NETIF_F_FCOE_CRC;
<a name="l08351"></a>08351             netdev-&gt;features |= NETIF_F_FCOE_MTU;
<a name="l08352"></a>08352             netdev-&gt;fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX - 1;
<a name="l08353"></a>08353             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;Enabling FCoE offload &quot;</span>
<a name="l08354"></a>08354                 <span class="stringliteral">&quot;feature\n&quot;</span>);
<a name="l08355"></a>08355         }
<a name="l08356"></a>08356 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_OPS_FCOE_ENABLE */</span>
<a name="l08357"></a>08357     }
<a name="l08358"></a>08358 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l08359"></a>08359 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_CAPABLE) {
<a name="l08360"></a>08360         netdev-&gt;vlan_features |= NETIF_F_FSO;
<a name="l08361"></a>08361         netdev-&gt;vlan_features |= NETIF_F_FCOE_CRC;
<a name="l08362"></a>08362         netdev-&gt;vlan_features |= NETIF_F_FCOE_MTU;
<a name="l08363"></a>08363     }
<a name="l08364"></a>08364 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l08365"></a>08365 <span class="preprocessor">#endif </span><span class="comment">/* NETIF_F_FSO */</span>
<a name="l08366"></a>08366 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l08367"></a>08367     <span class="keywordflow">if</span> (pci_using_dac) {
<a name="l08368"></a>08368         netdev-&gt;features |= NETIF_F_HIGHDMA;
<a name="l08369"></a>08369 <span class="preprocessor">#ifdef HAVE_NETDEV_VLAN_FEATURES</span>
<a name="l08370"></a>08370 <span class="preprocessor"></span>        netdev-&gt;vlan_features |= NETIF_F_HIGHDMA;
<a name="l08371"></a>08371 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_NETDEV_VLAN_FEATURES */</span>
<a name="l08372"></a>08372     }
<a name="l08373"></a>08373 
<a name="l08374"></a>08374 <span class="preprocessor">#endif </span><span class="comment">/* MAX_SKB_FRAGS */</span>
<a name="l08375"></a>08375     <span class="comment">/* make sure the EEPROM is good */</span>
<a name="l08376"></a>08376     <span class="keywordflow">if</span> (hw-&gt;eeprom.ops.validate_checksum &amp;&amp;
<a name="l08377"></a>08377         (hw-&gt;eeprom.ops.validate_checksum(hw, NULL) &lt; 0)) {
<a name="l08378"></a>08378         DPRINTK(PROBE, ERR, <span class="stringliteral">&quot;The EEPROM Checksum Is Not Valid\n&quot;</span>);
<a name="l08379"></a>08379         err = -EIO;
<a name="l08380"></a>08380         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08381"></a>08381     }
<a name="l08382"></a>08382 
<a name="l08383"></a>08383     memcpy(netdev-&gt;dev_addr, hw-&gt;mac.perm_addr, netdev-&gt;addr_len);
<a name="l08384"></a>08384 <span class="preprocessor">#ifdef ETHTOOL_GPERMADDR</span>
<a name="l08385"></a>08385 <span class="preprocessor"></span>    memcpy(netdev-&gt;perm_addr, hw-&gt;mac.perm_addr, netdev-&gt;addr_len);
<a name="l08386"></a>08386 
<a name="l08387"></a>08387     <span class="keywordflow">if</span> (ixgbe_validate_mac_addr(netdev-&gt;perm_addr)) {
<a name="l08388"></a>08388         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;invalid MAC address\n&quot;</span>);
<a name="l08389"></a>08389         err = -EIO;
<a name="l08390"></a>08390         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08391"></a>08391     }
<a name="l08392"></a>08392 <span class="preprocessor">#else</span>
<a name="l08393"></a>08393 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ixgbe_validate_mac_addr(netdev-&gt;dev_addr)) {
<a name="l08394"></a>08394         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;invalid MAC address\n&quot;</span>);
<a name="l08395"></a>08395         err = -EIO;
<a name="l08396"></a>08396         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08397"></a>08397     }
<a name="l08398"></a>08398 <span class="preprocessor">#endif</span>
<a name="l08399"></a>08399 <span class="preprocessor"></span>
<a name="l08400"></a>08400     <span class="comment">/* power down the optics */</span>
<a name="l08401"></a>08401     <span class="keywordflow">if</span> ((hw-&gt;phy.multispeed_fiber) ||
<a name="l08402"></a>08402         ((hw-&gt;phy.type == ixgbe_media_type_fiber) &amp;&amp;
<a name="l08403"></a>08403          (hw-&gt;mac.type = ixgbe_mac_82599EB)))
<a name="l08404"></a>08404         ixgbe_disable_tx_laser(hw);
<a name="l08405"></a>08405 
<a name="l08406"></a>08406     setup_timer(&amp;adapter-&gt;service_timer, &amp;ixgbe_service_timer,
<a name="l08407"></a>08407                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) adapter);
<a name="l08408"></a>08408 
<a name="l08409"></a>08409     INIT_WORK(&amp;adapter-&gt;service_task, ixgbe_service_task);
<a name="l08410"></a>08410     clear_bit(__IXGBE_SERVICE_SCHED, &amp;adapter-&gt;state);
<a name="l08411"></a>08411 
<a name="l08412"></a>08412     err = ixgbe_init_interrupt_scheme(adapter);
<a name="l08413"></a>08413     <span class="keywordflow">if</span> (err)
<a name="l08414"></a>08414         <span class="keywordflow">goto</span> err_sw_init;
<a name="l08415"></a>08415 
<a name="l08416"></a>08416     <span class="comment">/* WOL not supported for all but the following */</span>
<a name="l08417"></a>08417     adapter-&gt;wol = 0;
<a name="l08418"></a>08418     <span class="keywordflow">switch</span> (pdev-&gt;device) {
<a name="l08419"></a>08419     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_SFP:
<a name="l08420"></a>08420         <span class="comment">/* Only this subdevice supports WOL */</span>
<a name="l08421"></a>08421         <span class="keywordflow">if</span> (pdev-&gt;subsystem_device == IXGBE_SUBDEV_ID_82599_SFP)
<a name="l08422"></a>08422             adapter-&gt;wol = (IXGBE_WUFC_MAG | IXGBE_WUFC_EX |
<a name="l08423"></a>08423                             IXGBE_WUFC_MC | IXGBE_WUFC_BC);
<a name="l08424"></a>08424         <span class="keywordflow">break</span>;
<a name="l08425"></a>08425     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_COMBO_BACKPLANE:
<a name="l08426"></a>08426         <span class="comment">/* All except this subdevice support WOL */</span>
<a name="l08427"></a>08427         <span class="keywordflow">if</span> (pdev-&gt;subsystem_device != IXGBE_SUBDEV_ID_82599_KX4_KR_MEZZ)
<a name="l08428"></a>08428             adapter-&gt;wol = (IXGBE_WUFC_MAG | IXGBE_WUFC_EX |
<a name="l08429"></a>08429                             IXGBE_WUFC_MC | IXGBE_WUFC_BC);
<a name="l08430"></a>08430         <span class="keywordflow">break</span>;
<a name="l08431"></a>08431     <span class="keywordflow">case</span> IXGBE_DEV_ID_82599_KX4:
<a name="l08432"></a>08432         adapter-&gt;wol = (IXGBE_WUFC_MAG | IXGBE_WUFC_EX |
<a name="l08433"></a>08433                         IXGBE_WUFC_MC | IXGBE_WUFC_BC);
<a name="l08434"></a>08434         <span class="keywordflow">break</span>;
<a name="l08435"></a>08435     }
<a name="l08436"></a>08436     device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);
<a name="l08437"></a>08437 
<a name="l08438"></a>08438     <span class="comment">/* save off EEPROM version number */</span>
<a name="l08439"></a>08439     ixgbe_read_eeprom(hw, 0x29, &amp;adapter-&gt;eeprom_version);
<a name="l08440"></a>08440 
<a name="l08441"></a>08441     <span class="comment">/* reset the hardware with the new settings */</span>
<a name="l08442"></a>08442     err = hw-&gt;mac.ops.start_hw(hw);
<a name="l08443"></a>08443     <span class="keywordflow">if</span> (err == IXGBE_ERR_EEPROM_VERSION) {
<a name="l08444"></a>08444         <span class="comment">/* We are running on a pre-production device, log a warning */</span>
<a name="l08445"></a>08445         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;This device is a pre-production adapter/&quot;</span>
<a name="l08446"></a>08446                 <span class="stringliteral">&quot;LOM.  Please be aware there may be issues associated &quot;</span>
<a name="l08447"></a>08447                 <span class="stringliteral">&quot;with your hardware.  If you are experiencing problems &quot;</span>
<a name="l08448"></a>08448                 <span class="stringliteral">&quot;please contact your Intel or hardware representative &quot;</span>
<a name="l08449"></a>08449                 <span class="stringliteral">&quot;who provided you with this hardware.\n&quot;</span>);
<a name="l08450"></a>08450     }
<a name="l08451"></a>08451     <span class="comment">/* pick up the PCI bus settings for reporting later */</span>
<a name="l08452"></a>08452     <span class="keywordflow">if</span> (hw-&gt;mac.ops.get_bus_info)
<a name="l08453"></a>08453         hw-&gt;mac.ops.get_bus_info(hw);
<a name="l08454"></a>08454 
<a name="l08455"></a>08455 
<a name="l08456"></a>08456     strcpy(netdev-&gt;name, <span class="stringliteral">&quot;eth%d&quot;</span>);
<a name="l08457"></a>08457     err = register_netdev(netdev);
<a name="l08458"></a>08458     <span class="keywordflow">if</span> (err)
<a name="l08459"></a>08459         <span class="keywordflow">goto</span> err_register;
<a name="l08460"></a>08460 
<a name="l08461"></a>08461     adapter-&gt;netdev_registered = <span class="keyword">true</span>;
<a name="l08462"></a>08462     <span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span>
<a name="l08463"></a>08463     netif_carrier_off(netdev);
<a name="l08464"></a>08464     <span class="comment">/* keep stopping all the transmit queues for older kernels */</span>
<a name="l08465"></a>08465     netif_tx_stop_all_queues(netdev);
<a name="l08466"></a>08466 
<a name="l08467"></a>08467     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_CAPABLE) {
<a name="l08468"></a>08468         err = dca_add_requester(&amp;pdev-&gt;dev);
<a name="l08469"></a>08469         <span class="keywordflow">switch</span> (err) {
<a name="l08470"></a>08470         <span class="keywordflow">case</span> 0:
<a name="l08471"></a>08471             adapter-&gt;flags |= IXGBE_FLAG_DCA_ENABLED;
<a name="l08472"></a>08472             ixgbe_setup_dca(adapter);
<a name="l08473"></a>08473             <span class="keywordflow">break</span>;
<a name="l08474"></a>08474         <span class="comment">/* -19 is returned from the kernel when no provider is found */</span>
<a name="l08475"></a>08475         <span class="keywordflow">case</span> -19:
<a name="l08476"></a>08476             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;No DCA provider found.  Please &quot;</span>
<a name="l08477"></a>08477                     <span class="stringliteral">&quot;start ioatdma for DCA functionality.\n&quot;</span>);
<a name="l08478"></a>08478             <span class="keywordflow">break</span>;
<a name="l08479"></a>08479         <span class="keywordflow">default</span>:
<a name="l08480"></a>08480             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;DCA registration failed: %d\n&quot;</span>,
<a name="l08481"></a>08481                     err);
<a name="l08482"></a>08482             <span class="keywordflow">break</span>;
<a name="l08483"></a>08483         }
<a name="l08484"></a>08484     }
<a name="l08485"></a>08485 
<a name="l08486"></a>08486     <span class="comment">/* print all messages at the end so that we use our eth%d name */</span>
<a name="l08487"></a>08487     <span class="comment">/* print bus type/speed/width info */</span>
<a name="l08488"></a>08488     DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;(PCI Express:%s:%s) &quot;</span>,
<a name="l08489"></a>08489         (hw-&gt;bus.speed == ixgbe_bus_speed_5000 ? <span class="stringliteral">&quot;5.0Gb/s&quot;</span> :
<a name="l08490"></a>08490          hw-&gt;bus.speed == ixgbe_bus_speed_2500 ? <span class="stringliteral">&quot;2.5Gb/s&quot;</span> :
<a name="l08491"></a>08491          <span class="stringliteral">&quot;Unknown&quot;</span>),
<a name="l08492"></a>08492         (hw-&gt;bus.width == ixgbe_bus_width_pcie_x8 ? <span class="stringliteral">&quot;Width x8&quot;</span> :
<a name="l08493"></a>08493          hw-&gt;bus.width == ixgbe_bus_width_pcie_x4 ? <span class="stringliteral">&quot;Width x4&quot;</span> :
<a name="l08494"></a>08494          hw-&gt;bus.width == ixgbe_bus_width_pcie_x1 ? <span class="stringliteral">&quot;Width x1&quot;</span> :
<a name="l08495"></a>08495          <span class="stringliteral">&quot;Unknown&quot;</span>));
<a name="l08496"></a>08496 
<a name="l08497"></a>08497     <span class="comment">/* print the MAC address */</span>
<a name="l08498"></a>08498     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++)
<a name="l08499"></a>08499         printk(<span class="stringliteral">&quot;%2.2x%c&quot;</span>, netdev-&gt;dev_addr[i], i == 5 ? <span class="charliteral">&#39;\n&#39;</span> : <span class="charliteral">&#39;:&#39;</span>);
<a name="l08500"></a>08500 
<a name="l08501"></a>08501     <span class="comment">/* First try to read PBA as a string */</span>
<a name="l08502"></a>08502     err = ixgbe_read_pba_string(hw, part_str, IXGBE_PBANUM_LENGTH);
<a name="l08503"></a>08503     <span class="keywordflow">if</span> (err)
<a name="l08504"></a>08504         strcpy(part_str, <span class="stringliteral">&quot;Unknown&quot;</span>);
<a name="l08505"></a>08505     <span class="keywordflow">if</span> (ixgbe_is_sfp(hw) &amp;&amp; hw-&gt;phy.sfp_type != ixgbe_sfp_type_not_present)
<a name="l08506"></a>08506         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n&quot;</span>,
<a name="l08507"></a>08507                 hw-&gt;mac.type, hw-&gt;phy.type, hw-&gt;phy.sfp_type,
<a name="l08508"></a>08508                 part_str);
<a name="l08509"></a>08509     <span class="keywordflow">else</span>
<a name="l08510"></a>08510         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;MAC: %d, PHY: %d, PBA No: %s\n&quot;</span>,
<a name="l08511"></a>08511                 hw-&gt;mac.type, hw-&gt;phy.type, part_str);
<a name="l08512"></a>08512 
<a name="l08513"></a>08513     <span class="keywordflow">if</span> (((hw-&gt;bus.speed == ixgbe_bus_speed_2500) &amp;&amp;
<a name="l08514"></a>08514          (hw-&gt;bus.width &lt;= ixgbe_bus_width_pcie_x4)) ||
<a name="l08515"></a>08515         (hw-&gt;bus.width &lt;= ixgbe_bus_width_pcie_x2)) {
<a name="l08516"></a>08516         DPRINTK(PROBE, WARNING, <span class="stringliteral">&quot;PCI-Express bandwidth available for &quot;</span>
<a name="l08517"></a>08517             <span class="stringliteral">&quot;this card is not sufficient for optimal &quot;</span>
<a name="l08518"></a>08518             <span class="stringliteral">&quot;performance.\n&quot;</span>);
<a name="l08519"></a>08519         DPRINTK(PROBE, WARNING, <span class="stringliteral">&quot;For optimal performance a x8 &quot;</span>
<a name="l08520"></a>08520             <span class="stringliteral">&quot;PCI-Express slot is required.\n&quot;</span>);
<a name="l08521"></a>08521     }
<a name="l08522"></a>08522 
<a name="l08523"></a>08523 <span class="preprocessor">#ifdef NETIF_F_GRO</span>
<a name="l08524"></a>08524 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;netdev-&gt;features &amp; NETIF_F_GRO)
<a name="l08525"></a>08525         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;GRO is enabled\n&quot;</span>);
<a name="l08526"></a>08526     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED)
<a name="l08527"></a>08527 <span class="preprocessor">#else</span>
<a name="l08528"></a>08528 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_SWLRO_ENABLED)
<a name="l08529"></a>08529 <span class="preprocessor">#endif</span>
<a name="l08530"></a>08530 <span class="preprocessor"></span>        DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;Internal LRO is enabled \n&quot;</span>);
<a name="l08531"></a>08531     <span class="keywordflow">else</span>
<a name="l08532"></a>08532         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;LRO is disabled \n&quot;</span>);
<a name="l08533"></a>08533 
<a name="l08534"></a>08534     <span class="keywordflow">if</span> (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED)
<a name="l08535"></a>08535         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;HW RSC is enabled \n&quot;</span>);
<a name="l08536"></a>08536 <span class="preprocessor">#ifdef CONFIG_PCI_IOV</span>
<a name="l08537"></a>08537 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED) {
<a name="l08538"></a>08538         DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;IOV is enabled with %d VFs\n&quot;</span>,
<a name="l08539"></a>08539             adapter-&gt;num_vfs);
<a name="l08540"></a>08540         <span class="keywordflow">for</span> (i = 0; i &lt; adapter-&gt;num_vfs; i++)
<a name="l08541"></a>08541             ixgbe_vf_configuration(pdev, (i | 0x10000000));
<a name="l08542"></a>08542     }
<a name="l08543"></a>08543 <span class="preprocessor">#endif</span>
<a name="l08544"></a>08544 <span class="preprocessor"></span>
<a name="l08545"></a>08545 <span class="preprocessor">#if defined(HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN)</span>
<a name="l08546"></a>08546 <span class="preprocessor"></span>    <span class="comment">/* add san mac addr to netdev */</span>
<a name="l08547"></a>08547     ixgbe_add_sanmac_netdev(netdev);
<a name="l08548"></a>08548 
<a name="l08549"></a>08549 <span class="preprocessor">#endif </span><span class="comment">/* (HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; (NETDEV_HW_ADDR_T_SAN) */</span>
<a name="l08550"></a>08550     DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;Intel(R) 10 Gigabit Network Connection\n&quot;</span>);
<a name="l08551"></a>08551     cards_found++;
<a name="l08552"></a>08552     <span class="keywordflow">return</span> 0;
<a name="l08553"></a>08553 
<a name="l08554"></a>08554 err_register:
<a name="l08555"></a>08555     ixgbe_clear_interrupt_scheme(adapter);
<a name="l08556"></a>08556     ixgbe_release_hw_control(adapter);
<a name="l08557"></a>08557 err_sw_init:
<a name="l08558"></a>08558     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l08559"></a>08559         ixgbe_disable_sriov(adapter);
<a name="l08560"></a>08560     adapter-&gt;flags2 &amp;= ~IXGBE_FLAG2_SEARCH_FOR_SFP;
<a name="l08561"></a>08561     iounmap(hw-&gt;hw_addr);
<a name="l08562"></a>08562 err_ioremap:
<a name="l08563"></a>08563     free_netdev(netdev);
<a name="l08564"></a>08564 err_alloc_etherdev:
<a name="l08565"></a>08565     pci_release_selected_regions(pdev,
<a name="l08566"></a>08566                      pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l08567"></a>08567 err_pci_reg:
<a name="l08568"></a>08568 err_dma:
<a name="l08569"></a>08569 
<a name="l08570"></a>08570     pci_disable_device(pdev);
<a name="l08571"></a>08571     <span class="keywordflow">return</span> err;
<a name="l08572"></a>08572 }
<a name="l08573"></a>08573 
<a name="l08583"></a>08583 <span class="keyword">static</span> <span class="keywordtype">void</span> __devexit ixgbe_remove(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l08584"></a>08584 {
<a name="l08585"></a>08585     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08586"></a>08586     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l08587"></a>08587 
<a name="l08588"></a>08588 
<a name="l08589"></a>08589     set_bit(__IXGBE_DOWN, &amp;adapter-&gt;state);
<a name="l08590"></a>08590     cancel_work_sync(&amp;adapter-&gt;service_task);
<a name="l08591"></a>08591 
<a name="l08592"></a>08592     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED) {
<a name="l08593"></a>08593         adapter-&gt;flags &amp;= ~IXGBE_FLAG_DCA_ENABLED;
<a name="l08594"></a>08594         dca_remove_requester(&amp;pdev-&gt;dev);
<a name="l08595"></a>08595         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_DCA_CTRL, 1);
<a name="l08596"></a>08596     }
<a name="l08597"></a>08597 
<a name="l08598"></a>08598 <span class="preprocessor">#ifdef IXGBE_FCOE</span>
<a name="l08599"></a>08599 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_FCOE_ENABLED)
<a name="l08600"></a>08600         ixgbe_cleanup_fcoe(adapter);
<a name="l08601"></a>08601 
<a name="l08602"></a>08602 <span class="preprocessor">#endif </span><span class="comment">/* IXGBE_FCOE */</span>
<a name="l08603"></a>08603 <span class="preprocessor">#if defined(HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; defined(NETDEV_HW_ADDR_T_SAN)</span>
<a name="l08604"></a>08604 <span class="preprocessor"></span>    <span class="comment">/* remove the added san mac */</span>
<a name="l08605"></a>08605     ixgbe_del_sanmac_netdev(netdev);
<a name="l08606"></a>08606 
<a name="l08607"></a>08607 <span class="preprocessor">#endif </span><span class="comment">/* (HAVE_NETDEV_STORAGE_ADDRESS) &amp;&amp; (NETDEV_HW_ADDR_T_SAN) */</span>
<a name="l08608"></a>08608     <span class="keywordflow">if</span> (adapter-&gt;netdev_registered) {
<a name="l08609"></a>08609         unregister_netdev(netdev);
<a name="l08610"></a>08610         adapter-&gt;netdev_registered = <span class="keyword">false</span>;
<a name="l08611"></a>08611     }
<a name="l08612"></a>08612     <span class="keywordflow">if</span> (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)
<a name="l08613"></a>08613         ixgbe_disable_sriov(adapter);
<a name="l08614"></a>08614 
<a name="l08615"></a>08615     ixgbe_clear_interrupt_scheme(adapter);
<a name="l08616"></a>08616     ixgbe_release_hw_control(adapter);
<a name="l08617"></a>08617 
<a name="l08618"></a>08618     iounmap(adapter-&gt;hw.hw_addr);
<a name="l08619"></a>08619     pci_release_selected_regions(pdev,
<a name="l08620"></a>08620                      pci_select_bars(pdev, IORESOURCE_MEM));
<a name="l08621"></a>08621 
<a name="l08622"></a>08622     DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;complete\n&quot;</span>);
<a name="l08623"></a>08623     free_netdev(netdev);
<a name="l08624"></a>08624 
<a name="l08625"></a>08625     pci_disable_pcie_error_reporting(pdev);
<a name="l08626"></a>08626 
<a name="l08627"></a>08627     pci_disable_device(pdev);
<a name="l08628"></a>08628 }
<a name="l08629"></a>08629 
<a name="l08630"></a>08630 u16 ixgbe_read_pci_cfg_word(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw, u32 reg)
<a name="l08631"></a>08631 {
<a name="l08632"></a>08632     u16 value;
<a name="l08633"></a>08633     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = hw-&gt;back;
<a name="l08634"></a>08634 
<a name="l08635"></a>08635     pci_read_config_word(adapter-&gt;pdev, reg, &amp;value);
<a name="l08636"></a>08636     <span class="keywordflow">return</span> value;
<a name="l08637"></a>08637 }
<a name="l08638"></a>08638 
<a name="l08639"></a>08639 <span class="keywordtype">void</span> ixgbe_write_pci_cfg_word(<span class="keyword">struct</span> <a class="code" href="structixgbe__hw.html">ixgbe_hw</a> *hw, u32 reg, u16 value)
<a name="l08640"></a>08640 {
<a name="l08641"></a>08641     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = hw-&gt;back;
<a name="l08642"></a>08642 
<a name="l08643"></a>08643     pci_write_config_word(adapter-&gt;pdev, reg, value);
<a name="l08644"></a>08644 }
<a name="l08645"></a>08645 
<a name="l08646"></a>08646 <span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l08647"></a>08647 <span class="preprocessor"></span>
<a name="l08655"></a>08655 <span class="keyword">static</span> pci_ers_result_t ixgbe_io_error_detected(<span class="keyword">struct</span> pci_dev *pdev,
<a name="l08656"></a>08656                         pci_channel_state_t state)
<a name="l08657"></a>08657 {
<a name="l08658"></a>08658     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08659"></a>08659     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l08660"></a>08660 
<a name="l08661"></a>08661     netif_device_detach(netdev);
<a name="l08662"></a>08662 
<a name="l08663"></a>08663     <span class="keywordflow">if</span> (state == pci_channel_io_perm_failure)
<a name="l08664"></a>08664         <span class="keywordflow">return</span> PCI_ERS_RESULT_DISCONNECT;
<a name="l08665"></a>08665 
<a name="l08666"></a>08666     <span class="keywordflow">if</span> (netif_running(netdev))
<a name="l08667"></a>08667         ixgbe_down(adapter);
<a name="l08668"></a>08668     pci_disable_device(pdev);
<a name="l08669"></a>08669 
<a name="l08670"></a>08670     <span class="comment">/* Request a slot reset. */</span>
<a name="l08671"></a>08671     <span class="keywordflow">return</span> PCI_ERS_RESULT_NEED_RESET;
<a name="l08672"></a>08672 }
<a name="l08673"></a>08673 
<a name="l08680"></a>08680 <span class="keyword">static</span> pci_ers_result_t ixgbe_io_slot_reset(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l08681"></a>08681 {
<a name="l08682"></a>08682     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08683"></a>08683     pci_ers_result_t result;
<a name="l08684"></a>08684 
<a name="l08685"></a>08685     <span class="keywordflow">if</span> (pci_enable_device_mem(pdev)) {
<a name="l08686"></a>08686         DPRINTK(PROBE, ERR,
<a name="l08687"></a>08687             <span class="stringliteral">&quot;Cannot re-enable PCI device after reset.\n&quot;</span>);
<a name="l08688"></a>08688         result = PCI_ERS_RESULT_DISCONNECT;
<a name="l08689"></a>08689     } <span class="keywordflow">else</span> {
<a name="l08690"></a>08690         pci_set_master(pdev);
<a name="l08691"></a>08691         pci_restore_state(pdev);
<a name="l08692"></a>08692         <span class="comment">/*</span>
<a name="l08693"></a>08693 <span class="comment">         * After second error pci-&gt;state_saved is false, this</span>
<a name="l08694"></a>08694 <span class="comment">         * resets it so EEH doesn&#39;t break.</span>
<a name="l08695"></a>08695 <span class="comment">         */</span>
<a name="l08696"></a>08696         pci_save_state(pdev);
<a name="l08697"></a>08697 
<a name="l08698"></a>08698         pci_wake_from_d3(pdev, <span class="keyword">false</span>);
<a name="l08699"></a>08699 
<a name="l08700"></a>08700         ixgbe_reset(adapter);
<a name="l08701"></a>08701         IXGBE_WRITE_REG(&amp;adapter-&gt;hw, IXGBE_WUS, ~0);
<a name="l08702"></a>08702         result = PCI_ERS_RESULT_RECOVERED;
<a name="l08703"></a>08703     }
<a name="l08704"></a>08704 
<a name="l08705"></a>08705     pci_cleanup_aer_uncorrect_error_status(pdev);
<a name="l08706"></a>08706 
<a name="l08707"></a>08707     <span class="keywordflow">return</span> result;
<a name="l08708"></a>08708 }
<a name="l08709"></a>08709 
<a name="l08717"></a>08717 <span class="keyword">static</span> <span class="keywordtype">void</span> ixgbe_io_resume(<span class="keyword">struct</span> pci_dev *pdev)
<a name="l08718"></a>08718 {
<a name="l08719"></a>08719     <span class="keyword">struct </span><a class="code" href="structixgbe__adapter.html">ixgbe_adapter</a> *adapter = pci_get_drvdata(pdev);
<a name="l08720"></a>08720     <span class="keyword">struct </span>net_device *netdev = adapter-&gt;netdev;
<a name="l08721"></a>08721 
<a name="l08722"></a>08722     <span class="keywordflow">if</span> (netif_running(netdev)) {
<a name="l08723"></a>08723         <span class="keywordflow">if</span> (ixgbe_up(adapter)) {
<a name="l08724"></a>08724             DPRINTK(PROBE, INFO, <span class="stringliteral">&quot;ixgbe_up failed after reset\n&quot;</span>);
<a name="l08725"></a>08725             <span class="keywordflow">return</span>;
<a name="l08726"></a>08726         }
<a name="l08727"></a>08727     }
<a name="l08728"></a>08728 
<a name="l08729"></a>08729     netif_device_attach(netdev);
<a name="l08730"></a>08730 }
<a name="l08731"></a>08731 
<a name="l08732"></a>08732 <span class="keyword">static</span> <span class="keyword">struct </span>pci_error_handlers ixgbe_err_handler = {
<a name="l08733"></a>08733     .error_detected = ixgbe_io_error_detected,
<a name="l08734"></a>08734     .slot_reset = ixgbe_io_slot_reset,
<a name="l08735"></a>08735     .resume = ixgbe_io_resume,
<a name="l08736"></a>08736 };
<a name="l08737"></a>08737 
<a name="l08738"></a>08738 <span class="preprocessor">#endif</span>
<a name="l08739"></a>08739 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span>pci_driver ixgbe_driver = {
<a name="l08740"></a>08740     .name     = ixgbe_driver_name,
<a name="l08741"></a>08741     .id_table = ixgbe_pci_tbl,
<a name="l08742"></a>08742     .probe    = ixgbe_probe,
<a name="l08743"></a>08743     .remove   = __devexit_p(ixgbe_remove),
<a name="l08744"></a>08744 <span class="preprocessor">#ifdef CONFIG_PM</span>
<a name="l08745"></a>08745 <span class="preprocessor"></span>    .suspend  = ixgbe_suspend,
<a name="l08746"></a>08746     .resume   = ixgbe_resume,
<a name="l08747"></a>08747 <span class="preprocessor">#endif</span>
<a name="l08748"></a>08748 <span class="preprocessor"></span><span class="preprocessor">#ifndef USE_REBOOT_NOTIFIER</span>
<a name="l08749"></a>08749 <span class="preprocessor"></span>    .shutdown = ixgbe_shutdown,
<a name="l08750"></a>08750 <span class="preprocessor">#endif</span>
<a name="l08751"></a>08751 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_PCI_ERS</span>
<a name="l08752"></a>08752 <span class="preprocessor"></span>    .err_handler = &amp;ixgbe_err_handler
<a name="l08753"></a>08753 <span class="preprocessor">#endif</span>
<a name="l08754"></a>08754 <span class="preprocessor"></span>};
<a name="l08755"></a>08755 
<a name="l08756"></a>08756 <span class="keywordtype">bool</span> ixgbe_is_ixgbe(<span class="keyword">struct</span> pci_dev *pcidev)
<a name="l08757"></a>08757 {
<a name="l08758"></a>08758     <span class="keywordflow">if</span> (pci_dev_driver(pcidev) != &amp;ixgbe_driver)
<a name="l08759"></a>08759         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l08760"></a>08760     <span class="keywordflow">else</span>
<a name="l08761"></a>08761         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l08762"></a>08762 }
<a name="l08763"></a>08763 
<a name="l08770"></a>08770 <span class="keyword">static</span> <span class="keywordtype">int</span> __init ixgbe_init_module(<span class="keywordtype">void</span>)
<a name="l08771"></a>08771 {
<a name="l08772"></a>08772     <span class="keywordtype">int</span> ret;
<a name="l08773"></a>08773     pr_info(<span class="stringliteral">&quot;%s - version %s\n&quot;</span>, ixgbe_driver_string, ixgbe_driver_version);
<a name="l08774"></a>08774     pr_info(<span class="stringliteral">&quot;%s\n&quot;</span>, ixgbe_copyright);
<a name="l08775"></a>08775 
<a name="l08776"></a>08776 <span class="preprocessor">#ifndef CONFIG_DCB</span>
<a name="l08777"></a>08777 <span class="preprocessor"></span>    ixgbe_dcb_netlink_register();
<a name="l08778"></a>08778 <span class="preprocessor">#endif</span>
<a name="l08779"></a>08779 <span class="preprocessor"></span><span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l08780"></a>08780 <span class="preprocessor"></span>    dca_register_notify(&amp;dca_notifier);
<a name="l08781"></a>08781 
<a name="l08782"></a>08782 <span class="preprocessor">#endif</span>
<a name="l08783"></a>08783 <span class="preprocessor"></span>
<a name="l08784"></a>08784 <span class="preprocessor">#ifdef CPACKET_TIMESTAMPS</span>
<a name="l08785"></a>08785 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(cpacket_ts_enable) {
<a name="l08786"></a>08786       pr_info(<span class="stringliteral">&quot;Enabling cpacket.com nsec packet timestamp decoding\n&quot;</span>);
<a name="l08787"></a>08787     } <span class="keywordflow">else</span> {
<a name="l08788"></a>08788       pr_info(<span class="stringliteral">&quot;cpacket.com nsec packet timestamp decoding disabled\n&quot;</span>);
<a name="l08789"></a>08789     }
<a name="l08790"></a>08790 <span class="preprocessor">#endif</span>
<a name="l08791"></a>08791 <span class="preprocessor"></span>    ret = pci_register_driver(&amp;ixgbe_driver);
<a name="l08792"></a>08792     <span class="keywordflow">return</span> ret;
<a name="l08793"></a>08793 }
<a name="l08794"></a>08794 
<a name="l08795"></a>08795 module_init(ixgbe_init_module);
<a name="l08796"></a>08796 
<a name="l08803"></a>08803 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit ixgbe_exit_module(<span class="keywordtype">void</span>)
<a name="l08804"></a>08804 {
<a name="l08805"></a>08805 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l08806"></a>08806 <span class="preprocessor"></span>    dca_unregister_notify(&amp;dca_notifier);
<a name="l08807"></a>08807 <span class="preprocessor">#endif</span>
<a name="l08808"></a>08808 <span class="preprocessor"></span><span class="preprocessor">#ifndef CONFIG_DCB</span>
<a name="l08809"></a>08809 <span class="preprocessor"></span>    ixgbe_dcb_netlink_unregister();
<a name="l08810"></a>08810 <span class="preprocessor">#endif</span>
<a name="l08811"></a>08811 <span class="preprocessor"></span>    pci_unregister_driver(&amp;ixgbe_driver);
<a name="l08812"></a>08812 }
<a name="l08813"></a>08813 
<a name="l08814"></a>08814 <span class="preprocessor">#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)</span>
<a name="l08815"></a>08815 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> ixgbe_notify_dca(<span class="keyword">struct</span> notifier_block *nb, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event,
<a name="l08816"></a>08816                 <span class="keywordtype">void</span> *p)
<a name="l08817"></a>08817 {
<a name="l08818"></a>08818     <span class="keywordtype">int</span> ret_val;
<a name="l08819"></a>08819 
<a name="l08820"></a>08820     ret_val = driver_for_each_device(&amp;ixgbe_driver.driver, NULL, &amp;event,
<a name="l08821"></a>08821                      __ixgbe_notify_dca);
<a name="l08822"></a>08822 
<a name="l08823"></a>08823     <span class="keywordflow">return</span> ret_val ? NOTIFY_BAD : NOTIFY_DONE;
<a name="l08824"></a>08824 }
<a name="l08825"></a>08825 <span class="preprocessor">#endif</span>
<a name="l08826"></a>08826 <span class="preprocessor"></span>module_exit(ixgbe_exit_module);
<a name="l08827"></a>08827 
<a name="l08828"></a>08828 <span class="comment">/* ixgbe_main.c */</span>
<a name="l08829"></a>08829 
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 28 2011 14:20:28 for Mark6 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
